if ( TRACE ) { TRACE( JSON.parse( '["DG.Tweening.Color2#op_Addition","DG.Tweening.Color2#op_Subtraction","DG.Tweening.Color2#op_Multiply","DG.Tweening.Color2#getDefaultValue","DG.Tweening.Color2#init","DG.Tweening.Color2#$ctor1","DG.Tweening.Color2#ctor","DG.Tweening.Color2#getHashCode","DG.Tweening.Color2#equals","DG.Tweening.Color2#$clone","DG.Tweening.Core.ABSAnimationComponent#DORestart","DG.Tweening.Core.Debugger#init","DG.Tweening.Core.Debugger#Log","DG.Tweening.Core.Debugger#LogWarning","DG.Tweening.Core.Debugger#LogError","DG.Tweening.Core.Debugger#LogSafeModeCapturedError","DG.Tweening.Core.Debugger#LogReport","DG.Tweening.Core.Debugger#LogSafeModeReport","DG.Tweening.Core.Debugger#LogInvalidTween","DG.Tweening.Core.Debugger#LogNestedTween","DG.Tweening.Core.Debugger#LogNullTween","DG.Tweening.Core.Debugger#LogNonPathTween","DG.Tweening.Core.Debugger#LogMissingMaterialProperty$1","DG.Tweening.Core.Debugger#LogMissingMaterialProperty","DG.Tweening.Core.Debugger#LogRemoveActiveTweenError","DG.Tweening.Core.Debugger#LogAddActiveTweenError","DG.Tweening.Core.Debugger#SetLogPriority","DG.Tweening.Core.Debugger#ShouldLogSafeModeCapturedError","DG.Tweening.Core.Debugger#GetDebugDataMessage","DG.Tweening.Core.Debugger#AddDebugDataToMessage","DG.Tweening.Core.Debugger.Sequence#LogAddToNullSequence","DG.Tweening.Core.Debugger.Sequence#LogAddToInactiveSequence","DG.Tweening.Core.Debugger.Sequence#LogAddToLockedSequence","DG.Tweening.Core.Debugger.Sequence#LogAddNullTween","DG.Tweening.Core.Debugger.Sequence#LogAddInactiveTween","DG.Tweening.Core.Debugger.Sequence#LogAddAlreadySequencedTween","DG.Tweening.Core.DOTweenExternalCommand#Dispatch_SetOrientationOnPath","DG.Tweening.Core.DOTweenSettings#init","DG.Tweening.Core.DOTweenSettings#init","DG.Tweening.Core.DOTweenSettings.ModulesSetup#init","DG.Tweening.Core.DOTweenSettings.SafeModeOptions#init","DG.Tweening.Core.DOTweenUtils#init","DG.Tweening.Core.DOTweenUtils#Vector3FromAngle","DG.Tweening.Core.DOTweenUtils#Angle2D","DG.Tweening.Core.DOTweenUtils#RotateAroundPivot","DG.Tweening.Core.DOTweenUtils#GetPointOnCircle","DG.Tweening.Core.DOTweenUtils#Vector3AreApproximatelyEqual","DG.Tweening.Core.DOTweenUtils#GetLooseScriptType","DG.Tweening.Core.Easing.Bounce#EaseIn","DG.Tweening.Core.Easing.Bounce#EaseOut","DG.Tweening.Core.Easing.Bounce#EaseInOut","DG.Tweening.Core.Easing.EaseCurve#ctor","DG.Tweening.Core.Easing.EaseCurve#Evaluate","DG.Tweening.Core.Easing.EaseManager#init","DG.Tweening.Core.Easing.EaseManager#Evaluate$1","DG.Tweening.Core.Easing.EaseManager#Evaluate","DG.Tweening.Core.Easing.EaseManager#ToEaseFunction","DG.Tweening.Core.Easing.EaseManager#IsFlashEase","DG.Tweening.Core.Easing.Flash#Ease","DG.Tweening.Core.Easing.Flash#EaseIn","DG.Tweening.Core.Easing.Flash#EaseOut","DG.Tweening.Core.Easing.Flash#EaseInOut","DG.Tweening.Core.Easing.Flash#WeightedEase","DG.Tweening.Core.Extensions#SetSpecialStartupMode","DG.Tweening.Core.Extensions#Blendable","DG.Tweening.Core.Extensions#NoFrom","DG.Tweening.Core.SafeModeReport#getDefaultValue","DG.Tweening.Core.SafeModeReport#ctor","DG.Tweening.Core.SafeModeReport#Add","DG.Tweening.Core.SafeModeReport#GetTotErrors","DG.Tweening.Core.SafeModeReport#getHashCode","DG.Tweening.Core.SafeModeReport#equals","DG.Tweening.Core.SafeModeReport#$clone","DG.Tweening.Core.TweenLink#ctor","DG.Tweening.Core.TweenManager#init","DG.Tweening.Core.TweenManager#ctor","DG.Tweening.Core.TweenManager#GetTweener","DG.Tweening.Core.TweenManager#GetSequence","DG.Tweening.Core.TweenManager#SetUpdateType","DG.Tweening.Core.TweenManager#AddActiveTweenToSequence","DG.Tweening.Core.TweenManager#DespawnAll","DG.Tweening.Core.TweenManager#Despawn","DG.Tweening.Core.TweenManager#PurgeAll","DG.Tweening.Core.TweenManager#PurgePools","DG.Tweening.Core.TweenManager#AddTweenLink","DG.Tweening.Core.TweenManager#RemoveTweenLink","DG.Tweening.Core.TweenManager#ResetCapacities","DG.Tweening.Core.TweenManager#SetCapacities","DG.Tweening.Core.TweenManager#Validate","DG.Tweening.Core.TweenManager#Update$1","DG.Tweening.Core.TweenManager#Update","DG.Tweening.Core.TweenManager#FilteredOperation","DG.Tweening.Core.TweenManager#Complete","DG.Tweening.Core.TweenManager#Flip","DG.Tweening.Core.TweenManager#ForceInit","DG.Tweening.Core.TweenManager#Goto","DG.Tweening.Core.TweenManager#Pause","DG.Tweening.Core.TweenManager#Play","DG.Tweening.Core.TweenManager#PlayBackwards","DG.Tweening.Core.TweenManager#PlayForward","DG.Tweening.Core.TweenManager#Restart","DG.Tweening.Core.TweenManager#Rewind","DG.Tweening.Core.TweenManager#SmoothRewind","DG.Tweening.Core.TweenManager#TogglePause","DG.Tweening.Core.TweenManager#TotalPooledTweens","DG.Tweening.Core.TweenManager#TotalPlayingTweens","DG.Tweening.Core.TweenManager#TotalTweensById","DG.Tweening.Core.TweenManager#GetActiveTweens","DG.Tweening.Core.TweenManager#GetTweensById","DG.Tweening.Core.TweenManager#DoGetTweensById","DG.Tweening.Core.TweenManager#GetTweensByTarget","DG.Tweening.Core.TweenManager#MarkForKilling","DG.Tweening.Core.TweenManager#EvaluateTweenLink","DG.Tweening.Core.TweenManager#AddActiveTween","DG.Tweening.Core.TweenManager#ReorganizeActiveTweens","DG.Tweening.Core.TweenManager#DespawnActiveTweens","DG.Tweening.Core.TweenManager#RemoveActiveTween","DG.Tweening.Core.TweenManager#ClearTweenArray","DG.Tweening.Core.TweenManager#IncreaseCapacities","DG.Tweening.Core.TweenManager#ManageOnRewindCallbackWhenAlreadyRewinded","DG.Tweening.DOCurve.CubicBezier#GetPointOnSegment","DG.Tweening.DOCurve.CubicBezier#GetSegmentPointCloud$1","DG.Tweening.DOCurve.CubicBezier#GetSegmentPointCloud","DG.Tweening.DOTween#logBehaviour#get","DG.Tweening.DOTween#logBehaviour#set","DG.Tweening.DOTween#debugStoreTargetId#get","DG.Tweening.DOTween#debugStoreTargetId#set","DG.Tweening.DOTween#isQuitting#get","DG.Tweening.DOTween#isQuitting#set","DG.Tweening.DOTween#init","DG.Tweening.DOTween#To$16","DG.Tweening.DOTween#To$4","DG.Tweening.DOTween#To$1","DG.Tweening.DOTween#To$2","DG.Tweening.DOTween#To$6","DG.Tweening.DOTween#To$3","DG.Tweening.DOTween#To$7","DG.Tweening.DOTween#To$5","DG.Tweening.DOTween#To$11","DG.Tweening.DOTween#To$12","DG.Tweening.DOTween#To$13","DG.Tweening.DOTween#To$9","DG.Tweening.DOTween#To$8","DG.Tweening.DOTween#To$10","DG.Tweening.DOTween#To$14","DG.Tweening.DOTween#To","DG.Tweening.DOTween#To$15","DG.Tweening.DOTween#InitCheck","DG.Tweening.DOTween#ApplyTo","DG.Tweening.DOTween#Init","DG.Tweening.DOTween#Init$1","DG.Tweening.DOTween#AutoInit","DG.Tweening.DOTween#SetTweensCapacity","DG.Tweening.DOTween#Clear","DG.Tweening.DOTween#Clear$1","DG.Tweening.DOTween#ClearCachedTweens","DG.Tweening.DOTween#Validate","DG.Tweening.DOTween#ManualUpdate","DG.Tweening.DOTween#ToAxis","DG.Tweening.DOTween#ToAlpha","DG.Tweening.DOTween#Punch","DG.Tweening.DOTween#Shake","DG.Tweening.DOTween#Shake$1","DG.Tweening.DOTween#Shake$2","DG.Tweening.DOTween#ToArray","DG.Tweening.DOTween#Sequence","DG.Tweening.DOTween#Sequence$1","DG.Tweening.DOTween#CompleteAll","DG.Tweening.DOTween#Complete","DG.Tweening.DOTween#CompleteAndReturnKilledTot","DG.Tweening.DOTween#CompleteAndReturnKilledTot$1","DG.Tweening.DOTween#CompleteAndReturnKilledTot$2","DG.Tweening.DOTween#CompleteAndReturnKilledTotExceptFor","DG.Tweening.DOTween#FlipAll","DG.Tweening.DOTween#Flip","DG.Tweening.DOTween#GotoAll","DG.Tweening.DOTween#Goto","DG.Tweening.DOTween#KillAll","DG.Tweening.DOTween#KillAll$1","DG.Tweening.DOTween#Kill","DG.Tweening.DOTween#Kill$1","DG.Tweening.DOTween#PauseAll","DG.Tweening.DOTween#Pause","DG.Tweening.DOTween#PlayAll","DG.Tweening.DOTween#Play","DG.Tweening.DOTween#Play$1","DG.Tweening.DOTween#PlayBackwardsAll","DG.Tweening.DOTween#PlayBackwards","DG.Tweening.DOTween#PlayBackwards$1","DG.Tweening.DOTween#PlayForwardAll","DG.Tweening.DOTween#PlayForward","DG.Tweening.DOTween#PlayForward$1","DG.Tweening.DOTween#RestartAll","DG.Tweening.DOTween#Restart","DG.Tweening.DOTween#Restart$1","DG.Tweening.DOTween#RewindAll","DG.Tweening.DOTween#Rewind","DG.Tweening.DOTween#SmoothRewindAll","DG.Tweening.DOTween#SmoothRewind","DG.Tweening.DOTween#TogglePauseAll","DG.Tweening.DOTween#TogglePause","DG.Tweening.DOTween#IsTweening","DG.Tweening.DOTween#TotalActiveTweens","DG.Tweening.DOTween#TotalActiveTweeners","DG.Tweening.DOTween#TotalActiveSequences","DG.Tweening.DOTween#TotalPlayingTweens","DG.Tweening.DOTween#TotalTweensById","DG.Tweening.DOTween#PlayingTweens","DG.Tweening.DOTween#PausedTweens","DG.Tweening.DOTween#TweensById","DG.Tweening.DOTween#TweensByTarget","DG.Tweening.DOVirtual#Float","DG.Tweening.DOVirtual#Int","DG.Tweening.DOVirtual#Vector3","DG.Tweening.DOVirtual#Color","DG.Tweening.DOVirtual#EasedValue","DG.Tweening.DOVirtual#EasedValue$1","DG.Tweening.DOVirtual#EasedValue$2","DG.Tweening.DOVirtual#EasedValue$3","DG.Tweening.DOVirtual#EasedValue$4","DG.Tweening.DOVirtual#EasedValue$5","DG.Tweening.DOVirtual#EasedValue$6","DG.Tweening.DOVirtual#EasedValue$7","DG.Tweening.DOVirtual#DelayedCall","DG.Tweening.EaseFactory#StopMotion$1","DG.Tweening.EaseFactory#StopMotion$2","DG.Tweening.EaseFactory#StopMotion","DG.Tweening.Plugins.Core.PathCore.ControlPoint#op_Addition","DG.Tweening.Plugins.Core.PathCore.ControlPoint#getDefaultValue","DG.Tweening.Plugins.Core.PathCore.ControlPoint#init","DG.Tweening.Plugins.Core.PathCore.ControlPoint#$ctor1","DG.Tweening.Plugins.Core.PathCore.ControlPoint#ctor","DG.Tweening.Plugins.Core.PathCore.ControlPoint#toString","DG.Tweening.Plugins.Core.PathCore.ControlPoint#getHashCode","DG.Tweening.Plugins.Core.PathCore.ControlPoint#equals","DG.Tweening.Plugins.Core.PathCore.ControlPoint#$clone","DG.Tweening.Plugins.Core.PathCore.Path#Draw","DG.Tweening.Plugins.Core.PathCore.Path#ConvertToDrawPoint","DG.Tweening.Plugins.Core.PathCore.Path#GetDrawPoints","DG.Tweening.Plugins.Core.PathCore.Path#RefreshNonLinearDrawWps","DG.Tweening.Plugins.Core.PathCore.Path#minInputWaypoints#get","DG.Tweening.Plugins.Core.PathCore.Path#init","DG.Tweening.Plugins.Core.PathCore.Path#$ctor1","DG.Tweening.Plugins.Core.PathCore.Path#ctor","DG.Tweening.Plugins.Core.PathCore.Path#AssignWaypoints","DG.Tweening.Plugins.Core.PathCore.Path#AssignDecoder","DG.Tweening.Plugins.Core.PathCore.Path#Draw","DG.Tweening.Plugins.Core.PathCore.Path#FinalizePath","DG.Tweening.Plugins.Core.PathCore.Path#GetPoint","DG.Tweening.Plugins.Core.PathCore.Path#ConvertToConstantPathPerc","DG.Tweening.Plugins.Core.PathCore.Path#GetWaypointIndexFromPerc","DG.Tweening.Plugins.Core.PathCore.Path#Destroy","DG.Tweening.Plugins.Core.PathCore.Path#CloneIncremental","DG.Tweening.Plugins.Core.PluginsManager#init","DG.Tweening.Plugins.Core.PluginsManager#GetDefaultPlugin","DG.Tweening.Plugins.Core.PluginsManager#GetCustomPlugin","DG.Tweening.Plugins.Core.PluginsManager#PurgeAll","DG.Tweening.Plugins.Core.SpecialPluginsUtils#SetLookAt","DG.Tweening.Plugins.Core.SpecialPluginsUtils#SetPunch","DG.Tweening.Plugins.Core.SpecialPluginsUtils#SetShake","DG.Tweening.Plugins.Core.SpecialPluginsUtils#SetCameraShakePosition","DG.Tweening.Plugins.StringPluginExtensions#init","DG.Tweening.Plugins.StringPluginExtensions#ctor","DG.Tweening.Plugins.StringPluginExtensions#ScrambleChars","DG.Tweening.Plugins.StringPluginExtensions#AppendScrambledChars","DG.Tweening.ShortcutExtensions#DOColor$5","DG.Tweening.ShortcutExtensions#DOColor","DG.Tweening.ShortcutExtensions#DOColor$1","DG.Tweening.ShortcutExtensions#DOColor$3","DG.Tweening.ShortcutExtensions#DOColor$4","DG.Tweening.ShortcutExtensions#DOColor$2","DG.Tweening.ShortcutExtensions#DOTimeScale","DG.Tweening.ShortcutExtensions#DOAspect","DG.Tweening.ShortcutExtensions#DOFarClipPlane","DG.Tweening.ShortcutExtensions#DOFieldOfView","DG.Tweening.ShortcutExtensions#DONearClipPlane","DG.Tweening.ShortcutExtensions#DOOrthoSize","DG.Tweening.ShortcutExtensions#DOPixelRect","DG.Tweening.ShortcutExtensions#DORect","DG.Tweening.ShortcutExtensions#DOShakePosition","DG.Tweening.ShortcutExtensions#DOShakePosition$1","DG.Tweening.ShortcutExtensions#DOShakePosition$2","DG.Tweening.ShortcutExtensions#DOShakePosition$3","DG.Tweening.ShortcutExtensions#DOShakeRotation","DG.Tweening.ShortcutExtensions#DOShakeRotation$1","DG.Tweening.ShortcutExtensions#DOShakeRotation$2","DG.Tweening.ShortcutExtensions#DOShakeRotation$3","DG.Tweening.ShortcutExtensions#DOIntensity","DG.Tweening.ShortcutExtensions#DOShadowStrength","DG.Tweening.ShortcutExtensions#DOFade$1","DG.Tweening.ShortcutExtensions#DOFade$2","DG.Tweening.ShortcutExtensions#DOFade","DG.Tweening.ShortcutExtensions#DOFloat$1","DG.Tweening.ShortcutExtensions#DOFloat","DG.Tweening.ShortcutExtensions#DOOffset","DG.Tweening.ShortcutExtensions#DOOffset$1","DG.Tweening.ShortcutExtensions#DOTiling","DG.Tweening.ShortcutExtensions#DOTiling$1","DG.Tweening.ShortcutExtensions#DOVector$1","DG.Tweening.ShortcutExtensions#DOVector","DG.Tweening.ShortcutExtensions#DOResize","DG.Tweening.ShortcutExtensions#DOTime","DG.Tweening.ShortcutExtensions#DOMove","DG.Tweening.ShortcutExtensions#DOMoveX","DG.Tweening.ShortcutExtensions#DOMoveY","DG.Tweening.ShortcutExtensions#DOMoveZ","DG.Tweening.ShortcutExtensions#DOLocalMove","DG.Tweening.ShortcutExtensions#DOLocalMoveX","DG.Tweening.ShortcutExtensions#DOLocalMoveY","DG.Tweening.ShortcutExtensions#DOLocalMoveZ","DG.Tweening.ShortcutExtensions#DORotate","DG.Tweening.ShortcutExtensions#DORotateQuaternion","DG.Tweening.ShortcutExtensions#DOLocalRotate","DG.Tweening.ShortcutExtensions#DOLocalRotateQuaternion","DG.Tweening.ShortcutExtensions#DOScale$1","DG.Tweening.ShortcutExtensions#DOScale","DG.Tweening.ShortcutExtensions#DOScaleX","DG.Tweening.ShortcutExtensions#DOScaleY","DG.Tweening.ShortcutExtensions#DOScaleZ","DG.Tweening.ShortcutExtensions#DOLookAt","DG.Tweening.ShortcutExtensions#DODynamicLookAt","DG.Tweening.ShortcutExtensions#LookAt","DG.Tweening.ShortcutExtensions#DOPunchPosition","DG.Tweening.ShortcutExtensions#DOPunchScale","DG.Tweening.ShortcutExtensions#DOPunchRotation","DG.Tweening.ShortcutExtensions#DOShakeScale","DG.Tweening.ShortcutExtensions#DOShakeScale$1","DG.Tweening.ShortcutExtensions#DOJump","DG.Tweening.ShortcutExtensions#DOLocalJump","DG.Tweening.ShortcutExtensions#DOPath$1","DG.Tweening.ShortcutExtensions#DOPath","DG.Tweening.ShortcutExtensions#DOLocalPath$1","DG.Tweening.ShortcutExtensions#DOLocalPath","DG.Tweening.ShortcutExtensions#DOBlendableColor","DG.Tweening.ShortcutExtensions#DOBlendableColor$2","DG.Tweening.ShortcutExtensions#DOBlendableColor$3","DG.Tweening.ShortcutExtensions#DOBlendableColor$1","DG.Tweening.ShortcutExtensions#DOBlendableMoveBy","DG.Tweening.ShortcutExtensions#DOBlendableLocalMoveBy","DG.Tweening.ShortcutExtensions#DOBlendableRotateBy","DG.Tweening.ShortcutExtensions#DOBlendableLocalRotateBy","DG.Tweening.ShortcutExtensions#DOBlendablePunchRotation","DG.Tweening.ShortcutExtensions#DOBlendableScaleBy","DG.Tweening.ShortcutExtensions#DOComplete","DG.Tweening.ShortcutExtensions#DOComplete$1","DG.Tweening.ShortcutExtensions#DOKill","DG.Tweening.ShortcutExtensions#DOKill$1","DG.Tweening.ShortcutExtensions#DOFlip","DG.Tweening.ShortcutExtensions#DOFlip$1","DG.Tweening.ShortcutExtensions#DOGoto","DG.Tweening.ShortcutExtensions#DOGoto$1","DG.Tweening.ShortcutExtensions#DOPause","DG.Tweening.ShortcutExtensions#DOPause$1","DG.Tweening.ShortcutExtensions#DOPlay","DG.Tweening.ShortcutExtensions#DOPlay$1","DG.Tweening.ShortcutExtensions#DOPlayBackwards","DG.Tweening.ShortcutExtensions#DOPlayBackwards$1","DG.Tweening.ShortcutExtensions#DOPlayForward","DG.Tweening.ShortcutExtensions#DOPlayForward$1","DG.Tweening.ShortcutExtensions#DORestart","DG.Tweening.ShortcutExtensions#DORestart$1","DG.Tweening.ShortcutExtensions#DORewind","DG.Tweening.ShortcutExtensions#DORewind$1","DG.Tweening.ShortcutExtensions#DOSmoothRewind","DG.Tweening.ShortcutExtensions#DOSmoothRewind$1","DG.Tweening.ShortcutExtensions#DOTogglePause","DG.Tweening.ShortcutExtensions#DOTogglePause$1","DG.Tweening.TweenExtensions#Complete","DG.Tweening.TweenExtensions#Complete$1","DG.Tweening.TweenExtensions#Flip","DG.Tweening.TweenExtensions#ForceInit","DG.Tweening.TweenExtensions#Goto","DG.Tweening.TweenExtensions#GotoWithCallbacks","DG.Tweening.TweenExtensions#DoGoto","DG.Tweening.TweenExtensions#Kill","DG.Tweening.TweenExtensions#ManualUpdate","DG.Tweening.TweenExtensions#Pause","DG.Tweening.TweenExtensions#Play","DG.Tweening.TweenExtensions#PlayBackwards","DG.Tweening.TweenExtensions#PlayForward","DG.Tweening.TweenExtensions#Restart","DG.Tweening.TweenExtensions#Rewind","DG.Tweening.TweenExtensions#SmoothRewind","DG.Tweening.TweenExtensions#TogglePause","DG.Tweening.TweenExtensions#GotoWaypoint","DG.Tweening.TweenExtensions#WaitForCompletion","DG.Tweening.TweenExtensions#WaitForRewind","DG.Tweening.TweenExtensions#WaitForKill","DG.Tweening.TweenExtensions#WaitForElapsedLoops","DG.Tweening.TweenExtensions#WaitForPosition","DG.Tweening.TweenExtensions#WaitForStart","DG.Tweening.TweenExtensions#CompletedLoops","DG.Tweening.TweenExtensions#Delay","DG.Tweening.TweenExtensions#ElapsedDelay","DG.Tweening.TweenExtensions#Duration","DG.Tweening.TweenExtensions#Elapsed","DG.Tweening.TweenExtensions#ElapsedPercentage","DG.Tweening.TweenExtensions#ElapsedDirectionalPercentage","DG.Tweening.TweenExtensions#IsActive","DG.Tweening.TweenExtensions#IsBackwards","DG.Tweening.TweenExtensions#IsComplete","DG.Tweening.TweenExtensions#IsInitialized","DG.Tweening.TweenExtensions#IsPlaying","DG.Tweening.TweenExtensions#Loops","DG.Tweening.TweenExtensions#PathGetPoint","DG.Tweening.TweenExtensions#PathGetDrawPoints","DG.Tweening.TweenExtensions#PathLength","DG.Tweening.TweenParams#init","DG.Tweening.TweenParams#init","DG.Tweening.TweenParams#ctor","DG.Tweening.TweenParams#Clear","DG.Tweening.TweenParams#SetAutoKill","DG.Tweening.TweenParams#SetId$1","DG.Tweening.TweenParams#SetId$2","DG.Tweening.TweenParams#SetId","DG.Tweening.TweenParams#SetTarget","DG.Tweening.TweenParams#SetLoops","DG.Tweening.TweenParams#SetEase","DG.Tweening.TweenParams#SetEase$2","DG.Tweening.TweenParams#SetEase$1","DG.Tweening.TweenParams#SetRecyclable","DG.Tweening.TweenParams#SetUpdate$1","DG.Tweening.TweenParams#SetUpdate","DG.Tweening.TweenParams#OnStart","DG.Tweening.TweenParams#OnPlay","DG.Tweening.TweenParams#OnRewind","DG.Tweening.TweenParams#OnUpdate","DG.Tweening.TweenParams#OnStepComplete","DG.Tweening.TweenParams#OnComplete","DG.Tweening.TweenParams#OnKill","DG.Tweening.TweenParams#OnWaypointChange","DG.Tweening.TweenParams#SetDelay","DG.Tweening.TweenParams#SetRelative","DG.Tweening.TweenParams#SetSpeedBased","DG.Tweening.TweenSettingsExtensions#SetAutoKill","DG.Tweening.TweenSettingsExtensions#SetAutoKill$1","DG.Tweening.TweenSettingsExtensions#SetId$1","DG.Tweening.TweenSettingsExtensions#SetId$2","DG.Tweening.TweenSettingsExtensions#SetId","DG.Tweening.TweenSettingsExtensions#SetLink","DG.Tweening.TweenSettingsExtensions#SetLink$1","DG.Tweening.TweenSettingsExtensions#SetTarget","DG.Tweening.TweenSettingsExtensions#SetLoops","DG.Tweening.TweenSettingsExtensions#SetLoops$1","DG.Tweening.TweenSettingsExtensions#SetEase$2","DG.Tweening.TweenSettingsExtensions#SetEase$4","DG.Tweening.TweenSettingsExtensions#SetEase$3","DG.Tweening.TweenSettingsExtensions#SetEase","DG.Tweening.TweenSettingsExtensions#SetEase$1","DG.Tweening.TweenSettingsExtensions#SetRecyclable","DG.Tweening.TweenSettingsExtensions#SetRecyclable$1","DG.Tweening.TweenSettingsExtensions#SetUpdate","DG.Tweening.TweenSettingsExtensions#SetUpdate$1","DG.Tweening.TweenSettingsExtensions#SetUpdate$2","DG.Tweening.TweenSettingsExtensions#SetInverted","DG.Tweening.TweenSettingsExtensions#SetInverted$1","DG.Tweening.TweenSettingsExtensions#OnStart","DG.Tweening.TweenSettingsExtensions#OnPlay","DG.Tweening.TweenSettingsExtensions#OnPause","DG.Tweening.TweenSettingsExtensions#OnRewind","DG.Tweening.TweenSettingsExtensions#OnUpdate","DG.Tweening.TweenSettingsExtensions#OnStepComplete","DG.Tweening.TweenSettingsExtensions#OnComplete","DG.Tweening.TweenSettingsExtensions#OnKill","DG.Tweening.TweenSettingsExtensions#OnWaypointChange","DG.Tweening.TweenSettingsExtensions#SetAs","DG.Tweening.TweenSettingsExtensions#SetAs$1","DG.Tweening.TweenSettingsExtensions#Append","DG.Tweening.TweenSettingsExtensions#Prepend","DG.Tweening.TweenSettingsExtensions#Join","DG.Tweening.TweenSettingsExtensions#Insert","DG.Tweening.TweenSettingsExtensions#AppendInterval","DG.Tweening.TweenSettingsExtensions#PrependInterval","DG.Tweening.TweenSettingsExtensions#AppendCallback","DG.Tweening.TweenSettingsExtensions#PrependCallback","DG.Tweening.TweenSettingsExtensions#InsertCallback","DG.Tweening.TweenSettingsExtensions#ValidateAddToSequence","DG.Tweening.TweenSettingsExtensions#From","DG.Tweening.TweenSettingsExtensions#From$1","DG.Tweening.TweenSettingsExtensions#From$2","DG.Tweening.TweenSettingsExtensions#From$3","DG.Tweening.TweenSettingsExtensions#From$4","DG.Tweening.TweenSettingsExtensions#From$6","DG.Tweening.TweenSettingsExtensions#From$5","DG.Tweening.TweenSettingsExtensions#SetDelay","DG.Tweening.TweenSettingsExtensions#SetDelay$1","DG.Tweening.TweenSettingsExtensions#SetRelative","DG.Tweening.TweenSettingsExtensions#SetRelative$1","DG.Tweening.TweenSettingsExtensions#SetSpeedBased","DG.Tweening.TweenSettingsExtensions#SetSpeedBased$1","DG.Tweening.TweenSettingsExtensions#SetOptions$2","DG.Tweening.TweenSettingsExtensions#SetOptions$9","DG.Tweening.TweenSettingsExtensions#SetOptions$8","DG.Tweening.TweenSettingsExtensions#SetOptions$13","DG.Tweening.TweenSettingsExtensions#SetOptions$12","DG.Tweening.TweenSettingsExtensions#SetOptions$15","DG.Tweening.TweenSettingsExtensions#SetOptions$14","DG.Tweening.TweenSettingsExtensions#SetOptions$5","DG.Tweening.TweenSettingsExtensions#SetOptions$4","DG.Tweening.TweenSettingsExtensions#SetOptions$6","DG.Tweening.TweenSettingsExtensions#SetOptions$3","DG.Tweening.TweenSettingsExtensions#SetOptions$11","DG.Tweening.TweenSettingsExtensions#SetOptions$10","DG.Tweening.TweenSettingsExtensions#SetOptions$7","DG.Tweening.TweenSettingsExtensions#SetOptions","DG.Tweening.TweenSettingsExtensions#SetOptions$1","DG.Tweening.TweenSettingsExtensions#SetLookAt$5","DG.Tweening.TweenSettingsExtensions#SetLookAt$4","DG.Tweening.TweenSettingsExtensions#SetLookAt$3","DG.Tweening.TweenSettingsExtensions#SetLookAt$2","DG.Tweening.TweenSettingsExtensions#SetLookAt$1","DG.Tweening.TweenSettingsExtensions#SetLookAt","DG.Tweening.TweenSettingsExtensions#SetLookAt$6","DG.Tweening.TweenSettingsExtensions#SetPathForwardDirection","DG.Tweening.Core.DOTweenComponent#Create","DG.Tweening.Core.DOTweenComponent#DestroyInstance","DG.Tweening.Core.DOTweenComponent#SetCapacity","DG.Tweening.Core.DOTweenComponent#Awake","DG.Tweening.Core.DOTweenComponent#Start","DG.Tweening.Core.DOTweenComponent#Update","DG.Tweening.Core.DOTweenComponent#LateUpdate","DG.Tweening.Core.DOTweenComponent#FixedUpdate","DG.Tweening.Core.DOTweenComponent#OnDrawGizmos","DG.Tweening.Core.DOTweenComponent#OnDestroy","DG.Tweening.Core.DOTweenComponent#OnApplicationPause","DG.Tweening.Core.DOTweenComponent#OnApplicationQuit","DG.Tweening.Core.DOTweenComponent#WaitForCompletion","DG.Tweening.Core.DOTweenComponent#WaitForRewind","DG.Tweening.Core.DOTweenComponent#WaitForKill","DG.Tweening.Core.DOTweenComponent#WaitForElapsedLoops","DG.Tweening.Core.DOTweenComponent#WaitForPosition","DG.Tweening.Core.DOTweenComponent#WaitForStart","DG.Tweening.Core.SequenceCallback#ctor","DG.Tweening.Tween#DoGoto","DG.Tweening.Tween#OnTweenCallback","DG.Tweening.Tween#OnTweenCallback$1","DG.Tweening.Tween#fullPosition#get","DG.Tweening.Tween#fullPosition#set","DG.Tweening.Tween#hasLoops#get","DG.Tweening.Tween#init","DG.Tweening.Tween#Reset","DG.Tweening.Tween#UpdateDelay","DG.Tweening.Plugins.Core.ABSTweenPlugin$3#EvaluateAndApply","DG.Tweening.Plugins.Core.ABSTweenPlugin$3#EvaluateAndApply$1","DG.Tweening.DOTweenPath#init","DG.Tweening.DOTweenPath#DOPlay","DG.Tweening.DOTweenPath#DOPlayById","DG.Tweening.DOTweenPath#DOPlayAllById","DG.Tweening.DOTweenPath#DOPlayBackwards","DG.Tweening.DOTweenPath#DOPlayForward","DG.Tweening.DOTweenPath#DOPause","DG.Tweening.DOTweenPath#DOTogglePause","DG.Tweening.DOTweenPath#DORewind","DG.Tweening.DOTweenPath#DORestart","DG.Tweening.DOTweenPath#DORestart$1","DG.Tweening.DOTweenPath#DOComplete","DG.Tweening.DOTweenPath#DOKill","DG.Tweening.DOTweenPath#DOKillAllById","DG.Tweening.DOTweenPath#GetTween","DG.Tweening.DOTweenPath#GetDrawPoints","DG.Tweening.DOTweenPath#GetFullWps","DG.Tweening.Plugins.CircleOptions#getDefaultValue","DG.Tweening.Plugins.CircleOptions#init","DG.Tweening.Plugins.CircleOptions#ctor","DG.Tweening.Plugins.CircleOptions#Reset","DG.Tweening.Plugins.CircleOptions#Initialize","DG.Tweening.Plugins.CircleOptions#getHashCode","DG.Tweening.Plugins.CircleOptions#equals","DG.Tweening.Plugins.CircleOptions#$clone","DG.Tweening.Plugins.Core.PathCore.CatmullRomDecoder#init","DG.Tweening.Plugins.Core.PathCore.CatmullRomDecoder#minInputWaypoints#get","DG.Tweening.Plugins.Core.PathCore.CatmullRomDecoder#FinalizePath","DG.Tweening.Plugins.Core.PathCore.CatmullRomDecoder#GetPoint","DG.Tweening.Plugins.Core.PathCore.CatmullRomDecoder#SetTimeToLengthTables","DG.Tweening.Plugins.Core.PathCore.CatmullRomDecoder#SetWaypointsLengths","DG.Tweening.Plugins.Core.PathCore.CubicBezierDecoder#init","DG.Tweening.Plugins.Core.PathCore.CubicBezierDecoder#minInputWaypoints#get","DG.Tweening.Plugins.Core.PathCore.CubicBezierDecoder#FinalizePath","DG.Tweening.Plugins.Core.PathCore.CubicBezierDecoder#GetPoint","DG.Tweening.Plugins.Core.PathCore.CubicBezierDecoder#SetTimeToLengthTables","DG.Tweening.Plugins.Core.PathCore.CubicBezierDecoder#SetWaypointsLengths","DG.Tweening.Plugins.Core.PathCore.LinearDecoder#minInputWaypoints#get","DG.Tweening.Plugins.Core.PathCore.LinearDecoder#FinalizePath","DG.Tweening.Plugins.Core.PathCore.LinearDecoder#GetPoint","DG.Tweening.Plugins.Core.PathCore.LinearDecoder#SetTimeToLengthTables","DG.Tweening.Plugins.Core.PathCore.LinearDecoder#SetWaypointsLengths","DG.Tweening.Plugins.Options.PathOptions#getDefaultValue","DG.Tweening.Plugins.Options.PathOptions#init","DG.Tweening.Plugins.Options.PathOptions#ctor","DG.Tweening.Plugins.Options.PathOptions#Reset","DG.Tweening.Plugins.Options.PathOptions#getHashCode","DG.Tweening.Plugins.Options.PathOptions#equals","DG.Tweening.Plugins.Options.PathOptions#$clone","DG.Tweening.Plugins.Options.QuaternionOptions#getDefaultValue","DG.Tweening.Plugins.Options.QuaternionOptions#init","DG.Tweening.Plugins.Options.QuaternionOptions#ctor","DG.Tweening.Plugins.Options.QuaternionOptions#Reset","DG.Tweening.Plugins.Options.QuaternionOptions#getHashCode","DG.Tweening.Plugins.Options.QuaternionOptions#equals","DG.Tweening.Plugins.Options.QuaternionOptions#$clone","DG.Tweening.Plugins.Options.RectOptions#getDefaultValue","DG.Tweening.Plugins.Options.RectOptions#ctor","DG.Tweening.Plugins.Options.RectOptions#Reset","DG.Tweening.Plugins.Options.RectOptions#getHashCode","DG.Tweening.Plugins.Options.RectOptions#equals","DG.Tweening.Plugins.Options.RectOptions#$clone","DG.Tweening.Plugins.Options.StringOptions#getDefaultValue","DG.Tweening.Plugins.Options.StringOptions#ctor","DG.Tweening.Plugins.Options.StringOptions#Reset","DG.Tweening.Plugins.Options.StringOptions#getHashCode","DG.Tweening.Plugins.Options.StringOptions#equals","DG.Tweening.Plugins.Options.StringOptions#$clone","DG.Tweening.Plugins.Options.UintOptions#getDefaultValue","DG.Tweening.Plugins.Options.UintOptions#ctor","DG.Tweening.Plugins.Options.UintOptions#Reset","DG.Tweening.Plugins.Options.UintOptions#getHashCode","DG.Tweening.Plugins.Options.UintOptions#equals","DG.Tweening.Plugins.Options.UintOptions#$clone","DG.Tweening.Plugins.Options.Vector3ArrayOptions#getDefaultValue","DG.Tweening.Plugins.Options.Vector3ArrayOptions#ctor","DG.Tweening.Plugins.Options.Vector3ArrayOptions#Reset","DG.Tweening.Plugins.Options.Vector3ArrayOptions#getHashCode","DG.Tweening.Plugins.Options.Vector3ArrayOptions#equals","DG.Tweening.Plugins.Options.Vector3ArrayOptions#$clone","DG.Tweening.Plugins.Options.VectorOptions#getDefaultValue","DG.Tweening.Plugins.Options.VectorOptions#ctor","DG.Tweening.Plugins.Options.VectorOptions#Reset","DG.Tweening.Plugins.Options.VectorOptions#getHashCode","DG.Tweening.Plugins.Options.VectorOptions#equals","DG.Tweening.Plugins.Options.VectorOptions#$clone","DG.Tweening.Plugins.SpiralOptions#getDefaultValue","DG.Tweening.Plugins.SpiralOptions#init","DG.Tweening.Plugins.SpiralOptions#ctor","DG.Tweening.Plugins.SpiralOptions#Reset","DG.Tweening.Plugins.SpiralOptions#getHashCode","DG.Tweening.Plugins.SpiralOptions#equals","DG.Tweening.Plugins.SpiralOptions#$clone","DG.Tweening.Tweener#Setup","DG.Tweening.Tweener#DoUpdateDelay","DG.Tweening.Tweener#DoStartup","DG.Tweening.Tweener#DoChangeStartValue","DG.Tweening.Tweener#DoChangeEndValue","DG.Tweening.Tweener#DoChangeValues","DG.Tweening.Tweener#DOStartupSpecials","DG.Tweening.Tweener#DOStartupDurationBased","DG.Tweening.Tweener#init","DG.Tweening.Tweener#ctor","DG.Tweening.Plugins.Options.NoOptions#getDefaultValue","DG.Tweening.Plugins.Options.NoOptions#ctor","DG.Tweening.Plugins.Options.NoOptions#Reset","DG.Tweening.Plugins.Options.NoOptions#$clone","DG.Tweening.Plugins.CirclePlugin#Get","DG.Tweening.Plugins.CirclePlugin#Reset","DG.Tweening.Plugins.CirclePlugin#SetFrom$1","DG.Tweening.Plugins.CirclePlugin#SetFrom","DG.Tweening.Plugins.CirclePlugin#ConvertToStartValue","DG.Tweening.Plugins.CirclePlugin#SetRelativeEndValue","DG.Tweening.Plugins.CirclePlugin#SetChangeValue","DG.Tweening.Plugins.CirclePlugin#GetSpeedBasedDuration","DG.Tweening.Plugins.CirclePlugin#EvaluateAndApply","DG.Tweening.Plugins.CirclePlugin#GetPositionOnCircle","DG.Tweening.Plugins.Options.ColorOptions#getDefaultValue","DG.Tweening.Plugins.Options.ColorOptions#ctor","DG.Tweening.Plugins.Options.ColorOptions#Reset","DG.Tweening.Plugins.Options.ColorOptions#getHashCode","DG.Tweening.Plugins.Options.ColorOptions#equals","DG.Tweening.Plugins.Options.ColorOptions#$clone","DG.Tweening.Plugins.Options.FloatOptions#getDefaultValue","DG.Tweening.Plugins.Options.FloatOptions#ctor","DG.Tweening.Plugins.Options.FloatOptions#Reset","DG.Tweening.Plugins.Options.FloatOptions#getHashCode","DG.Tweening.Plugins.Options.FloatOptions#equals","DG.Tweening.Plugins.Options.FloatOptions#$clone","DG.Tweening.Plugins.PathPlugin#init","DG.Tweening.Plugins.PathPlugin#Get","DG.Tweening.Plugins.PathPlugin#Reset","DG.Tweening.Plugins.PathPlugin#SetFrom$1","DG.Tweening.Plugins.PathPlugin#SetFrom","DG.Tweening.Plugins.PathPlugin#ConvertToStartValue","DG.Tweening.Plugins.PathPlugin#SetRelativeEndValue","DG.Tweening.Plugins.PathPlugin#SetChangeValue","DG.Tweening.Plugins.PathPlugin#GetSpeedBasedDuration","DG.Tweening.Plugins.PathPlugin#EvaluateAndApply","DG.Tweening.Plugins.PathPlugin#SetOrientation","DG.Tweening.Plugins.PathPlugin#DivideVectorByVector","DG.Tweening.Plugins.PathPlugin#MultiplyVectorByVector","DG.Tweening.Plugins.QuaternionPlugin#Reset","DG.Tweening.Plugins.QuaternionPlugin#SetFrom$1","DG.Tweening.Plugins.QuaternionPlugin#SetFrom","DG.Tweening.Plugins.QuaternionPlugin#ConvertToStartValue","DG.Tweening.Plugins.QuaternionPlugin#SetRelativeEndValue","DG.Tweening.Plugins.QuaternionPlugin#SetChangeValue","DG.Tweening.Plugins.QuaternionPlugin#GetSpeedBasedDuration","DG.Tweening.Plugins.QuaternionPlugin#EvaluateAndApply","DG.Tweening.Plugins.QuaternionPlugin#GetEulerValForCalculations","DG.Tweening.Plugins.QuaternionPlugin#FlipEulerAngles","DG.Tweening.Plugins.RectPlugin#Reset","DG.Tweening.Plugins.RectPlugin#SetFrom$1","DG.Tweening.Plugins.RectPlugin#SetFrom","DG.Tweening.Plugins.RectPlugin#ConvertToStartValue","DG.Tweening.Plugins.RectPlugin#SetRelativeEndValue","DG.Tweening.Plugins.RectPlugin#SetChangeValue","DG.Tweening.Plugins.RectPlugin#GetSpeedBasedDuration","DG.Tweening.Plugins.RectPlugin#EvaluateAndApply","DG.Tweening.Plugins.SpiralPlugin#init","DG.Tweening.Plugins.SpiralPlugin#Get","DG.Tweening.Plugins.SpiralPlugin#Reset","DG.Tweening.Plugins.SpiralPlugin#SetFrom$1","DG.Tweening.Plugins.SpiralPlugin#SetFrom","DG.Tweening.Plugins.SpiralPlugin#ConvertToStartValue","DG.Tweening.Plugins.SpiralPlugin#SetRelativeEndValue","DG.Tweening.Plugins.SpiralPlugin#SetChangeValue","DG.Tweening.Plugins.SpiralPlugin#GetSpeedBasedDuration","DG.Tweening.Plugins.SpiralPlugin#EvaluateAndApply","DG.Tweening.Plugins.StringPlugin#init","DG.Tweening.Plugins.StringPlugin#SetFrom$1","DG.Tweening.Plugins.StringPlugin#SetFrom","DG.Tweening.Plugins.StringPlugin#Reset","DG.Tweening.Plugins.StringPlugin#ConvertToStartValue","DG.Tweening.Plugins.StringPlugin#SetRelativeEndValue","DG.Tweening.Plugins.StringPlugin#SetChangeValue","DG.Tweening.Plugins.StringPlugin#GetSpeedBasedDuration","DG.Tweening.Plugins.StringPlugin#EvaluateAndApply","DG.Tweening.Plugins.StringPlugin#Append","DG.Tweening.Plugins.StringPlugin#ScrambledCharsToUse","DG.Tweening.Plugins.UintPlugin#Reset","DG.Tweening.Plugins.UintPlugin#SetFrom$1","DG.Tweening.Plugins.UintPlugin#SetFrom","DG.Tweening.Plugins.UintPlugin#ConvertToStartValue","DG.Tweening.Plugins.UintPlugin#SetRelativeEndValue","DG.Tweening.Plugins.UintPlugin#SetChangeValue","DG.Tweening.Plugins.UintPlugin#GetSpeedBasedDuration","DG.Tweening.Plugins.UintPlugin#EvaluateAndApply","DG.Tweening.Plugins.Vector2Plugin#Reset","DG.Tweening.Plugins.Vector2Plugin#SetFrom$1","DG.Tweening.Plugins.Vector2Plugin#SetFrom","DG.Tweening.Plugins.Vector2Plugin#ConvertToStartValue","DG.Tweening.Plugins.Vector2Plugin#SetRelativeEndValue","DG.Tweening.Plugins.Vector2Plugin#SetChangeValue","DG.Tweening.Plugins.Vector2Plugin#GetSpeedBasedDuration","DG.Tweening.Plugins.Vector2Plugin#EvaluateAndApply","DG.Tweening.Plugins.Vector3ArrayPlugin#Reset","DG.Tweening.Plugins.Vector3ArrayPlugin#SetFrom$1","DG.Tweening.Plugins.Vector3ArrayPlugin#SetFrom","DG.Tweening.Plugins.Vector3ArrayPlugin#ConvertToStartValue","DG.Tweening.Plugins.Vector3ArrayPlugin#SetRelativeEndValue","DG.Tweening.Plugins.Vector3ArrayPlugin#SetChangeValue","DG.Tweening.Plugins.Vector3ArrayPlugin#GetSpeedBasedDuration","DG.Tweening.Plugins.Vector3ArrayPlugin#EvaluateAndApply","DG.Tweening.Plugins.Vector3Plugin#Reset","DG.Tweening.Plugins.Vector3Plugin#SetFrom$1","DG.Tweening.Plugins.Vector3Plugin#SetFrom","DG.Tweening.Plugins.Vector3Plugin#ConvertToStartValue","DG.Tweening.Plugins.Vector3Plugin#SetRelativeEndValue","DG.Tweening.Plugins.Vector3Plugin#SetChangeValue","DG.Tweening.Plugins.Vector3Plugin#GetSpeedBasedDuration","DG.Tweening.Plugins.Vector3Plugin#EvaluateAndApply","DG.Tweening.Plugins.Vector4Plugin#Reset","DG.Tweening.Plugins.Vector4Plugin#SetFrom$1","DG.Tweening.Plugins.Vector4Plugin#SetFrom","DG.Tweening.Plugins.Vector4Plugin#ConvertToStartValue","DG.Tweening.Plugins.Vector4Plugin#SetRelativeEndValue","DG.Tweening.Plugins.Vector4Plugin#SetChangeValue","DG.Tweening.Plugins.Vector4Plugin#GetSpeedBasedDuration","DG.Tweening.Plugins.Vector4Plugin#EvaluateAndApply","DG.Tweening.Sequence#Setup","DG.Tweening.Sequence#DoStartup","DG.Tweening.Sequence#DoApplyTween","DG.Tweening.Sequence#ApplyInternalCycle","DG.Tweening.Sequence#StableSortSequencedObjs","DG.Tweening.Sequence#IsAnyCallbackSet","DG.Tweening.Sequence#DoPrepend","DG.Tweening.Sequence#DoInsert","DG.Tweening.Sequence#DoAppendInterval","DG.Tweening.Sequence#DoPrependInterval","DG.Tweening.Sequence#DoInsertCallback","DG.Tweening.Sequence#init","DG.Tweening.Sequence#ctor","DG.Tweening.Sequence#UpdateDelay","DG.Tweening.Sequence#Reset","DG.Tweening.Sequence#Validate","DG.Tweening.Sequence#Startup","DG.Tweening.Sequence#ApplyTween","DG.Tweening.Core.TweenerCore$3#init","DG.Tweening.Core.TweenerCore$3#init","DG.Tweening.Core.TweenerCore$3#ctor","DG.Tweening.Core.TweenerCore$3#ChangeStartValue","DG.Tweening.Core.TweenerCore$3#ChangeStartValue$1","DG.Tweening.Core.TweenerCore$3#ChangeEndValue","DG.Tweening.Core.TweenerCore$3#ChangeEndValue$1","DG.Tweening.Core.TweenerCore$3#ChangeEndValue$2","DG.Tweening.Core.TweenerCore$3#ChangeEndValue$3","DG.Tweening.Core.TweenerCore$3#ChangeValues","DG.Tweening.Core.TweenerCore$3#ChangeValues$1","DG.Tweening.Core.TweenerCore$3#SetFrom","DG.Tweening.Core.TweenerCore$3#SetFrom$1","DG.Tweening.Core.TweenerCore$3#Reset","DG.Tweening.Core.TweenerCore$3#Validate","DG.Tweening.Core.TweenerCore$3#ValidateChangeValueType","DG.Tweening.Core.TweenerCore$3#UpdateDelay","DG.Tweening.Core.TweenerCore$3#Startup","DG.Tweening.Core.TweenerCore$3#ApplyTween","DG.Tweening.CustomPlugins.PureQuaternionPlugin#Plug","DG.Tweening.CustomPlugins.PureQuaternionPlugin#Reset","DG.Tweening.CustomPlugins.PureQuaternionPlugin#SetFrom$1","DG.Tweening.CustomPlugins.PureQuaternionPlugin#SetFrom","DG.Tweening.CustomPlugins.PureQuaternionPlugin#ConvertToStartValue","DG.Tweening.CustomPlugins.PureQuaternionPlugin#SetRelativeEndValue","DG.Tweening.CustomPlugins.PureQuaternionPlugin#SetChangeValue","DG.Tweening.CustomPlugins.PureQuaternionPlugin#GetSpeedBasedDuration","DG.Tweening.CustomPlugins.PureQuaternionPlugin#EvaluateAndApply","DG.Tweening.Plugins.Color2Plugin#Reset","DG.Tweening.Plugins.Color2Plugin#SetFrom$1","DG.Tweening.Plugins.Color2Plugin#SetFrom","DG.Tweening.Plugins.Color2Plugin#ConvertToStartValue","DG.Tweening.Plugins.Color2Plugin#SetRelativeEndValue","DG.Tweening.Plugins.Color2Plugin#SetChangeValue","DG.Tweening.Plugins.Color2Plugin#GetSpeedBasedDuration","DG.Tweening.Plugins.Color2Plugin#EvaluateAndApply","DG.Tweening.Plugins.ColorPlugin#Reset","DG.Tweening.Plugins.ColorPlugin#SetFrom$1","DG.Tweening.Plugins.ColorPlugin#SetFrom","DG.Tweening.Plugins.ColorPlugin#ConvertToStartValue","DG.Tweening.Plugins.ColorPlugin#SetRelativeEndValue","DG.Tweening.Plugins.ColorPlugin#SetChangeValue","DG.Tweening.Plugins.ColorPlugin#GetSpeedBasedDuration","DG.Tweening.Plugins.ColorPlugin#EvaluateAndApply","DG.Tweening.Plugins.DoublePlugin#Reset","DG.Tweening.Plugins.DoublePlugin#SetFrom$1","DG.Tweening.Plugins.DoublePlugin#SetFrom","DG.Tweening.Plugins.DoublePlugin#ConvertToStartValue","DG.Tweening.Plugins.DoublePlugin#SetRelativeEndValue","DG.Tweening.Plugins.DoublePlugin#SetChangeValue","DG.Tweening.Plugins.DoublePlugin#GetSpeedBasedDuration","DG.Tweening.Plugins.DoublePlugin#EvaluateAndApply","DG.Tweening.Plugins.FloatPlugin#Reset","DG.Tweening.Plugins.FloatPlugin#SetFrom$1","DG.Tweening.Plugins.FloatPlugin#SetFrom","DG.Tweening.Plugins.FloatPlugin#ConvertToStartValue","DG.Tweening.Plugins.FloatPlugin#SetRelativeEndValue","DG.Tweening.Plugins.FloatPlugin#SetChangeValue","DG.Tweening.Plugins.FloatPlugin#GetSpeedBasedDuration","DG.Tweening.Plugins.FloatPlugin#EvaluateAndApply","DG.Tweening.Plugins.IntPlugin#Reset","DG.Tweening.Plugins.IntPlugin#SetFrom$1","DG.Tweening.Plugins.IntPlugin#SetFrom","DG.Tweening.Plugins.IntPlugin#ConvertToStartValue","DG.Tweening.Plugins.IntPlugin#SetRelativeEndValue","DG.Tweening.Plugins.IntPlugin#SetChangeValue","DG.Tweening.Plugins.IntPlugin#GetSpeedBasedDuration","DG.Tweening.Plugins.IntPlugin#EvaluateAndApply","DG.Tweening.Plugins.LongPlugin#Reset","DG.Tweening.Plugins.LongPlugin#SetFrom$1","DG.Tweening.Plugins.LongPlugin#SetFrom","DG.Tweening.Plugins.LongPlugin#ConvertToStartValue","DG.Tweening.Plugins.LongPlugin#SetRelativeEndValue","DG.Tweening.Plugins.LongPlugin#SetChangeValue","DG.Tweening.Plugins.LongPlugin#GetSpeedBasedDuration","DG.Tweening.Plugins.LongPlugin#EvaluateAndApply","DG.Tweening.Plugins.RectOffsetPlugin#init","DG.Tweening.Plugins.RectOffsetPlugin#Reset","DG.Tweening.Plugins.RectOffsetPlugin#SetFrom$1","DG.Tweening.Plugins.RectOffsetPlugin#SetFrom","DG.Tweening.Plugins.RectOffsetPlugin#ConvertToStartValue","DG.Tweening.Plugins.RectOffsetPlugin#SetRelativeEndValue","DG.Tweening.Plugins.RectOffsetPlugin#SetChangeValue","DG.Tweening.Plugins.RectOffsetPlugin#GetSpeedBasedDuration","DG.Tweening.Plugins.RectOffsetPlugin#EvaluateAndApply","DG.Tweening.Plugins.UlongPlugin#Reset","DG.Tweening.Plugins.UlongPlugin#SetFrom$1","DG.Tweening.Plugins.UlongPlugin#SetFrom","DG.Tweening.Plugins.UlongPlugin#ConvertToStartValue","DG.Tweening.Plugins.UlongPlugin#SetRelativeEndValue","DG.Tweening.Plugins.UlongPlugin#SetChangeValue","DG.Tweening.Plugins.UlongPlugin#GetSpeedBasedDuration","DG.Tweening.Plugins.UlongPlugin#EvaluateAndApply"]' ) ); }
/**
 * @compiler Bridge.NET 17.9.28-luna
 */
Bridge.assembly("DOTween", function ($asm, globals) {
    "use strict";

    /*DG.Tweening.AutoPlay start.*/
    /** @namespace DG.Tweening */

    /**
     * Types of autoPlay behaviours
     *
     * @public
     * @class DG.Tweening.AutoPlay
     */
    Bridge.define("DG.Tweening.AutoPlay", {
        $kind: 6,
        statics: {
            fields: {
                /**
                 * No tween is automatically played
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.AutoPlay
                 * @constant
                 * @default 0
                 * @type DG.Tweening.AutoPlay
                 */
                None: 0,
                /**
                 * Only Sequences are automatically played
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.AutoPlay
                 * @constant
                 * @default 1
                 * @type DG.Tweening.AutoPlay
                 */
                AutoPlaySequences: 1,
                /**
                 * Only Tweeners are automatically played
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.AutoPlay
                 * @constant
                 * @default 2
                 * @type DG.Tweening.AutoPlay
                 */
                AutoPlayTweeners: 2,
                /**
                 * All tweens are automatically played
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.AutoPlay
                 * @constant
                 * @default 3
                 * @type DG.Tweening.AutoPlay
                 */
                All: 3
            }
        }
    });
    /*DG.Tweening.AutoPlay end.*/

    /*DG.Tweening.AxisConstraint start.*/
    /**
     * What axis to constrain in case of Vector tweens
     *
     * @public
     * @class DG.Tweening.AxisConstraint
     */
    Bridge.define("DG.Tweening.AxisConstraint", {
        $kind: 6,
        statics: {
            fields: {
                None: 0,
                X: 2,
                Y: 4,
                Z: 8,
                W: 16
            }
        },
        $flags: true
    });
    /*DG.Tweening.AxisConstraint end.*/

    /*DG.Tweening.Color2 start.*/
    /**
     * Struct that stores two colors (used for LineRenderer tweens)
     *
     * @public
     * @class DG.Tweening.Color2
     */
    Bridge.define("DG.Tweening.Color2", {
        $kind: 4,
        statics: {
            methods: {
                op_Addition: function (c1, c2) {
if ( TRACE ) { TRACE( "DG.Tweening.Color2#op_Addition", this ); }

                    return new DG.Tweening.Color2.$ctor1(new pc.Color( c1.ca.r + c2.ca.r, c1.ca.g + c2.ca.g, c1.ca.b + c2.ca.b, c1.ca.a + c2.ca.a ), new pc.Color( c1.cb.r + c2.cb.r, c1.cb.g + c2.cb.g, c1.cb.b + c2.cb.b, c1.cb.a + c2.cb.a ));
                },
                op_Subtraction: function (c1, c2) {
if ( TRACE ) { TRACE( "DG.Tweening.Color2#op_Subtraction", this ); }

                    return new DG.Tweening.Color2.$ctor1(new pc.Color( c1.ca.r - c2.ca.r, c1.ca.g - c2.ca.g, c1.ca.b - c2.ca.b, c1.ca.a - c2.ca.a ), new pc.Color( c1.cb.r - c2.cb.r, c1.cb.g - c2.cb.g, c1.cb.b - c2.cb.b, c1.cb.a - c2.cb.a ));
                },
                op_Multiply: function (c1, f) {
if ( TRACE ) { TRACE( "DG.Tweening.Color2#op_Multiply", this ); }

                    return new DG.Tweening.Color2.$ctor1(new pc.Color( c1.ca.r * f, c1.ca.g * f, c1.ca.b * f, c1.ca.a * f ), new pc.Color( c1.cb.r * f, c1.cb.g * f, c1.cb.b * f, c1.cb.a * f ));
                },
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Color2#getDefaultValue", this ); }
 return new DG.Tweening.Color2(); }
            }
        },
        fields: {
            ca: null,
            cb: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Color2#init", this ); }

                this.ca = new UnityEngine.Color();
                this.cb = new UnityEngine.Color();
            },
            $ctor1: function (ca, cb) {
if ( TRACE ) { TRACE( "DG.Tweening.Color2#$ctor1", this ); }

                this.$initialize();
                this.ca = ca.$clone();
                this.cb = cb.$clone();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Color2#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Color2#getHashCode", this ); }

                var h = Bridge.addHash([1869390261, this.ca, this.cb]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "DG.Tweening.Color2#equals", this ); }

                if (!Bridge.is(o, DG.Tweening.Color2)) {
                    return false;
                }
                return Bridge.equals(this.ca, o.ca) && Bridge.equals(this.cb, o.cb);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "DG.Tweening.Color2#$clone", this ); }

                var s = to || new DG.Tweening.Color2();
                s.ca = this.ca.$clone();
                s.cb = this.cb.$clone();
                return s;
            }
        }
    });
    /*DG.Tweening.Color2 end.*/

    /*DG.Tweening.Core.ABSAnimationComponent start.*/
    Bridge.define("DG.Tweening.Core.ABSAnimationComponent", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            updateType: 0,
            isSpeedBased: false,
            hasOnStart: false,
            hasOnPlay: false,
            hasOnUpdate: false,
            hasOnStepComplete: false,
            hasOnComplete: false,
            hasOnTweenCreated: false,
            hasOnRewind: false,
            onStart: null,
            onPlay: null,
            onUpdate: null,
            onStepComplete: null,
            onComplete: null,
            onTweenCreated: null,
            onRewind: null,
            tween: null
        },
        methods: {
            /*DG.Tweening.Core.ABSAnimationComponent.DORestart start.*/
            DORestart: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.ABSAnimationComponent#DORestart", this ); }
 },
            /*DG.Tweening.Core.ABSAnimationComponent.DORestart end.*/


        }
    });
    /*DG.Tweening.Core.ABSAnimationComponent end.*/
    /**
     * @memberof DG.Tweening
     * @callback DG.Tweening.TweenCallback
     * @return  {void}
     */


    /*DG.Tweening.Core.ABSSequentiable start.*/
    Bridge.define("DG.Tweening.Core.ABSSequentiable", {
        fields: {
            /**
             * Called the first time the tween is set in a playing state, after any eventual delay
             *
             * @instance
             * @memberof DG.Tweening.Core.ABSSequentiable
             * @type DG.Tweening.TweenCallback
             */
            onStart: null,
            sequencedEndPosition: 0,
            sequencedPosition: 0,
            tweenType: 0
        }
    });
    /*DG.Tweening.Core.ABSSequentiable end.*/

    /*DG.Tweening.Core.Debugger start.*/
    /** @namespace DG.Tweening.Core */

    /**
     * Public so it can be used by lose scripts related to DOTween (like DOTweenAnimation)
     *
     * @static
     * @abstract
     * @public
     * @class DG.Tweening.Core.Debugger
     */
    Bridge.define("DG.Tweening.Core.Debugger", {
        statics: {
            fields: {
                _LogPrefix: null,
                logPriority: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Debugger#init", this ); }

                    this._LogPrefix = "<color=#0099bc><b>DOTWEEN \u25ba </b></color>";
                }
            },
            methods: {
                /*DG.Tweening.Core.Debugger.Log:static start.*/
                Log: function (message) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Debugger#Log", this ); }

                    var txt = System.String.concat(DG.Tweening.Core.Debugger._LogPrefix, message);
                    if (!Bridge.staticEquals(DG.Tweening.DOTween.onWillLog, null) && !DG.Tweening.DOTween.onWillLog(UnityEngine.LogType.Log, txt)) {
                        return;
                    }

                    UnityEngine.Debug.Log$1(txt);
                },
                /*DG.Tweening.Core.Debugger.Log:static end.*/

                /*DG.Tweening.Core.Debugger.LogWarning:static start.*/
                LogWarning: function (message, t) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Debugger#LogWarning", this ); }

                    if (t === void 0) { t = null; }
                    var txt;
                    if (DG.Tweening.DOTween.debugMode) {
                        txt = System.String.concat(DG.Tweening.Core.Debugger._LogPrefix + DG.Tweening.Core.Debugger.GetDebugDataMessage(t), message);
                    } else {
                        txt = System.String.concat(DG.Tweening.Core.Debugger._LogPrefix, message);
                    }

                    if (!Bridge.staticEquals(DG.Tweening.DOTween.onWillLog, null) && !DG.Tweening.DOTween.onWillLog(UnityEngine.LogType.Warning, txt)) {
                        return;
                    }

                    UnityEngine.Debug.LogWarning$1(txt);
                },
                /*DG.Tweening.Core.Debugger.LogWarning:static end.*/

                /*DG.Tweening.Core.Debugger.LogError:static start.*/
                LogError: function (message, t) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Debugger#LogError", this ); }

                    if (t === void 0) { t = null; }
                    var txt;
                    if (DG.Tweening.DOTween.debugMode) {
                        txt = System.String.concat(DG.Tweening.Core.Debugger._LogPrefix + DG.Tweening.Core.Debugger.GetDebugDataMessage(t), message);
                    } else {
                        txt = System.String.concat(DG.Tweening.Core.Debugger._LogPrefix, message);
                    }

                    if (!Bridge.staticEquals(DG.Tweening.DOTween.onWillLog, null) && !DG.Tweening.DOTween.onWillLog(UnityEngine.LogType.Error, txt)) {
                        return;
                    }

                    UnityEngine.Debug.LogError$2(txt);
                },
                /*DG.Tweening.Core.Debugger.LogError:static end.*/

                /*DG.Tweening.Core.Debugger.LogSafeModeCapturedError:static start.*/
                LogSafeModeCapturedError: function (message, t) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Debugger#LogSafeModeCapturedError", this ); }

                    if (t === void 0) { t = null; }
                    var txt;
                    if (DG.Tweening.DOTween.debugMode) {
                        txt = System.String.concat(DG.Tweening.Core.Debugger._LogPrefix + DG.Tweening.Core.Debugger.GetDebugDataMessage(t), message);
                    } else {
                        txt = System.String.concat(DG.Tweening.Core.Debugger._LogPrefix, message);
                    }

                    if (!Bridge.staticEquals(DG.Tweening.DOTween.onWillLog, null) && !DG.Tweening.DOTween.onWillLog(UnityEngine.LogType.Log, txt)) {
                        return;
                    }

                    switch (DG.Tweening.DOTween.safeModeLogBehaviour) {
                        case DG.Tweening.Core.Enums.SafeModeLogBehaviour.Normal: 
                            UnityEngine.Debug.Log$1(txt);
                            break;
                        case DG.Tweening.Core.Enums.SafeModeLogBehaviour.Warning: 
                            UnityEngine.Debug.LogWarning$1(txt);
                            break;
                        case DG.Tweening.Core.Enums.SafeModeLogBehaviour.Error: 
                            UnityEngine.Debug.LogError$2(txt);
                            break;
                    }
                },
                /*DG.Tweening.Core.Debugger.LogSafeModeCapturedError:static end.*/

                /*DG.Tweening.Core.Debugger.LogReport:static start.*/
                LogReport: function (message) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Debugger#LogReport", this ); }

                    var txt = System.String.format("<color=#00B500FF>{0} REPORT \u25ba</color> {1}", DG.Tweening.Core.Debugger._LogPrefix, message);
                    if (!Bridge.staticEquals(DG.Tweening.DOTween.onWillLog, null) && !DG.Tweening.DOTween.onWillLog(UnityEngine.LogType.Log, txt)) {
                        return;
                    }

                    UnityEngine.Debug.Log$1(txt);
                },
                /*DG.Tweening.Core.Debugger.LogReport:static end.*/

                /*DG.Tweening.Core.Debugger.LogSafeModeReport:static start.*/
                LogSafeModeReport: function (message) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Debugger#LogSafeModeReport", this ); }

                    var txt = System.String.format("<color=#ff7337>{0} SAFE MODE \u25ba</color> {1}", DG.Tweening.Core.Debugger._LogPrefix, message);
                    if (!Bridge.staticEquals(DG.Tweening.DOTween.onWillLog, null) && !DG.Tweening.DOTween.onWillLog(UnityEngine.LogType.Log, txt)) {
                        return;
                    }

                    UnityEngine.Debug.LogWarning$1(txt);
                },
                /*DG.Tweening.Core.Debugger.LogSafeModeReport:static end.*/

                /*DG.Tweening.Core.Debugger.LogInvalidTween:static start.*/
                LogInvalidTween: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Debugger#LogInvalidTween", this ); }

                    DG.Tweening.Core.Debugger.LogWarning("This Tween has been killed and is now invalid");
                },
                /*DG.Tweening.Core.Debugger.LogInvalidTween:static end.*/

                /*DG.Tweening.Core.Debugger.LogNestedTween:static start.*/
                LogNestedTween: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Debugger#LogNestedTween", this ); }

                    DG.Tweening.Core.Debugger.LogWarning("This Tween was added to a Sequence and can't be controlled directly", t);
                },
                /*DG.Tweening.Core.Debugger.LogNestedTween:static end.*/

                /*DG.Tweening.Core.Debugger.LogNullTween:static start.*/
                LogNullTween: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Debugger#LogNullTween", this ); }

                    DG.Tweening.Core.Debugger.LogWarning("Null Tween");
                },
                /*DG.Tweening.Core.Debugger.LogNullTween:static end.*/

                /*DG.Tweening.Core.Debugger.LogNonPathTween:static start.*/
                LogNonPathTween: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Debugger#LogNonPathTween", this ); }

                    DG.Tweening.Core.Debugger.LogWarning("This Tween is not a path tween", t);
                },
                /*DG.Tweening.Core.Debugger.LogNonPathTween:static end.*/

                /*DG.Tweening.Core.Debugger.LogMissingMaterialProperty$1:static start.*/
                LogMissingMaterialProperty$1: function (propertyName) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Debugger#LogMissingMaterialProperty$1", this ); }

                    DG.Tweening.Core.Debugger.LogWarning(System.String.format("This material doesn't have a {0} property", [propertyName]));
                },
                /*DG.Tweening.Core.Debugger.LogMissingMaterialProperty$1:static end.*/

                /*DG.Tweening.Core.Debugger.LogMissingMaterialProperty:static start.*/
                LogMissingMaterialProperty: function (propertyId) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Debugger#LogMissingMaterialProperty", this ); }

                    DG.Tweening.Core.Debugger.LogWarning(System.String.format("This material doesn't have a {0} property ID", [propertyId]));
                },
                /*DG.Tweening.Core.Debugger.LogMissingMaterialProperty:static end.*/

                /*DG.Tweening.Core.Debugger.LogRemoveActiveTweenError:static start.*/
                LogRemoveActiveTweenError: function (errorInfo, t) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Debugger#LogRemoveActiveTweenError", this ); }

                    DG.Tweening.Core.Debugger.LogWarning(System.String.format("Error in RemoveActiveTween ({0}). It's been taken care of so no problems, but Daniele (DOTween's author) is trying to pinpoint it (it's very rare and he can't reproduce it) so it would be awesome if you could reproduce this log in a sample project and send it to him. Or even just write him the complete log that was generated by this message. Fixing this would make DOTween slightly faster. Thanks.", [errorInfo]), t);
                },
                /*DG.Tweening.Core.Debugger.LogRemoveActiveTweenError:static end.*/

                /*DG.Tweening.Core.Debugger.LogAddActiveTweenError:static start.*/
                LogAddActiveTweenError: function (errorInfo, t) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Debugger#LogAddActiveTweenError", this ); }

                    DG.Tweening.Core.Debugger.LogWarning(System.String.format("Error in AddActiveTween ({0}). It's been taken care of so no problems, but Daniele (DOTween's author) is trying to pinpoint it (it's very rare and he can't reproduce it) so it would be awesome if you could reproduce this log in a sample project and send it to him. Or even just write him the complete log that was generated by this message. Fixing this would make DOTween slightly faster. Thanks.", [errorInfo]), t);
                },
                /*DG.Tweening.Core.Debugger.LogAddActiveTweenError:static end.*/

                /*DG.Tweening.Core.Debugger.SetLogPriority:static start.*/
                SetLogPriority: function (logBehaviour) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Debugger#SetLogPriority", this ); }

                    switch (logBehaviour) {
                        case DG.Tweening.LogBehaviour.Default: 
                            DG.Tweening.Core.Debugger.logPriority = 1;
                            break;
                        case DG.Tweening.LogBehaviour.Verbose: 
                            DG.Tweening.Core.Debugger.logPriority = 2;
                            break;
                        default: 
                            DG.Tweening.Core.Debugger.logPriority = 0;
                            break;
                    }
                },
                /*DG.Tweening.Core.Debugger.SetLogPriority:static end.*/

                /*DG.Tweening.Core.Debugger.ShouldLogSafeModeCapturedError:static start.*/
                ShouldLogSafeModeCapturedError: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Debugger#ShouldLogSafeModeCapturedError", this ); }

                    switch (DG.Tweening.DOTween.safeModeLogBehaviour) {
                        case DG.Tweening.Core.Enums.SafeModeLogBehaviour.None: 
                            return false;
                        case DG.Tweening.Core.Enums.SafeModeLogBehaviour.Normal: 
                        case DG.Tweening.Core.Enums.SafeModeLogBehaviour.Warning: 
                            return DG.Tweening.Core.Debugger.logPriority >= 1;
                        default: 
                            return true;
                    }
                },
                /*DG.Tweening.Core.Debugger.ShouldLogSafeModeCapturedError:static end.*/

                /*DG.Tweening.Core.Debugger.GetDebugDataMessage:static start.*/
                GetDebugDataMessage: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Debugger#GetDebugDataMessage", this ); }

                    var txt = { v : "" };
                    DG.Tweening.Core.Debugger.AddDebugDataToMessage(txt, t);
                    return txt.v;
                },
                /*DG.Tweening.Core.Debugger.GetDebugDataMessage:static end.*/

                /*DG.Tweening.Core.Debugger.AddDebugDataToMessage:static start.*/
                AddDebugDataToMessage: function (message, t) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Debugger#AddDebugDataToMessage", this ); }

                    if (t == null) {
                        return;
                    }

                    var hasDebugTargetId = t.debugTargetId != null;
                    var hasStringId = t.stringId != null;
                    var hasIntId = t.intId !== -999;
                    if (hasDebugTargetId || hasStringId || hasIntId) {
                        message.v = (message.v || "") + "DEBUG MODE INFO \u25ba ";
                        if (hasDebugTargetId) {
                            message.v = (message.v || "") + ((System.String.format("[tween target: {0}]", [t.debugTargetId])) || "");
                        }

                        if (hasStringId) {
                            message.v = (message.v || "") + ((System.String.format("[stringId: {0}]", [t.stringId])) || "");
                        }

                        if (hasIntId) {
                            message.v = (message.v || "") + ((System.String.format("[intId: {0}]", [t.intId])) || "");
                        }

                        message.v = (message.v || "") + "\n";
                    }
                },
                /*DG.Tweening.Core.Debugger.AddDebugDataToMessage:static end.*/


            }
        }
    });
    /*DG.Tweening.Core.Debugger end.*/

    /*DG.Tweening.Core.Debugger+Sequence start.*/
    Bridge.define("DG.Tweening.Core.Debugger.Sequence", {
        $kind: 1002,
        statics: {
            methods: {
                /*DG.Tweening.Core.Debugger+Sequence.LogAddToNullSequence:static start.*/
                LogAddToNullSequence: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Debugger.Sequence#LogAddToNullSequence", this ); }

                    DG.Tweening.Core.Debugger.LogWarning("You can't add elements to a NULL Sequence");
                },
                /*DG.Tweening.Core.Debugger+Sequence.LogAddToNullSequence:static end.*/

                /*DG.Tweening.Core.Debugger+Sequence.LogAddToInactiveSequence:static start.*/
                LogAddToInactiveSequence: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Debugger.Sequence#LogAddToInactiveSequence", this ); }

                    DG.Tweening.Core.Debugger.LogWarning("You can't add elements to an inactive/killed Sequence");
                },
                /*DG.Tweening.Core.Debugger+Sequence.LogAddToInactiveSequence:static end.*/

                /*DG.Tweening.Core.Debugger+Sequence.LogAddToLockedSequence:static start.*/
                LogAddToLockedSequence: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Debugger.Sequence#LogAddToLockedSequence", this ); }

                    DG.Tweening.Core.Debugger.LogWarning("The Sequence has started and is now locked, you can only elements to a Sequence before it starts");
                },
                /*DG.Tweening.Core.Debugger+Sequence.LogAddToLockedSequence:static end.*/

                /*DG.Tweening.Core.Debugger+Sequence.LogAddNullTween:static start.*/
                LogAddNullTween: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Debugger.Sequence#LogAddNullTween", this ); }

                    DG.Tweening.Core.Debugger.LogWarning("You can't add a NULL tween to a Sequence");
                },
                /*DG.Tweening.Core.Debugger+Sequence.LogAddNullTween:static end.*/

                /*DG.Tweening.Core.Debugger+Sequence.LogAddInactiveTween:static start.*/
                LogAddInactiveTween: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Debugger.Sequence#LogAddInactiveTween", this ); }

                    DG.Tweening.Core.Debugger.LogWarning("You can't add an inactive/killed tween to a Sequence", t);
                },
                /*DG.Tweening.Core.Debugger+Sequence.LogAddInactiveTween:static end.*/

                /*DG.Tweening.Core.Debugger+Sequence.LogAddAlreadySequencedTween:static start.*/
                LogAddAlreadySequencedTween: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Debugger.Sequence#LogAddAlreadySequencedTween", this ); }

                    DG.Tweening.Core.Debugger.LogWarning("You can't add a tween that is already nested into a Sequence to another Sequence", t);
                },
                /*DG.Tweening.Core.Debugger+Sequence.LogAddAlreadySequencedTween:static end.*/


            }
        }
    });
    /*DG.Tweening.Core.Debugger+Sequence end.*/

    /*DG.Tweening.Core.DOTweenAnimationType start.*/
    Bridge.define("DG.Tweening.Core.DOTweenAnimationType", {
        $kind: 6,
        statics: {
            fields: {
                None: 0,
                Move: 1,
                LocalMove: 2,
                Rotate: 3,
                LocalRotate: 4,
                Scale: 5,
                Color: 6,
                Fade: 7,
                Text: 8,
                PunchPosition: 9,
                PunchRotation: 10,
                PunchScale: 11,
                ShakePosition: 12,
                ShakeRotation: 13,
                ShakeScale: 14,
                CameraAspect: 15,
                CameraBackgroundColor: 16,
                CameraFieldOfView: 17,
                CameraOrthoSize: 18,
                CameraPixelRect: 19,
                CameraRect: 20,
                UIWidthHeight: 21
            }
        }
    });
    /*DG.Tweening.Core.DOTweenAnimationType end.*/

    /*DG.Tweening.IDOTweenInit start.*/
    /**
     * Used to allow method chaining with DOTween.Init
     *
     * @abstract
     * @public
     * @class DG.Tweening.IDOTweenInit
     */
    Bridge.define("DG.Tweening.IDOTweenInit", {
        $kind: 3
    });
    /*DG.Tweening.IDOTweenInit end.*/

    /*DG.Tweening.Core.DOTweenExternalCommand start.*/
    /**
     * Used to dispatch commands that need to be captured externally, usually by Modules
     *
     * @static
     * @abstract
     * @public
     * @class DG.Tweening.Core.DOTweenExternalCommand
     */
    Bridge.define("DG.Tweening.Core.DOTweenExternalCommand", {
        statics: {
            events: {
                SetOrientationOnPath: null
            },
            methods: {
                /*DG.Tweening.Core.DOTweenExternalCommand.Dispatch_SetOrientationOnPath:static start.*/
                Dispatch_SetOrientationOnPath: function (options, t, newRot, trans) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.DOTweenExternalCommand#Dispatch_SetOrientationOnPath", this ); }

                    if (!Bridge.staticEquals(DG.Tweening.Core.DOTweenExternalCommand.SetOrientationOnPath, null)) {
                        DG.Tweening.Core.DOTweenExternalCommand.SetOrientationOnPath(options.$clone(), t, newRot.$clone(), trans);
                    }
                },
                /*DG.Tweening.Core.DOTweenExternalCommand.Dispatch_SetOrientationOnPath:static end.*/


            }
        }
    });
    /*DG.Tweening.Core.DOTweenExternalCommand end.*/

    /*DG.Tweening.Core.DOTweenSettings start.*/
    Bridge.define("DG.Tweening.Core.DOTweenSettings", {
        inherits: [UnityEngine.ScriptableObject],
        statics: {
            fields: {
                AssetName: null,
                AssetFullFilename: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.DOTweenSettings#init", this ); }

                    this.AssetName = "DOTweenSettings";
                    this.AssetFullFilename = "DOTweenSettings.asset";
                }
            }
        },
        fields: {
            useSafeMode: false,
            safeModeOptions: null,
            timeScale: 0,
            unscaledTimeScale: 0,
            useSmoothDeltaTime: false,
            maxSmoothUnscaledTime: 0,
            rewindCallbackMode: 0,
            showUnityEditorReport: false,
            logBehaviour: 0,
            drawGizmos: false,
            defaultRecyclable: false,
            defaultAutoPlay: 0,
            defaultUpdateType: 0,
            defaultTimeScaleIndependent: false,
            defaultEaseType: 0,
            defaultEaseOvershootOrAmplitude: 0,
            defaultEasePeriod: 0,
            defaultAutoKill: false,
            defaultLoopType: 0,
            debugMode: false,
            debugStoreTargetId: false,
            showPreviewPanel: false,
            storeSettingsLocation: 0,
            modules: null,
            createASMDEF: false,
            showPlayingTweens: false,
            showPausedTweens: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.DOTweenSettings#init", this ); }

                this.useSafeMode = true;
                this.safeModeOptions = new DG.Tweening.Core.DOTweenSettings.SafeModeOptions();
                this.timeScale = 1;
                this.unscaledTimeScale = 1;
                this.maxSmoothUnscaledTime = 0.15;
                this.rewindCallbackMode = DG.Tweening.Core.Enums.RewindCallbackMode.FireIfPositionChanged;
                this.logBehaviour = DG.Tweening.LogBehaviour.Default;
                this.drawGizmos = true;
                this.defaultAutoPlay = DG.Tweening.AutoPlay.All;
                this.defaultEaseType = DG.Tweening.Ease.OutQuad;
                this.defaultEaseOvershootOrAmplitude = 1.70158;
                this.defaultAutoKill = true;
                this.defaultLoopType = DG.Tweening.LoopType.Restart;
                this.debugStoreTargetId = true;
                this.showPreviewPanel = true;
                this.storeSettingsLocation = DG.Tweening.Core.DOTweenSettings.SettingsLocation.AssetsDirectory;
                this.modules = new DG.Tweening.Core.DOTweenSettings.ModulesSetup();
            }
        }
    });
    /*DG.Tweening.Core.DOTweenSettings end.*/

    /*DG.Tweening.Core.DOTweenSettings+ModulesSetup start.*/
    Bridge.define("DG.Tweening.Core.DOTweenSettings.ModulesSetup", {
        $kind: 1002,
        fields: {
            showPanel: false,
            audioEnabled: false,
            physicsEnabled: false,
            physics2DEnabled: false,
            spriteEnabled: false,
            uiEnabled: false,
            textMeshProEnabled: false,
            tk2DEnabled: false,
            deAudioEnabled: false,
            deUnityExtendedEnabled: false,
            epoOutlineEnabled: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.DOTweenSettings.ModulesSetup#init", this ); }

                this.audioEnabled = true;
                this.physicsEnabled = true;
                this.physics2DEnabled = true;
                this.spriteEnabled = true;
                this.uiEnabled = true;
            }
        }
    });
    /*DG.Tweening.Core.DOTweenSettings+ModulesSetup end.*/

    /*DG.Tweening.Core.DOTweenSettings+SafeModeOptions start.*/
    Bridge.define("DG.Tweening.Core.DOTweenSettings.SafeModeOptions", {
        $kind: 1002,
        fields: {
            logBehaviour: 0,
            nestedTweenFailureBehaviour: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.DOTweenSettings.SafeModeOptions#init", this ); }

                this.logBehaviour = DG.Tweening.Core.Enums.SafeModeLogBehaviour.Warning;
                this.nestedTweenFailureBehaviour = DG.Tweening.Core.Enums.NestedTweenFailureBehaviour.TryToPreserveSequence;
            }
        }
    });
    /*DG.Tweening.Core.DOTweenSettings+SafeModeOptions end.*/

    /*DG.Tweening.Core.DOTweenSettings+SettingsLocation start.*/
    Bridge.define("DG.Tweening.Core.DOTweenSettings.SettingsLocation", {
        $kind: 1006,
        statics: {
            fields: {
                AssetsDirectory: 0,
                DOTweenDirectory: 1,
                DemigiantDirectory: 2
            }
        }
    });
    /*DG.Tweening.Core.DOTweenSettings+SettingsLocation end.*/

    /*DG.Tweening.Core.DOTweenUtils start.*/
    Bridge.define("DG.Tweening.Core.DOTweenUtils", {
        statics: {
            fields: {
                _loadedAssemblies: null,
                _defAssembliesToQuery: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.DOTweenUtils#init", this ); }

                    this._defAssembliesToQuery = System.Array.init([
                        "DOTween.Modules", 
                        "Assembly-CSharp", 
                        "Assembly-CSharp-firstpass"
                    ], System.String);
                }
            },
            methods: {
                /*DG.Tweening.Core.DOTweenUtils.Vector3FromAngle:static start.*/
                /**
                 * Returns a Vector3 with z = 0
                 *
                 * @static
                 * @this DG.Tweening.Core.DOTweenUtils
                 * @memberof DG.Tweening.Core.DOTweenUtils
                 * @param   {number}                 degrees      
                 * @param   {number}                 magnitude
                 * @return  {UnityEngine.Vector3}
                 */
                Vector3FromAngle: function (degrees, magnitude) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.DOTweenUtils#Vector3FromAngle", this ); }

                    var radians = degrees * UnityEngine.Mathf.Deg2Rad;
                    return new pc.Vec3( magnitude * Math.cos(radians), magnitude * Math.sin(radians), 0 );
                },
                /*DG.Tweening.Core.DOTweenUtils.Vector3FromAngle:static end.*/

                /*DG.Tweening.Core.DOTweenUtils.Angle2D:static start.*/
                /**
                 * Returns the 2D angle between two vectors
                 *
                 * @static
                 * @this DG.Tweening.Core.DOTweenUtils
                 * @memberof DG.Tweening.Core.DOTweenUtils
                 * @param   {UnityEngine.Vector3}    from    
                 * @param   {UnityEngine.Vector3}    to
                 * @return  {number}
                 */
                Angle2D: function (from, to) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.DOTweenUtils#Angle2D", this ); }

                    var baseDir = pc.Vec2.RIGHT.clone();
                    to = to.$clone().sub( from.$clone() );
                    var ang = pc.Vec2.angle( baseDir, UnityEngine.Vector2.FromVector3(to) );
                    var cross = new pc.Vec3().cross( UnityEngine.Vector3.FromVector2(baseDir), to );
                    if (cross.z > 0) {
                        ang = 360 - ang;
                    }

                    ang *= -1.0;
                    return ang;
                },
                /*DG.Tweening.Core.DOTweenUtils.Angle2D:static end.*/

                /*DG.Tweening.Core.DOTweenUtils.RotateAroundPivot:static start.*/
                RotateAroundPivot: function (point, pivot, rotation) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.DOTweenUtils#RotateAroundPivot", this ); }

                    return rotation.transformVector( (point.$clone().sub( pivot )) ).add( pivot );
                },
                /*DG.Tweening.Core.DOTweenUtils.RotateAroundPivot:static end.*/

                /*DG.Tweening.Core.DOTweenUtils.GetPointOnCircle:static start.*/
                /**
                 * Returns a point on a circle with the given center and radius,
                     using Unity's circle coordinates (0 points up and increases clockwise)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.Core.DOTweenUtils
                 * @memberof DG.Tweening.Core.DOTweenUtils
                 * @param   {UnityEngine.Vector2}    center     
                 * @param   {number}                 radius     
                 * @param   {number}                 degrees
                 * @return  {UnityEngine.Vector2}
                 */
                GetPointOnCircle: function (center, radius, degrees) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.DOTweenUtils#GetPointOnCircle", this ); }

                    // Adapt to Unity's circle coordinates
                    // (Unity's circle 0 points up and increases clockwise, unit circle 0 points right and rotates counter-clockwise)
                    degrees = 90 - degrees;
                    //
                    var radians = degrees * UnityEngine.Mathf.Deg2Rad;
                    return center.$clone().add( new pc.Vec2( Math.cos(radians), Math.sin(radians) ).scale( radius ) );
                },
                /*DG.Tweening.Core.DOTweenUtils.GetPointOnCircle:static end.*/

                /*DG.Tweening.Core.DOTweenUtils.Vector3AreApproximatelyEqual:static start.*/
                /**
                 * Uses approximate equality on each axis instead of Unity's Vector3 equality,
                     because the latter fails (in some cases) when assigning a Vector3 to a transform.position and then checking it.
                 *
                 * @static
                 * @this DG.Tweening.Core.DOTweenUtils
                 * @memberof DG.Tweening.Core.DOTweenUtils
                 * @param   {UnityEngine.Vector3}    a    
                 * @param   {UnityEngine.Vector3}    b
                 * @return  {boolean}
                 */
                Vector3AreApproximatelyEqual: function (a, b) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.DOTweenUtils#Vector3AreApproximatelyEqual", this ); }

                    return UnityEngine.Mathf.Approximately(a.x, b.x) && UnityEngine.Mathf.Approximately(a.y, b.y) && UnityEngine.Mathf.Approximately(a.z, b.z);
                },
                /*DG.Tweening.Core.DOTweenUtils.Vector3AreApproximatelyEqual:static end.*/

                /*DG.Tweening.Core.DOTweenUtils.GetLooseScriptType:static start.*/
                /**
                 * Looks for the type within all possible project assembly names
                 *
                 * @static
                 * @this DG.Tweening.Core.DOTweenUtils
                 * @memberof DG.Tweening.Core.DOTweenUtils
                 * @param   {string}         typeName
                 * @return  {System.Type}
                 */
                GetLooseScriptType: function (typeName) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.DOTweenUtils#GetLooseScriptType", this ); }

                    // Check in default assemblies (Unity 2017 and later)
                    for (var i = 0; i < DG.Tweening.Core.DOTweenUtils._defAssembliesToQuery.length; ++i) {
                        var result = Bridge.Reflection.getType(System.String.format("{0}, {1}", typeName, DG.Tweening.Core.DOTweenUtils._defAssembliesToQuery[i]));
                        if (result == null) {
                            continue;
                        }

                        return result;
                    }

                    // Check in all assemblies
                    if (DG.Tweening.Core.DOTweenUtils._loadedAssemblies == null) {
                        DG.Tweening.Core.DOTweenUtils._loadedAssemblies = System.AppDomain.getAssemblies();
                    }

                    for (var i1 = 0; i1 < DG.Tweening.Core.DOTweenUtils._loadedAssemblies.length; ++i1) {
                        var result1 = Bridge.Reflection.getType(System.String.format("{0}, {1}", typeName, DG.Tweening.Core.DOTweenUtils._loadedAssemblies[i1].getName()));
                        if (result1 == null) {
                            continue;
                        }

                        return result1;
                    }

                    return null;
                },
                /*DG.Tweening.Core.DOTweenUtils.GetLooseScriptType:static end.*/


            }
        }
    });
    /*DG.Tweening.Core.DOTweenUtils end.*/

    /*DG.Tweening.Core.Easing.Bounce start.*/
    /** @namespace DG.Tweening.Core.Easing */

    /**
     * This class contains a C# port of the easing equations created by Robert Penner (http://robertpenner.com/easing).
     *
     * @static
     * @abstract
     * @public
     * @class DG.Tweening.Core.Easing.Bounce
     */
    Bridge.define("DG.Tweening.Core.Easing.Bounce", {
        statics: {
            methods: {
                /*DG.Tweening.Core.Easing.Bounce.EaseIn:static start.*/
                /**
                 * Easing equation function for a bounce (exponentially decaying parabolic bounce) easing in: accelerating from zero
                     velocity.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.Core.Easing.Bounce
                 * @memberof DG.Tweening.Core.Easing.Bounce
                 * @param   {number}    time                          Current time (in frames or seconds).
                 * @param   {number}    duration                      Expected easing duration (in frames or seconds).
                 * @param   {number}    unusedOvershootOrAmplitude    Unused: here to keep same delegate for all ease types.
                 * @param   {number}    unusedPeriod                  Unused: here to keep same delegate for all ease types.
                 * @return  {number}                                  The eased value.
                 */
                EaseIn: function (time, duration, unusedOvershootOrAmplitude, unusedPeriod) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Easing.Bounce#EaseIn", this ); }

                    return 1 - DG.Tweening.Core.Easing.Bounce.EaseOut(duration - time, duration, -1, -1);
                },
                /*DG.Tweening.Core.Easing.Bounce.EaseIn:static end.*/

                /*DG.Tweening.Core.Easing.Bounce.EaseOut:static start.*/
                /**
                 * Easing equation function for a bounce (exponentially decaying parabolic bounce) easing out: decelerating from zero
                     velocity.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.Core.Easing.Bounce
                 * @memberof DG.Tweening.Core.Easing.Bounce
                 * @param   {number}    time                          Current time (in frames or seconds).
                 * @param   {number}    duration                      Expected easing duration (in frames or seconds).
                 * @param   {number}    unusedOvershootOrAmplitude    Unused: here to keep same delegate for all ease types.
                 * @param   {number}    unusedPeriod                  Unused: here to keep same delegate for all ease types.
                 * @return  {number}                                  The eased value.
                 */
                EaseOut: function (time, duration, unusedOvershootOrAmplitude, unusedPeriod) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Easing.Bounce#EaseOut", this ); }

                    if (((time = time / duration)) < 0.363636374) {
                        return 7.5625 * time * time;
                    }

                    if (time < 0.727272749) {
                        return 7.5625 * ((time = time - (0.545454562))) * time + 0.75;
                    }

                    if (time < 0.909090936) {
                        return 7.5625 * ((time = time - (0.8181818))) * time + 0.9375;
                    }

                    return 7.5625 * ((time = time - (0.954545438))) * time + 0.984375;
                },
                /*DG.Tweening.Core.Easing.Bounce.EaseOut:static end.*/

                /*DG.Tweening.Core.Easing.Bounce.EaseInOut:static start.*/
                /**
                 * Easing equation function for a bounce (exponentially decaying parabolic bounce) easing in/out: acceleration until
                     halfway, then deceleration.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.Core.Easing.Bounce
                 * @memberof DG.Tweening.Core.Easing.Bounce
                 * @param   {number}    time                          Current time (in frames or seconds).
                 * @param   {number}    duration                      Expected easing duration (in frames or seconds).
                 * @param   {number}    unusedOvershootOrAmplitude    Unused: here to keep same delegate for all ease types.
                 * @param   {number}    unusedPeriod                  Unused: here to keep same delegate for all ease types.
                 * @return  {number}                                  The eased value.
                 */
                EaseInOut: function (time, duration, unusedOvershootOrAmplitude, unusedPeriod) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Easing.Bounce#EaseInOut", this ); }

                    if (time < duration * 0.5) {
                        return DG.Tweening.Core.Easing.Bounce.EaseIn(time * 2, duration, -1, -1) * 0.5;
                    }

                    return DG.Tweening.Core.Easing.Bounce.EaseOut(time * 2 - duration, duration, -1, -1) * 0.5 + 0.5;
                },
                /*DG.Tweening.Core.Easing.Bounce.EaseInOut:static end.*/


            }
        }
    });
    /*DG.Tweening.Core.Easing.Bounce end.*/

    /*DG.Tweening.Core.Easing.EaseCurve start.*/
    /**
     * Used to interpret AnimationCurves as eases.
         Public so it can be used by external ease factories
     *
     * @public
     * @class DG.Tweening.Core.Easing.EaseCurve
     */
    Bridge.define("DG.Tweening.Core.Easing.EaseCurve", {
        fields: {
            _animCurve: null
        },
        ctors: {
            ctor: function (animCurve) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Easing.EaseCurve#ctor", this ); }

                this.$initialize();
                this._animCurve = animCurve;
            }
        },
        methods: {
            /*DG.Tweening.Core.Easing.EaseCurve.Evaluate start.*/
            Evaluate: function (time, duration, unusedOvershoot, unusedPeriod) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Easing.EaseCurve#Evaluate", this ); }

                var curveLen = this._animCurve.keys[this._animCurve.keys.length - 1].time;
                var timePerc = time / duration;
                var $eval = this._animCurve.value(timePerc * curveLen);
                return $eval;
            },
            /*DG.Tweening.Core.Easing.EaseCurve.Evaluate end.*/


        }
    });
    /*DG.Tweening.Core.Easing.EaseCurve end.*/
    /**
     * @memberof DG.Tweening
     * @callback DG.Tweening.EaseFunction
     * @param   {number}    time                    
     * @param   {number}    duration                
     * @param   {number}    overshootOrAmplitude    
     * @param   {number}    period
     * @return  {number}
     */


    /*DG.Tweening.Core.Easing.EaseManager start.*/
    Bridge.define("DG.Tweening.Core.Easing.EaseManager", {
        statics: {
            fields: {
                _PiOver2: 0,
                _TwoPi: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Easing.EaseManager#init", this ); }

                    this._PiOver2 = 1.57079637;
                    this._TwoPi = 6.28318548;
                }
            },
            methods: {
                /*DG.Tweening.Core.Easing.EaseManager.Evaluate$1:static start.*/
                /**
                 * Returns a value between 0 and 1 (inclusive) based on the elapsed time and ease selected
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.Core.Easing.EaseManager
                 * @memberof DG.Tweening.Core.Easing.EaseManager
                 * @param   {DG.Tweening.Tween}    t                       
                 * @param   {number}               time                    
                 * @param   {number}               duration                
                 * @param   {number}               overshootOrAmplitude    
                 * @param   {number}               period
                 * @return  {number}
                 */
                Evaluate$1: function (t, time, duration, overshootOrAmplitude, period) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Easing.EaseManager#Evaluate$1", this ); }

                    // Overload used only to allow custom user plugins to avoid calling t.easeType and t.customEase since they're internal
                    return DG.Tweening.Core.Easing.EaseManager.Evaluate(t.easeType, t.customEase, time, duration, overshootOrAmplitude, period);
                },
                /*DG.Tweening.Core.Easing.EaseManager.Evaluate$1:static end.*/

                /*DG.Tweening.Core.Easing.EaseManager.Evaluate:static start.*/
                /**
                 * Returns a value between 0 and 1 (inclusive) based on the elapsed time and ease selected
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.Core.Easing.EaseManager
                 * @memberof DG.Tweening.Core.Easing.EaseManager
                 * @param   {DG.Tweening.Ease}            easeType                
                 * @param   {DG.Tweening.EaseFunction}    customEase              
                 * @param   {number}                      time                    
                 * @param   {number}                      duration                
                 * @param   {number}                      overshootOrAmplitude    
                 * @param   {number}                      period
                 * @return  {number}
                 */
                Evaluate: function (easeType, customEase, time, duration, overshootOrAmplitude, period) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Easing.EaseManager#Evaluate", this ); }

                    switch (easeType) {
                        case DG.Tweening.Ease.Linear: 
                            return time / duration;
                        case DG.Tweening.Ease.InSine: 
                            return -Math.cos(time / duration * DG.Tweening.Core.Easing.EaseManager._PiOver2) + 1;
                        case DG.Tweening.Ease.OutSine: 
                            return Math.sin(time / duration * DG.Tweening.Core.Easing.EaseManager._PiOver2);
                        case DG.Tweening.Ease.InOutSine: 
                            return -0.5 * (Math.cos(UnityEngine.Mathf.PI * time / duration) - 1);
                        case DG.Tweening.Ease.InQuad: 
                            return ((time = time / duration)) * time;
                        case DG.Tweening.Ease.OutQuad: 
                            return -((time = time / duration)) * (time - 2);
                        case DG.Tweening.Ease.InOutQuad: 
                            if (((time = time / (duration * 0.5))) < 1) {
                                return 0.5 * time * time;
                            }
                            return -0.5 * (--time * (time - 2) - 1);
                        case DG.Tweening.Ease.InCubic: 
                            return ((time = time / duration)) * time * time;
                        case DG.Tweening.Ease.OutCubic: 
                            return ((time = time / duration - 1)) * time * time + 1;
                        case DG.Tweening.Ease.InOutCubic: 
                            if (((time = time / (duration * 0.5))) < 1) {
                                return 0.5 * time * time * time;
                            }
                            return 0.5 * (((time = time - 2)) * time * time + 2);
                        case DG.Tweening.Ease.InQuart: 
                            return ((time = time / duration)) * time * time * time;
                        case DG.Tweening.Ease.OutQuart: 
                            return -(((time = time / duration - 1)) * time * time * time - 1);
                        case DG.Tweening.Ease.InOutQuart: 
                            if (((time = time / (duration * 0.5))) < 1) {
                                return 0.5 * time * time * time * time;
                            }
                            return -0.5 * (((time = time - 2)) * time * time * time - 2);
                        case DG.Tweening.Ease.InQuint: 
                            return ((time = time / duration)) * time * time * time * time;
                        case DG.Tweening.Ease.OutQuint: 
                            return ((time = time / duration - 1)) * time * time * time * time + 1;
                        case DG.Tweening.Ease.InOutQuint: 
                            if (((time = time / (duration * 0.5))) < 1) {
                                return 0.5 * time * time * time * time * time;
                            }
                            return 0.5 * (((time = time - 2)) * time * time * time * time + 2);
                        case DG.Tweening.Ease.InExpo: 
                            return time === 0 ? 0 : Math.pow(2, 10 * (time / duration - 1));
                        case DG.Tweening.Ease.OutExpo: 
                            if (time === duration) {
                                return 1;
                            }
                            return -Math.pow(2, -10 * time / duration) + 1;
                        case DG.Tweening.Ease.InOutExpo: 
                            if (time === 0) {
                                return 0;
                            }
                            if (time === duration) {
                                return 1;
                            }
                            if (((time = time / (duration * 0.5))) < 1) {
                                return 0.5 * Math.pow(2, 10 * (time - 1));
                            }
                            return 0.5 * (-Math.pow(2, -10 * --time) + 2);
                        case DG.Tweening.Ease.InCirc: 
                            return -(Math.sqrt(1 - ((time = time / duration)) * time) - 1);
                        case DG.Tweening.Ease.OutCirc: 
                            return Math.sqrt(1 - ((time = time / duration - 1)) * time);
                        case DG.Tweening.Ease.InOutCirc: 
                            if (((time = time / (duration * 0.5))) < 1) {
                                return -0.5 * (Math.sqrt(1 - time * time) - 1);
                            }
                            return 0.5 * (Math.sqrt(1 - ((time = time - 2)) * time) + 1);
                        case DG.Tweening.Ease.InElastic: 
                            var s0;
                            if (time === 0) {
                                return 0;
                            }
                            if (((time = time / duration)) === 1) {
                                return 1;
                            }
                            if (period === 0) {
                                period = duration * 0.3;
                            }
                            if (overshootOrAmplitude < 1) {
                                overshootOrAmplitude = 1;
                                s0 = period / 4;
                            } else {
                                s0 = period / DG.Tweening.Core.Easing.EaseManager._TwoPi * Math.asin(1 / overshootOrAmplitude);
                            }
                            return -(overshootOrAmplitude * Math.pow(2, 10 * ((time = time - 1))) * Math.sin((time * duration - s0) * DG.Tweening.Core.Easing.EaseManager._TwoPi / period));
                        case DG.Tweening.Ease.OutElastic: 
                            var s1;
                            if (time === 0) {
                                return 0;
                            }
                            if (((time = time / duration)) === 1) {
                                return 1;
                            }
                            if (period === 0) {
                                period = duration * 0.3;
                            }
                            if (overshootOrAmplitude < 1) {
                                overshootOrAmplitude = 1;
                                s1 = period / 4;
                            } else {
                                s1 = period / DG.Tweening.Core.Easing.EaseManager._TwoPi * Math.asin(1 / overshootOrAmplitude);
                            }
                            return overshootOrAmplitude * Math.pow(2, -10 * time) * Math.sin((time * duration - s1) * DG.Tweening.Core.Easing.EaseManager._TwoPi / period) + 1;
                        case DG.Tweening.Ease.InOutElastic: 
                            var s;
                            if (time === 0) {
                                return 0;
                            }
                            if (((time = time / (duration * 0.5))) === 2) {
                                return 1;
                            }
                            if (period === 0) {
                                period = duration * (0.450000018);
                            }
                            if (overshootOrAmplitude < 1) {
                                overshootOrAmplitude = 1;
                                s = period / 4;
                            } else {
                                s = period / DG.Tweening.Core.Easing.EaseManager._TwoPi * Math.asin(1 / overshootOrAmplitude);
                            }
                            if (time < 1) {
                                return -0.5 * (overshootOrAmplitude * Math.pow(2, 10 * ((time = time - 1))) * Math.sin((time * duration - s) * DG.Tweening.Core.Easing.EaseManager._TwoPi / period));
                            }
                            return overshootOrAmplitude * Math.pow(2, -10 * ((time = time - 1))) * Math.sin((time * duration - s) * DG.Tweening.Core.Easing.EaseManager._TwoPi / period) * 0.5 + 1;
                        case DG.Tweening.Ease.InBack: 
                            return ((time = time / duration)) * time * ((overshootOrAmplitude + 1) * time - overshootOrAmplitude);
                        case DG.Tweening.Ease.OutBack: 
                            return ((time = time / duration - 1)) * time * ((overshootOrAmplitude + 1) * time + overshootOrAmplitude) + 1;
                        case DG.Tweening.Ease.InOutBack: 
                            if (((time = time / (duration * 0.5))) < 1) {
                                return 0.5 * (time * time * ((((overshootOrAmplitude = overshootOrAmplitude * 1.525)) + 1) * time - overshootOrAmplitude));
                            }
                            return 0.5 * (((time = time - 2)) * time * ((((overshootOrAmplitude = overshootOrAmplitude * 1.525)) + 1) * time + overshootOrAmplitude) + 2);
                        case DG.Tweening.Ease.InBounce: 
                            return DG.Tweening.Core.Easing.Bounce.EaseIn(time, duration, overshootOrAmplitude, period);
                        case DG.Tweening.Ease.OutBounce: 
                            return DG.Tweening.Core.Easing.Bounce.EaseOut(time, duration, overshootOrAmplitude, period);
                        case DG.Tweening.Ease.InOutBounce: 
                            return DG.Tweening.Core.Easing.Bounce.EaseInOut(time, duration, overshootOrAmplitude, period);
                        case DG.Tweening.Ease.INTERNAL_Custom: 
                            return customEase(time, duration, overshootOrAmplitude, period);
                        case DG.Tweening.Ease.INTERNAL_Zero: 
                            // 0 duration tween
                            return 1;
                        case DG.Tweening.Ease.Flash: 
                            return DG.Tweening.Core.Easing.Flash.Ease(time, duration, overshootOrAmplitude, period);
                        case DG.Tweening.Ease.InFlash: 
                            return DG.Tweening.Core.Easing.Flash.EaseIn(time, duration, overshootOrAmplitude, period);
                        case DG.Tweening.Ease.OutFlash: 
                            return DG.Tweening.Core.Easing.Flash.EaseOut(time, duration, overshootOrAmplitude, period);
                        case DG.Tweening.Ease.InOutFlash: 
                            return DG.Tweening.Core.Easing.Flash.EaseInOut(time, duration, overshootOrAmplitude, period);
                        default: 
                            // OutQuad
                            return -((time = time / duration)) * (time - 2);
                    }
                },
                /*DG.Tweening.Core.Easing.EaseManager.Evaluate:static end.*/

                /*DG.Tweening.Core.Easing.EaseManager.ToEaseFunction:static start.*/
                ToEaseFunction: function (ease) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Easing.EaseManager#ToEaseFunction", this ); }

                    switch (ease) {
                        case DG.Tweening.Ease.Linear: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                return time / duration;
                            };
                        case DG.Tweening.Ease.InSine: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                return -Math.cos(time / duration * DG.Tweening.Core.Easing.EaseManager._PiOver2) + 1;
                            };
                        case DG.Tweening.Ease.OutSine: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                return Math.sin(time / duration * DG.Tweening.Core.Easing.EaseManager._PiOver2);
                            };
                        case DG.Tweening.Ease.InOutSine: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                return -0.5 * (Math.cos(UnityEngine.Mathf.PI * time / duration) - 1);
                            };
                        case DG.Tweening.Ease.InQuad: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                return ((time = time / duration)) * time;
                            };
                        case DG.Tweening.Ease.OutQuad: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                return -((time = time / duration)) * (time - 2);
                            };
                        case DG.Tweening.Ease.InOutQuad: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                if (((time = time / (duration * 0.5))) < 1) {
                                    return 0.5 * time * time;
                                }

                                return -0.5 * (--time * (time - 2) - 1);
                            };
                        case DG.Tweening.Ease.InCubic: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                return ((time = time / duration)) * time * time;
                            };
                        case DG.Tweening.Ease.OutCubic: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                return ((time = time / duration - 1)) * time * time + 1;
                            };
                        case DG.Tweening.Ease.InOutCubic: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                if (((time = time / (duration * 0.5))) < 1) {
                                    return 0.5 * time * time * time;
                                }

                                return 0.5 * (((time = time - 2)) * time * time + 2);
                            };
                        case DG.Tweening.Ease.InQuart: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                return ((time = time / duration)) * time * time * time;
                            };
                        case DG.Tweening.Ease.OutQuart: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                return -(((time = time / duration - 1)) * time * time * time - 1);
                            };
                        case DG.Tweening.Ease.InOutQuart: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                if (((time = time / (duration * 0.5))) < 1) {
                                    return 0.5 * time * time * time * time;
                                }

                                return -0.5 * (((time = time - 2)) * time * time * time - 2);
                            };
                        case DG.Tweening.Ease.InQuint: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                return ((time = time / duration)) * time * time * time * time;
                            };
                        case DG.Tweening.Ease.OutQuint: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                return ((time = time / duration - 1)) * time * time * time * time + 1;
                            };
                        case DG.Tweening.Ease.InOutQuint: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                if (((time = time / (duration * 0.5))) < 1) {
                                    return 0.5 * time * time * time * time * time;
                                }

                                return 0.5 * (((time = time - 2)) * time * time * time * time + 2);
                            };
                        case DG.Tweening.Ease.InExpo: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                return time === 0 ? 0 : Math.pow(2, 10 * (time / duration - 1));
                            };
                        case DG.Tweening.Ease.OutExpo: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                if (time === duration) {
                                    return 1;
                                }

                                return -Math.pow(2, -10 * time / duration) + 1;
                            };
                        case DG.Tweening.Ease.InOutExpo: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                if (time === 0) {
                                    return 0;
                                }

                                if (time === duration) {
                                    return 1;
                                }

                                if (((time = time / (duration * 0.5))) < 1) {
                                    return 0.5 * Math.pow(2, 10 * (time - 1));
                                }

                                return 0.5 * (-Math.pow(2, -10 * --time) + 2);
                            };
                        case DG.Tweening.Ease.InCirc: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                return -(Math.sqrt(1 - ((time = time / duration)) * time) - 1);
                            };
                        case DG.Tweening.Ease.OutCirc: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                return Math.sqrt(1 - ((time = time / duration - 1)) * time);
                            };
                        case DG.Tweening.Ease.InOutCirc: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                if (((time = time / (duration * 0.5))) < 1) {
                                    return -0.5 * (Math.sqrt(1 - time * time) - 1);
                                }

                                return 0.5 * (Math.sqrt(1 - ((time = time - 2)) * time) + 1);
                            };
                        case DG.Tweening.Ease.InElastic: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                var s0;
                                if (time === 0) {
                                    return 0;
                                }

                                if (((time = time / duration)) === 1) {
                                    return 1;
                                }

                                if (period === 0) {
                                    period = duration * 0.3;
                                }

                                if (overshootOrAmplitude < 1) {
                                    overshootOrAmplitude = 1;
                                    s0 = period / 4;
                                } else {
                                    s0 = period / DG.Tweening.Core.Easing.EaseManager._TwoPi * Math.asin(1 / overshootOrAmplitude);
                                }

                                return -(overshootOrAmplitude * Math.pow(2, 10 * ((time = time - 1))) * Math.sin((time * duration - s0) * DG.Tweening.Core.Easing.EaseManager._TwoPi / period));
                            };
                        case DG.Tweening.Ease.OutElastic: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                var s1;
                                if (time === 0) {
                                    return 0;
                                }

                                if (((time = time / duration)) === 1) {
                                    return 1;
                                }

                                if (period === 0) {
                                    period = duration * 0.3;
                                }

                                if (overshootOrAmplitude < 1) {
                                    overshootOrAmplitude = 1;
                                    s1 = period / 4;
                                } else {
                                    s1 = period / DG.Tweening.Core.Easing.EaseManager._TwoPi * Math.asin(1 / overshootOrAmplitude);
                                }

                                return overshootOrAmplitude * Math.pow(2, -10 * time) * Math.sin((time * duration - s1) * DG.Tweening.Core.Easing.EaseManager._TwoPi / period) + 1;
                            };
                        case DG.Tweening.Ease.InOutElastic: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                var s;
                                if (time === 0) {
                                    return 0;
                                }

                                if (((time = time / (duration * 0.5))) === 2) {
                                    return 1;
                                }

                                if (period === 0) {
                                    period = duration * (0.450000018);
                                }

                                if (overshootOrAmplitude < 1) {
                                    overshootOrAmplitude = 1;
                                    s = period / 4;
                                } else {
                                    s = period / DG.Tweening.Core.Easing.EaseManager._TwoPi * Math.asin(1 / overshootOrAmplitude);
                                }

                                if (time < 1) {
                                    return -0.5 * (overshootOrAmplitude * Math.pow(2, 10 * ((time = time - 1))) * Math.sin((time * duration - s) * DG.Tweening.Core.Easing.EaseManager._TwoPi / period));
                                }

                                return overshootOrAmplitude * Math.pow(2, -10 * ((time = time - 1))) * Math.sin((time * duration - s) * DG.Tweening.Core.Easing.EaseManager._TwoPi / period) * 0.5 + 1;
                            };
                        case DG.Tweening.Ease.InBack: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                return ((time = time / duration)) * time * ((overshootOrAmplitude + 1) * time - overshootOrAmplitude);
                            };
                        case DG.Tweening.Ease.OutBack: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                return ((time = time / duration - 1)) * time * ((overshootOrAmplitude + 1) * time + overshootOrAmplitude) + 1;
                            };
                        case DG.Tweening.Ease.InOutBack: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                if (((time = time / (duration * 0.5))) < 1) {
                                    return 0.5 * (time * time * ((((overshootOrAmplitude = overshootOrAmplitude * 1.525)) + 1) * time - overshootOrAmplitude));
                                }

                                return 0.5 * (((time = time - 2)) * time * ((((overshootOrAmplitude = overshootOrAmplitude * 1.525)) + 1) * time + overshootOrAmplitude) + 2);
                            };
                        case DG.Tweening.Ease.InBounce: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                return DG.Tweening.Core.Easing.Bounce.EaseIn(time, duration, overshootOrAmplitude, period);
                            };
                        case DG.Tweening.Ease.OutBounce: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                return DG.Tweening.Core.Easing.Bounce.EaseOut(time, duration, overshootOrAmplitude, period);
                            };
                        case DG.Tweening.Ease.InOutBounce: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                return DG.Tweening.Core.Easing.Bounce.EaseInOut(time, duration, overshootOrAmplitude, period);
                            };
                        case DG.Tweening.Ease.Flash: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                return DG.Tweening.Core.Easing.Flash.Ease(time, duration, overshootOrAmplitude, period);
                            };
                        case DG.Tweening.Ease.InFlash: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                return DG.Tweening.Core.Easing.Flash.EaseIn(time, duration, overshootOrAmplitude, period);
                            };
                        case DG.Tweening.Ease.OutFlash: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                return DG.Tweening.Core.Easing.Flash.EaseOut(time, duration, overshootOrAmplitude, period);
                            };
                        case DG.Tweening.Ease.InOutFlash: 
                            return function (time, duration, overshootOrAmplitude, period) {
                                return DG.Tweening.Core.Easing.Flash.EaseInOut(time, duration, overshootOrAmplitude, period);
                            };
                        default: 
                            // OutQuad
                            return function (time, duration, overshootOrAmplitude, period) {
                                return -((time = time / duration)) * (time - 2);
                            };
                    }
                },
                /*DG.Tweening.Core.Easing.EaseManager.ToEaseFunction:static end.*/

                /*DG.Tweening.Core.Easing.EaseManager.IsFlashEase:static start.*/
                IsFlashEase: function (ease) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Easing.EaseManager#IsFlashEase", this ); }

                    switch (ease) {
                        case DG.Tweening.Ease.Flash: 
                        case DG.Tweening.Ease.InFlash: 
                        case DG.Tweening.Ease.OutFlash: 
                        case DG.Tweening.Ease.InOutFlash: 
                            return true;
                    }

                    return false;
                },
                /*DG.Tweening.Core.Easing.EaseManager.IsFlashEase:static end.*/


            }
        }
    });
    /*DG.Tweening.Core.Easing.EaseManager end.*/

    /*DG.Tweening.Core.Easing.Flash start.*/
    Bridge.define("DG.Tweening.Core.Easing.Flash", {
        statics: {
            methods: {
                /*DG.Tweening.Core.Easing.Flash.Ease:static start.*/
                Ease: function (time, duration, overshootOrAmplitude, period) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Easing.Flash#Ease", this ); }

                    var stepIndex = Math.ceil(time / duration * overshootOrAmplitude); // 1 to overshootOrAmplitude
                    var stepDuration = duration / overshootOrAmplitude;
                    time -= stepDuration * (stepIndex - 1);
                    var dir = stepIndex % 2 !== 0 ? 1 : -1;
                    if (dir < 0) {
                        time -= stepDuration;
                    }

                    var res = time * dir / stepDuration;
                    return DG.Tweening.Core.Easing.Flash.WeightedEase(overshootOrAmplitude, period, stepIndex, stepDuration, dir, res);
                },
                /*DG.Tweening.Core.Easing.Flash.Ease:static end.*/

                /*DG.Tweening.Core.Easing.Flash.EaseIn:static start.*/
                EaseIn: function (time, duration, overshootOrAmplitude, period) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Easing.Flash#EaseIn", this ); }

                    var stepIndex = Math.ceil(time / duration * overshootOrAmplitude); // 1 to overshootOrAmplitude
                    var stepDuration = duration / overshootOrAmplitude;
                    time -= stepDuration * (stepIndex - 1);
                    var dir = stepIndex % 2 !== 0 ? 1 : -1;
                    if (dir < 0) {
                        time -= stepDuration;
                    }

                    time = time * dir;
                    var res = ((time = time / stepDuration)) * time;
                    return DG.Tweening.Core.Easing.Flash.WeightedEase(overshootOrAmplitude, period, stepIndex, stepDuration, dir, res);
                },
                /*DG.Tweening.Core.Easing.Flash.EaseIn:static end.*/

                /*DG.Tweening.Core.Easing.Flash.EaseOut:static start.*/
                EaseOut: function (time, duration, overshootOrAmplitude, period) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Easing.Flash#EaseOut", this ); }

                    var stepIndex = Math.ceil(time / duration * overshootOrAmplitude); // 1 to overshootOrAmplitude
                    var stepDuration = duration / overshootOrAmplitude;
                    time -= stepDuration * (stepIndex - 1);
                    var dir = stepIndex % 2 !== 0 ? 1 : -1;
                    if (dir < 0) {
                        time -= stepDuration;
                    }

                    time = time * dir;
                    var res = -((time = time / stepDuration)) * (time - 2);
                    return DG.Tweening.Core.Easing.Flash.WeightedEase(overshootOrAmplitude, period, stepIndex, stepDuration, dir, res);
                },
                /*DG.Tweening.Core.Easing.Flash.EaseOut:static end.*/

                /*DG.Tweening.Core.Easing.Flash.EaseInOut:static start.*/
                EaseInOut: function (time, duration, overshootOrAmplitude, period) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Easing.Flash#EaseInOut", this ); }

                    var stepIndex = Math.ceil(time / duration * overshootOrAmplitude); // 1 to overshootOrAmplitude
                    var stepDuration = duration / overshootOrAmplitude;
                    time -= stepDuration * (stepIndex - 1);
                    var dir = stepIndex % 2 !== 0 ? 1 : -1;
                    if (dir < 0) {
                        time -= stepDuration;
                    }

                    time = time * dir;
                    var res = ((time = time / (stepDuration * 0.5))) < 1 ? 0.5 * time * time : -0.5 * (--time * (time - 2) - 1);
                    return DG.Tweening.Core.Easing.Flash.WeightedEase(overshootOrAmplitude, period, stepIndex, stepDuration, dir, res);
                },
                /*DG.Tweening.Core.Easing.Flash.EaseInOut:static end.*/

                /*DG.Tweening.Core.Easing.Flash.WeightedEase:static start.*/
                WeightedEase: function (overshootOrAmplitude, period, stepIndex, stepDuration, dir, res) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Easing.Flash#WeightedEase", this ); }

                    var easedRes = 0;
                    var finalDecimals = 0;
                    // Use previous stepIndex in case of odd ones, so that back ease is not clamped
                    if (dir > 0 && Math.floor(overshootOrAmplitude) % 2 === 0) {
                        stepIndex++;
                    } else if (dir < 0 && Math.floor(overshootOrAmplitude) % 2 !== 0) {
                        stepIndex++;
                    }

                    if (period > 0) {
                        var finalTruncated = Bridge.Int.trunc(overshootOrAmplitude);
                        finalDecimals = overshootOrAmplitude - finalTruncated;
                        if (finalTruncated % 2 > 0) {
                            finalDecimals = 1 - finalDecimals;
                        }

                        finalDecimals = finalDecimals * stepIndex / overshootOrAmplitude;
                        easedRes = res * (overshootOrAmplitude - stepIndex) / overshootOrAmplitude;
                    } else if (period < 0) {
                        period = -period;
                        easedRes = res * stepIndex / overshootOrAmplitude;
                    }

                    var diff = easedRes - res;
                    res += diff * period + finalDecimals;
                    if (res > 1) {
                        res = 1;
                    }

                    return res;
                },
                /*DG.Tweening.Core.Easing.Flash.WeightedEase:static end.*/


            }
        }
    });
    /*DG.Tweening.Core.Easing.Flash end.*/

    /*DG.Tweening.Core.Enums.FilterType start.*/
    Bridge.define("DG.Tweening.Core.Enums.FilterType", {
        $kind: 6,
        statics: {
            fields: {
                All: 0,
                TargetOrId: 1,
                TargetAndId: 2,
                AllExceptTargetsOrIds: 3,
                DOGetter: 4
            }
        }
    });
    /*DG.Tweening.Core.Enums.FilterType end.*/

    /*DG.Tweening.Core.Enums.NestedTweenFailureBehaviour start.*/
    /** @namespace DG.Tweening.Core.Enums */

    /**
     * Behaviour in case a tween nested inside a Sequence fails and is captured by safe mode
     *
     * @public
     * @class DG.Tweening.Core.Enums.NestedTweenFailureBehaviour
     */
    Bridge.define("DG.Tweening.Core.Enums.NestedTweenFailureBehaviour", {
        $kind: 6,
        statics: {
            fields: {
                /**
                 * If the Sequence contains other elements, kill the failed tween but preserve the rest
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.Core.Enums.NestedTweenFailureBehaviour
                 * @constant
                 * @default 0
                 * @type DG.Tweening.Core.Enums.NestedTweenFailureBehaviour
                 */
                TryToPreserveSequence: 0,
                /**
                 * Kill the whole Sequence
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.Core.Enums.NestedTweenFailureBehaviour
                 * @constant
                 * @default 1
                 * @type DG.Tweening.Core.Enums.NestedTweenFailureBehaviour
                 */
                KillWholeSequence: 1
            }
        }
    });
    /*DG.Tweening.Core.Enums.NestedTweenFailureBehaviour end.*/

    /*DG.Tweening.Core.Enums.OperationType start.*/
    Bridge.define("DG.Tweening.Core.Enums.OperationType", {
        $kind: 6,
        statics: {
            fields: {
                Complete: 0,
                Despawn: 1,
                Flip: 2,
                Goto: 3,
                Pause: 4,
                Play: 5,
                PlayForward: 6,
                PlayBackwards: 7,
                Rewind: 8,
                SmoothRewind: 9,
                Restart: 10,
                TogglePause: 11,
                IsTweening: 12
            }
        }
    });
    /*DG.Tweening.Core.Enums.OperationType end.*/

    /*DG.Tweening.Core.Enums.RewindCallbackMode start.*/
    /**
     * OnRewind callback behaviour (can only be set via DOTween's Utility Panel)
     *
     * @public
     * @class DG.Tweening.Core.Enums.RewindCallbackMode
     */
    Bridge.define("DG.Tweening.Core.Enums.RewindCallbackMode", {
        $kind: 6,
        statics: {
            fields: {
                /**
                 * When calling Rewind or PlayBackwards/SmoothRewind, OnRewind callbacks will be fired only if the tween isn't already
                     rewinded
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.Core.Enums.RewindCallbackMode
                 * @constant
                 * @default 0
                 * @type DG.Tweening.Core.Enums.RewindCallbackMode
                 */
                FireIfPositionChanged: 0,
                /**
                 * When calling Rewind, OnRewind callbacks will always be fired, even if the tween is already rewinded.
                     When calling PlayBackwards/SmoothRewind instead, OnRewind callbacks will be fired only if the tween isn't already
                     rewinded
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.Core.Enums.RewindCallbackMode
                 * @constant
                 * @default 1
                 * @type DG.Tweening.Core.Enums.RewindCallbackMode
                 */
                FireAlwaysWithRewind: 1,
                /**
                 * When calling Rewind or PlayBackwards/SmoothRewind, OnRewind callbacks will always be fired, even if the tween is
                     already rewinded
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.Core.Enums.RewindCallbackMode
                 * @constant
                 * @default 2
                 * @type DG.Tweening.Core.Enums.RewindCallbackMode
                 */
                FireAlways: 2
            }
        }
    });
    /*DG.Tweening.Core.Enums.RewindCallbackMode end.*/

    /*DG.Tweening.Core.Enums.SafeModeLogBehaviour start.*/
    /**
     * Log types thrown by errors captured and prevented by safe mode
     *
     * @public
     * @class DG.Tweening.Core.Enums.SafeModeLogBehaviour
     */
    Bridge.define("DG.Tweening.Core.Enums.SafeModeLogBehaviour", {
        $kind: 6,
        statics: {
            fields: {
                /**
                 * No logs. NOT RECOMMENDED
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.Core.Enums.SafeModeLogBehaviour
                 * @constant
                 * @default 0
                 * @type DG.Tweening.Core.Enums.SafeModeLogBehaviour
                 */
                None: 0,
                /**
                 * Throw a normal log
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.Core.Enums.SafeModeLogBehaviour
                 * @constant
                 * @default 1
                 * @type DG.Tweening.Core.Enums.SafeModeLogBehaviour
                 */
                Normal: 1,
                /**
                 * Throw a warning log (default)
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.Core.Enums.SafeModeLogBehaviour
                 * @constant
                 * @default 2
                 * @type DG.Tweening.Core.Enums.SafeModeLogBehaviour
                 */
                Warning: 2,
                /**
                 * Throw an error log
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.Core.Enums.SafeModeLogBehaviour
                 * @constant
                 * @default 3
                 * @type DG.Tweening.Core.Enums.SafeModeLogBehaviour
                 */
                Error: 3
            }
        }
    });
    /*DG.Tweening.Core.Enums.SafeModeLogBehaviour end.*/

    /*DG.Tweening.Core.Enums.SpecialStartupMode start.*/
    Bridge.define("DG.Tweening.Core.Enums.SpecialStartupMode", {
        $kind: 6,
        statics: {
            fields: {
                None: 0,
                SetLookAt: 1,
                SetShake: 2,
                SetPunch: 3,
                SetCameraShakePosition: 4
            }
        }
    });
    /*DG.Tweening.Core.Enums.SpecialStartupMode end.*/

    /*DG.Tweening.Core.Enums.UpdateMode start.*/
    Bridge.define("DG.Tweening.Core.Enums.UpdateMode", {
        $kind: 6,
        statics: {
            fields: {
                Update: 0,
                Goto: 1,
                IgnoreOnUpdate: 2,
                IgnoreOnComplete: 3
            }
        }
    });
    /*DG.Tweening.Core.Enums.UpdateMode end.*/

    /*DG.Tweening.Core.Enums.UpdateNotice start.*/
    /**
     * Additional notices passed to plugins when updating.
         Public so it can be used by custom plugins. Internally, only PathPlugin uses it
     *
     * @public
     * @class DG.Tweening.Core.Enums.UpdateNotice
     */
    Bridge.define("DG.Tweening.Core.Enums.UpdateNotice", {
        $kind: 6,
        statics: {
            fields: {
                /**
                 * None
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.Core.Enums.UpdateNotice
                 * @constant
                 * @default 0
                 * @type DG.Tweening.Core.Enums.UpdateNotice
                 */
                None: 0,
                /**
                 * Lets the plugin know that we restarted or rewinded
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.Core.Enums.UpdateNotice
                 * @constant
                 * @default 1
                 * @type DG.Tweening.Core.Enums.UpdateNotice
                 */
                RewindStep: 1
            }
        }
    });
    /*DG.Tweening.Core.Enums.UpdateNotice end.*/

    /*DG.Tweening.Core.Extensions start.*/
    /**
     * Public only so custom shortcuts can access some of these methods
     *
     * @static
     * @abstract
     * @public
     * @class DG.Tweening.Core.Extensions
     */
    Bridge.define("DG.Tweening.Core.Extensions", {
        statics: {
            methods: {
                /*DG.Tweening.Core.Extensions.SetSpecialStartupMode:static start.*/
                /**
                 * INTERNAL: used by DO shortcuts and Modules to set special startup mode
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.Core.Extensions
                 * @memberof DG.Tweening.Core.Extensions
                 * @param   {Function}                                     T       
                 * @param   {T}                                            t       
                 * @param   {DG.Tweening.Core.Enums.SpecialStartupMode}    mode
                 * @return  {T}
                 */
                SetSpecialStartupMode: function (T, t, mode) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Extensions#SetSpecialStartupMode", this ); }

Bridge.rValue(                    t).specialStartupMode = mode;
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.Core.Extensions.SetSpecialStartupMode:static end.*/

                /*DG.Tweening.Core.Extensions.Blendable:static start.*/
                /**
                 * INTERNAL: used by DO shortcuts and Modules to set the tween as blendable
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.Core.Extensions
                 * @memberof DG.Tweening.Core.Extensions
                 * @param   {Function}                          T1              
                 * @param   {Function}                          T2              
                 * @param   {Function}                          TPlugOptions    
                 * @param   {DG.Tweening.Core.TweenerCore$3}    t
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                Blendable: function (T1, T2, TPlugOptions, t) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Extensions#Blendable", this ); }

                    t.isBlendable = true;
                    return t;
                },
                /*DG.Tweening.Core.Extensions.Blendable:static end.*/

                /*DG.Tweening.Core.Extensions.NoFrom:static start.*/
                /**
                 * INTERNAL: used by DO shortcuts and Modules to prevent a tween from using a From setup even if passed
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.Core.Extensions
                 * @memberof DG.Tweening.Core.Extensions
                 * @param   {Function}                          T1              
                 * @param   {Function}                          T2              
                 * @param   {Function}                          TPlugOptions    
                 * @param   {DG.Tweening.Core.TweenerCore$3}    t
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                NoFrom: function (T1, T2, TPlugOptions, t) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.Extensions#NoFrom", this ); }

                    t.isFromAllowed = false;
                    return t;
                },
                /*DG.Tweening.Core.Extensions.NoFrom:static end.*/


            }
        }
    });
    /*DG.Tweening.Core.Extensions end.*/

    /*DG.Tweening.Core.OnDisableBehaviour start.*/
    Bridge.define("DG.Tweening.Core.OnDisableBehaviour", {
        $kind: 6,
        statics: {
            fields: {
                None: 0,
                Pause: 1,
                Rewind: 2,
                Kill: 3,
                KillAndComplete: 4,
                DestroyGameObject: 5
            }
        }
    });
    /*DG.Tweening.Core.OnDisableBehaviour end.*/

    /*DG.Tweening.Core.OnEnableBehaviour start.*/
    Bridge.define("DG.Tweening.Core.OnEnableBehaviour", {
        $kind: 6,
        statics: {
            fields: {
                None: 0,
                Play: 1,
                Restart: 2,
                RestartFromSpawnPoint: 3
            }
        }
    });
    /*DG.Tweening.Core.OnEnableBehaviour end.*/

    /*DG.Tweening.Core.SafeModeReport start.*/
    Bridge.define("DG.Tweening.Core.SafeModeReport", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.SafeModeReport#getDefaultValue", this ); }
 return new DG.Tweening.Core.SafeModeReport(); }
            }
        },
        fields: {
            totMissingTargetOrFieldErrors: 0,
            totCallbackErrors: 0,
            totStartupErrors: 0,
            totUnsetErrors: 0
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.SafeModeReport#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*DG.Tweening.Core.SafeModeReport.Add start.*/
            Add: function (type) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.SafeModeReport#Add", this ); }

                switch (type) {
                    case DG.Tweening.Core.SafeModeReport.SafeModeReportType.TargetOrFieldMissing: 
                        this.totMissingTargetOrFieldErrors++;
                        break;
                    case DG.Tweening.Core.SafeModeReport.SafeModeReportType.Callback: 
                        this.totCallbackErrors++;
                        break;
                    case DG.Tweening.Core.SafeModeReport.SafeModeReportType.StartupFailure: 
                        this.totStartupErrors++;
                        break;
                    default: 
                        this.totUnsetErrors++;
                        break;
                }
            },
            /*DG.Tweening.Core.SafeModeReport.Add end.*/

            /*DG.Tweening.Core.SafeModeReport.GetTotErrors start.*/
            GetTotErrors: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.SafeModeReport#GetTotErrors", this ); }

                return this.totMissingTargetOrFieldErrors + this.totCallbackErrors + this.totStartupErrors + this.totUnsetErrors;
            },
            /*DG.Tweening.Core.SafeModeReport.GetTotErrors end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.SafeModeReport#getHashCode", this ); }

                var h = Bridge.addHash([5271956068, this.totMissingTargetOrFieldErrors, this.totCallbackErrors, this.totStartupErrors, this.totUnsetErrors]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.SafeModeReport#equals", this ); }

                if (!Bridge.is(o, DG.Tweening.Core.SafeModeReport)) {
                    return false;
                }
                return Bridge.equals(this.totMissingTargetOrFieldErrors, o.totMissingTargetOrFieldErrors) && Bridge.equals(this.totCallbackErrors, o.totCallbackErrors) && Bridge.equals(this.totStartupErrors, o.totStartupErrors) && Bridge.equals(this.totUnsetErrors, o.totUnsetErrors);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.SafeModeReport#$clone", this ); }

                var s = to || new DG.Tweening.Core.SafeModeReport();
                s.totMissingTargetOrFieldErrors = this.totMissingTargetOrFieldErrors;
                s.totCallbackErrors = this.totCallbackErrors;
                s.totStartupErrors = this.totStartupErrors;
                s.totUnsetErrors = this.totUnsetErrors;
                return s;
            }
        }
    });
    /*DG.Tweening.Core.SafeModeReport end.*/

    /*DG.Tweening.Core.SafeModeReport+SafeModeReportType start.*/
    Bridge.define("DG.Tweening.Core.SafeModeReport.SafeModeReportType", {
        $kind: 1006,
        statics: {
            fields: {
                Unset: 0,
                TargetOrFieldMissing: 1,
                Callback: 2,
                StartupFailure: 3
            }
        }
    });
    /*DG.Tweening.Core.SafeModeReport+SafeModeReportType end.*/

    /*DG.Tweening.Core.TargetType start.*/
    Bridge.define("DG.Tweening.Core.TargetType", {
        $kind: 6,
        statics: {
            fields: {
                Unset: 0,
                Camera: 1,
                CanvasGroup: 2,
                Image: 3,
                Light: 4,
                RectTransform: 5,
                Renderer: 6,
                SpriteRenderer: 7,
                Rigidbody: 8,
                Rigidbody2D: 9,
                Text: 10,
                Transform: 11,
                tk2dBaseSprite: 12,
                tk2dTextMesh: 13,
                TextMeshPro: 14,
                TextMeshProUGUI: 15
            }
        }
    });
    /*DG.Tweening.Core.TargetType end.*/

    /*DG.Tweening.Plugins.Options.IPlugOptions start.*/
    /** @namespace DG.Tweening.Plugins.Options */

    /**
     * Base interface for all tween plugins options
     *
     * @abstract
     * @public
     * @class DG.Tweening.Plugins.Options.IPlugOptions
     */
    Bridge.define("DG.Tweening.Plugins.Options.IPlugOptions", {
        $kind: 3
    });
    /*DG.Tweening.Plugins.Options.IPlugOptions end.*/

    /*DG.Tweening.Core.TweenLink start.*/
    Bridge.define("DG.Tweening.Core.TweenLink", {
        fields: {
            behaviour: 0,
            target: null,
            lastSeenActive: false
        },
        ctors: {
            ctor: function (target, behaviour) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenLink#ctor", this ); }

                this.$initialize();
                this.target = target;
                this.behaviour = behaviour;
                this.lastSeenActive = target.activeInHierarchy;
            }
        }
    });
    /*DG.Tweening.Core.TweenLink end.*/

    /*DG.Tweening.Core.TweenManager start.*/
    Bridge.define("DG.Tweening.Core.TweenManager", {
        statics: {
            fields: {
                _DefaultMaxTweeners: 0,
                _DefaultMaxSequences: 0,
                _MaxTweensReached: null,
                _EpsilonVsTimeCheck: 0,
                isUnityEditor: false,
                isDebugBuild: false,
                maxActive: 0,
                maxTweeners: 0,
                maxSequences: 0,
                hasActiveTweens: false,
                hasActiveDefaultTweens: false,
                hasActiveLateTweens: false,
                hasActiveFixedTweens: false,
                hasActiveManualTweens: false,
                totActiveTweens: 0,
                totActiveDefaultTweens: 0,
                totActiveLateTweens: 0,
                totActiveFixedTweens: 0,
                totActiveManualTweens: 0,
                totActiveTweeners: 0,
                totActiveSequences: 0,
                totPooledTweeners: 0,
                totPooledSequences: 0,
                totTweeners: 0,
                totSequences: 0,
                isUpdateLoop: false,
                _activeTweens: null,
                _pooledTweeners: null,
                _PooledSequences: null,
                _KillList: null,
                _TweenLinks: null,
                _totTweenLinks: 0,
                _maxActiveLookupId: 0,
                _requiresActiveReorganization: false,
                _reorganizeFromId: 0,
                _minPooledTweenerId: 0,
                _maxPooledTweenerId: 0,
                _despawnAllCalledFromUpdateLoopCallback: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#init", this ); }

                    this._DefaultMaxTweeners = 200;
                    this._DefaultMaxSequences = 50;
                    this._MaxTweensReached = "Max Tweens reached: capacity has automatically been increased from #0 to #1. Use DOTween.SetTweensCapacity to set it manually at startup";
                    this._EpsilonVsTimeCheck = 1E-06;
                    this.maxActive = 250;
                    this.maxTweeners = 200;
                    this.maxSequences = 50;
                    this._activeTweens = System.Array.init(250, null, DG.Tweening.Tween);
                    this._pooledTweeners = System.Array.init(DG.Tweening.Core.TweenManager._DefaultMaxTweeners, null, DG.Tweening.Tween);
                    this._PooledSequences = new (System.Collections.Generic.Stack$1(DG.Tweening.Tween)).ctor();
                    this._KillList = new (System.Collections.Generic.List$1(DG.Tweening.Tween)).$ctor2(250);
                    this._TweenLinks = new (System.Collections.Generic.Dictionary$2(DG.Tweening.Tween,DG.Tweening.Core.TweenLink)).$ctor4(250);
                    this._maxActiveLookupId = -1;
                    this._reorganizeFromId = -1;
                    this._minPooledTweenerId = -1;
                    this._maxPooledTweenerId = -1;
                },
                ctor: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#ctor", this ); }

                    DG.Tweening.Core.TweenManager.isUnityEditor = UnityEngine.Application.isEditor;
                }
            },
            methods: {
                /*DG.Tweening.Core.TweenManager.GetTweener:static start.*/
                GetTweener: function (T1, T2, TPlugOptions) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#GetTweener", this ); }

                    var t;
                    // Search inside pool
                    if (DG.Tweening.Core.TweenManager.totPooledTweeners > 0) {
                        var typeofT1 = T1;
                        var typeofT2 = T2;
                        var typeofTPlugOptions = TPlugOptions;
                        for (var i = DG.Tweening.Core.TweenManager._maxPooledTweenerId; i > DG.Tweening.Core.TweenManager._minPooledTweenerId - 1; --i) {
                            var tween = DG.Tweening.Core.TweenManager._pooledTweeners[i];
                            if (tween != null && Bridge.referenceEquals(tween.typeofT1, typeofT1) && Bridge.referenceEquals(tween.typeofT2, typeofT2) && Bridge.referenceEquals(tween.typeofTPlugOptions, typeofTPlugOptions)) {
                                // Pooled Tweener exists: spawn it
                                t = Bridge.cast(tween, DG.Tweening.Core.TweenerCore$3(T1,T2,TPlugOptions));
                                DG.Tweening.Core.TweenManager.AddActiveTween(t);
                                DG.Tweening.Core.TweenManager._pooledTweeners[i] = null;
                                if (DG.Tweening.Core.TweenManager._maxPooledTweenerId !== DG.Tweening.Core.TweenManager._minPooledTweenerId) {
                                    if (i === DG.Tweening.Core.TweenManager._maxPooledTweenerId) {
                                        DG.Tweening.Core.TweenManager._maxPooledTweenerId--;
                                    } else if (i === DG.Tweening.Core.TweenManager._minPooledTweenerId) {
                                        DG.Tweening.Core.TweenManager._minPooledTweenerId++;
                                    }
                                }

                                DG.Tweening.Core.TweenManager.totPooledTweeners--;
                                return t;
                            }
                        }

                        // Not found: remove a tween from the pool in case it's full
                        if (DG.Tweening.Core.TweenManager.totTweeners >= DG.Tweening.Core.TweenManager.maxTweeners) {
                            DG.Tweening.Core.TweenManager._pooledTweeners[DG.Tweening.Core.TweenManager._maxPooledTweenerId] = null;
                            DG.Tweening.Core.TweenManager._maxPooledTweenerId--;
                            DG.Tweening.Core.TweenManager.totPooledTweeners--;
                            DG.Tweening.Core.TweenManager.totTweeners--;
                        }
                    } else {
                        // Increase capacity in case max number of Tweeners has already been reached, then continue
                        if (DG.Tweening.Core.TweenManager.totTweeners >= DG.Tweening.Core.TweenManager.maxTweeners - 1) {
                            var prevMaxTweeners = DG.Tweening.Core.TweenManager.maxTweeners;
                            var prevMaxSequences = DG.Tweening.Core.TweenManager.maxSequences;
                            DG.Tweening.Core.TweenManager.IncreaseCapacities(DG.Tweening.Core.TweenManager.CapacityIncreaseMode.TweenersOnly);
                            if (DG.Tweening.Core.Debugger.logPriority >= 1) {
                                DG.Tweening.Core.Debugger.LogWarning(System.String.replaceAll(System.String.replaceAll(DG.Tweening.Core.TweenManager._MaxTweensReached, "#0", prevMaxTweeners + "/" + prevMaxSequences), "#1", DG.Tweening.Core.TweenManager.maxTweeners + "/" + DG.Tweening.Core.TweenManager.maxSequences));
                            }
                        }
                    }

                    // Not found: create new TweenerController
                    t = new (DG.Tweening.Core.TweenerCore$3(T1,T2,TPlugOptions))();
                    DG.Tweening.Core.TweenManager.totTweeners++;
                    DG.Tweening.Core.TweenManager.AddActiveTween(t);
                    return t;
                },
                /*DG.Tweening.Core.TweenManager.GetTweener:static end.*/

                /*DG.Tweening.Core.TweenManager.GetSequence:static start.*/
                GetSequence: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#GetSequence", this ); }

                    var s;
                    if (DG.Tweening.Core.TweenManager.totPooledSequences > 0) {
                        s = Bridge.cast(DG.Tweening.Core.TweenManager._PooledSequences.Pop(), DG.Tweening.Sequence);
                        DG.Tweening.Core.TweenManager.AddActiveTween(s);
                        DG.Tweening.Core.TweenManager.totPooledSequences--;
                        return s;
                    }

                    // Increase capacity in case max number of Sequences has already been reached, then continue
                    if (DG.Tweening.Core.TweenManager.totSequences >= DG.Tweening.Core.TweenManager.maxSequences - 1) {
                        var prevMaxTweeners = DG.Tweening.Core.TweenManager.maxTweeners;
                        var prevMaxSequences = DG.Tweening.Core.TweenManager.maxSequences;
                        DG.Tweening.Core.TweenManager.IncreaseCapacities(DG.Tweening.Core.TweenManager.CapacityIncreaseMode.SequencesOnly);
                        if (DG.Tweening.Core.Debugger.logPriority >= 1) {
                            DG.Tweening.Core.Debugger.LogWarning(System.String.replaceAll(System.String.replaceAll(DG.Tweening.Core.TweenManager._MaxTweensReached, "#0", prevMaxTweeners + "/" + prevMaxSequences), "#1", DG.Tweening.Core.TweenManager.maxTweeners + "/" + DG.Tweening.Core.TweenManager.maxSequences));
                        }
                    }

                    // Not found: create new Sequence
                    s = new DG.Tweening.Sequence();
                    DG.Tweening.Core.TweenManager.totSequences++;
                    DG.Tweening.Core.TweenManager.AddActiveTween(s);
                    return s;
                },
                /*DG.Tweening.Core.TweenManager.GetSequence:static end.*/

                /*DG.Tweening.Core.TweenManager.SetUpdateType:static start.*/
                SetUpdateType: function (t, updateType, isIndependentUpdate) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#SetUpdateType", this ); }

                    if (!t.active || t.updateType === updateType) {
                        t.updateType = updateType;
                        t.isIndependentUpdate = isIndependentUpdate;
                        return;
                    }

                    // Remove previous update type
                    if (t.updateType === DG.Tweening.UpdateType.Normal) {
                        DG.Tweening.Core.TweenManager.totActiveDefaultTweens--;
                        DG.Tweening.Core.TweenManager.hasActiveDefaultTweens = DG.Tweening.Core.TweenManager.totActiveDefaultTweens > 0;
                    } else {
                        switch (t.updateType) {
                            case DG.Tweening.UpdateType.Fixed: 
                                DG.Tweening.Core.TweenManager.totActiveFixedTweens--;
                                DG.Tweening.Core.TweenManager.hasActiveFixedTweens = DG.Tweening.Core.TweenManager.totActiveFixedTweens > 0;
                                break;
                            case DG.Tweening.UpdateType.Late: 
                                DG.Tweening.Core.TweenManager.totActiveLateTweens--;
                                DG.Tweening.Core.TweenManager.hasActiveLateTweens = DG.Tweening.Core.TweenManager.totActiveLateTweens > 0;
                                break;
                            default:  // Manual
                                DG.Tweening.Core.TweenManager.totActiveManualTweens--;
                                DG.Tweening.Core.TweenManager.hasActiveManualTweens = DG.Tweening.Core.TweenManager.totActiveManualTweens > 0;
                                break;
                        }
                    }

                    // Assign new one
                    t.updateType = updateType;
                    t.isIndependentUpdate = isIndependentUpdate;
                    if (updateType === DG.Tweening.UpdateType.Normal) {
                        DG.Tweening.Core.TweenManager.totActiveDefaultTweens++;
                        DG.Tweening.Core.TweenManager.hasActiveDefaultTweens = true;
                    } else {
                        switch (updateType) {
                            case DG.Tweening.UpdateType.Fixed: 
                                DG.Tweening.Core.TweenManager.totActiveFixedTweens++;
                                DG.Tweening.Core.TweenManager.hasActiveFixedTweens = true;
                                break;
                            case DG.Tweening.UpdateType.Late: 
                                DG.Tweening.Core.TweenManager.totActiveLateTweens++;
                                DG.Tweening.Core.TweenManager.hasActiveLateTweens = true;
                                break;
                            default:  // Manual
                                DG.Tweening.Core.TweenManager.totActiveManualTweens++;
                                DG.Tweening.Core.TweenManager.hasActiveManualTweens = true;
                                break;
                        }
                    }
                },
                /*DG.Tweening.Core.TweenManager.SetUpdateType:static end.*/

                /*DG.Tweening.Core.TweenManager.AddActiveTweenToSequence:static start.*/
                AddActiveTweenToSequence: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#AddActiveTweenToSequence", this ); }

                    DG.Tweening.Core.TweenManager.RemoveActiveTween(t);
                },
                /*DG.Tweening.Core.TweenManager.AddActiveTweenToSequence:static end.*/

                /*DG.Tweening.Core.TweenManager.DespawnAll:static start.*/
                DespawnAll: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#DespawnAll", this ); }

                    var $t, $t1, $t2, $t3, $t4, $t5;
                    var totDespawned = DG.Tweening.Core.TweenManager.totActiveTweens;
                    for (var i = 0; i < DG.Tweening.Core.TweenManager._maxActiveLookupId + 1; ++i) {
                        var t = DG.Tweening.Core.TweenManager._activeTweens[i];
                        if (t != null) {
                            DG.Tweening.Core.TweenManager.Despawn(t, false);
                        }
                    }

                    DG.Tweening.Core.TweenManager.ClearTweenArray(DG.Tweening.Core.TweenManager._activeTweens);
                    DG.Tweening.Core.TweenManager.hasActiveTweens = ($t = ($t1 = ($t2 = (DG.Tweening.Core.TweenManager.hasActiveManualTweens = false, false), DG.Tweening.Core.TweenManager.hasActiveFixedTweens = $t2, $t2), DG.Tweening.Core.TweenManager.hasActiveLateTweens = $t1, $t1), DG.Tweening.Core.TweenManager.hasActiveDefaultTweens = $t, $t);
                    DG.Tweening.Core.TweenManager.totActiveTweens = ($t3 = ($t4 = ($t5 = (DG.Tweening.Core.TweenManager.totActiveManualTweens = 0, 0), DG.Tweening.Core.TweenManager.totActiveFixedTweens = $t5, $t5), DG.Tweening.Core.TweenManager.totActiveLateTweens = $t4, $t4), DG.Tweening.Core.TweenManager.totActiveDefaultTweens = $t3, $t3);
                    DG.Tweening.Core.TweenManager.totActiveTweeners = (DG.Tweening.Core.TweenManager.totActiveSequences = 0, 0);
                    DG.Tweening.Core.TweenManager._maxActiveLookupId = (DG.Tweening.Core.TweenManager._reorganizeFromId = -1, -1);
                    DG.Tweening.Core.TweenManager._requiresActiveReorganization = false;
                    DG.Tweening.Core.TweenManager._TweenLinks.clear();
                    DG.Tweening.Core.TweenManager._totTweenLinks = 0;

                    if (DG.Tweening.Core.TweenManager.isUpdateLoop) {
                        DG.Tweening.Core.TweenManager._despawnAllCalledFromUpdateLoopCallback = true;
                    }

                    return totDespawned;
                },
                /*DG.Tweening.Core.TweenManager.DespawnAll:static end.*/

                /*DG.Tweening.Core.TweenManager.Despawn:static start.*/
                Despawn: function (t, modifyActiveLists) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#Despawn", this ); }

                    if (modifyActiveLists === void 0) { modifyActiveLists = true; }
                    // Callbacks
                    if (!Bridge.staticEquals(t.onKill, null)) {
                        DG.Tweening.Tween.OnTweenCallback(t.onKill, t);
                    }

                    if (modifyActiveLists) {
                        // Remove tween from active list
                        DG.Tweening.Core.TweenManager.RemoveActiveTween(t);
                    }

                    if (t.isRecyclable) {
                        // Put the tween inside a pool
                        switch (t.tweenType) {
                            case DG.Tweening.TweenType.Sequence: 
                                DG.Tweening.Core.TweenManager._PooledSequences.Push(t);
                                DG.Tweening.Core.TweenManager.totPooledSequences++;
                                // Despawn sequenced tweens
                                var s = Bridge.cast(t, DG.Tweening.Sequence);
                                var len = s.sequencedTweens.Count;
                                for (var i = 0; i < len; ++i) {
                                    DG.Tweening.Core.TweenManager.Despawn(s.sequencedTweens.getItem(i), false);
                                }
                                break;
                            case DG.Tweening.TweenType.Tweener: 
                                if (DG.Tweening.Core.TweenManager._maxPooledTweenerId === -1) {
                                    DG.Tweening.Core.TweenManager._maxPooledTweenerId = DG.Tweening.Core.TweenManager.maxTweeners - 1;
                                    DG.Tweening.Core.TweenManager._minPooledTweenerId = DG.Tweening.Core.TweenManager.maxTweeners - 1;
                                }
                                if (DG.Tweening.Core.TweenManager._maxPooledTweenerId < DG.Tweening.Core.TweenManager.maxTweeners - 1) {
                                    DG.Tweening.Core.TweenManager._pooledTweeners[DG.Tweening.Core.TweenManager._maxPooledTweenerId + 1] = t;
                                    DG.Tweening.Core.TweenManager._maxPooledTweenerId++;
                                    if (DG.Tweening.Core.TweenManager._minPooledTweenerId > DG.Tweening.Core.TweenManager._maxPooledTweenerId) {
                                        DG.Tweening.Core.TweenManager._minPooledTweenerId = DG.Tweening.Core.TweenManager._maxPooledTweenerId;
                                    }
                                } else {
                                    for (var i1 = DG.Tweening.Core.TweenManager._maxPooledTweenerId; i1 > -1; --i1) {
                                        if (DG.Tweening.Core.TweenManager._pooledTweeners[i1] != null) {
                                            continue;
                                        }

                                        DG.Tweening.Core.TweenManager._pooledTweeners[i1] = t;
                                        if (i1 < DG.Tweening.Core.TweenManager._minPooledTweenerId) {
                                            DG.Tweening.Core.TweenManager._minPooledTweenerId = i1;
                                        }

                                        if (DG.Tweening.Core.TweenManager._maxPooledTweenerId < DG.Tweening.Core.TweenManager._minPooledTweenerId) {
                                            DG.Tweening.Core.TweenManager._maxPooledTweenerId = DG.Tweening.Core.TweenManager._minPooledTweenerId;
                                        }

                                        break;
                                    }
                                }
                                DG.Tweening.Core.TweenManager.totPooledTweeners++;
                                break;
                        }
                    } else {
                        // Remove
                        switch (t.tweenType) {
                            case DG.Tweening.TweenType.Sequence: 
                                DG.Tweening.Core.TweenManager.totSequences--;
                                // Despawn sequenced tweens
                                var s1 = Bridge.cast(t, DG.Tweening.Sequence);
                                var len1 = s1.sequencedTweens.Count;
                                for (var i2 = 0; i2 < len1; ++i2) {
                                    DG.Tweening.Core.TweenManager.Despawn(s1.sequencedTweens.getItem(i2), false);
                                }
                                break;
                            case DG.Tweening.TweenType.Tweener: 
                                DG.Tweening.Core.TweenManager.totTweeners--;
                                break;
                        }
                    }

                    t.active = false;
                    t.Reset();
                },
                /*DG.Tweening.Core.TweenManager.Despawn:static end.*/

                /*DG.Tweening.Core.TweenManager.PurgeAll:static start.*/
                PurgeAll: function (isApplicationQuitting) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#PurgeAll", this ); }

                    var $t, $t1, $t2, $t3, $t4, $t5;
                    if (!isApplicationQuitting) {
                        // Fire eventual onKill callbacks
                        for (var i = 0; i < DG.Tweening.Core.TweenManager.maxActive; ++i) {
                            var t = DG.Tweening.Core.TweenManager._activeTweens[i];
                            if (t != null && t.active) {
                                t.active = false;
                                if (!Bridge.staticEquals(t.onKill, null)) {
                                    DG.Tweening.Tween.OnTweenCallback(t.onKill, t);
                                }
                            }
                        }
                    }

                    DG.Tweening.Core.TweenManager.ClearTweenArray(DG.Tweening.Core.TweenManager._activeTweens);
                    DG.Tweening.Core.TweenManager.hasActiveTweens = ($t = ($t1 = ($t2 = (DG.Tweening.Core.TweenManager.hasActiveManualTweens = false, false), DG.Tweening.Core.TweenManager.hasActiveFixedTweens = $t2, $t2), DG.Tweening.Core.TweenManager.hasActiveLateTweens = $t1, $t1), DG.Tweening.Core.TweenManager.hasActiveDefaultTweens = $t, $t);
                    DG.Tweening.Core.TweenManager.totActiveTweens = ($t3 = ($t4 = ($t5 = (DG.Tweening.Core.TweenManager.totActiveManualTweens = 0, 0), DG.Tweening.Core.TweenManager.totActiveFixedTweens = $t5, $t5), DG.Tweening.Core.TweenManager.totActiveLateTweens = $t4, $t4), DG.Tweening.Core.TweenManager.totActiveDefaultTweens = $t3, $t3);
                    DG.Tweening.Core.TweenManager.totActiveTweeners = (DG.Tweening.Core.TweenManager.totActiveSequences = 0, 0);
                    DG.Tweening.Core.TweenManager._maxActiveLookupId = (DG.Tweening.Core.TweenManager._reorganizeFromId = -1, -1);
                    DG.Tweening.Core.TweenManager._requiresActiveReorganization = false;
                    DG.Tweening.Core.TweenManager.PurgePools();
                    DG.Tweening.Core.TweenManager.ResetCapacities();
                    DG.Tweening.Core.TweenManager.totTweeners = (DG.Tweening.Core.TweenManager.totSequences = 0, 0);
                },
                /*DG.Tweening.Core.TweenManager.PurgeAll:static end.*/

                /*DG.Tweening.Core.TweenManager.PurgePools:static start.*/
                PurgePools: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#PurgePools", this ); }

                    DG.Tweening.Core.TweenManager.totTweeners -= DG.Tweening.Core.TweenManager.totPooledTweeners;
                    DG.Tweening.Core.TweenManager.totSequences -= DG.Tweening.Core.TweenManager.totPooledSequences;
                    DG.Tweening.Core.TweenManager.ClearTweenArray(DG.Tweening.Core.TweenManager._pooledTweeners);
                    DG.Tweening.Core.TweenManager._PooledSequences.Clear();
                    DG.Tweening.Core.TweenManager.totPooledTweeners = (DG.Tweening.Core.TweenManager.totPooledSequences = 0, 0);
                    DG.Tweening.Core.TweenManager._minPooledTweenerId = (DG.Tweening.Core.TweenManager._maxPooledTweenerId = -1, -1);
                },
                /*DG.Tweening.Core.TweenManager.PurgePools:static end.*/

                /*DG.Tweening.Core.TweenManager.AddTweenLink:static start.*/
                AddTweenLink: function (t, tweenLink) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#AddTweenLink", this ); }

                    DG.Tweening.Core.TweenManager._totTweenLinks++;
                    if (DG.Tweening.Core.TweenManager._TweenLinks.containsKey(t)) {
                        DG.Tweening.Core.TweenManager._TweenLinks.setItem(t, tweenLink);
                    } else {
                        DG.Tweening.Core.TweenManager._TweenLinks.add(t, tweenLink);
                    }

                    // Pause or play tween immediately depending on target's state
                    if (tweenLink.lastSeenActive) {
                        switch (tweenLink.behaviour) {
                            case DG.Tweening.LinkBehaviour.PauseOnDisablePlayOnEnable: 
                            case DG.Tweening.LinkBehaviour.PauseOnDisableRestartOnEnable: 
                            case DG.Tweening.LinkBehaviour.PlayOnEnable: 
                            case DG.Tweening.LinkBehaviour.RestartOnEnable: 
                                DG.Tweening.Core.TweenManager.Play(t);
                                break;
                        }
                    } else {
                        switch (tweenLink.behaviour) {
                            case DG.Tweening.LinkBehaviour.PauseOnDisable: 
                            case DG.Tweening.LinkBehaviour.PauseOnDisablePlayOnEnable: 
                            case DG.Tweening.LinkBehaviour.PauseOnDisableRestartOnEnable: 
                                DG.Tweening.Core.TweenManager.Pause(t);
                                break;
                        }
                    }
                },
                /*DG.Tweening.Core.TweenManager.AddTweenLink:static end.*/

                /*DG.Tweening.Core.TweenManager.RemoveTweenLink:static start.*/
                RemoveTweenLink: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#RemoveTweenLink", this ); }

                    if (!DG.Tweening.Core.TweenManager._TweenLinks.containsKey(t)) {
                        return;
                    }

                    DG.Tweening.Core.TweenManager._TweenLinks.remove(t);
                    DG.Tweening.Core.TweenManager._totTweenLinks--;
                },
                /*DG.Tweening.Core.TweenManager.RemoveTweenLink:static end.*/

                /*DG.Tweening.Core.TweenManager.ResetCapacities:static start.*/
                ResetCapacities: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#ResetCapacities", this ); }

                    DG.Tweening.Core.TweenManager.SetCapacities(DG.Tweening.Core.TweenManager._DefaultMaxTweeners, DG.Tweening.Core.TweenManager._DefaultMaxSequences);
                },
                /*DG.Tweening.Core.TweenManager.ResetCapacities:static end.*/

                /*DG.Tweening.Core.TweenManager.SetCapacities:static start.*/
                SetCapacities: function (tweenersCapacity, sequencesCapacity) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#SetCapacities", this ); }

                    if (tweenersCapacity < sequencesCapacity) {
                        tweenersCapacity = sequencesCapacity;
                    }

                    //            maxActive = tweenersCapacity;
                    DG.Tweening.Core.TweenManager.maxActive = tweenersCapacity + sequencesCapacity;
                    DG.Tweening.Core.TweenManager.maxTweeners = Bridge.Math.round(tweenersCapacity, 0, 6);
                    DG.Tweening.Core.TweenManager.maxSequences = sequencesCapacity;
                    System.Array.resize(Bridge.ref(DG.Tweening.Core.TweenManager, "_activeTweens"), DG.Tweening.Core.TweenManager.maxActive, null, DG.Tweening.Tween);
                    System.Array.resize(Bridge.ref(DG.Tweening.Core.TweenManager, "_pooledTweeners"), tweenersCapacity, null, DG.Tweening.Tween);
                    DG.Tweening.Core.TweenManager._KillList.Capacity = DG.Tweening.Core.TweenManager.maxActive;
                },
                /*DG.Tweening.Core.TweenManager.SetCapacities:static end.*/

                /*DG.Tweening.Core.TweenManager.Validate:static start.*/
                Validate: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#Validate", this ); }

                    if (DG.Tweening.Core.TweenManager._requiresActiveReorganization) {
                        DG.Tweening.Core.TweenManager.ReorganizeActiveTweens();
                    }

                    var totInvalid = 0;
                    for (var i = 0; i < DG.Tweening.Core.TweenManager._maxActiveLookupId + 1; ++i) {
                        var t = DG.Tweening.Core.TweenManager._activeTweens[i];
                        if (!t.Validate()) {
                            totInvalid++;
                            DG.Tweening.Core.TweenManager.MarkForKilling(t);
                        }
                    }

                    // Kill all eventually marked tweens
                    if (totInvalid > 0) {
                        DG.Tweening.Core.TweenManager.DespawnActiveTweens(DG.Tweening.Core.TweenManager._KillList);
                        DG.Tweening.Core.TweenManager._KillList.clear();
                    }

                    return totInvalid;
                },
                /*DG.Tweening.Core.TweenManager.Validate:static end.*/

                /*DG.Tweening.Core.TweenManager.Update$1:static start.*/
                Update$1: function (updateType, deltaTime, independentTime) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#Update$1", this ); }

                    if (DG.Tweening.Core.TweenManager._requiresActiveReorganization) {
                        DG.Tweening.Core.TweenManager.ReorganizeActiveTweens();
                    }

                    DG.Tweening.Core.TweenManager.isUpdateLoop = true;
                    var willKill = false;
                    //            Debug.Log("::::::::::: " + updateType + " > " + (_maxActiveLookupId + 1));
                    var len = DG.Tweening.Core.TweenManager._maxActiveLookupId + 1; // Stored here so if _maxActiveLookupId changed during update loop (like if new tween is created at onComplete) new tweens are still ignored
                    for (var i = 0; i < len; ++i) {
                        var t = DG.Tweening.Core.TweenManager._activeTweens[i];
                        if (t == null || t.updateType !== updateType) {
                            continue; // Wrong updateType or was added to a Sequence (thus removed from active list) while inside current updateLoop
                        }

                        if (DG.Tweening.Core.TweenManager.Update(t, deltaTime, independentTime, false)) {
                            willKill = true;
                        }

                        //  Commented in favor of the new Update(tween...) method
                        // if (_totTweenLinks > 0) EvaluateTweenLink(t); // TweenLinks
                        // if (!t.active) {
                        //     // Manually killed by another tween's callback or deactivated by the TweenLink evaluation
                        //     willKill = true;
                        //     MarkForKilling(t);
                        //     continue;
                        // }
                        // if (!t.isPlaying) continue;
                        // t.creationLocked = true; // Lock tween creation methods from now on
                        // float tDeltaTime = (t.isIndependentUpdate ? independentTime : deltaTime) * t.timeScale;
                        // if (tDeltaTime < _EpsilonVsTimeCheck && tDeltaTime > -_EpsilonVsTimeCheck) continue; // Skip update in case time is approximately 0
                        // if (!t.delayComplete) {
                        //     tDeltaTime = t.UpdateDelay(t.elapsedDelay + tDeltaTime);
                        //     if (tDeltaTime <= -1) {
                        //         // Error during startup (can happen with FROM tweens): mark tween for killing
                        //         willKill = true;
                        //         MarkForKilling(t);
                        //         continue;
                        //     }
                        //     if (tDeltaTime <= 0) continue;
                        //     // Delay elapsed - call OnPlay if required
                        //     if (t.playedOnce && t.onPlay != null) {
                        //         // Don't call in case it hasn't started because onStart routine will call it
                        //         Tween.OnTweenCallback(t.onPlay, t);
                        //     }
                        // }
                        // // Startup (needs to be here other than in Tween.DoGoto in case of speed-based tweens, to calculate duration correctly)
                        // if (!t.startupDone) {
                        //     if (!t.Startup()) {
                        //         // Startup failure: mark for killing
                        //         willKill = true;
                        //         MarkForKilling(t);
                        //         continue;
                        //     }
                        // }
                        // // Find update data
                        // float toPosition = t.position;
                        // bool wasEndPosition = toPosition >= t.duration;
                        // int toCompletedLoops = t.completedLoops;
                        // if (t.duration <= 0) {
                        //     toPosition = 0;
                        //     toCompletedLoops = t.loops == -1 ? t.completedLoops + 1 : t.loops;
                        // } else {
                        //     if (t.isBackwards) {
                        //         toPosition -= tDeltaTime;
                        //         while (toPosition < 0 && toCompletedLoops > -1) {
                        //             toPosition += t.duration;
                        //             toCompletedLoops--;
                        //         }
                        //         if (toCompletedLoops < 0 || wasEndPosition && toCompletedLoops < 1) {
                        //             // Result is equivalent to a rewind, so set values according to it
                        //             toPosition = 0;
                        //             toCompletedLoops = wasEndPosition ? 1 : 0;
                        //         }
                        //     } else {
                        //         toPosition += tDeltaTime;
                        //         while (toPosition >= t.duration && (t.loops == -1 || toCompletedLoops < t.loops)) {
                        //             toPosition -= t.duration;
                        //             toCompletedLoops++;
                        //         }
                        //     }
                        //     if (wasEndPosition) toCompletedLoops--;
                        //     if (t.loops != -1 && toCompletedLoops >= t.loops) toPosition = t.duration;
                        // }
                        // // Goto
                        // bool needsKilling = Tween.DoGoto(t, toPosition, toCompletedLoops, UpdateMode.Update);
                        // if (needsKilling) {
                        //     willKill = true;
                        //     MarkForKilling(t);
                        // }
                    }

                    // Kill all eventually marked tweens
                    if (willKill) {
                        if (DG.Tweening.Core.TweenManager._despawnAllCalledFromUpdateLoopCallback) {
                            // Do not despawn tweens again, since Kill/DespawnAll was already called
                            DG.Tweening.Core.TweenManager._despawnAllCalledFromUpdateLoopCallback = false;
                        } else {
                            DG.Tweening.Core.TweenManager.DespawnActiveTweens(DG.Tweening.Core.TweenManager._KillList);
                        }

                        DG.Tweening.Core.TweenManager._KillList.clear();
                    }

                    DG.Tweening.Core.TweenManager.isUpdateLoop = false;
                },
                /*DG.Tweening.Core.TweenManager.Update$1:static end.*/

                /*DG.Tweening.Core.TweenManager.Update:static start.*/
                Update: function (t, deltaTime, independentTime, isSingleTweenManualUpdate) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#Update", this ); }

                    if (DG.Tweening.Core.TweenManager._totTweenLinks > 0) {
                        DG.Tweening.Core.TweenManager.EvaluateTweenLink(t); // TweenLinks
                    }

                    if (!t.active) {
                        // Manually killed by another tween's callback or deactivated by the TweenLink evaluation
                        DG.Tweening.Core.TweenManager.MarkForKilling(t, isSingleTweenManualUpdate);
                        return true;
                    }

                    if (!t.isPlaying) {
                        return false;
                    }

                    t.creationLocked = true; // Lock tween creation methods from now on
                    var tDeltaTime = (t.isIndependentUpdate ? independentTime : deltaTime) * t.timeScale;
                    if (tDeltaTime < DG.Tweening.Core.TweenManager._EpsilonVsTimeCheck && tDeltaTime > -1E-06) {
                        return false; // Skip update in case time is approximately 0
                    }

                    if (!t.delayComplete) {
                        tDeltaTime = t.UpdateDelay(t.elapsedDelay + tDeltaTime);
                        if (tDeltaTime <= -1) {
                            // Error during startup (can happen with FROM tweens): mark tween for killing
                            DG.Tweening.Core.TweenManager.MarkForKilling(t, isSingleTweenManualUpdate);
                            return true;
                        }

                        if (tDeltaTime <= 0) {
                            return false;
                        }

                        // Delay elapsed - call OnPlay if required
                        if (t.playedOnce && !Bridge.staticEquals(t.onPlay, null)) {
                            // Don't call in case it hasn't started because onStart routine will call it
                            DG.Tweening.Tween.OnTweenCallback(t.onPlay, t);
                        }
                    }

                    // Startup (needs to be here other than in Tween.DoGoto in case of speed-based tweens, to calculate duration correctly)
                    if (!t.startupDone) {
                        if (!t.Startup()) {
                            // Startup failure: mark for killing
                            DG.Tweening.Core.TweenManager.MarkForKilling(t, isSingleTweenManualUpdate);
                            return true;
                        }
                    }

                    // Find update data
                    var toPosition = t.position;
                    var wasEndPosition = toPosition >= t.duration;
                    var toCompletedLoops = t.completedLoops;
                    if (t.duration <= 0) {
                        toPosition = 0;
                        toCompletedLoops = t.loops === -1 ? t.completedLoops + 1 : t.loops;
                    } else {
                        if (t.isBackwards) {
                            toPosition -= tDeltaTime;
                            while (toPosition < 0 && toCompletedLoops > -1) {
                                toPosition += t.duration;
                                toCompletedLoops--;
                            }

                            if (toCompletedLoops < 0 || wasEndPosition && toCompletedLoops < 1) {
                                // Result is equivalent to a rewind, so set values according to it
                                toPosition = 0;
                                toCompletedLoops = wasEndPosition ? 1 : 0;
                            }
                        } else {
                            toPosition += tDeltaTime;
                            while (toPosition >= t.duration && (t.loops === -1 || toCompletedLoops < t.loops)) {
                                toPosition -= t.duration;
                                toCompletedLoops++;
                            }
                        }

                        if (wasEndPosition) {
                            toCompletedLoops--;
                        }

                        if (t.loops !== -1 && toCompletedLoops >= t.loops) {
                            toPosition = t.duration;
                        }
                    }

                    // Goto
                    var needsKilling = DG.Tweening.Tween.DoGoto(t, toPosition, toCompletedLoops, DG.Tweening.Core.Enums.UpdateMode.Update);
                    if (needsKilling) {
                        DG.Tweening.Core.TweenManager.MarkForKilling(t, isSingleTweenManualUpdate);
                        return true;
                    }

                    return false;
                },
                /*DG.Tweening.Core.TweenManager.Update:static end.*/

                /*DG.Tweening.Core.TweenManager.FilteredOperation:static start.*/
                FilteredOperation: function (operationType, filterType, id, optionalBool, optionalFloat, optionalObj, optionalArray) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#FilteredOperation", this ); }

                    if (optionalObj === void 0) { optionalObj = null; }
                    if (optionalArray === void 0) { optionalArray = null; }
                    var totInvolved = 0;
                    var hasDespawned = false;
                    var optionalArrayLen = optionalArray == null ? 0 : optionalArray.length;
                    // Determine if ID is required, and if it's stringId
                    var useStringId = false;
                    var stringId = null;
                    var useIntId = false;
                    var intId = 0;
                    switch (filterType) {
                        case DG.Tweening.Core.Enums.FilterType.TargetOrId: 
                        case DG.Tweening.Core.Enums.FilterType.TargetAndId: 
                            if (Bridge.is(id, System.String)) {
                                useStringId = true;
                                stringId = Bridge.cast(id, System.String);
                            } else if (Bridge.is(id, System.Int32)) {
                                useIntId = true;
                                intId = Bridge.cast(id, System.Int32);
                            }
                            break;
                    }

                    for (var i = DG.Tweening.Core.TweenManager._maxActiveLookupId; i > -1; --i) {
                        var t = DG.Tweening.Core.TweenManager._activeTweens[i];
                        if (t == null || !t.active) {
                            continue;
                        }

                        var isFilterCompliant = false;
                        switch (filterType) {
                            case DG.Tweening.Core.Enums.FilterType.All: 
                                isFilterCompliant = true;
                                break;
                            case DG.Tweening.Core.Enums.FilterType.TargetOrId: 
                                if (useStringId) {
                                    isFilterCompliant = t.stringId != null && Bridge.referenceEquals(t.stringId, stringId);
                                } else if (useIntId) {
                                    isFilterCompliant = t.intId === intId;
                                } else {
                                    isFilterCompliant = t.id != null && Bridge.equals(id, t.id) || t.target != null && Bridge.equals(id, t.target);
                                }
                                break;
                            case DG.Tweening.Core.Enums.FilterType.TargetAndId: 
                                if (useStringId) {
                                    isFilterCompliant = t.target != null && Bridge.referenceEquals(t.stringId, stringId) && optionalObj != null && Bridge.equals(optionalObj, t.target);
                                } else if (useIntId) {
                                    isFilterCompliant = t.target != null && t.intId === intId && optionalObj != null && Bridge.equals(optionalObj, t.target);
                                } else {
                                    isFilterCompliant = t.id != null && t.target != null && optionalObj != null && Bridge.equals(id, t.id) && Bridge.equals(optionalObj, t.target);
                                }
                                break;
                            case DG.Tweening.Core.Enums.FilterType.AllExceptTargetsOrIds: 
                                isFilterCompliant = true;
                                for (var c = 0; c < optionalArrayLen; ++c) {
                                    var objId = optionalArray[c];
                                    if (Bridge.is(objId, System.String)) {
                                        useStringId = true;
                                        stringId = Bridge.cast(objId, System.String);
                                    } else if (Bridge.is(objId, System.Int32)) {
                                        useIntId = true;
                                        intId = Bridge.cast(objId, System.Int32);
                                    }

                                    if (useStringId && Bridge.referenceEquals(t.stringId, stringId)) {
                                        isFilterCompliant = false;
                                        break;
                                    }

                                    if (useIntId && t.intId === intId) {
                                        isFilterCompliant = false;
                                        break;
                                    }

                                    if (t.id != null && Bridge.equals(objId, t.id) || t.target != null && Bridge.equals(objId, t.target)) {
                                        isFilterCompliant = false;
                                        break;
                                    }
                                }
                                break;
                        }

                        if (isFilterCompliant) {
                            switch (operationType) {
                                case DG.Tweening.Core.Enums.OperationType.Despawn: 
                                    totInvolved++;
                                    t.active = false; // Mark it as inactive immediately, so eventual kills called inside a kill won't have effect
                                    //                        if (isUpdateLoop) t.active = false; // Just mark it for killing, so the update loop will take care of it
                                    if (DG.Tweening.Core.TweenManager.isUpdateLoop) {
                                        break; // Just mark it for killing, the update loop will take care of the rest
                                    }
                                    DG.Tweening.Core.TweenManager.Despawn(t, false);
                                    hasDespawned = true;
                                    DG.Tweening.Core.TweenManager._KillList.add(t);
                                    break;
                                case DG.Tweening.Core.Enums.OperationType.Complete: 
                                    var hasAutoKill = t.autoKill;
                                    if (!t.startupDone) {
                                        DG.Tweening.Core.TweenManager.ForceInit(t); // Initialize the tween if it's not initialized already (required for speed-based)
                                    }
                                    // If optionalFloat is > 0 completes with callbacks
                                    if (DG.Tweening.Core.TweenManager.Complete(t, false, optionalFloat > 0 ? DG.Tweening.Core.Enums.UpdateMode.Update : DG.Tweening.Core.Enums.UpdateMode.Goto)) {
                                        // If optionalBool is TRUE only returns tweens killed by completion
                                        totInvolved += !optionalBool ? 1 : hasAutoKill ? 1 : 0;
                                        if (hasAutoKill) {
                                            if (DG.Tweening.Core.TweenManager.isUpdateLoop) {
                                                t.active = false; // Just mark it for killing, so the update loop will take care of it
                                            } else {
                                                hasDespawned = true;
                                                DG.Tweening.Core.TweenManager._KillList.add(t);
                                            }
                                        }
                                    }
                                    break;
                                case DG.Tweening.Core.Enums.OperationType.Flip: 
                                    if (DG.Tweening.Core.TweenManager.Flip(t)) {
                                        totInvolved++;
                                    }
                                    break;
                                case DG.Tweening.Core.Enums.OperationType.Goto: 
                                    if (!t.startupDone) {
                                        DG.Tweening.Core.TweenManager.ForceInit(t); // Initialize the tween if it's not initialized already (required for speed-based)
                                    }
                                    DG.Tweening.Core.TweenManager.Goto(t, optionalFloat, optionalBool);
                                    totInvolved++;
                                    break;
                                case DG.Tweening.Core.Enums.OperationType.Pause: 
                                    if (DG.Tweening.Core.TweenManager.Pause(t)) {
                                        totInvolved++;
                                    }
                                    break;
                                case DG.Tweening.Core.Enums.OperationType.Play: 
                                    if (DG.Tweening.Core.TweenManager.Play(t)) {
                                        totInvolved++;
                                    }
                                    break;
                                case DG.Tweening.Core.Enums.OperationType.PlayBackwards: 
                                    if (DG.Tweening.Core.TweenManager.PlayBackwards(t)) {
                                        totInvolved++;
                                    }
                                    break;
                                case DG.Tweening.Core.Enums.OperationType.PlayForward: 
                                    if (DG.Tweening.Core.TweenManager.PlayForward(t)) {
                                        totInvolved++;
                                    }
                                    break;
                                case DG.Tweening.Core.Enums.OperationType.Restart: 
                                    if (DG.Tweening.Core.TweenManager.Restart(t, optionalBool, optionalFloat)) {
                                        totInvolved++;
                                    }
                                    break;
                                case DG.Tweening.Core.Enums.OperationType.Rewind: 
                                    if (DG.Tweening.Core.TweenManager.Rewind(t, optionalBool)) {
                                        totInvolved++;
                                    }
                                    break;
                                case DG.Tweening.Core.Enums.OperationType.SmoothRewind: 
                                    if (DG.Tweening.Core.TweenManager.SmoothRewind(t)) {
                                        totInvolved++;
                                    }
                                    break;
                                case DG.Tweening.Core.Enums.OperationType.TogglePause: 
                                    if (DG.Tweening.Core.TweenManager.TogglePause(t)) {
                                        totInvolved++;
                                    }
                                    break;
                                case DG.Tweening.Core.Enums.OperationType.IsTweening: 
                                    if ((!t.isComplete || !t.autoKill) && (!optionalBool || t.isPlaying)) {
                                        totInvolved++;
                                    }
                                    break;
                            }
                        }
                    }

                    // Special additional operations in case of despawn
                    if (hasDespawned) {
                        var count = DG.Tweening.Core.TweenManager._KillList.Count - 1;
                        for (var i1 = count; i1 > -1; --i1) {
                            var t1 = DG.Tweening.Core.TweenManager._KillList.getItem(i1);
                            // Ignore tweens with activeId -1, since they were already killed and removed
                            //  by nested OnComplete callbacks
                            if (t1.activeId !== -1) {
                                DG.Tweening.Core.TweenManager.RemoveActiveTween(t1);
                            }
                        }

                        DG.Tweening.Core.TweenManager._KillList.clear();
                    }

                    return totInvolved;
                },
                /*DG.Tweening.Core.TweenManager.FilteredOperation:static end.*/

                /*DG.Tweening.Core.TweenManager.Complete:static start.*/
                Complete: function (t, modifyActiveLists, updateMode) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#Complete", this ); }

                    if (modifyActiveLists === void 0) { modifyActiveLists = true; }
                    if (updateMode === void 0) { updateMode = 1; }
                    if (t.loops === -1) {
                        return false;
                    }

                    if (!t.isComplete) {
                        DG.Tweening.Tween.DoGoto(t, t.duration, t.loops, updateMode);
                        t.isPlaying = false;
                        // Despawn if needed (might have already been killed by the complete callback/operation)
                        if (t.autoKill && t.active) {
                            if (DG.Tweening.Core.TweenManager.isUpdateLoop) {
                                t.active = false; // Just mark it for killing, so the update loop will take care of it
                            } else {
                                DG.Tweening.Core.TweenManager.Despawn(t, modifyActiveLists);
                            }
                        }

                        return true;
                    }

                    return false;
                },
                /*DG.Tweening.Core.TweenManager.Complete:static end.*/

                /*DG.Tweening.Core.TweenManager.Flip:static start.*/
                Flip: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#Flip", this ); }

                    t.isBackwards = !t.isBackwards;
                    return true;
                },
                /*DG.Tweening.Core.TweenManager.Flip:static end.*/

                /*DG.Tweening.Core.TweenManager.ForceInit:static start.*/
                ForceInit: function (t, isSequenced) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#ForceInit", this ); }

                    if (isSequenced === void 0) { isSequenced = false; }
                    if (t.startupDone) {
                        return;
                    }

                    if (!t.Startup() && !isSequenced) {
                        // Startup failed: kill tween
                        if (DG.Tweening.Core.TweenManager.isUpdateLoop) {
                            t.active = false; // Just mark it for killing, so the update loop will take care of it
                        } else {
                            DG.Tweening.Core.TweenManager.RemoveActiveTween(t);
                        }
                    }
                },
                /*DG.Tweening.Core.TweenManager.ForceInit:static end.*/

                /*DG.Tweening.Core.TweenManager.Goto:static start.*/
                Goto: function (t, to, andPlay, updateMode) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#Goto", this ); }

                    if (andPlay === void 0) { andPlay = false; }
                    if (updateMode === void 0) { updateMode = 1; }
                    var wasPlaying = t.isPlaying;
                    t.isPlaying = andPlay;
                    t.delayComplete = true;
                    t.elapsedDelay = t.delay;
                    //            int toCompletedLoops = (int)(to / t.duration); // With very small floats creates floating points imprecision
                    var toCompletedLoops = t.duration <= 0 ? 1 : Math.floor(to / t.duration); // Still generates imprecision with some values (like 0.4)
                    //            int toCompletedLoops = (int)((decimal)to / (decimal)t.duration); // Takes care of floating points imprecision (nahh doesn't work correctly either)
                    var toPosition = to % t.duration;
                    if (t.loops !== -1 && toCompletedLoops >= t.loops) {
                        toCompletedLoops = t.loops;
                        toPosition = t.duration;
                    } else if (toPosition >= t.duration) {
                        toPosition = 0;
                    }

                    // If andPlay is FALSE manage onPause from here because DoGoto won't detect it (since t.isPlaying was already set from here)
                    var needsKilling = DG.Tweening.Tween.DoGoto(t, toPosition, toCompletedLoops, updateMode);
                    if (!andPlay && wasPlaying && !needsKilling && !Bridge.staticEquals(t.onPause, null)) {
                        DG.Tweening.Tween.OnTweenCallback(t.onPause, t);
                    }

                    return needsKilling;
                },
                /*DG.Tweening.Core.TweenManager.Goto:static end.*/

                /*DG.Tweening.Core.TweenManager.Pause:static start.*/
                Pause: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#Pause", this ); }

                    if (t.isPlaying) {
                        t.isPlaying = false;
                        if (!Bridge.staticEquals(t.onPause, null)) {
                            DG.Tweening.Tween.OnTweenCallback(t.onPause, t);
                        }

                        return true;
                    }

                    return false;
                },
                /*DG.Tweening.Core.TweenManager.Pause:static end.*/

                /*DG.Tweening.Core.TweenManager.Play:static start.*/
                Play: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#Play", this ); }

                    if (!t.isPlaying && (!t.isBackwards && !t.isComplete || t.isBackwards && (t.completedLoops > 0 || t.position > 0))) {
                        t.isPlaying = true;
                        if (t.playedOnce && t.delayComplete && !Bridge.staticEquals(t.onPlay, null)) {
                            // Don't call in case there's a delay to run or if it hasn't started because onStart routine will call it
                            DG.Tweening.Tween.OnTweenCallback(t.onPlay, t);
                        }

                        return true;
                    }

                    return false;
                },
                /*DG.Tweening.Core.TweenManager.Play:static end.*/

                /*DG.Tweening.Core.TweenManager.PlayBackwards:static start.*/
                PlayBackwards: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#PlayBackwards", this ); }

                    if (t.completedLoops === 0 && t.position <= 0) {
                        // Already rewinded, manage OnRewind callback
                        DG.Tweening.Core.TweenManager.ManageOnRewindCallbackWhenAlreadyRewinded(t, true);
                        t.isBackwards = true;
                        t.isPlaying = false;
                        return false;
                    }

                    if (!t.isBackwards) {
                        t.isBackwards = true;
                        DG.Tweening.Core.TweenManager.Play(t);
                        return true;
                    }

                    return DG.Tweening.Core.TweenManager.Play(t);
                },
                /*DG.Tweening.Core.TweenManager.PlayBackwards:static end.*/

                /*DG.Tweening.Core.TweenManager.PlayForward:static start.*/
                PlayForward: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#PlayForward", this ); }

                    if (t.isComplete) {
                        t.isBackwards = false;
                        t.isPlaying = false;
                        return false;
                    }

                    if (t.isBackwards) {
                        t.isBackwards = false;
                        DG.Tweening.Core.TweenManager.Play(t);
                        return true;
                    }

                    return DG.Tweening.Core.TweenManager.Play(t);
                },
                /*DG.Tweening.Core.TweenManager.PlayForward:static end.*/

                /*DG.Tweening.Core.TweenManager.Restart:static start.*/
                Restart: function (t, includeDelay, changeDelayTo) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#Restart", this ); }

                    if (includeDelay === void 0) { includeDelay = true; }
                    if (changeDelayTo === void 0) { changeDelayTo = -1.0; }
                    var wasPaused = !t.isPlaying;
                    t.isBackwards = false;
                    if (changeDelayTo >= 0 && t.tweenType === DG.Tweening.TweenType.Tweener) {
                        t.delay = changeDelayTo;
                    }

                    DG.Tweening.Core.TweenManager.Rewind(t, includeDelay);
                    t.isPlaying = true;
                    if (wasPaused && t.playedOnce && t.delayComplete && !Bridge.staticEquals(t.onPlay, null)) {
                        // Don't call in case there's a delay to run or if it hasn't started because onStart routine will call it
                        DG.Tweening.Tween.OnTweenCallback(t.onPlay, t);
                    }

                    return true;
                },
                /*DG.Tweening.Core.TweenManager.Restart:static end.*/

                /*DG.Tweening.Core.TweenManager.Rewind:static start.*/
                Rewind: function (t, includeDelay) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#Rewind", this ); }

                    if (includeDelay === void 0) { includeDelay = true; }
                    var wasPlaying = t.isPlaying; // Manage onPause from this method because DoGoto won't detect it
                    t.isPlaying = false;
                    var rewinded = false;
                    if (t.delay > 0) {
                        if (includeDelay) {
                            rewinded = t.delay > 0 && t.elapsedDelay > 0;
                            t.elapsedDelay = 0;
                            t.delayComplete = false;
                        } else {
                            rewinded = t.elapsedDelay < t.delay;
                            t.elapsedDelay = t.delay;
                            t.delayComplete = true;
                        }
                    }

                    if (t.position > 0 || t.completedLoops > 0 || !t.startupDone) {
                        rewinded = true;
                        var needsKilling = DG.Tweening.Tween.DoGoto(t, 0, 0, DG.Tweening.Core.Enums.UpdateMode.Goto);
                        if (!needsKilling && wasPlaying && !Bridge.staticEquals(t.onPause, null)) {
                            DG.Tweening.Tween.OnTweenCallback(t.onPause, t);
                        }
                    } else {
                        // Alread rewinded
                        DG.Tweening.Core.TweenManager.ManageOnRewindCallbackWhenAlreadyRewinded(t, false);
                    }

                    return rewinded;
                },
                /*DG.Tweening.Core.TweenManager.Rewind:static end.*/

                /*DG.Tweening.Core.TweenManager.SmoothRewind:static start.*/
                SmoothRewind: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#SmoothRewind", this ); }

                    var rewinded = false;
                    if (t.delay > 0) {
                        rewinded = t.elapsedDelay < t.delay;
                        t.elapsedDelay = t.delay;
                        t.delayComplete = true;
                    }

                    if (t.position > 0 || t.completedLoops > 0 || !t.startupDone) {
                        rewinded = true;
                        if (t.loopType === DG.Tweening.LoopType.Incremental) {
                            DG.Tweening.TweenExtensions.PlayBackwards(t);
                        } else {
                            DG.Tweening.TweenExtensions.Goto(t, DG.Tweening.TweenExtensions.ElapsedDirectionalPercentage(t) * t.duration);
                            DG.Tweening.TweenExtensions.PlayBackwards(t);
                        }
                    } else {
                        // Already rewinded
                        t.isPlaying = false;
                        DG.Tweening.Core.TweenManager.ManageOnRewindCallbackWhenAlreadyRewinded(t, true);
                    }

                    return rewinded;
                },
                /*DG.Tweening.Core.TweenManager.SmoothRewind:static end.*/

                /*DG.Tweening.Core.TweenManager.TogglePause:static start.*/
                TogglePause: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#TogglePause", this ); }

                    if (t.isPlaying) {
                        return DG.Tweening.Core.TweenManager.Pause(t);
                    }

                    return DG.Tweening.Core.TweenManager.Play(t);
                },
                /*DG.Tweening.Core.TweenManager.TogglePause:static end.*/

                /*DG.Tweening.Core.TweenManager.TotalPooledTweens:static start.*/
                TotalPooledTweens: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#TotalPooledTweens", this ); }

                    return DG.Tweening.Core.TweenManager.totPooledTweeners + DG.Tweening.Core.TweenManager.totPooledSequences;
                },
                /*DG.Tweening.Core.TweenManager.TotalPooledTweens:static end.*/

                /*DG.Tweening.Core.TweenManager.TotalPlayingTweens:static start.*/
                TotalPlayingTweens: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#TotalPlayingTweens", this ); }

                    if (!DG.Tweening.Core.TweenManager.hasActiveTweens) {
                        return 0;
                    }

                    if (DG.Tweening.Core.TweenManager._requiresActiveReorganization) {
                        DG.Tweening.Core.TweenManager.ReorganizeActiveTweens();
                    }

                    var tot = 0;
                    for (var i = 0; i < DG.Tweening.Core.TweenManager._maxActiveLookupId + 1; ++i) {
                        var t = DG.Tweening.Core.TweenManager._activeTweens[i];
                        if (t != null && t.isPlaying) {
                            tot++;
                        }
                    }

                    return tot;
                },
                /*DG.Tweening.Core.TweenManager.TotalPlayingTweens:static end.*/

                /*DG.Tweening.Core.TweenManager.TotalTweensById:static start.*/
                /**
                 * @static
                 * @this DG.Tweening.Core.TweenManager
                 * @memberof DG.Tweening.Core.TweenManager
                 * @param   {System.Object}    id             
                 * @param   {boolean}          playingOnly
                 * @return  {number}
                 */
                TotalTweensById: function (id, playingOnly) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#TotalTweensById", this ); }

                    if (DG.Tweening.Core.TweenManager._requiresActiveReorganization) {
                        DG.Tweening.Core.TweenManager.ReorganizeActiveTweens();
                    }

                    if (DG.Tweening.Core.TweenManager.totActiveTweens <= 0) {
                        return 0;
                    }

                    return DG.Tweening.Core.TweenManager.DoGetTweensById(id, playingOnly, false, null);
                },
                /*DG.Tweening.Core.TweenManager.TotalTweensById:static end.*/

                /*DG.Tweening.Core.TweenManager.GetActiveTweens:static start.*/
                GetActiveTweens: function (playing, fillableList) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#GetActiveTweens", this ); }

                    if (fillableList === void 0) { fillableList = null; }
                    if (DG.Tweening.Core.TweenManager._requiresActiveReorganization) {
                        DG.Tweening.Core.TweenManager.ReorganizeActiveTweens();
                    }

                    if (DG.Tweening.Core.TweenManager.totActiveTweens <= 0) {
                        return null;
                    }

                    var len = DG.Tweening.Core.TweenManager.totActiveTweens;
                    if (fillableList == null) {
                        fillableList = new (System.Collections.Generic.List$1(DG.Tweening.Tween)).$ctor2(len);
                    }

                    for (var i = 0; i < len; ++i) {
                        var t = DG.Tweening.Core.TweenManager._activeTweens[i];
                        if (t.isPlaying === playing) {
                            fillableList.add(t);
                        }
                    }

                    if (fillableList.Count > 0) {
                        return fillableList;
                    }

                    return null;
                },
                /*DG.Tweening.Core.TweenManager.GetActiveTweens:static end.*/

                /*DG.Tweening.Core.TweenManager.GetTweensById:static start.*/
                GetTweensById: function (id, playingOnly, fillableList) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#GetTweensById", this ); }

                    if (fillableList === void 0) { fillableList = null; }
                    if (DG.Tweening.Core.TweenManager._requiresActiveReorganization) {
                        DG.Tweening.Core.TweenManager.ReorganizeActiveTweens();
                    }

                    if (DG.Tweening.Core.TweenManager.totActiveTweens <= 0) {
                        return null;
                    }

                    if (fillableList == null) {
                        fillableList = new (System.Collections.Generic.List$1(DG.Tweening.Tween)).$ctor2(DG.Tweening.Core.TweenManager.totActiveTweens);
                    }

                    DG.Tweening.Core.TweenManager.DoGetTweensById(id, playingOnly, true, fillableList);
                    return fillableList.Count > 0 ? fillableList : null;
                },
                /*DG.Tweening.Core.TweenManager.GetTweensById:static end.*/

                /*DG.Tweening.Core.TweenManager.DoGetTweensById:static start.*/
                DoGetTweensById: function (id, playingOnly, addToList, fillableList) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#DoGetTweensById", this ); }

                    var result = 0;
                    // Determine ID to use
                    var useStringId = false;
                    var stringId = null;
                    var useIntId = false;
                    var intId = 0;
                    if (Bridge.is(id, System.String)) {
                        useStringId = true;
                        stringId = Bridge.cast(id, System.String);
                    } else if (Bridge.is(id, System.Int32)) {
                        useIntId = true;
                        intId = Bridge.cast(id, System.Int32);
                    }

                    //
                    var len = DG.Tweening.Core.TweenManager.totActiveTweens;
                    for (var i = 0; i < len; ++i) {
                        var t = DG.Tweening.Core.TweenManager._activeTweens[i];
                        if (t == null) {
                            continue;
                        }

                        if (useStringId) {
                            if (t.stringId == null || !Bridge.referenceEquals(t.stringId, stringId)) {
                                continue;
                            }
                        } else if (useIntId) {
                            if (t.intId !== intId) {
                                continue;
                            }
                        } else if (t.id == null || !Bridge.equals(id, t.id)) {
                            continue;
                        }

                        if (!playingOnly || t.isPlaying) {
                            result++;
                            if (addToList) {
                                fillableList.add(t);
                            }
                        }
                    }

                    return result;
                },
                /*DG.Tweening.Core.TweenManager.DoGetTweensById:static end.*/

                /*DG.Tweening.Core.TweenManager.GetTweensByTarget:static start.*/
                GetTweensByTarget: function (target, playingOnly, fillableList) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#GetTweensByTarget", this ); }

                    if (fillableList === void 0) { fillableList = null; }
                    if (DG.Tweening.Core.TweenManager._requiresActiveReorganization) {
                        DG.Tweening.Core.TweenManager.ReorganizeActiveTweens();
                    }

                    if (DG.Tweening.Core.TweenManager.totActiveTweens <= 0) {
                        return null;
                    }

                    var len = DG.Tweening.Core.TweenManager.totActiveTweens;
                    if (fillableList == null) {
                        fillableList = new (System.Collections.Generic.List$1(DG.Tweening.Tween)).$ctor2(len);
                    }

                    for (var i = 0; i < len; ++i) {
                        var t = DG.Tweening.Core.TweenManager._activeTweens[i];
                        if (!Bridge.referenceEquals(t.target, target)) {
                            continue;
                        }

                        if (!playingOnly || t.isPlaying) {
                            fillableList.add(t);
                        }
                    }

                    if (fillableList.Count > 0) {
                        return fillableList;
                    }

                    return null;
                },
                /*DG.Tweening.Core.TweenManager.GetTweensByTarget:static end.*/

                /*DG.Tweening.Core.TweenManager.MarkForKilling:static start.*/
                MarkForKilling: function (t, isSingleTweenManualUpdate) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#MarkForKilling", this ); }

                    if (isSingleTweenManualUpdate === void 0) { isSingleTweenManualUpdate = false; }
                    if (isSingleTweenManualUpdate && !DG.Tweening.Core.TweenManager.isUpdateLoop) {
                        // Kill immediately
                        DG.Tweening.Core.TweenManager.Despawn(t);
                    } else {
                        t.active = false;
                        DG.Tweening.Core.TweenManager._KillList.add(t);
                    }
                },
                /*DG.Tweening.Core.TweenManager.MarkForKilling:static end.*/

                /*DG.Tweening.Core.TweenManager.EvaluateTweenLink:static start.*/
                EvaluateTweenLink: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#EvaluateTweenLink", this ); }

                    // Check tween links
                    var tLink = { };
                    if (!DG.Tweening.Core.TweenManager._TweenLinks.tryGetValue(t, tLink)) {
                        return;
                    }

                    if (UnityEngine.GameObject.op_Equality(tLink.v.target, null)) {
                        t.active = false; // Will be killed by rest of Update loop
                    } else {
                        var goActive = tLink.v.target.activeInHierarchy;
                        var justEnabled = !tLink.v.lastSeenActive && goActive;
                        var justDisabled = tLink.v.lastSeenActive && !goActive;
                        tLink.v.lastSeenActive = goActive;
                        switch (tLink.v.behaviour) {
                            case DG.Tweening.LinkBehaviour.KillOnDisable: 
                                if (!goActive) {
                                    t.active = false; // Will be killed by rest of Update loop
                                }
                                break;
                            case DG.Tweening.LinkBehaviour.CompleteAndKillOnDisable: 
                                if (goActive) {
                                    break;
                                }
                                if (!t.isComplete) {
                                    DG.Tweening.TweenExtensions.Complete(t);
                                }
                                t.active = false; // Will be killed by rest of Update loop
                                break;
                            case DG.Tweening.LinkBehaviour.RewindAndKillOnDisable: 
                                if (goActive) {
                                    break;
                                }
                                DG.Tweening.TweenExtensions.Rewind(t, false);
                                t.active = false; // Will be killed by rest of Update loop
                                break;
                            case DG.Tweening.LinkBehaviour.CompleteOnDisable: 
                                if (justDisabled && !t.isComplete) {
                                    DG.Tweening.TweenExtensions.Complete(t);
                                }
                                break;
                            case DG.Tweening.LinkBehaviour.RewindOnDisable: 
                                if (justDisabled) {
                                    DG.Tweening.TweenExtensions.Rewind(t, false);
                                }
                                break;
                            case DG.Tweening.LinkBehaviour.PauseOnDisable: 
                                if (justDisabled && t.isPlaying) {
                                    DG.Tweening.Core.TweenManager.Pause(t);
                                }
                                break;
                            case DG.Tweening.LinkBehaviour.PauseOnDisablePlayOnEnable: 
                                if (justDisabled) {
                                    DG.Tweening.Core.TweenManager.Pause(t);
                                } else if (justEnabled) {
                                    DG.Tweening.Core.TweenManager.Play(t);
                                }
                                break;
                            case DG.Tweening.LinkBehaviour.PauseOnDisableRestartOnEnable: 
                                if (justDisabled) {
                                    DG.Tweening.Core.TweenManager.Pause(t);
                                } else if (justEnabled) {
                                    DG.Tweening.Core.TweenManager.Restart(t);
                                }
                                break;
                            case DG.Tweening.LinkBehaviour.PlayOnEnable: 
                                if (justEnabled) {
                                    DG.Tweening.Core.TweenManager.Play(t);
                                }
                                break;
                            case DG.Tweening.LinkBehaviour.RestartOnEnable: 
                                if (justEnabled) {
                                    DG.Tweening.Core.TweenManager.Restart(t);
                                }
                                break;
                        }
                    }
                },
                /*DG.Tweening.Core.TweenManager.EvaluateTweenLink:static end.*/

                /*DG.Tweening.Core.TweenManager.AddActiveTween:static start.*/
                AddActiveTween: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#AddActiveTween", this ); }

                    var $t;
                    if (DG.Tweening.Core.TweenManager._requiresActiveReorganization) {
                        DG.Tweening.Core.TweenManager.ReorganizeActiveTweens();
                    }

                    // Safety check (IndexOutOfRangeException)
                    if (DG.Tweening.Core.TweenManager.totActiveTweens < 0) {
                        DG.Tweening.Core.Debugger.LogAddActiveTweenError("totActiveTweens < 0", t);
                        DG.Tweening.Core.TweenManager.totActiveTweens = 0;
                    }
                    //            else if (totActiveTweens > _activeTweens.Length - 1) {
                    //                Debugger.LogError("AddActiveTween: totActiveTweens > _activeTweens capacity. This should never ever happen. Please report it with instructions on how to reproduce it");
                    //                return;
                    //            }

                    t.active = true;
                    t.updateType = DG.Tweening.DOTween.defaultUpdateType;
                    t.isIndependentUpdate = DG.Tweening.DOTween.defaultTimeScaleIndependent;
                    t.activeId = ($t = DG.Tweening.Core.TweenManager.totActiveTweens, DG.Tweening.Core.TweenManager._maxActiveLookupId = $t, $t);
                    DG.Tweening.Core.TweenManager._activeTweens[DG.Tweening.Core.TweenManager.totActiveTweens] = t;
                    if (t.updateType === DG.Tweening.UpdateType.Normal) {
                        DG.Tweening.Core.TweenManager.totActiveDefaultTweens++;
                        DG.Tweening.Core.TweenManager.hasActiveDefaultTweens = true;
                    } else {
                        switch (t.updateType) {
                            case DG.Tweening.UpdateType.Fixed: 
                                DG.Tweening.Core.TweenManager.totActiveFixedTweens++;
                                DG.Tweening.Core.TweenManager.hasActiveFixedTweens = true;
                                break;
                            case DG.Tweening.UpdateType.Late: 
                                DG.Tweening.Core.TweenManager.totActiveLateTweens++;
                                DG.Tweening.Core.TweenManager.hasActiveLateTweens = true;
                                break;
                            default: 
                                DG.Tweening.Core.TweenManager.totActiveManualTweens++;
                                DG.Tweening.Core.TweenManager.hasActiveManualTweens = true;
                                break;
                        }
                    }

                    DG.Tweening.Core.TweenManager.totActiveTweens++;
                    if (t.tweenType === DG.Tweening.TweenType.Tweener) {
                        DG.Tweening.Core.TweenManager.totActiveTweeners++;
                    } else {
                        DG.Tweening.Core.TweenManager.totActiveSequences++;
                    }

                    DG.Tweening.Core.TweenManager.hasActiveTweens = true;
                },
                /*DG.Tweening.Core.TweenManager.AddActiveTween:static end.*/

                /*DG.Tweening.Core.TweenManager.ReorganizeActiveTweens:static start.*/
                ReorganizeActiveTweens: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#ReorganizeActiveTweens", this ); }

                    var $t;
                    if (DG.Tweening.Core.TweenManager.totActiveTweens <= 0) {
                        DG.Tweening.Core.TweenManager._maxActiveLookupId = -1;
                        DG.Tweening.Core.TweenManager._requiresActiveReorganization = false;
                        DG.Tweening.Core.TweenManager._reorganizeFromId = -1;
                        return;
                    }

                    if (DG.Tweening.Core.TweenManager._reorganizeFromId === DG.Tweening.Core.TweenManager._maxActiveLookupId) {
                        DG.Tweening.Core.TweenManager._maxActiveLookupId--;
                        DG.Tweening.Core.TweenManager._requiresActiveReorganization = false;
                        DG.Tweening.Core.TweenManager._reorganizeFromId = -1;
                        return;
                    }

                    var shift = 1;
                    var len = DG.Tweening.Core.TweenManager._maxActiveLookupId + 1;
                    DG.Tweening.Core.TweenManager._maxActiveLookupId = DG.Tweening.Core.TweenManager._reorganizeFromId - 1;
                    for (var i = DG.Tweening.Core.TweenManager._reorganizeFromId + 1; i < len; ++i) {
                        var t = DG.Tweening.Core.TweenManager._activeTweens[i];
                        if (t == null) {
                            shift++;
                            continue;
                        }

                        t.activeId = ($t = i - shift, DG.Tweening.Core.TweenManager._maxActiveLookupId = $t, $t);
                        DG.Tweening.Core.TweenManager._activeTweens[i - shift] = t;
                        DG.Tweening.Core.TweenManager._activeTweens[i] = null;
                    }

                    DG.Tweening.Core.TweenManager._requiresActiveReorganization = false;
                    DG.Tweening.Core.TweenManager._reorganizeFromId = -1;
                },
                /*DG.Tweening.Core.TweenManager.ReorganizeActiveTweens:static end.*/

                /*DG.Tweening.Core.TweenManager.DespawnActiveTweens:static start.*/
                DespawnActiveTweens: function (tweens) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#DespawnActiveTweens", this ); }

                    var count = tweens.Count - 1;
                    for (var i = count; i > -1; --i) {
                        DG.Tweening.Core.TweenManager.Despawn(tweens.getItem(i));
                    }
                },
                /*DG.Tweening.Core.TweenManager.DespawnActiveTweens:static end.*/

                /*DG.Tweening.Core.TweenManager.RemoveActiveTween:static start.*/
                RemoveActiveTween: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#RemoveActiveTween", this ); }

                    var index = t.activeId;

                    if (DG.Tweening.Core.TweenManager._totTweenLinks > 0) {
                        DG.Tweening.Core.TweenManager.RemoveTweenLink(t);
                    }

                    t.activeId = -1;
                    DG.Tweening.Core.TweenManager._requiresActiveReorganization = true;
                    if (DG.Tweening.Core.TweenManager._reorganizeFromId === -1 || DG.Tweening.Core.TweenManager._reorganizeFromId > index) {
                        DG.Tweening.Core.TweenManager._reorganizeFromId = index;
                    }

                    DG.Tweening.Core.TweenManager._activeTweens[index] = null;

                    if (t.updateType === DG.Tweening.UpdateType.Normal) {
                        // Safety check (IndexOutOfRangeException)
                        if (DG.Tweening.Core.TweenManager.totActiveDefaultTweens > 0) {
                            DG.Tweening.Core.TweenManager.totActiveDefaultTweens--;
                            DG.Tweening.Core.TweenManager.hasActiveDefaultTweens = DG.Tweening.Core.TweenManager.totActiveDefaultTweens > 0;
                        } else {
                            DG.Tweening.Core.Debugger.LogRemoveActiveTweenError("totActiveDefaultTweens < 0", t);
                        }
                    } else {
                        switch (t.updateType) {
                            case DG.Tweening.UpdateType.Fixed: 
                                // Safety check (IndexOutOfRangeException)
                                if (DG.Tweening.Core.TweenManager.totActiveFixedTweens > 0) {
                                    DG.Tweening.Core.TweenManager.totActiveFixedTweens--;
                                    DG.Tweening.Core.TweenManager.hasActiveFixedTweens = DG.Tweening.Core.TweenManager.totActiveFixedTweens > 0;
                                } else {
                                    DG.Tweening.Core.Debugger.LogRemoveActiveTweenError("totActiveFixedTweens < 0", t);
                                }
                                break;
                            case DG.Tweening.UpdateType.Late: 
                                // Safety check (IndexOutOfRangeException)
                                if (DG.Tweening.Core.TweenManager.totActiveLateTweens > 0) {
                                    DG.Tweening.Core.TweenManager.totActiveLateTweens--;
                                    DG.Tweening.Core.TweenManager.hasActiveLateTweens = DG.Tweening.Core.TweenManager.totActiveLateTweens > 0;
                                } else {
                                    DG.Tweening.Core.Debugger.LogRemoveActiveTweenError("totActiveLateTweens < 0", t);
                                }
                                break;
                            default: 
                                // Safety check (IndexOutOfRangeException)
                                if (DG.Tweening.Core.TweenManager.totActiveManualTweens > 0) {
                                    DG.Tweening.Core.TweenManager.totActiveManualTweens--;
                                    DG.Tweening.Core.TweenManager.hasActiveManualTweens = DG.Tweening.Core.TweenManager.totActiveManualTweens > 0;
                                } else {
                                    DG.Tweening.Core.Debugger.LogRemoveActiveTweenError("totActiveManualTweens < 0", t);
                                }
                                break;
                        }
                    }

                    DG.Tweening.Core.TweenManager.totActiveTweens--;
                    DG.Tweening.Core.TweenManager.hasActiveTweens = DG.Tweening.Core.TweenManager.totActiveTweens > 0;
                    if (t.tweenType === DG.Tweening.TweenType.Tweener) {
                        DG.Tweening.Core.TweenManager.totActiveTweeners--;
                    } else {
                        DG.Tweening.Core.TweenManager.totActiveSequences--;
                    }

                    // Safety check (IndexOutOfRangeException)
                    if (DG.Tweening.Core.TweenManager.totActiveTweens < 0) {
                        DG.Tweening.Core.TweenManager.totActiveTweens = 0;
                        DG.Tweening.Core.Debugger.LogRemoveActiveTweenError("totActiveTweens < 0", t);
                    }

                    // Safety check (IndexOutOfRangeException)
                    if (DG.Tweening.Core.TweenManager.totActiveTweeners < 0) {
                        DG.Tweening.Core.TweenManager.totActiveTweeners = 0;
                        DG.Tweening.Core.Debugger.LogRemoveActiveTweenError("totActiveTweeners < 0", t);
                    }

                    // Safety check (IndexOutOfRangeException)
                    if (DG.Tweening.Core.TweenManager.totActiveSequences < 0) {
                        DG.Tweening.Core.TweenManager.totActiveSequences = 0;
                        DG.Tweening.Core.Debugger.LogRemoveActiveTweenError("totActiveSequences < 0", t);
                    }
                },
                /*DG.Tweening.Core.TweenManager.RemoveActiveTween:static end.*/

                /*DG.Tweening.Core.TweenManager.ClearTweenArray:static start.*/
                ClearTweenArray: function (tweens) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#ClearTweenArray", this ); }

                    var len = tweens.length;
                    for (var i = 0; i < len; i++) {
                        tweens[i] = null;
                    }
                },
                /*DG.Tweening.Core.TweenManager.ClearTweenArray:static end.*/

                /*DG.Tweening.Core.TweenManager.IncreaseCapacities:static start.*/
                IncreaseCapacities: function (increaseMode) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#IncreaseCapacities", this ); }

                    var $t;
                    var killAdd = 0;
                    var increaseTweenersBy = Bridge.Math.round(UnityEngine.Mathf.Max(DG.Tweening.Core.TweenManager.maxTweeners * 1.5, DG.Tweening.Core.TweenManager._DefaultMaxTweeners), 0, 6);
                    var increaseSequencesBy = Bridge.Math.round(UnityEngine.Mathf.Max(DG.Tweening.Core.TweenManager.maxSequences * 1.5, DG.Tweening.Core.TweenManager._DefaultMaxSequences), 0, 6);
                    switch (increaseMode) {
                        case DG.Tweening.Core.TweenManager.CapacityIncreaseMode.TweenersOnly: 
                            killAdd += increaseTweenersBy;
                            DG.Tweening.Core.TweenManager.maxTweeners += increaseTweenersBy;
                            System.Array.resize(Bridge.ref(DG.Tweening.Core.TweenManager, "_pooledTweeners"), DG.Tweening.Core.TweenManager.maxTweeners, null, DG.Tweening.Tween);
                            break;
                        case DG.Tweening.Core.TweenManager.CapacityIncreaseMode.SequencesOnly: 
                            killAdd += increaseSequencesBy;
                            DG.Tweening.Core.TweenManager.maxSequences += increaseSequencesBy;
                            break;
                        default: 
                            killAdd += increaseTweenersBy + increaseSequencesBy;
                            DG.Tweening.Core.TweenManager.maxTweeners += increaseTweenersBy;
                            DG.Tweening.Core.TweenManager.maxSequences += increaseSequencesBy;
                            System.Array.resize(Bridge.ref(DG.Tweening.Core.TweenManager, "_pooledTweeners"), DG.Tweening.Core.TweenManager.maxTweeners, null, DG.Tweening.Tween);
                            break;
                    }

                    //            maxActive = Mathf.Max(maxTweeners, maxSequences);
                    DG.Tweening.Core.TweenManager.maxActive = DG.Tweening.Core.TweenManager.maxTweeners + DG.Tweening.Core.TweenManager.maxSequences;
                    System.Array.resize(Bridge.ref(DG.Tweening.Core.TweenManager, "_activeTweens"), DG.Tweening.Core.TweenManager.maxActive, null, DG.Tweening.Tween);
                    if (killAdd > 0) {
                        $t = DG.Tweening.Core.TweenManager._KillList;
                        $t.Capacity += killAdd;
                    }
                },
                /*DG.Tweening.Core.TweenManager.IncreaseCapacities:static end.*/

                /*DG.Tweening.Core.TweenManager.ManageOnRewindCallbackWhenAlreadyRewinded:static start.*/
                ManageOnRewindCallbackWhenAlreadyRewinded: function (t, isPlayBackwardsOrSmoothRewind) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenManager#ManageOnRewindCallbackWhenAlreadyRewinded", this ); }

                    if (Bridge.staticEquals(t.onRewind, null)) {
                        return;
                    }

                    if (isPlayBackwardsOrSmoothRewind) {
                        // PlayBackwards or SmoothRewind
                        if (DG.Tweening.DOTween.rewindCallbackMode === DG.Tweening.Core.Enums.RewindCallbackMode.FireAlways) {
                            t.onRewind();
                        }
                    } else {
                        // Rewind
                        if (DG.Tweening.DOTween.rewindCallbackMode !== DG.Tweening.Core.Enums.RewindCallbackMode.FireIfPositionChanged) {
                            t.onRewind();
                        }
                    }
                },
                /*DG.Tweening.Core.TweenManager.ManageOnRewindCallbackWhenAlreadyRewinded:static end.*/


            }
        }
    });
    /*DG.Tweening.Core.TweenManager end.*/

    /*DG.Tweening.Core.TweenManager+CapacityIncreaseMode start.*/
    Bridge.define("DG.Tweening.Core.TweenManager.CapacityIncreaseMode", {
        $kind: 1006,
        statics: {
            fields: {
                TweenersAndSequences: 0,
                TweenersOnly: 1,
                SequencesOnly: 2
            }
        }
    });
    /*DG.Tweening.Core.TweenManager+CapacityIncreaseMode end.*/

    /*DG.Tweening.Core.VisualManagerPreset start.*/
    Bridge.define("DG.Tweening.Core.VisualManagerPreset", {
        $kind: 6,
        statics: {
            fields: {
                Custom: 0,
                PoolingSystem: 1
            }
        }
    });
    /*DG.Tweening.Core.VisualManagerPreset end.*/

    /*DG.Tweening.Plugins.Core.ITweenPlugin start.*/
    Bridge.define("DG.Tweening.Plugins.Core.ITweenPlugin", {
        $kind: 3
    });
    /*DG.Tweening.Plugins.Core.ITweenPlugin end.*/

    /*DG.Tweening.DOCurve start.*/
    /**
     * Extra non-tweening-related curve methods
     *
     * @static
     * @abstract
     * @public
     * @class DG.Tweening.DOCurve
     */
    Bridge.define("DG.Tweening.DOCurve");
    /*DG.Tweening.DOCurve end.*/

    /*DG.Tweening.DOCurve+CubicBezier start.*/
    /**
     * Cubic bezier curve methods
     *
     * @static
     * @abstract
     * @public
     * @class DG.Tweening.DOCurve.CubicBezier
     */
    Bridge.define("DG.Tweening.DOCurve.CubicBezier", {
        $kind: 1002,
        statics: {
            methods: {
                /*DG.Tweening.DOCurve+CubicBezier.GetPointOnSegment:static start.*/
                /**
                 * Calculates a point along the given Cubic Bezier segment-curve.
                     <p />
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOCurve.CubicBezier
                 * @memberof DG.Tweening.DOCurve.CubicBezier
                 * @param   {UnityEngine.Vector3}    startPoint           Segment start point
                 * @param   {UnityEngine.Vector3}    startControlPoint    Start point's control point/handle
                 * @param   {UnityEngine.Vector3}    endPoint             Segment end point
                 * @param   {UnityEngine.Vector3}    endControlPoint      End point's control point/handle
                 * @param   {number}                 factor               0-1 percentage along which to retrieve point
                 * @return  {UnityEngine.Vector3}
                 */
                GetPointOnSegment: function (startPoint, startControlPoint, endPoint, endControlPoint, factor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOCurve.CubicBezier#GetPointOnSegment", this ); }

                    var u = 1 - factor;
                    var tt = factor * factor;
                    var uu = u * u;
                    var uuu = uu * u;
                    var ttt = tt * factor;
                    var p = startPoint.clone().scale( uuu ).add( startControlPoint.clone().scale( 3 * uu * factor ) ).add( endControlPoint.clone().scale( 3 * u * tt ) ).add( endPoint.clone().scale( ttt ) );
                    return p.$clone();
                },
                /*DG.Tweening.DOCurve+CubicBezier.GetPointOnSegment:static end.*/

                /*DG.Tweening.DOCurve+CubicBezier.GetSegmentPointCloud$1:static start.*/
                /**
                 * Returns an array containing a series of points along the given Cubic Bezier segment-curve.
                     <p />
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOCurve.CubicBezier
                 * @memberof DG.Tweening.DOCurve.CubicBezier
                 * @param   {UnityEngine.Vector3}            startPoint           Start point
                 * @param   {UnityEngine.Vector3}            startControlPoint    Start point's control point/handle
                 * @param   {UnityEngine.Vector3}            endPoint             End point
                 * @param   {UnityEngine.Vector3}            endControlPoint      End point's control point/handle
                 * @param   {number}                         resolution           Cloud resolution (min: 2)
                 * @return  {Array.<UnityEngine.Vector3>}
                 */
                GetSegmentPointCloud$1: function (startPoint, startControlPoint, endPoint, endControlPoint, resolution) {
if ( TRACE ) { TRACE( "DG.Tweening.DOCurve.CubicBezier#GetSegmentPointCloud$1", this ); }

                    if (resolution === void 0) { resolution = 10; }
                    if (resolution < 2) {
                        resolution = 2;
                    }

                    var pointCloud = System.Array.init(resolution, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                    var step = 1.0 / (resolution - 1);
                    for (var i = 0; i < resolution; ++i) {
                        pointCloud[i] = DG.Tweening.DOCurve.CubicBezier.GetPointOnSegment(startPoint.$clone(), startControlPoint.$clone(), endPoint.$clone(), endControlPoint.$clone(), step * i);
                    }

                    return pointCloud;
                },
                /*DG.Tweening.DOCurve+CubicBezier.GetSegmentPointCloud$1:static end.*/

                /*DG.Tweening.DOCurve+CubicBezier.GetSegmentPointCloud:static start.*/
                /**
                 * Calculates a series of points along the given Cubic Bezier segment-curve and adds them to the given list.
                     <p />
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOCurve.CubicBezier
                 * @memberof DG.Tweening.DOCurve.CubicBezier
                 * @param   {System.Collections.Generic.List$1}    addToList            
                 * @param   {UnityEngine.Vector3}                  startPoint           Start point
                 * @param   {UnityEngine.Vector3}                  startControlPoint    Start point's control point/handle
                 * @param   {UnityEngine.Vector3}                  endPoint             End point
                 * @param   {UnityEngine.Vector3}                  endControlPoint      End point's control point/handle
                 * @param   {number}                               resolution           Cloud resolution (min: 2)
                 * @return  {void}
                 */
                GetSegmentPointCloud: function (addToList, startPoint, startControlPoint, endPoint, endControlPoint, resolution) {
if ( TRACE ) { TRACE( "DG.Tweening.DOCurve.CubicBezier#GetSegmentPointCloud", this ); }

                    if (resolution === void 0) { resolution = 10; }
                    if (resolution < 2) {
                        resolution = 2;
                    }

                    var step = 1.0 / (resolution - 1);
                    for (var i = 0; i < resolution; ++i) {
                        addToList.add(DG.Tweening.DOCurve.CubicBezier.GetPointOnSegment(startPoint.$clone(), startControlPoint.$clone(), endPoint.$clone(), endControlPoint.$clone(), step * i));
                    }
                },
                /*DG.Tweening.DOCurve+CubicBezier.GetSegmentPointCloud:static end.*/


            }
        }
    });
    /*DG.Tweening.DOCurve+CubicBezier end.*/
    /**
     * @memberof DG.Tweening.Core
     * @callback DG.Tweening.Core.DOSetter
     * @param   {number}    pNewValue
     * @return  {void}
     */

    /**
     * @memberof DG.Tweening.Core
     * @callback DG.Tweening.Core.DOGetter
     * @return  {number}
     */

    /** @namespace System */

    /**
     * @memberof System
     * @callback System.Func
     * @param   {UnityEngine.LogType}    arg1    
     * @param   {System.Object}          arg2
     * @return  {boolean}
     */


    /*DG.Tweening.DOTween start.*/
    /**
     * Main DOTween class. Contains static methods to create and control tweens in a generic way
     *
     * @public
     * @class DG.Tweening.DOTween
     */
    Bridge.define("DG.Tweening.DOTween", {
        statics: {
            fields: {
                /**
                 * DOTween's version
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof DG.Tweening.DOTween
                 * @default "1.2.705"
                 * @type string
                 */
                Version: null,
                /**
                 * If TRUE (default) makes tweens slightly slower but safer, automatically taking care of a series of things
                     (like targets becoming null while a tween is playing).
                     <p>Default: TRUE</p>
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.DOTween
                 * @default true
                 * @type boolean
                 */
                useSafeMode: false,
                /**
                 * Log type when safe mode reports capturing an error and preventing it
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.DOTween
                 * @type DG.Tweening.Core.Enums.SafeModeLogBehaviour
                 */
                safeModeLogBehaviour: 0,
                /**
                 * Behaviour in case a tween nested inside a Sequence fails (and is caught by safe mode).
                     <p>Default: NestedTweenFailureBehaviour.TryToPreserveSequence</p>
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.DOTween
                 * @type DG.Tweening.Core.Enums.NestedTweenFailureBehaviour
                 */
                nestedTweenFailureBehaviour: 0,
                /**
                 * If TRUE you will get a DOTween report when exiting play mode (only in the Editor).
                     Useful to know how many max Tweeners and Sequences you reached and optimize your final project accordingly.
                     Beware, this will slightly slow down your tweens while inside Unity Editor.
                     <p>Default: FALSE</p>
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.DOTween
                 * @type boolean
                 */
                showUnityEditorReport: false,
                /**
                 * Global DOTween global timeScale (default: 1).
                     <p />
                     The final timeScale of a non-timeScaleIndependent tween is:
                     <p /><pre><code>Unity's Time.timeScale * DOTween.timeScale * tween.timeScale</code></pre><p />
                     while the final timeScale of a timeScaleIndependent tween is:
                     <p /><pre><code>DOTween.unscaledTimeScale * DOTween.timeScale * tween.timeScale</code></pre>
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.DOTween
                 * @default 1
                 * @type number
                 */
                timeScale: 0,
                /**
                 * DOTween timeScale applied only to timeScaleIndependent tweens (default: 1).
                     <p />
                     The final timeScale of a timeScaleIndependent tween is:
                     <p /><pre><code>DOTween.unscaledTimeScale * DOTween.timeScale * tween.timeScale</code></pre>
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.DOTween
                 * @default 1
                 * @type number
                 */
                unscaledTimeScale: 0,
                /**
                 * If TRUE, DOTween will use Time.smoothDeltaTime instead of Time.deltaTime for UpdateType.Normal and UpdateType.Late
                     tweens
                     (unless they're set as timeScaleIndependent, in which case a value between the last timestep
                     and {@link } will be used instead).
                     Setting this to TRUE will lead to smoother animations.
                     <p>Default: FALSE</p>
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.DOTween
                 * @type boolean
                 */
                useSmoothDeltaTime: false,
                /**
                 * If {@link } is TRUE, this indicates the max timeStep that an independent update call can
                     last.
                     Setting this to TRUE will lead to smoother animations.
                     <p>Default: FALSE</p>
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.DOTween
                 * @default 0.15
                 * @type number
                 */
                maxSmoothUnscaledTime: 0,
                rewindCallbackMode: 0,
                _logBehaviour: 0,
                /**
                 * Used to intercept DOTween's logs. If this method isn't NULL, DOTween will call it before writing a log via Unity's
                     own Debug log methods.
                     <p />
                     Return TRUE if you want DOTween to proceed with the log, FALSE otherwise.
                     <p />
                     This method must return a <pre><code>bool</code></pre> and accept two parameters:
                     <p />
                     - <pre><code>LogType</code></pre>: the type of Unity log that DOTween is trying to log
                     <p />
                     - <pre><code>object</code></pre>: the log message that DOTween wants to log
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.DOTween
                 * @type System.Func
                 */
                onWillLog: null,
                /**
                 * If TRUE draws path gizmos in Unity Editor (if the gizmos button is active).
                     Deactivate this if you want to avoid gizmos overhead while in Unity Editor
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.DOTween
                 * @default true
                 * @type boolean
                 */
                drawGizmos: false,
                /**
                 * If TRUE activates various debug options
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.DOTween
                 * @type boolean
                 */
                debugMode: false,
                _fooDebugStoreTargetId: false,
                /**
                 * Default updateType for new tweens.
                     <p>Default: UpdateType.Normal</p>
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.DOTween
                 * @type DG.Tweening.UpdateType
                 */
                defaultUpdateType: 0,
                /**
                 * Sets whether Unity's timeScale should be taken into account by default or not.
                     <p>Default: false</p>
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.DOTween
                 * @type boolean
                 */
                defaultTimeScaleIndependent: false,
                /**
                 * Default autoPlay behaviour for new tweens.
                     <p>Default: AutoPlay.All</p>
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.DOTween
                 * @type DG.Tweening.AutoPlay
                 */
                defaultAutoPlay: 0,
                /**
                 * Default autoKillOnComplete behaviour for new tweens.
                     <p>Default: TRUE</p>
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.DOTween
                 * @default true
                 * @type boolean
                 */
                defaultAutoKill: false,
                /**
                 * Default loopType applied to all new tweens.
                     <p>Default: LoopType.Restart</p>
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.DOTween
                 * @type DG.Tweening.LoopType
                 */
                defaultLoopType: 0,
                /**
                 * If TRUE all newly created tweens are set as recyclable, otherwise not.
                     <p>Default: FALSE</p>
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.DOTween
                 * @type boolean
                 */
                defaultRecyclable: false,
                /**
                 * Default ease applied to all new Tweeners (not to Sequences which always have Ease.Linear as default).
                     <p>Default: Ease.InOutQuad</p>
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.DOTween
                 * @type DG.Tweening.Ease
                 */
                defaultEaseType: 0,
                /**
                 * Default overshoot/amplitude used for eases
                     <p>Default: 1.70158f</p>
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.DOTween
                 * @default 1.70158
                 * @type number
                 */
                defaultEaseOvershootOrAmplitude: 0,
                /**
                 * Default period used for eases
                     <p>Default: 0</p>
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.DOTween
                 * @type number
                 */
                defaultEasePeriod: 0,
                /**
                 * Used internally. Assigned/removed by DOTweenComponent.Create/DestroyInstance
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.DOTween
                 * @type DG.Tweening.Core.DOTweenComponent
                 */
                instance: null,
                _foo_isQuitting: false,
                maxActiveTweenersReached: 0,
                maxActiveSequencesReached: 0,
                safeModeReport: null,
                GizmosDelegates: null,
                initialized: false,
                _isQuittingFrame: 0
            },
            props: {
                /**
                 * DOTween's log behaviour.
                     <p>Default: LogBehaviour.ErrorsOnly</p>
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.DOTween
                 * @function logBehaviour
                 * @type DG.Tweening.LogBehaviour
                 */
                logBehaviour: {
                    get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#logBehaviour#get", this ); }

                        return DG.Tweening.DOTween._logBehaviour;
                    },
                    set: function (value) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#logBehaviour#set", this ); }

                        DG.Tweening.DOTween._logBehaviour = value;
                        DG.Tweening.Core.Debugger.SetLogPriority(DG.Tweening.DOTween._logBehaviour);
                    }
                },
                /**
                 * Stores the target id so it can be used to give more info in case of safeMode error capturing.
                     Only active if both <pre><code>debugMode</code></pre> and <pre><code>useSafeMode</code></pre> are TRUE
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.DOTween
                 * @function debugStoreTargetId
                 * @type boolean
                 */
                debugStoreTargetId: {
                    get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#debugStoreTargetId#get", this ); }

                        return DG.Tweening.DOTween.debugMode && DG.Tweening.DOTween.useSafeMode && DG.Tweening.DOTween._fooDebugStoreTargetId;
                    },
                    set: function (value) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#debugStoreTargetId#set", this ); }

                        DG.Tweening.DOTween._fooDebugStoreTargetId = value;
                    }
                },
                isQuitting: {
                    get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#isQuitting#get", this ); }

                        if (!DG.Tweening.DOTween._foo_isQuitting) {
                            return false;
                        }

                        // if (Time.frameCount > 0 && _isQuittingFrame != Time.frameCount) { // Doesn't work with domain reload if checking with a > 0 frameCount
                        if (UnityEngine.Time.frameCount >= 0 && DG.Tweening.DOTween._isQuittingFrame !== UnityEngine.Time.frameCount) {
                            DG.Tweening.DOTween._foo_isQuitting = false;
                            return false;
                        }

                        return true;
                    },
                    set: function (value) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#isQuitting#set", this ); }

                        DG.Tweening.DOTween._foo_isQuitting = value;
                        if (value) {
                            DG.Tweening.DOTween._isQuittingFrame = UnityEngine.Time.frameCount;
                        }
                    }
                }
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#init", this ); }

                    this.safeModeReport = new DG.Tweening.Core.SafeModeReport();
                    this.Version = "1.2.705";
                    this.useSafeMode = true;
                    this.safeModeLogBehaviour = DG.Tweening.Core.Enums.SafeModeLogBehaviour.Warning;
                    this.nestedTweenFailureBehaviour = DG.Tweening.Core.Enums.NestedTweenFailureBehaviour.TryToPreserveSequence;
                    this.timeScale = 1;
                    this.unscaledTimeScale = 1;
                    this.maxSmoothUnscaledTime = 0.15;
                    this.rewindCallbackMode = DG.Tweening.Core.Enums.RewindCallbackMode.FireIfPositionChanged;
                    this._logBehaviour = DG.Tweening.LogBehaviour.ErrorsOnly;
                    this.drawGizmos = true;
                    this._fooDebugStoreTargetId = true;
                    this.defaultUpdateType = DG.Tweening.UpdateType.Normal;
                    this.defaultAutoPlay = DG.Tweening.AutoPlay.All;
                    this.defaultAutoKill = true;
                    this.defaultLoopType = DG.Tweening.LoopType.Restart;
                    this.defaultEaseType = DG.Tweening.Ease.OutQuad;
                    this.defaultEaseOvershootOrAmplitude = 1.70158;
                    this.GizmosDelegates = new (System.Collections.Generic.List$1(Function)).ctor();
                    this._isQuittingFrame = -1;
                }
            },
            methods: {
                /*DG.Tweening.DOTween.To$16:static start.*/
                To$16: function (getter, setter, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#To$16", this ); }

                    return DG.Tweening.DOTween.ApplyTo(DG.Tweening.Color2, DG.Tweening.Color2, DG.Tweening.Plugins.Options.ColorOptions, getter, setter, endValue.$clone(), duration);
                },
                /*DG.Tweening.DOTween.To$16:static end.*/

                /*DG.Tweening.DOTween.To$4:static start.*/
                /**
                 * Tweens a property or field to the given value using default plugins
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {DG.Tweening.Core.DOGetter}         getter      A getter for the field or property to tween.
                     <p>Example usage with lambda:</p><pre><code>()=&gt; myProperty</code></pre>
                 * @param   {DG.Tweening.Core.DOSetter}         setter      A setter for the field or property to tween
                     <p>Example usage with lambda:</p><pre><code>x=&gt; myProperty = x</code></pre>
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The tween's duration
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                To$4: function (getter, setter, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#To$4", this ); }

                    return DG.Tweening.DOTween.ApplyTo(System.Single, System.Single, DG.Tweening.Plugins.Options.FloatOptions, getter, setter, endValue, duration);
                },
                /*DG.Tweening.DOTween.To$4:static end.*/

                /*DG.Tweening.DOTween.To$1:static start.*/
                /**
                 * Tweens a property or field to the given value using default plugins
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {DG.Tweening.Core.DOGetter}         getter      A getter for the field or property to tween.
                     <p>Example usage with lambda:</p><pre><code>()=&gt; myProperty</code></pre>
                 * @param   {DG.Tweening.Core.DOSetter}         setter      A setter for the field or property to tween
                     <p>Example usage with lambda:</p><pre><code>x=&gt; myProperty = x</code></pre>
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The tween's duration
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                To$1: function (getter, setter, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#To$1", this ); }

                    return DG.Tweening.DOTween.ApplyTo(System.Double, System.Double, DG.Tweening.Plugins.Options.NoOptions, getter, setter, endValue, duration);
                },
                /*DG.Tweening.DOTween.To$1:static end.*/

                /*DG.Tweening.DOTween.To$2:static start.*/
                /**
                 * Tweens a property or field to the given value using default plugins
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {DG.Tweening.Core.DOGetter}         getter      A getter for the field or property to tween.
                     <p>Example usage with lambda:</p><pre><code>()=&gt; myProperty</code></pre>
                 * @param   {DG.Tweening.Core.DOSetter}         setter      A setter for the field or property to tween
                     <p>Example usage with lambda:</p><pre><code>x=&gt; myProperty = x</code></pre>
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The tween's duration
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                To$2: function (getter, setter, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#To$2", this ); }

                    return DG.Tweening.DOTween.ApplyTo(System.Int32, System.Int32, DG.Tweening.Plugins.Options.NoOptions, getter, setter, endValue, duration);
                },
                /*DG.Tweening.DOTween.To$2:static end.*/

                /*DG.Tweening.DOTween.To$6:static start.*/
                /**
                 * Tweens a property or field to the given value using default plugins
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {DG.Tweening.Core.DOGetter}         getter      A getter for the field or property to tween.
                     <p>Example usage with lambda:</p><pre><code>()=&gt; myProperty</code></pre>
                 * @param   {DG.Tweening.Core.DOSetter}         setter      A setter for the field or property to tween
                     <p>Example usage with lambda:</p><pre><code>x=&gt; myProperty = x</code></pre>
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The tween's duration
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                To$6: function (getter, setter, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#To$6", this ); }

                    return DG.Tweening.DOTween.ApplyTo(System.UInt32, System.UInt32, DG.Tweening.Plugins.Options.UintOptions, getter, setter, endValue, duration);
                },
                /*DG.Tweening.DOTween.To$6:static end.*/

                /*DG.Tweening.DOTween.To$3:static start.*/
                /**
                 * Tweens a property or field to the given value using default plugins
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {DG.Tweening.Core.DOGetter}         getter      A getter for the field or property to tween.
                     <p>Example usage with lambda:</p><pre><code>()=&gt; myProperty</code></pre>
                 * @param   {DG.Tweening.Core.DOSetter}         setter      A setter for the field or property to tween
                     <p>Example usage with lambda:</p><pre><code>x=&gt; myProperty = x</code></pre>
                 * @param   {System.Int64}                      endValue    The end value to reach
                 * @param   {number}                            duration    The tween's duration
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                To$3: function (getter, setter, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#To$3", this ); }

                    return DG.Tweening.DOTween.ApplyTo(System.Int64, System.Int64, DG.Tweening.Plugins.Options.NoOptions, getter, setter, endValue, duration);
                },
                /*DG.Tweening.DOTween.To$3:static end.*/

                /*DG.Tweening.DOTween.To$7:static start.*/
                /**
                 * Tweens a property or field to the given value using default plugins
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {DG.Tweening.Core.DOGetter}         getter      A getter for the field or property to tween.
                     <p>Example usage with lambda:</p><pre><code>()=&gt; myProperty</code></pre>
                 * @param   {DG.Tweening.Core.DOSetter}         setter      A setter for the field or property to tween
                     <p>Example usage with lambda:</p><pre><code>x=&gt; myProperty = x</code></pre>
                 * @param   {System.UInt64}                     endValue    The end value to reach
                 * @param   {number}                            duration    The tween's duration
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                To$7: function (getter, setter, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#To$7", this ); }

                    return DG.Tweening.DOTween.ApplyTo(System.UInt64, System.UInt64, DG.Tweening.Plugins.Options.NoOptions, getter, setter, endValue, duration);
                },
                /*DG.Tweening.DOTween.To$7:static end.*/

                /*DG.Tweening.DOTween.To$5:static start.*/
                /**
                 * Tweens a property or field to the given value using default plugins
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {DG.Tweening.Core.DOGetter}         getter      A getter for the field or property to tween.
                     <p>Example usage with lambda:</p><pre><code>()=&gt; myProperty</code></pre>
                 * @param   {DG.Tweening.Core.DOSetter}         setter      A setter for the field or property to tween
                     <p>Example usage with lambda:</p><pre><code>x=&gt; myProperty = x</code></pre>
                 * @param   {string}                            endValue    The end value to reach
                 * @param   {number}                            duration    The tween's duration
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                To$5: function (getter, setter, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#To$5", this ); }

                    return DG.Tweening.DOTween.ApplyTo(System.String, System.String, DG.Tweening.Plugins.Options.StringOptions, getter, setter, endValue, duration);
                },
                /*DG.Tweening.DOTween.To$5:static end.*/

                /*DG.Tweening.DOTween.To$11:static start.*/
                /**
                 * Tweens a property or field to the given value using default plugins
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {DG.Tweening.Core.DOGetter}         getter      A getter for the field or property to tween.
                     <p>Example usage with lambda:</p><pre><code>()=&gt; myProperty</code></pre>
                 * @param   {DG.Tweening.Core.DOSetter}         setter      A setter for the field or property to tween
                     <p>Example usage with lambda:</p><pre><code>x=&gt; myProperty = x</code></pre>
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The tween's duration
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                To$11: function (getter, setter, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#To$11", this ); }

                    return DG.Tweening.DOTween.ApplyTo(UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.Options.VectorOptions, getter, setter, endValue.$clone(), duration);
                },
                /*DG.Tweening.DOTween.To$11:static end.*/

                /*DG.Tweening.DOTween.To$12:static start.*/
                /**
                 * Tweens a property or field to the given value using default plugins
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {DG.Tweening.Core.DOGetter}         getter      A getter for the field or property to tween.
                     <p>Example usage with lambda:</p><pre><code>()=&gt; myProperty</code></pre>
                 * @param   {DG.Tweening.Core.DOSetter}         setter      A setter for the field or property to tween
                     <p>Example usage with lambda:</p><pre><code>x=&gt; myProperty = x</code></pre>
                 * @param   {UnityEngine.Vector3}               endValue    The end value to reach
                 * @param   {number}                            duration    The tween's duration
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                To$12: function (getter, setter, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#To$12", this ); }

                    return DG.Tweening.DOTween.ApplyTo(UnityEngine.Vector3, UnityEngine.Vector3, DG.Tweening.Plugins.Options.VectorOptions, getter, setter, endValue.$clone(), duration);
                },
                /*DG.Tweening.DOTween.To$12:static end.*/

                /*DG.Tweening.DOTween.To$13:static start.*/
                /**
                 * Tweens a property or field to the given value using default plugins
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {DG.Tweening.Core.DOGetter}         getter      A getter for the field or property to tween.
                     <p>Example usage with lambda:</p><pre><code>()=&gt; myProperty</code></pre>
                 * @param   {DG.Tweening.Core.DOSetter}         setter      A setter for the field or property to tween
                     <p>Example usage with lambda:</p><pre><code>x=&gt; myProperty = x</code></pre>
                 * @param   {UnityEngine.Vector4}               endValue    The end value to reach
                 * @param   {number}                            duration    The tween's duration
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                To$13: function (getter, setter, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#To$13", this ); }

                    return DG.Tweening.DOTween.ApplyTo(UnityEngine.Vector4, UnityEngine.Vector4, DG.Tweening.Plugins.Options.VectorOptions, getter, setter, endValue.$clone(), duration);
                },
                /*DG.Tweening.DOTween.To$13:static end.*/

                /*DG.Tweening.DOTween.To$9:static start.*/
                /**
                 * Tweens a property or field to the given value using default plugins
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {DG.Tweening.Core.DOGetter}         getter      A getter for the field or property to tween.
                     <p>Example usage with lambda:</p><pre><code>()=&gt; myProperty</code></pre>
                 * @param   {DG.Tweening.Core.DOSetter}         setter      A setter for the field or property to tween
                     <p>Example usage with lambda:</p><pre><code>x=&gt; myProperty = x</code></pre>
                 * @param   {UnityEngine.Vector3}               endValue    The end value to reach
                 * @param   {number}                            duration    The tween's duration
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                To$9: function (getter, setter, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#To$9", this ); }

                    return DG.Tweening.DOTween.ApplyTo(UnityEngine.Quaternion, UnityEngine.Vector3, DG.Tweening.Plugins.Options.QuaternionOptions, getter, setter, endValue.$clone(), duration);
                },
                /*DG.Tweening.DOTween.To$9:static end.*/

                /*DG.Tweening.DOTween.To$8:static start.*/
                /**
                 * Tweens a property or field to the given value using default plugins
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {DG.Tweening.Core.DOGetter}         getter      A getter for the field or property to tween.
                     <p>Example usage with lambda:</p><pre><code>()=&gt; myProperty</code></pre>
                 * @param   {DG.Tweening.Core.DOSetter}         setter      A setter for the field or property to tween
                     <p>Example usage with lambda:</p><pre><code>x=&gt; myProperty = x</code></pre>
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The tween's duration
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                To$8: function (getter, setter, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#To$8", this ); }

                    return DG.Tweening.DOTween.ApplyTo(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, getter, setter, endValue.$clone(), duration);
                },
                /*DG.Tweening.DOTween.To$8:static end.*/

                /*DG.Tweening.DOTween.To$10:static start.*/
                /**
                 * Tweens a property or field to the given value using default plugins
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {DG.Tweening.Core.DOGetter}         getter      A getter for the field or property to tween.
                     <p>Example usage with lambda:</p><pre><code>()=&gt; myProperty</code></pre>
                 * @param   {DG.Tweening.Core.DOSetter}         setter      A setter for the field or property to tween
                     <p>Example usage with lambda:</p><pre><code>x=&gt; myProperty = x</code></pre>
                 * @param   {UnityEngine.Rect}                  endValue    The end value to reach
                 * @param   {number}                            duration    The tween's duration
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                To$10: function (getter, setter, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#To$10", this ); }

                    return DG.Tweening.DOTween.ApplyTo(UnityEngine.Rect, UnityEngine.Rect, DG.Tweening.Plugins.Options.RectOptions, getter, setter, endValue.$clone(), duration);
                },
                /*DG.Tweening.DOTween.To$10:static end.*/

                /*DG.Tweening.DOTween.To$14:static start.*/
                /**
                 * Tweens a property or field to the given value using default plugins
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {DG.Tweening.Core.DOGetter}    getter      A getter for the field or property to tween.
                     <p>Example usage with lambda:</p><pre><code>()=&gt; myProperty</code></pre>
                 * @param   {DG.Tweening.Core.DOSetter}    setter      A setter for the field or property to tween
                     <p>Example usage with lambda:</p><pre><code>x=&gt; myProperty = x</code></pre>
                 * @param   {UnityEngine.RectOffset}       endValue    The end value to reach
                 * @param   {number}                       duration    The tween's duration
                 * @return  {DG.Tweening.Tweener}
                 */
                To$14: function (getter, setter, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#To$14", this ); }

                    return DG.Tweening.DOTween.ApplyTo(UnityEngine.RectOffset, UnityEngine.RectOffset, DG.Tweening.Plugins.Options.NoOptions, getter, setter, endValue, duration);
                },
                /*DG.Tweening.DOTween.To$14:static end.*/

                /*DG.Tweening.DOTween.To:static start.*/
                /**
                 * Tweens a property or field to the given value using a custom plugin
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {Function}                                     T1              
                 * @param   {Function}                                     T2              
                 * @param   {Function}                                     TPlugOptions    
                 * @param   {DG.Tweening.Plugins.Core.ABSTweenPlugin$3}    plugin          The plugin to use. Each custom plugin implements a static <pre><code>Get()</code></pre> method
                     you'll need to call to assign the correct plugin in the correct way, like this:
                     <p><pre><code>CustomPlugin.Get()</code></pre></p>
                 * @param   {DG.Tweening.Core.DOGetter}                    getter          A getter for the field or property to tween.
                     <p>Example usage with lambda:</p><pre><code>()=&gt; myProperty</code></pre>
                 * @param   {DG.Tweening.Core.DOSetter}                    setter          A setter for the field or property to tween
                     <p>Example usage with lambda:</p><pre><code>x=&gt; myProperty = x</code></pre>
                 * @param   {T2}                                           endValue        The end value to reach
                 * @param   {number}                                       duration        The tween's duration
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                To: function (T1, T2, TPlugOptions, plugin, getter, setter, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#To", this ); }

                    return DG.Tweening.DOTween.ApplyTo(T1, T2, TPlugOptions, getter, setter, Bridge.rValue(endValue), duration, plugin);
                },
                /*DG.Tweening.DOTween.To:static end.*/

                /*DG.Tweening.DOTween.To$15:static start.*/
                /**
                 * Tweens a virtual property from the given start to the given end value
                     and implements a setter that allows to use that value with an external method or a lambda
                     <p>Example:</p><pre><code>To(MyMethod, 0, 12, 0.5f);</code></pre><p>Where MyMethod is a function that accepts a float parameter (which will be the result of the virtual tween)</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {DG.Tweening.Core.DOSetter}    setter        The action to perform with the tweened value
                 * @param   {number}                       startValue    The value to start from
                 * @param   {number}                       endValue      The end value to reach
                 * @param   {number}                       duration      The duration of the virtual tween
                 * @return  {DG.Tweening.Tweener}
                 */
                To$15: function (setter, startValue, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#To$15", this ); }

                    var v = startValue;
                    return DG.Tweening.Core.Extensions.NoFrom(System.Single, System.Single, DG.Tweening.Plugins.Options.FloatOptions, DG.Tweening.DOTween.To$4(function () {
                        return v;
                    }, function (x) {
                        v = x;
                        setter(v);
                    }, endValue, duration));
                },
                /*DG.Tweening.DOTween.To$15:static end.*/

                /*DG.Tweening.DOTween.InitCheck:static start.*/
                InitCheck: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#InitCheck", this ); }

                    if (DG.Tweening.DOTween.initialized || !UnityEngine.Application.isPlaying || DG.Tweening.DOTween.isQuitting) {
                        return;
                    }

                    DG.Tweening.DOTween.AutoInit();
                },
                /*DG.Tweening.DOTween.InitCheck:static end.*/

                /*DG.Tweening.DOTween.ApplyTo:static start.*/
                ApplyTo: function (T1, T2, TPlugOptions, getter, setter, endValue, duration, plugin) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#ApplyTo", this ); }

                    if (plugin === void 0) { plugin = null; }
                    DG.Tweening.DOTween.InitCheck();
                    var tweener = DG.Tweening.Core.TweenManager.GetTweener(T1, T2, TPlugOptions);
                    var setupSuccessful = DG.Tweening.Tweener.Setup(T1, T2, TPlugOptions, tweener, getter, setter, Bridge.rValue(endValue), duration, plugin);
                    if (!setupSuccessful) {
                        DG.Tweening.Core.TweenManager.Despawn(tweener);
                        return null;
                    }

                    return tweener;
                },
                /*DG.Tweening.DOTween.ApplyTo:static end.*/

                /*DG.Tweening.DOTween.Init:static start.*/
                /**
                 * Must be called once, before the first ever DOTween call/reference,
                     otherwise it will be called automatically and will use default options.
                     Calling it a second time won't have any effect.
                     <p>You can chain <pre><code>SetCapacity</code></pre> to this method, to directly set the max starting size of Tweeners and
                         Sequences:</p><pre><code>DOTween.Init(false, false, LogBehaviour.Default).SetCapacity(100, 20);</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {?boolean}                     recycleAllByDefault    If TRUE all new tweens will be set for recycling, meaning that when killed,
                     instead of being destroyed, they will be put in a pool and reused instead of creating new tweens. This option
                     allows you to avoid
                     GC allocations by reusing tweens, but you will have to take care of tween references, since they might result
                     active
                     even if they were killed (since they might have been respawned and are now being used for other tweens).
                     <p>If you want to automatically set your tween references to NULL when a tween is killed
                         you can use the OnKill callback like this:</p><pre><code>.OnKill(()=&gt; myTweenReference = null)</code></pre><p>You can change this setting at any time by changing the static {@link }
                         property,
                         or you can set the recycling behaviour for each tween separately, using:</p><p><pre><code>SetRecyclable(bool recyclable)</code></pre></p><p>Default: FALSE</p>
                 * @param   {?boolean}                     useSafeMode            If TRUE makes tweens slightly slower but safer, automatically taking care of a series of things
                     (like targets becoming null while a tween is playing).
                     You can change this setting at any time by changing the static {@link } property.
                     <p>Default: FALSE</p>
                 * @param   {?DG.Tweening.LogBehaviour}    logBehaviour           Type of logging to use.
                     You can change this setting at any time by changing the static {@link } property.
                     <p>Default: ErrorsOnly</p>
                 * @return  {DG.Tweening.IDOTweenInit}
                 */
                Init: function (recycleAllByDefault, useSafeMode, logBehaviour) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#Init", this ); }

                    if (recycleAllByDefault === void 0) { recycleAllByDefault = null; }
                    if (useSafeMode === void 0) { useSafeMode = null; }
                    if (logBehaviour === void 0) { logBehaviour = null; }
                    if (DG.Tweening.DOTween.initialized) {
                        return DG.Tweening.DOTween.instance;
                    }

                    if (!UnityEngine.Application.isPlaying || DG.Tweening.DOTween.isQuitting) {
                        return null;
                    }

                    var settings = Bridge.as(UnityEngine.Resources.Load$1(DG.Tweening.Core.DOTweenSettings.AssetName), DG.Tweening.Core.DOTweenSettings);
                    return DG.Tweening.DOTween.Init$1(settings, recycleAllByDefault, useSafeMode, logBehaviour);
                },
                /*DG.Tweening.DOTween.Init:static end.*/

                /*DG.Tweening.DOTween.Init$1:static start.*/
                Init$1: function (settings, recycleAllByDefault, useSafeMode, logBehaviour) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#Init$1", this ); }

                    DG.Tweening.DOTween.initialized = true;
                    // Options
                    if (recycleAllByDefault != null) {
                        DG.Tweening.DOTween.defaultRecyclable = System.Nullable.getValue(recycleAllByDefault);
                    }

                    if (useSafeMode != null) {
                        DG.Tweening.DOTween.useSafeMode = System.Nullable.getValue(useSafeMode);
                    }

                    if (logBehaviour != null) {
                        DG.Tweening.DOTween.logBehaviour = System.Nullable.getValue(logBehaviour);
                    }

                    // Gameobject - also assign instance
                    DG.Tweening.Core.DOTweenComponent.Create();
                    // Assign settings
                    if (settings != null) {
                        if (useSafeMode == null) {
                            DG.Tweening.DOTween.useSafeMode = settings.useSafeMode;
                        }

                        if (logBehaviour == null) {
                            DG.Tweening.DOTween.logBehaviour = settings.logBehaviour;
                        }

                        if (recycleAllByDefault == null) {
                            DG.Tweening.DOTween.defaultRecyclable = settings.defaultRecyclable;
                        }

                        DG.Tweening.DOTween.safeModeLogBehaviour = settings.safeModeOptions.logBehaviour;
                        DG.Tweening.DOTween.nestedTweenFailureBehaviour = settings.safeModeOptions.nestedTweenFailureBehaviour;
                        DG.Tweening.DOTween.timeScale = settings.timeScale;
                        DG.Tweening.DOTween.unscaledTimeScale = settings.unscaledTimeScale;
                        DG.Tweening.DOTween.useSmoothDeltaTime = settings.useSmoothDeltaTime;
                        DG.Tweening.DOTween.maxSmoothUnscaledTime = settings.maxSmoothUnscaledTime;
                        DG.Tweening.DOTween.rewindCallbackMode = settings.rewindCallbackMode;
                        DG.Tweening.DOTween.defaultRecyclable = recycleAllByDefault == null ? settings.defaultRecyclable : System.Nullable.getValue(recycleAllByDefault);
                        DG.Tweening.DOTween.showUnityEditorReport = settings.showUnityEditorReport;
                        DG.Tweening.DOTween.drawGizmos = settings.drawGizmos;
                        DG.Tweening.DOTween.defaultAutoPlay = settings.defaultAutoPlay;
                        DG.Tweening.DOTween.defaultUpdateType = settings.defaultUpdateType;
                        DG.Tweening.DOTween.defaultTimeScaleIndependent = settings.defaultTimeScaleIndependent;
                        DG.Tweening.DOTween.defaultEaseType = settings.defaultEaseType;
                        DG.Tweening.DOTween.defaultEaseOvershootOrAmplitude = settings.defaultEaseOvershootOrAmplitude;
                        DG.Tweening.DOTween.defaultEasePeriod = settings.defaultEasePeriod;
                        DG.Tweening.DOTween.defaultAutoKill = settings.defaultAutoKill;
                        DG.Tweening.DOTween.defaultLoopType = settings.defaultLoopType;
                        // Debug options
                        DG.Tweening.DOTween.debugMode = settings.debugMode;
                        DG.Tweening.DOTween.debugStoreTargetId = settings.debugStoreTargetId;
                    }

                    // Log
                    if (DG.Tweening.Core.Debugger.logPriority >= 2) {
                        DG.Tweening.Core.Debugger.Log("DOTween initialization (useSafeMode: " + System.Boolean.toString(DG.Tweening.DOTween.useSafeMode) + ", recycling: " + ((DG.Tweening.DOTween.defaultRecyclable ? "ON" : "OFF") || "") + ", logBehaviour: " + System.Enum.toString(DG.Tweening.LogBehaviour, DG.Tweening.DOTween.logBehaviour) + ")");
                    }

                    return DG.Tweening.DOTween.instance;
                },
                /*DG.Tweening.DOTween.Init$1:static end.*/

                /*DG.Tweening.DOTween.AutoInit:static start.*/
                AutoInit: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#AutoInit", this ); }

                    if (!UnityEngine.Application.isPlaying || DG.Tweening.DOTween.isQuitting) {
                        return;
                    }

                    var settings = Bridge.as(UnityEngine.Resources.Load$1(DG.Tweening.Core.DOTweenSettings.AssetName), DG.Tweening.Core.DOTweenSettings);
                    DG.Tweening.DOTween.Init$1(settings, null, null, null);
                },
                /*DG.Tweening.DOTween.AutoInit:static end.*/

                /*DG.Tweening.DOTween.SetTweensCapacity:static start.*/
                /**
                 * Directly sets the current max capacity of Tweeners and Sequences
                     (meaning how many Tweeners and Sequences can be running at the same time),
                     so that DOTween doesn't need to automatically increase them in case the max is reached
                     (which might lead to hiccups when that happens).
                     Sequences capacity must be less or equal to Tweeners capacity
                     (if you pass a low Tweener capacity it will be automatically increased to match the Sequence's).
                     Beware: use this method only when there are no tweens running.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {number}    tweenersCapacity     Max Tweeners capacity.
                     Default: 200
                 * @param   {number}    sequencesCapacity    Max Sequences capacity.
                     Default: 50
                 * @return  {void}
                 */
                SetTweensCapacity: function (tweenersCapacity, sequencesCapacity) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#SetTweensCapacity", this ); }

                    DG.Tweening.Core.TweenManager.SetCapacities(tweenersCapacity, sequencesCapacity);
                },
                /*DG.Tweening.DOTween.SetTweensCapacity:static end.*/

                /*DG.Tweening.DOTween.Clear:static start.*/
                /**
                 * Kills all tweens, clears all cached tween pools and plugins and resets the max Tweeners/Sequences capacities to the
                     default values.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {boolean}    destroy    If TRUE also destroys DOTween's gameObject and resets its initializiation, default settings and everything else
                     (so that next time you use it it will need to be re-initialized)
                 * @return  {void}
                 */
                Clear: function (destroy) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#Clear", this ); }

                    if (destroy === void 0) { destroy = false; }
                    DG.Tweening.DOTween.Clear$1(destroy, false);
                },
                /*DG.Tweening.DOTween.Clear:static end.*/

                /*DG.Tweening.DOTween.Clear$1:static start.*/
                Clear$1: function (destroy, isApplicationQuitting) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#Clear$1", this ); }

                    DG.Tweening.Core.TweenManager.PurgeAll(isApplicationQuitting);
                    DG.Tweening.Plugins.Core.PluginsManager.PurgeAll();
                    if (!destroy) {
                        return;
                    }

                    DG.Tweening.DOTween.initialized = false;
                    DG.Tweening.DOTween.useSafeMode = false;
                    DG.Tweening.DOTween.safeModeLogBehaviour = DG.Tweening.Core.Enums.SafeModeLogBehaviour.Warning;
                    DG.Tweening.DOTween.nestedTweenFailureBehaviour = DG.Tweening.Core.Enums.NestedTweenFailureBehaviour.TryToPreserveSequence;
                    DG.Tweening.DOTween.showUnityEditorReport = false;
                    DG.Tweening.DOTween.drawGizmos = true;
                    DG.Tweening.DOTween.timeScale = 1;
                    DG.Tweening.DOTween.unscaledTimeScale = 1;
                    DG.Tweening.DOTween.useSmoothDeltaTime = false;
                    DG.Tweening.DOTween.maxSmoothUnscaledTime = 0.15;
                    DG.Tweening.DOTween.rewindCallbackMode = DG.Tweening.Core.Enums.RewindCallbackMode.FireIfPositionChanged;
                    DG.Tweening.DOTween.logBehaviour = DG.Tweening.LogBehaviour.ErrorsOnly;
                    DG.Tweening.DOTween.onWillLog = null;
                    DG.Tweening.DOTween.defaultEaseType = DG.Tweening.Ease.OutQuad;
                    DG.Tweening.DOTween.defaultEaseOvershootOrAmplitude = 1.70158;
                    DG.Tweening.DOTween.defaultEasePeriod = 0;
                    DG.Tweening.DOTween.defaultUpdateType = DG.Tweening.UpdateType.Normal;
                    DG.Tweening.DOTween.defaultTimeScaleIndependent = false;
                    DG.Tweening.DOTween.defaultAutoPlay = DG.Tweening.AutoPlay.All;
                    DG.Tweening.DOTween.defaultLoopType = DG.Tweening.LoopType.Restart;
                    DG.Tweening.DOTween.defaultAutoKill = true;
                    DG.Tweening.DOTween.defaultRecyclable = false;
                    DG.Tweening.DOTween.maxActiveTweenersReached = (DG.Tweening.DOTween.maxActiveSequencesReached = 0, 0);
                    DG.Tweening.DOTween.GizmosDelegates.clear();

                    DG.Tweening.Core.DOTweenComponent.DestroyInstance();
                },
                /*DG.Tweening.DOTween.Clear$1:static end.*/

                /*DG.Tweening.DOTween.ClearCachedTweens:static start.*/
                /**
                 * Clears all cached tween pools.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @return  {void}
                 */
                ClearCachedTweens: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#ClearCachedTweens", this ); }

                    DG.Tweening.Core.TweenManager.PurgePools();
                },
                /*DG.Tweening.DOTween.ClearCachedTweens:static end.*/

                /*DG.Tweening.DOTween.Validate:static start.*/
                /**
                 * Checks all active tweens to find and remove eventually invalid ones (usually because their targets became NULL)
                     and returns the total number of invalid tweens found and removed.
                     IMPORTANT: this will cause an error on UWP platform, so don't use it there
                     BEWARE: this is a slightly expensive operation so use it with care
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @return  {number}
                 */
                Validate: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#Validate", this ); }

                    return DG.Tweening.Core.TweenManager.Validate();
                },
                /*DG.Tweening.DOTween.Validate:static end.*/

                /*DG.Tweening.DOTween.ManualUpdate:static start.*/
                /**
                 * Updates all tweens that are set to {@link }.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {number}    deltaTime            Manual deltaTime
                 * @param   {number}    unscaledDeltaTime    Unscaled delta time (used with tweens set as timeScaleIndependent)
                 * @return  {void}
                 */
                ManualUpdate: function (deltaTime, unscaledDeltaTime) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#ManualUpdate", this ); }

                    DG.Tweening.DOTween.InitCheck();
                    //            instance.ManualUpdate(deltaTime, unscaledDeltaTime);
                    if (DG.Tweening.Core.TweenManager.hasActiveManualTweens) {
                        DG.Tweening.Core.TweenManager.Update$1(DG.Tweening.UpdateType.Manual, deltaTime * DG.Tweening.DOTween.timeScale, unscaledDeltaTime * DG.Tweening.DOTween.unscaledTimeScale * DG.Tweening.DOTween.timeScale);
                    }
                },
                /*DG.Tweening.DOTween.ManualUpdate:static end.*/

                /*DG.Tweening.DOTween.ToAxis:static start.*/
                /**
                 * Tweens only one axis of a Vector3 to the given value using default plugins.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {DG.Tweening.Core.DOGetter}         getter            A getter for the field or property to tween.
                     <p>Example usage with lambda:</p><pre><code>()=&gt; myProperty</code></pre>
                 * @param   {DG.Tweening.Core.DOSetter}         setter            A setter for the field or property to tween
                     <p>Example usage with lambda:</p><pre><code>x=&gt; myProperty = x</code></pre>
                 * @param   {number}                            endValue          The end value to reach
                 * @param   {number}                            duration          The tween's duration
                 * @param   {DG.Tweening.AxisConstraint}        axisConstraint    The axis to tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                ToAxis: function (getter, setter, endValue, duration, axisConstraint) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#ToAxis", this ); }

                    if (axisConstraint === void 0) { axisConstraint = 2; }
                    var t = DG.Tweening.DOTween.ApplyTo(UnityEngine.Vector3, UnityEngine.Vector3, DG.Tweening.Plugins.Options.VectorOptions, getter, setter, new pc.Vec3( endValue, endValue, endValue ), duration);
                    t.plugOptions.axisConstraint = axisConstraint;
                    return t;
                },
                /*DG.Tweening.DOTween.ToAxis:static end.*/

                /*DG.Tweening.DOTween.ToAlpha:static start.*/
                /**
                 * Tweens only the alpha of a Color to the given value using default plugins
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {DG.Tweening.Core.DOGetter}         getter      A getter for the field or property to tween.
                     <p>Example usage with lambda:</p><pre><code>()=&gt; myProperty</code></pre>
                 * @param   {DG.Tweening.Core.DOSetter}         setter      A setter for the field or property to tween
                     <p>Example usage with lambda:</p><pre><code>x=&gt; myProperty = x</code></pre>
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The tween's duration
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                ToAlpha: function (getter, setter, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#ToAlpha", this ); }

                    var t = DG.Tweening.DOTween.ApplyTo(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, getter, setter, new pc.Color( 0, 0, 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetOptions$4(t, true);
                    return t;
                },
                /*DG.Tweening.DOTween.ToAlpha:static end.*/

                /*DG.Tweening.DOTween.Punch:static start.*/
                /**
                 * Punches a Vector3 towards the given direction and then back to the starting one
                     as if it was connected to the starting position via an elastic.
                     <p>This tween type generates some GC allocations at startup</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {DG.Tweening.Core.DOGetter}         getter        A getter for the field or property to tween.
                     <p>Example usage with lambda:</p><pre><code>()=&gt; myProperty</code></pre>
                 * @param   {DG.Tweening.Core.DOSetter}         setter        A setter for the field or property to tween
                     <p>Example usage with lambda:</p><pre><code>x=&gt; myProperty = x</code></pre>
                 * @param   {UnityEngine.Vector3}               direction     The direction and strength of the punch
                 * @param   {number}                            duration      The duration of the tween
                 * @param   {number}                            vibrato       Indicates how much will the punch vibrate
                 * @param   {number}                            elasticity    Represents how much (0 to 1) the vector will go beyond the starting position when bouncing backwards.
                     1 creates a full oscillation between the direction and the opposite decaying direction,
                     while 0 oscillates only between the starting position and the decaying direction
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                Punch: function (getter, setter, direction, duration, vibrato, elasticity) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#Punch", this ); }

                    if (vibrato === void 0) { vibrato = 10; }
                    if (elasticity === void 0) { elasticity = 1.0; }
                    if (elasticity > 1) {
                        elasticity = 1;
                    } else if (elasticity < 0) {
                        elasticity = 0;
                    }

                    var strength = direction.length();
                    var totIterations = Math.floor(vibrato * duration);
                    if (totIterations < 2) {
                        totIterations = 2;
                    }

                    var decayXTween = strength / totIterations;
                    // Calculate and store the duration of each tween
                    var tDurations = System.Array.init(totIterations, 0, System.Single);
                    var sum = 0;
                    for (var i = 0; i < totIterations; ++i) {
                        var iterationPerc = (i + 1) / totIterations;
                        var tDuration = duration * iterationPerc;
                        sum += tDuration;
                        tDurations[i] = tDuration;
                    }

                    var tDurationMultiplier = duration / sum; // Multiplier that allows the sum of tDurations to equal the set duration
                    for (var i1 = 0; i1 < totIterations; ++i1) {
                        tDurations[i1] = tDurations[i1] * tDurationMultiplier;
                    }

                    // Create the tween
                    var tos = System.Array.init(totIterations, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                    for (var i2 = 0; i2 < totIterations; ++i2) {
                        if (i2 < totIterations - 1) {
                            if (i2 === 0) {
                                tos[i2] = direction.$clone();
                            } else if (i2 % 2 !== 0) {
                                tos[i2] = pc.Vec3.clampMagnitude( direction, strength * elasticity ).scale( -1 );
                            } else {
                                tos[i2] = pc.Vec3.clampMagnitude( direction, strength );
                            }

                            strength -= decayXTween;
                        } else {
                            tos[i2] = pc.Vec3.ZERO.clone();
                        }
                    }

                    return DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.Core.Extensions.NoFrom(UnityEngine.Vector3, System.Array.type(UnityEngine.Vector3), DG.Tweening.Plugins.Options.Vector3ArrayOptions, DG.Tweening.DOTween.ToArray(getter, setter, tos, tDurations)), DG.Tweening.Core.Enums.SpecialStartupMode.SetPunch);
                },
                /*DG.Tweening.DOTween.Punch:static end.*/

                /*DG.Tweening.DOTween.Shake:static start.*/
                /**
                 * Shakes a Vector3 with the given values.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {DG.Tweening.Core.DOGetter}          getter            A getter for the field or property to tween.
                     <p>Example usage with lambda:</p><pre><code>()=&gt; myProperty</code></pre>
                 * @param   {DG.Tweening.Core.DOSetter}          setter            A setter for the field or property to tween
                     <p>Example usage with lambda:</p><pre><code>x=&gt; myProperty = x</code></pre>
                 * @param   {number}                             duration          The duration of the tween
                 * @param   {number}                             strength          The shake strength
                 * @param   {number}                             vibrato           Indicates how much will the shake vibrate
                 * @param   {number}                             randomness        Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware).
                     Setting it to 0 will shake along a single direction and behave like a random punch.
                 * @param   {boolean}                            ignoreZAxis       If TRUE only shakes on the X Y axis (looks better with things like cameras).
                 * @param   {boolean}                            fadeOut           If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it
                     will not
                 * @param   {DG.Tweening.ShakeRandomnessMode}    randomnessMode    Randomness mode
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                Shake: function (getter, setter, duration, strength, vibrato, randomness, ignoreZAxis, fadeOut, randomnessMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#Shake", this ); }

                    if (strength === void 0) { strength = 3.0; }
                    if (vibrato === void 0) { vibrato = 10; }
                    if (randomness === void 0) { randomness = 90.0; }
                    if (ignoreZAxis === void 0) { ignoreZAxis = true; }
                    if (fadeOut === void 0) { fadeOut = true; }
                    if (randomnessMode === void 0) { randomnessMode = 0; }
                    return DG.Tweening.DOTween.Shake$2(getter, setter, duration, new pc.Vec3( strength, strength, strength ), vibrato, randomness, ignoreZAxis, false, fadeOut, randomnessMode);
                },
                /*DG.Tweening.DOTween.Shake:static end.*/

                /*DG.Tweening.DOTween.Shake$1:static start.*/
                /**
                 * Shakes a Vector3 with the given values.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {DG.Tweening.Core.DOGetter}          getter            A getter for the field or property to tween.
                     <p>Example usage with lambda:</p><pre><code>()=&gt; myProperty</code></pre>
                 * @param   {DG.Tweening.Core.DOSetter}          setter            A setter for the field or property to tween
                     <p>Example usage with lambda:</p><pre><code>x=&gt; myProperty = x</code></pre>
                 * @param   {number}                             duration          The duration of the tween
                 * @param   {UnityEngine.Vector3}                strength          The shake strength on each axis
                 * @param   {number}                             vibrato           Indicates how much will the shake vibrate
                 * @param   {number}                             randomness        Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware).
                     Setting it to 0 will shake along a single direction and behave like a random punch.
                 * @param   {boolean}                            fadeOut           If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it
                     will not
                 * @param   {DG.Tweening.ShakeRandomnessMode}    randomnessMode    Randomness mode
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                Shake$1: function (getter, setter, duration, strength, vibrato, randomness, fadeOut, randomnessMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#Shake$1", this ); }

                    if (vibrato === void 0) { vibrato = 10; }
                    if (randomness === void 0) { randomness = 90.0; }
                    if (fadeOut === void 0) { fadeOut = true; }
                    if (randomnessMode === void 0) { randomnessMode = 0; }
                    return DG.Tweening.DOTween.Shake$2(getter, setter, duration, strength.$clone(), vibrato, randomness, false, true, fadeOut, randomnessMode);
                },
                /*DG.Tweening.DOTween.Shake$1:static end.*/

                /*DG.Tweening.DOTween.Shake$2:static start.*/
                Shake$2: function (getter, setter, duration, strength, vibrato, randomness, ignoreZAxis, vectorBased, fadeOut, randomnessMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#Shake$2", this ); }

                    var shakeMagnitude = vectorBased ? strength.length() : strength.x;
                    var totIterations = Math.floor(vibrato * duration);
                    if (totIterations < 2) {
                        totIterations = 2;
                    }

                    var decayXTween = shakeMagnitude / totIterations;
                    // Calculate and store the duration of each tween
                    var tDurations = System.Array.init(totIterations, 0, System.Single);
                    var sum = 0;
                    for (var i = 0; i < totIterations; ++i) {
                        var iterationPerc = (i + 1) / totIterations;
                        var tDuration = fadeOut ? duration * iterationPerc : duration / totIterations;
                        sum += tDuration;
                        tDurations[i] = tDuration;
                    }

                    var tDurationMultiplier = duration / sum; // Multiplier that allows the sum of tDurations to equal the set duration
                    for (var i1 = 0; i1 < totIterations; ++i1) {
                        tDurations[i1] = tDurations[i1] * tDurationMultiplier;
                    }

                    // Create the tween
                    var ang = UnityEngine.Random.Range$1(0.0, 360.0);
                    var tos = System.Array.init(totIterations, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                    for (var i2 = 0; i2 < totIterations; ++i2) {
                        if (i2 < totIterations - 1) {
                            var rndQuaternion = pc.Quat.IDENTITY.clone();
                            switch (randomnessMode) {
                                case DG.Tweening.ShakeRandomnessMode.Harmonic: 
                                    if (i2 > 0) {
                                        ang = ang - 180 + UnityEngine.Random.Range$1(0, randomness);
                                    }
                                    if (vectorBased || !ignoreZAxis) {
                                        rndQuaternion = new pc.Quat().setFromAxisAngle( pc.Vec3.UP.clone(), UnityEngine.Random.Range$1(0, randomness) );
                                    }
                                    break;
                                default:  // Full
                                    if (i2 > 0) {
                                        ang = ang - 180 + UnityEngine.Random.Range$1(-randomness, randomness);
                                    }
                                    if (vectorBased || !ignoreZAxis) {
                                        rndQuaternion = new pc.Quat().setFromAxisAngle( pc.Vec3.UP.clone(), UnityEngine.Random.Range$1(-randomness, randomness) );
                                    }
                                    break;
                            }

                            if (vectorBased) {
                                var to = rndQuaternion.transformVector( DG.Tweening.Core.DOTweenUtils.Vector3FromAngle(ang, shakeMagnitude) );
                                to.x = pc.Vec3.clampMagnitude( to, strength.x ).x;
                                to.y = pc.Vec3.clampMagnitude( to, strength.y ).y;
                                to.z = pc.Vec3.clampMagnitude( to, strength.z ).z;
                                to = to.clone().normalize().$clone().clone().scale( shakeMagnitude ); // Make sure first shake uses max magnitude
                                tos[i2] = to.$clone();
                                if (fadeOut) {
                                    shakeMagnitude -= decayXTween;
                                }

                                strength = pc.Vec3.clampMagnitude( strength, shakeMagnitude );
                            } else {
                                if (ignoreZAxis) {
                                    tos[i2] = DG.Tweening.Core.DOTweenUtils.Vector3FromAngle(ang, shakeMagnitude);
                                } else {
                                    tos[i2] = rndQuaternion.transformVector( DG.Tweening.Core.DOTweenUtils.Vector3FromAngle(ang, shakeMagnitude) );
                                }

                                if (fadeOut) {
                                    shakeMagnitude -= decayXTween;
                                }
                            }
                        } else {
                            tos[i2] = pc.Vec3.ZERO.clone();
                        }
                    }

                    return DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.Core.Extensions.NoFrom(UnityEngine.Vector3, System.Array.type(UnityEngine.Vector3), DG.Tweening.Plugins.Options.Vector3ArrayOptions, DG.Tweening.DOTween.ToArray(getter, setter, tos, tDurations)), DG.Tweening.Core.Enums.SpecialStartupMode.SetShake);
                },
                /*DG.Tweening.DOTween.Shake$2:static end.*/

                /*DG.Tweening.DOTween.ToArray:static start.*/
                /**
                 * Tweens a property or field to the given values using default plugins.
                     Ease is applied between each segment and not as a whole.
                     <p>This tween type generates some GC allocations at startup</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {DG.Tweening.Core.DOGetter}         getter       A getter for the field or property to tween.
                     <p>Example usage with lambda:</p><pre><code>()=&gt; myProperty</code></pre>
                 * @param   {DG.Tweening.Core.DOSetter}         setter       A setter for the field or property to tween
                     <p>Example usage with lambda:</p><pre><code>x=&gt; myProperty = x</code></pre>
                 * @param   {Array.<UnityEngine.Vector3>}       endValues    The end values to reach for each segment. This array must have the same length as
                     <pre><code>durations</code></pre>
                 * @param   {Array.<number>}                    durations    The duration of each segment. This array must have the same length as <pre><code>endValues</code></pre>
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                ToArray: function (getter, setter, endValues, durations) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#ToArray", this ); }

                    var len = durations.length;
                    if (len !== endValues.length) {
                        DG.Tweening.Core.Debugger.LogError("To Vector3 array tween: endValues and durations arrays must have the same length");
                        return null;
                    }

                    // Clone the arrays
                    var endValuesClone = System.Array.init(len, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                    var durationsClone = System.Array.init(len, 0, System.Single);
                    for (var i = 0; i < len; i++) {
                        endValuesClone[i] = endValues[i].$clone();
                        durationsClone[i] = durations[i];
                    }

                    var totDuration = 0;
                    for (var i1 = 0; i1 < len; ++i1) {
                        totDuration += durationsClone[i1];
                    }

                    var t = DG.Tweening.Core.Extensions.NoFrom(UnityEngine.Vector3, System.Array.type(UnityEngine.Vector3), DG.Tweening.Plugins.Options.Vector3ArrayOptions, DG.Tweening.DOTween.ApplyTo(UnityEngine.Vector3, System.Array.type(UnityEngine.Vector3), DG.Tweening.Plugins.Options.Vector3ArrayOptions, getter, setter, endValuesClone, totDuration));
                    t.plugOptions.durations = durationsClone;
                    return t;
                },
                /*DG.Tweening.DOTween.ToArray:static end.*/

                /*DG.Tweening.DOTween.Sequence:static start.*/
                /**
                 * Returns a new {@link } to be used for tween groups.
                     <p />
                     Mind that Sequences don't have a target applied automatically like Tweener creation shortcuts,
                     so if you want to be able to kill this Sequence when calling DOTween.Kill(target) you'll have to add
                     the target manually; you can do that directly by using the {@link } overload instead of this
                     one
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @return  {DG.Tweening.Sequence}
                 */
                Sequence: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#Sequence", this ); }

                    DG.Tweening.DOTween.InitCheck();
                    var sequence = DG.Tweening.Core.TweenManager.GetSequence();
                    DG.Tweening.Sequence.Setup(sequence);
                    return sequence;
                },
                /*DG.Tweening.DOTween.Sequence:static end.*/

                /*DG.Tweening.DOTween.Sequence$1:static start.*/
                /**
                 * Returns a new {@link } to be used for tween groups, and allows to set a target
                     (because Sequences don't have their target set automatically like Tweener creation shortcuts).
                     That way killing/controlling tweens by target will apply to this Sequence too.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {System.Object}           target    The target of the Sequence. Relevant only for static target-based methods like DOTween.Kill(target),
                     useless otherwise
                 * @return  {DG.Tweening.Sequence}
                 */
                Sequence$1: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#Sequence$1", this ); }

                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, DG.Tweening.DOTween.Sequence(), target);
                },
                /*DG.Tweening.DOTween.Sequence$1:static end.*/

                /*DG.Tweening.DOTween.CompleteAll:static start.*/
                /**
                 * Completes all tweens and returns the number of actual tweens completed
                     (meaning tweens that don't have infinite loops and were not already complete)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {boolean}    withCallbacks    For Sequences only: if TRUE also internal Sequence callbacks will be fired,
                     otherwise they will be ignored
                 * @return  {number}
                 */
                CompleteAll: function (withCallbacks) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#CompleteAll", this ); }

                    if (withCallbacks === void 0) { withCallbacks = false; }
                    return DG.Tweening.Core.TweenManager.FilteredOperation(DG.Tweening.Core.Enums.OperationType.Complete, DG.Tweening.Core.Enums.FilterType.All, null, false, withCallbacks ? 1 : 0);
                },
                /*DG.Tweening.DOTween.CompleteAll:static end.*/

                /*DG.Tweening.DOTween.Complete:static start.*/
                /**
                 * Completes all tweens with the given ID or target and returns the number of actual tweens completed
                     (meaning the tweens that don't have infinite loops and were not already complete)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {System.Object}    targetOrId       
                 * @param   {boolean}          withCallbacks    For Sequences only: if TRUE internal Sequence callbacks will be fired,
                     otherwise they will be ignored
                 * @return  {number}
                 */
                Complete: function (targetOrId, withCallbacks) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#Complete", this ); }

                    if (withCallbacks === void 0) { withCallbacks = false; }
                    if (targetOrId == null) {
                        return 0;
                    }

                    return DG.Tweening.Core.TweenManager.FilteredOperation(DG.Tweening.Core.Enums.OperationType.Complete, DG.Tweening.Core.Enums.FilterType.TargetOrId, targetOrId, false, withCallbacks ? 1 : 0);
                },
                /*DG.Tweening.DOTween.Complete:static end.*/

                /*DG.Tweening.DOTween.CompleteAndReturnKilledTot:static start.*/
                CompleteAndReturnKilledTot: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#CompleteAndReturnKilledTot", this ); }

                    return DG.Tweening.Core.TweenManager.FilteredOperation(DG.Tweening.Core.Enums.OperationType.Complete, DG.Tweening.Core.Enums.FilterType.All, null, true, 0);
                },
                /*DG.Tweening.DOTween.CompleteAndReturnKilledTot:static end.*/

                /*DG.Tweening.DOTween.CompleteAndReturnKilledTot$1:static start.*/
                CompleteAndReturnKilledTot$1: function (targetOrId) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#CompleteAndReturnKilledTot$1", this ); }

                    if (targetOrId == null) {
                        return 0;
                    }

                    return DG.Tweening.Core.TweenManager.FilteredOperation(DG.Tweening.Core.Enums.OperationType.Complete, DG.Tweening.Core.Enums.FilterType.TargetOrId, targetOrId, true, 0);
                },
                /*DG.Tweening.DOTween.CompleteAndReturnKilledTot$1:static end.*/

                /*DG.Tweening.DOTween.CompleteAndReturnKilledTot$2:static start.*/
                CompleteAndReturnKilledTot$2: function (target, id) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#CompleteAndReturnKilledTot$2", this ); }

                    if (target == null || id == null) {
                        return 0;
                    }

                    return DG.Tweening.Core.TweenManager.FilteredOperation(DG.Tweening.Core.Enums.OperationType.Complete, DG.Tweening.Core.Enums.FilterType.TargetAndId, id, true, 0, target);
                },
                /*DG.Tweening.DOTween.CompleteAndReturnKilledTot$2:static end.*/

                /*DG.Tweening.DOTween.CompleteAndReturnKilledTotExceptFor:static start.*/
                CompleteAndReturnKilledTotExceptFor: function (excludeTargetsOrIds) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#CompleteAndReturnKilledTotExceptFor", this ); }

                    if (excludeTargetsOrIds === void 0) { excludeTargetsOrIds = []; }
                    // excludeTargetsOrIds is never NULL (checked by DOTween.KillAll)
                    return DG.Tweening.Core.TweenManager.FilteredOperation(DG.Tweening.Core.Enums.OperationType.Complete, DG.Tweening.Core.Enums.FilterType.AllExceptTargetsOrIds, null, true, 0, null, excludeTargetsOrIds);
                },
                /*DG.Tweening.DOTween.CompleteAndReturnKilledTotExceptFor:static end.*/

                /*DG.Tweening.DOTween.FlipAll:static start.*/
                /**
                 * Flips all tweens (changing their direction to forward if it was backwards and viceversa),
                     then returns the number of actual tweens flipped
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @return  {number}
                 */
                FlipAll: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#FlipAll", this ); }

                    return DG.Tweening.Core.TweenManager.FilteredOperation(DG.Tweening.Core.Enums.OperationType.Flip, DG.Tweening.Core.Enums.FilterType.All, null, false, 0);
                },
                /*DG.Tweening.DOTween.FlipAll:static end.*/

                /*DG.Tweening.DOTween.Flip:static start.*/
                /**
                 * Flips the tweens with the given ID or target (changing their direction to forward if it was backwards and
                     viceversa),
                     then returns the number of actual tweens flipped
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {System.Object}    targetOrId
                 * @return  {number}
                 */
                Flip: function (targetOrId) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#Flip", this ); }

                    if (targetOrId == null) {
                        return 0;
                    }

                    return DG.Tweening.Core.TweenManager.FilteredOperation(DG.Tweening.Core.Enums.OperationType.Flip, DG.Tweening.Core.Enums.FilterType.TargetOrId, targetOrId, false, 0);
                },
                /*DG.Tweening.DOTween.Flip:static end.*/

                /*DG.Tweening.DOTween.GotoAll:static start.*/
                /**
                 * Sends all tweens to the given position (calculating also eventual loop cycles) and returns the actual tweens
                     involved
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {number}     to         
                 * @param   {boolean}    andPlay
                 * @return  {number}
                 */
                GotoAll: function (to, andPlay) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#GotoAll", this ); }

                    if (andPlay === void 0) { andPlay = false; }
                    return DG.Tweening.Core.TweenManager.FilteredOperation(DG.Tweening.Core.Enums.OperationType.Goto, DG.Tweening.Core.Enums.FilterType.All, null, andPlay, to);
                },
                /*DG.Tweening.DOTween.GotoAll:static end.*/

                /*DG.Tweening.DOTween.Goto:static start.*/
                /**
                 * Sends all tweens with the given ID or target to the given position (calculating also eventual loop cycles)
                     and returns the actual tweens involved
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {System.Object}    targetOrId    
                 * @param   {number}           to            
                 * @param   {boolean}          andPlay
                 * @return  {number}
                 */
                Goto: function (targetOrId, to, andPlay) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#Goto", this ); }

                    if (andPlay === void 0) { andPlay = false; }
                    if (targetOrId == null) {
                        return 0;
                    }

                    return DG.Tweening.Core.TweenManager.FilteredOperation(DG.Tweening.Core.Enums.OperationType.Goto, DG.Tweening.Core.Enums.FilterType.TargetOrId, targetOrId, andPlay, to);
                },
                /*DG.Tweening.DOTween.Goto:static end.*/

                /*DG.Tweening.DOTween.KillAll:static start.*/
                /**
                 * Kills all tweens and returns the number of actual tweens killed
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {boolean}    complete    If TRUE completes the tweens before killing them
                 * @return  {number}
                 */
                KillAll: function (complete) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#KillAll", this ); }

                    if (complete === void 0) { complete = false; }
                    var tot = complete ? DG.Tweening.DOTween.CompleteAndReturnKilledTot() : 0;
                    return tot + DG.Tweening.Core.TweenManager.DespawnAll();
                },
                /*DG.Tweening.DOTween.KillAll:static end.*/

                /*DG.Tweening.DOTween.KillAll$1:static start.*/
                /**
                 * Kills all tweens and returns the number of actual tweens killed
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {boolean}                  complete                 If TRUE completes the tweens before killing them
                 * @param   {Array.<System.Object>}    idsOrTargetsToExclude    Eventual IDs or targets to exclude from the killing
                 * @return  {number}
                 */
                KillAll$1: function (complete, idsOrTargetsToExclude) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#KillAll$1", this ); }

                    if (idsOrTargetsToExclude === void 0) { idsOrTargetsToExclude = []; }
                    var tot;
                    if (idsOrTargetsToExclude == null) {
                        tot = complete ? DG.Tweening.DOTween.CompleteAndReturnKilledTot() : 0;
                        return tot + DG.Tweening.Core.TweenManager.DespawnAll();
                    }

                    tot = complete ? DG.Tweening.DOTween.CompleteAndReturnKilledTotExceptFor(idsOrTargetsToExclude) : 0;
                    return tot + DG.Tweening.Core.TweenManager.FilteredOperation(DG.Tweening.Core.Enums.OperationType.Despawn, DG.Tweening.Core.Enums.FilterType.AllExceptTargetsOrIds, null, false, 0, null, idsOrTargetsToExclude);
                },
                /*DG.Tweening.DOTween.KillAll$1:static end.*/

                /*DG.Tweening.DOTween.Kill:static start.*/
                /**
                 * Kills all tweens with the given ID or target and returns the number of actual tweens killed
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {System.Object}    targetOrId    
                 * @param   {boolean}          complete      If TRUE completes the tweens before killing them
                 * @return  {number}
                 */
                Kill: function (targetOrId, complete) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#Kill", this ); }

                    if (complete === void 0) { complete = false; }
                    if (targetOrId == null) {
                        return 0;
                    }

                    var tot = complete ? DG.Tweening.DOTween.CompleteAndReturnKilledTot$1(targetOrId) : 0;
                    return tot + DG.Tweening.Core.TweenManager.FilteredOperation(DG.Tweening.Core.Enums.OperationType.Despawn, DG.Tweening.Core.Enums.FilterType.TargetOrId, targetOrId, false, 0);
                },
                /*DG.Tweening.DOTween.Kill:static end.*/

                /*DG.Tweening.DOTween.Kill$1:static start.*/
                /**
                 * Kills all tweens with the given target and the given ID, and returns the number of actual tweens killed
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {System.Object}    target      
                 * @param   {System.Object}    id          
                 * @param   {boolean}          complete    If TRUE completes the tweens before killing them
                 * @return  {number}
                 */
                Kill$1: function (target, id, complete) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#Kill$1", this ); }

                    if (complete === void 0) { complete = false; }
                    if (target == null || id == null) {
                        return 0;
                    }

                    var tot = complete ? DG.Tweening.DOTween.CompleteAndReturnKilledTot$2(target, id) : 0;
                    return tot + DG.Tweening.Core.TweenManager.FilteredOperation(DG.Tweening.Core.Enums.OperationType.Despawn, DG.Tweening.Core.Enums.FilterType.TargetAndId, id, false, 0, target);
                },
                /*DG.Tweening.DOTween.Kill$1:static end.*/

                /*DG.Tweening.DOTween.PauseAll:static start.*/
                /**
                 * Pauses all tweens and returns the number of actual tweens paused
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @return  {number}
                 */
                PauseAll: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#PauseAll", this ); }

                    return DG.Tweening.Core.TweenManager.FilteredOperation(DG.Tweening.Core.Enums.OperationType.Pause, DG.Tweening.Core.Enums.FilterType.All, null, false, 0);
                },
                /*DG.Tweening.DOTween.PauseAll:static end.*/

                /*DG.Tweening.DOTween.Pause:static start.*/
                /**
                 * Pauses all tweens with the given ID or target and returns the number of actual tweens paused
                     (meaning the tweens that were actually playing and have been paused)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {System.Object}    targetOrId
                 * @return  {number}
                 */
                Pause: function (targetOrId) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#Pause", this ); }

                    if (targetOrId == null) {
                        return 0;
                    }

                    return DG.Tweening.Core.TweenManager.FilteredOperation(DG.Tweening.Core.Enums.OperationType.Pause, DG.Tweening.Core.Enums.FilterType.TargetOrId, targetOrId, false, 0);
                },
                /*DG.Tweening.DOTween.Pause:static end.*/

                /*DG.Tweening.DOTween.PlayAll:static start.*/
                /**
                 * Plays all tweens and returns the number of actual tweens played
                     (meaning tweens that were not already playing or complete)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @return  {number}
                 */
                PlayAll: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#PlayAll", this ); }

                    return DG.Tweening.Core.TweenManager.FilteredOperation(DG.Tweening.Core.Enums.OperationType.Play, DG.Tweening.Core.Enums.FilterType.All, null, false, 0);
                },
                /*DG.Tweening.DOTween.PlayAll:static end.*/

                /*DG.Tweening.DOTween.Play:static start.*/
                /**
                 * Plays all tweens with the given ID or target and returns the number of actual tweens played
                     (meaning the tweens that were not already playing or complete)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {System.Object}    targetOrId
                 * @return  {number}
                 */
                Play: function (targetOrId) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#Play", this ); }

                    if (targetOrId == null) {
                        return 0;
                    }

                    return DG.Tweening.Core.TweenManager.FilteredOperation(DG.Tweening.Core.Enums.OperationType.Play, DG.Tweening.Core.Enums.FilterType.TargetOrId, targetOrId, false, 0);
                },
                /*DG.Tweening.DOTween.Play:static end.*/

                /*DG.Tweening.DOTween.Play$1:static start.*/
                /**
                 * Plays all tweens with the given target and the given ID, and returns the number of actual tweens played
                     (meaning the tweens that were not already playing or complete)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {System.Object}    target    
                 * @param   {System.Object}    id
                 * @return  {number}
                 */
                Play$1: function (target, id) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#Play$1", this ); }

                    if (target == null || id == null) {
                        return 0;
                    }

                    return DG.Tweening.Core.TweenManager.FilteredOperation(DG.Tweening.Core.Enums.OperationType.Play, DG.Tweening.Core.Enums.FilterType.TargetAndId, id, false, 0, target);
                },
                /*DG.Tweening.DOTween.Play$1:static end.*/

                /*DG.Tweening.DOTween.PlayBackwardsAll:static start.*/
                /**
                 * Plays backwards all tweens and returns the number of actual tweens played
                     (meaning tweens that were not already started, playing backwards or rewinded)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @return  {number}
                 */
                PlayBackwardsAll: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#PlayBackwardsAll", this ); }

                    return DG.Tweening.Core.TweenManager.FilteredOperation(DG.Tweening.Core.Enums.OperationType.PlayBackwards, DG.Tweening.Core.Enums.FilterType.All, null, false, 0);
                },
                /*DG.Tweening.DOTween.PlayBackwardsAll:static end.*/

                /*DG.Tweening.DOTween.PlayBackwards:static start.*/
                /**
                 * Plays backwards all tweens with the given ID or target and returns the number of actual tweens played
                     (meaning the tweens that were not already started, playing backwards or rewinded)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {System.Object}    targetOrId
                 * @return  {number}
                 */
                PlayBackwards: function (targetOrId) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#PlayBackwards", this ); }

                    if (targetOrId == null) {
                        return 0;
                    }

                    return DG.Tweening.Core.TweenManager.FilteredOperation(DG.Tweening.Core.Enums.OperationType.PlayBackwards, DG.Tweening.Core.Enums.FilterType.TargetOrId, targetOrId, false, 0);
                },
                /*DG.Tweening.DOTween.PlayBackwards:static end.*/

                /*DG.Tweening.DOTween.PlayBackwards$1:static start.*/
                /**
                 * Plays backwards all tweens with the given target and ID and returns the number of actual tweens played
                     (meaning the tweens that were not already started, playing backwards or rewinded)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {System.Object}    target    
                 * @param   {System.Object}    id
                 * @return  {number}
                 */
                PlayBackwards$1: function (target, id) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#PlayBackwards$1", this ); }

                    if (target == null || id == null) {
                        return 0;
                    }

                    return DG.Tweening.Core.TweenManager.FilteredOperation(DG.Tweening.Core.Enums.OperationType.PlayBackwards, DG.Tweening.Core.Enums.FilterType.TargetAndId, id, false, 0, target);
                },
                /*DG.Tweening.DOTween.PlayBackwards$1:static end.*/

                /*DG.Tweening.DOTween.PlayForwardAll:static start.*/
                /**
                 * Plays forward all tweens and returns the number of actual tweens played
                     (meaning tweens that were not already playing forward or complete)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @return  {number}
                 */
                PlayForwardAll: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#PlayForwardAll", this ); }

                    return DG.Tweening.Core.TweenManager.FilteredOperation(DG.Tweening.Core.Enums.OperationType.PlayForward, DG.Tweening.Core.Enums.FilterType.All, null, false, 0);
                },
                /*DG.Tweening.DOTween.PlayForwardAll:static end.*/

                /*DG.Tweening.DOTween.PlayForward:static start.*/
                /**
                 * Plays forward all tweens with the given ID or target and returns the number of actual tweens played
                     (meaning the tweens that were not already playing forward or complete)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {System.Object}    targetOrId
                 * @return  {number}
                 */
                PlayForward: function (targetOrId) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#PlayForward", this ); }

                    if (targetOrId == null) {
                        return 0;
                    }

                    return DG.Tweening.Core.TweenManager.FilteredOperation(DG.Tweening.Core.Enums.OperationType.PlayForward, DG.Tweening.Core.Enums.FilterType.TargetOrId, targetOrId, false, 0);
                },
                /*DG.Tweening.DOTween.PlayForward:static end.*/

                /*DG.Tweening.DOTween.PlayForward$1:static start.*/
                /**
                 * Plays forward all tweens with the given target and ID and returns the number of actual tweens played
                     (meaning the tweens that were not already started, playing backwards or rewinded)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {System.Object}    target    
                 * @param   {System.Object}    id
                 * @return  {number}
                 */
                PlayForward$1: function (target, id) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#PlayForward$1", this ); }

                    if (target == null || id == null) {
                        return 0;
                    }

                    return DG.Tweening.Core.TweenManager.FilteredOperation(DG.Tweening.Core.Enums.OperationType.PlayForward, DG.Tweening.Core.Enums.FilterType.TargetAndId, id, false, 0, target);
                },
                /*DG.Tweening.DOTween.PlayForward$1:static end.*/

                /*DG.Tweening.DOTween.RestartAll:static start.*/
                /**
                 * Restarts all tweens, then returns the number of actual tweens restarted
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {boolean}    includeDelay
                 * @return  {number}
                 */
                RestartAll: function (includeDelay) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#RestartAll", this ); }

                    if (includeDelay === void 0) { includeDelay = true; }
                    return DG.Tweening.Core.TweenManager.FilteredOperation(DG.Tweening.Core.Enums.OperationType.Restart, DG.Tweening.Core.Enums.FilterType.All, null, includeDelay, 0);
                },
                /*DG.Tweening.DOTween.RestartAll:static end.*/

                /*DG.Tweening.DOTween.Restart:static start.*/
                /**
                 * Restarts all tweens with the given ID or target, then returns the number of actual tweens restarted
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {System.Object}    targetOrId       
                 * @param   {boolean}          includeDelay     If TRUE includes the eventual tweens delays, otherwise skips them
                 * @param   {number}           changeDelayTo    If &gt;= 0 changes the startup delay of all involved tweens to this value, otherwise doesn't
                     touch it
                 * @return  {number}
                 */
                Restart: function (targetOrId, includeDelay, changeDelayTo) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#Restart", this ); }

                    if (includeDelay === void 0) { includeDelay = true; }
                    if (changeDelayTo === void 0) { changeDelayTo = -1.0; }
                    if (targetOrId == null) {
                        return 0;
                    }

                    return DG.Tweening.Core.TweenManager.FilteredOperation(DG.Tweening.Core.Enums.OperationType.Restart, DG.Tweening.Core.Enums.FilterType.TargetOrId, targetOrId, includeDelay, changeDelayTo);
                },
                /*DG.Tweening.DOTween.Restart:static end.*/

                /*DG.Tweening.DOTween.Restart$1:static start.*/
                /**
                 * Restarts all tweens with the given target and the given ID, and returns the number of actual tweens played
                     (meaning the tweens that were not already playing or complete)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {System.Object}    target           
                 * @param   {System.Object}    id               
                 * @param   {boolean}          includeDelay     If TRUE includes the eventual tweens delays, otherwise skips them
                 * @param   {number}           changeDelayTo    If &gt;= 0 changes the startup delay of all involved tweens to this value, otherwise doesn't
                     touch it
                 * @return  {number}
                 */
                Restart$1: function (target, id, includeDelay, changeDelayTo) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#Restart$1", this ); }

                    if (includeDelay === void 0) { includeDelay = true; }
                    if (changeDelayTo === void 0) { changeDelayTo = -1.0; }
                    if (target == null || id == null) {
                        return 0;
                    }

                    return DG.Tweening.Core.TweenManager.FilteredOperation(DG.Tweening.Core.Enums.OperationType.Restart, DG.Tweening.Core.Enums.FilterType.TargetAndId, id, includeDelay, changeDelayTo, target);
                },
                /*DG.Tweening.DOTween.Restart$1:static end.*/

                /*DG.Tweening.DOTween.RewindAll:static start.*/
                /**
                 * Rewinds and pauses all tweens, then returns the number of actual tweens rewinded
                     (meaning tweens that were not already rewinded)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {boolean}    includeDelay
                 * @return  {number}
                 */
                RewindAll: function (includeDelay) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#RewindAll", this ); }

                    if (includeDelay === void 0) { includeDelay = true; }
                    return DG.Tweening.Core.TweenManager.FilteredOperation(DG.Tweening.Core.Enums.OperationType.Rewind, DG.Tweening.Core.Enums.FilterType.All, null, includeDelay, 0);
                },
                /*DG.Tweening.DOTween.RewindAll:static end.*/

                /*DG.Tweening.DOTween.Rewind:static start.*/
                /**
                 * Rewinds and pauses all tweens with the given ID or target, then returns the number of actual tweens rewinded
                     (meaning the tweens that were not already rewinded)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {System.Object}    targetOrId      
                 * @param   {boolean}          includeDelay
                 * @return  {number}
                 */
                Rewind: function (targetOrId, includeDelay) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#Rewind", this ); }

                    if (includeDelay === void 0) { includeDelay = true; }
                    if (targetOrId == null) {
                        return 0;
                    }

                    return DG.Tweening.Core.TweenManager.FilteredOperation(DG.Tweening.Core.Enums.OperationType.Rewind, DG.Tweening.Core.Enums.FilterType.TargetOrId, targetOrId, includeDelay, 0);
                },
                /*DG.Tweening.DOTween.Rewind:static end.*/

                /*DG.Tweening.DOTween.SmoothRewindAll:static start.*/
                /**
                 * Smoothly rewinds all tweens (delays excluded), then returns the number of actual tweens rewinding/rewinded
                     (meaning tweens that were not already rewinded).
                     A "smooth rewind" animates the tween to its start position,
                     skipping all elapsed loops (except in case of LoopType.Incremental) while keeping the animation fluent.
                     <p>Note that a tween that was smoothly rewinded will have its play direction flipped</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @return  {number}
                 */
                SmoothRewindAll: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#SmoothRewindAll", this ); }

                    return DG.Tweening.Core.TweenManager.FilteredOperation(DG.Tweening.Core.Enums.OperationType.SmoothRewind, DG.Tweening.Core.Enums.FilterType.All, null, false, 0);
                },
                /*DG.Tweening.DOTween.SmoothRewindAll:static end.*/

                /*DG.Tweening.DOTween.SmoothRewind:static start.*/
                /**
                 * Smoothly rewinds all tweens (delays excluded) with the given ID or target, then returns the number of actual tweens
                     rewinding/rewinded
                     (meaning the tweens that were not already rewinded).
                     A "smooth rewind" animates the tween to its start position,
                     skipping all elapsed loops (except in case of LoopType.Incremental) while keeping the animation fluent.
                     <p>Note that a tween that was smoothly rewinded will have its play direction flipped</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {System.Object}    targetOrId
                 * @return  {number}
                 */
                SmoothRewind: function (targetOrId) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#SmoothRewind", this ); }

                    if (targetOrId == null) {
                        return 0;
                    }

                    return DG.Tweening.Core.TweenManager.FilteredOperation(DG.Tweening.Core.Enums.OperationType.SmoothRewind, DG.Tweening.Core.Enums.FilterType.TargetOrId, targetOrId, false, 0);
                },
                /*DG.Tweening.DOTween.SmoothRewind:static end.*/

                /*DG.Tweening.DOTween.TogglePauseAll:static start.*/
                /**
                 * Toggles the play state of all tweens and returns the number of actual tweens toggled
                     (meaning tweens that could be played or paused, depending on the toggle state)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @return  {number}
                 */
                TogglePauseAll: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#TogglePauseAll", this ); }

                    return DG.Tweening.Core.TweenManager.FilteredOperation(DG.Tweening.Core.Enums.OperationType.TogglePause, DG.Tweening.Core.Enums.FilterType.All, null, false, 0);
                },
                /*DG.Tweening.DOTween.TogglePauseAll:static end.*/

                /*DG.Tweening.DOTween.TogglePause:static start.*/
                /**
                 * Toggles the play state of all tweens with the given ID or target and returns the number of actual tweens toggled
                     (meaning the tweens that could be played or paused, depending on the toggle state)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {System.Object}    targetOrId
                 * @return  {number}
                 */
                TogglePause: function (targetOrId) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#TogglePause", this ); }

                    if (targetOrId == null) {
                        return 0;
                    }

                    return DG.Tweening.Core.TweenManager.FilteredOperation(DG.Tweening.Core.Enums.OperationType.TogglePause, DG.Tweening.Core.Enums.FilterType.TargetOrId, targetOrId, false, 0);
                },
                /*DG.Tweening.DOTween.TogglePause:static end.*/

                /*DG.Tweening.DOTween.IsTweening:static start.*/
                /**
                 * Returns TRUE if a tween with the given ID or target is active.
                     <p>You can also use this to know if a shortcut tween is active for a given target.</p><p>Example:</p><p><pre><code>transform.DOMoveX(45, 1); // transform is automatically added as the tween target</code></pre></p><p><pre><code>DOTween.IsTweening(transform); // Returns true</code></pre></p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {System.Object}    targetOrId              The target or ID to look for
                 * @param   {boolean}          alsoCheckIfIsPlaying    If FALSE (default) returns TRUE as long as a tween for the given target/ID is active,
                     otherwise also requires it to be playing
                 * @return  {boolean}
                 */
                IsTweening: function (targetOrId, alsoCheckIfIsPlaying) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#IsTweening", this ); }

                    if (alsoCheckIfIsPlaying === void 0) { alsoCheckIfIsPlaying = false; }
                    return DG.Tweening.Core.TweenManager.FilteredOperation(DG.Tweening.Core.Enums.OperationType.IsTweening, DG.Tweening.Core.Enums.FilterType.TargetOrId, targetOrId, alsoCheckIfIsPlaying, 0) > 0;
                },
                /*DG.Tweening.DOTween.IsTweening:static end.*/

                /*DG.Tweening.DOTween.TotalActiveTweens:static start.*/
                /**
                 * Returns the total number of active tweens (so both Tweeners and Sequences).
                     A tween is considered active if it wasn't killed, regardless if it's playing or paused
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @return  {number}
                 */
                TotalActiveTweens: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#TotalActiveTweens", this ); }

                    return DG.Tweening.Core.TweenManager.totActiveTweens;
                },
                /*DG.Tweening.DOTween.TotalActiveTweens:static end.*/

                /*DG.Tweening.DOTween.TotalActiveTweeners:static start.*/
                /**
                 * Returns the total number of active Tweeners.
                     A Tweener is considered active if it wasn't killed, regardless if it's playing or paused
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @return  {number}
                 */
                TotalActiveTweeners: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#TotalActiveTweeners", this ); }

                    return DG.Tweening.Core.TweenManager.totActiveTweeners;
                },
                /*DG.Tweening.DOTween.TotalActiveTweeners:static end.*/

                /*DG.Tweening.DOTween.TotalActiveSequences:static start.*/
                /**
                 * Returns the total number of active Sequences.
                     A Sequence is considered active if it wasn't killed, regardless if it's playing or paused
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @return  {number}
                 */
                TotalActiveSequences: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#TotalActiveSequences", this ); }

                    return DG.Tweening.Core.TweenManager.totActiveSequences;
                },
                /*DG.Tweening.DOTween.TotalActiveSequences:static end.*/

                /*DG.Tweening.DOTween.TotalPlayingTweens:static start.*/
                /**
                 * Returns the total number of active and playing tweens.
                     A tween is considered as playing even if its delay is actually playing
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @return  {number}
                 */
                TotalPlayingTweens: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#TotalPlayingTweens", this ); }

                    return DG.Tweening.Core.TweenManager.TotalPlayingTweens();
                },
                /*DG.Tweening.DOTween.TotalPlayingTweens:static end.*/

                /*DG.Tweening.DOTween.TotalTweensById:static start.*/
                /**
                 * Returns a the total number of active tweens with the given id.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {System.Object}    id             
                 * @param   {boolean}          playingOnly    If TRUE returns only the tweens with the given ID that are currently playing
                 * @return  {number}
                 */
                TotalTweensById: function (id, playingOnly) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#TotalTweensById", this ); }

                    if (playingOnly === void 0) { playingOnly = false; }
                    if (id == null) {
                        return 0;
                    }

                    return DG.Tweening.Core.TweenManager.TotalTweensById(id, playingOnly);
                },
                /*DG.Tweening.DOTween.TotalTweensById:static end.*/

                /*DG.Tweening.DOTween.PlayingTweens:static start.*/
                /**
                 * Returns a list of all active tweens in a playing state.
                     Returns NULL if there are no active playing tweens.
                     <p>Beware: each time you call this method a new list is generated, so use it for debug only</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {System.Collections.Generic.List$1}    fillableList    If NULL creates a new list, otherwise clears and fills this one (and thus saves allocations)
                 * @return  {System.Collections.Generic.List$1}
                 */
                PlayingTweens: function (fillableList) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#PlayingTweens", this ); }

                    if (fillableList === void 0) { fillableList = null; }
                    if (fillableList != null) {
                        fillableList.clear();
                    }

                    return DG.Tweening.Core.TweenManager.GetActiveTweens(true, fillableList);
                },
                /*DG.Tweening.DOTween.PlayingTweens:static end.*/

                /*DG.Tweening.DOTween.PausedTweens:static start.*/
                /**
                 * Returns a list of all active tweens in a paused state.
                     Returns NULL if there are no active paused tweens.
                     <p>Beware: each time you call this method a new list is generated, so use it for debug only</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {System.Collections.Generic.List$1}    fillableList    If NULL creates a new list, otherwise clears and fills this one (and thus saves allocations)
                 * @return  {System.Collections.Generic.List$1}
                 */
                PausedTweens: function (fillableList) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#PausedTweens", this ); }

                    if (fillableList === void 0) { fillableList = null; }
                    if (fillableList != null) {
                        fillableList.clear();
                    }

                    return DG.Tweening.Core.TweenManager.GetActiveTweens(false, fillableList);
                },
                /*DG.Tweening.DOTween.PausedTweens:static end.*/

                /*DG.Tweening.DOTween.TweensById:static start.*/
                /**
                 * Returns a list of all active tweens with the given id.
                     Returns NULL if there are no active tweens with the given id.
                     <p>Beware: each time you call this method a new list is generated</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {System.Object}                        id              
                 * @param   {boolean}                              playingOnly     If TRUE returns only the tweens with the given ID that are currently playing
                 * @param   {System.Collections.Generic.List$1}    fillableList    If NULL creates a new list, otherwise clears and fills this one (and thus saves allocations)
                 * @return  {System.Collections.Generic.List$1}
                 */
                TweensById: function (id, playingOnly, fillableList) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#TweensById", this ); }

                    if (playingOnly === void 0) { playingOnly = false; }
                    if (fillableList === void 0) { fillableList = null; }
                    if (id == null) {
                        return null;
                    }

                    if (fillableList != null) {
                        fillableList.clear();
                    }

                    return DG.Tweening.Core.TweenManager.GetTweensById(id, playingOnly, fillableList);
                },
                /*DG.Tweening.DOTween.TweensById:static end.*/

                /*DG.Tweening.DOTween.TweensByTarget:static start.*/
                /**
                 * Returns a list of all active tweens with the given target.
                     Returns NULL if there are no active tweens with the given target.
                     <p>Beware: each time you call this method a new list is generated</p><param name="playingOnly">If TRUE returns only the tweens with the given target that are currently playing</param><param name="fillableList">
                         If NULL creates a new list, otherwise clears and fills this one (and thus saves
                         allocations)
                     </param>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTween
                 * @memberof DG.Tweening.DOTween
                 * @param   {System.Object}                        target          
                 * @param   {boolean}                              playingOnly     If TRUE returns only the tweens with the given target that are currently playing
                 * @param   {System.Collections.Generic.List$1}    fillableList    If NULL creates a new list, otherwise clears and fills this one (and thus saves
                         allocations)
                 * @return  {System.Collections.Generic.List$1}
                 */
                TweensByTarget: function (target, playingOnly, fillableList) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTween#TweensByTarget", this ); }

                    if (playingOnly === void 0) { playingOnly = false; }
                    if (fillableList === void 0) { fillableList = null; }
                    if (fillableList != null) {
                        fillableList.clear();
                    }

                    return DG.Tweening.Core.TweenManager.GetTweensByTarget(target, playingOnly, fillableList);
                },
                /*DG.Tweening.DOTween.TweensByTarget:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTween end.*/

    /*DG.Tweening.DOTweenInspectorMode start.*/
    Bridge.define("DG.Tweening.DOTweenInspectorMode", {
        $kind: 6,
        statics: {
            fields: {
                Default: 0,
                InfoAndWaypointsOnly: 1,
                Developer: 2,
                OnlyPath: 3
            }
        }
    });
    /*DG.Tweening.DOTweenInspectorMode end.*/

    /*DG.Tweening.DOTweenVisualManager start.*/
    Bridge.define("DG.Tweening.DOTweenVisualManager", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            preset: 0,
            onEnableBehaviour: 0,
            onDisableBehaviour: 0
        }
    });
    /*DG.Tweening.DOTweenVisualManager end.*/

    /*DG.Tweening.DOVirtual start.*/
    /**
     * Creates virtual tweens that can be used to change other elements via their OnUpdate calls
     *
     * @static
     * @abstract
     * @public
     * @class DG.Tweening.DOVirtual
     */
    Bridge.define("DG.Tweening.DOVirtual", {
        statics: {
            methods: {
                /*DG.Tweening.DOVirtual.Float:static start.*/
                /**
                 * Tweens a virtual float.
                     You can add regular settings to the generated tween,
                     but do not use <pre><code>SetUpdate</code></pre> or you will overwrite the onVirtualUpdate parameter
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOVirtual
                 * @memberof DG.Tweening.DOVirtual
                 * @param   {number}                       from               The value to start from
                 * @param   {number}                       to                 The value to tween to
                 * @param   {number}                       duration           The duration of the tween
                 * @param   {DG.Tweening.TweenCallback}    onVirtualUpdate    A callback which must accept a parameter of type float, called at each update
                 * @return  {DG.Tweening.Tweener}
                 */
                Float: function (from, to, duration, onVirtualUpdate) {
if ( TRACE ) { TRACE( "DG.Tweening.DOVirtual#Float", this ); }

                    var val = from;
                    return DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), DG.Tweening.DOTween.To$4(function () {
                        return val;
                    }, function (x) {
                        val = x;
                    }, to, duration), function () {
                        onVirtualUpdate(val);
                    });
                },
                /*DG.Tweening.DOVirtual.Float:static end.*/

                /*DG.Tweening.DOVirtual.Int:static start.*/
                /**
                 * Tweens a virtual int.
                     You can add regular settings to the generated tween,
                     but do not use <pre><code>SetUpdate</code></pre> or you will overwrite the onVirtualUpdate parameter
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOVirtual
                 * @memberof DG.Tweening.DOVirtual
                 * @param   {number}                       from               The value to start from
                 * @param   {number}                       to                 The value to tween to
                 * @param   {number}                       duration           The duration of the tween
                 * @param   {DG.Tweening.TweenCallback}    onVirtualUpdate    A callback which must accept a parameter of type int, called at each update
                 * @return  {DG.Tweening.Tweener}
                 */
                Int: function (from, to, duration, onVirtualUpdate) {
if ( TRACE ) { TRACE( "DG.Tweening.DOVirtual#Int", this ); }

                    var val = from;
                    return DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Core.TweenerCore$3(System.Int32,System.Int32,DG.Tweening.Plugins.Options.NoOptions), DG.Tweening.DOTween.To$2(function () {
                        return val;
                    }, function (x) {
                        val = x;
                    }, to, duration), function () {
                        onVirtualUpdate(val);
                    });
                },
                /*DG.Tweening.DOVirtual.Int:static end.*/

                /*DG.Tweening.DOVirtual.Vector3:static start.*/
                /**
                 * Tweens a virtual Vector3.
                     You can add regular settings to the generated tween,
                     but do not use <pre><code>SetUpdate</code></pre> or you will overwrite the onVirtualUpdate parameter
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOVirtual
                 * @memberof DG.Tweening.DOVirtual
                 * @param   {UnityEngine.Vector3}          from               The value to start from
                 * @param   {UnityEngine.Vector3}          to                 The value to tween to
                 * @param   {number}                       duration           The duration of the tween
                 * @param   {DG.Tweening.TweenCallback}    onVirtualUpdate    A callback which must accept a parameter of type Vector3, called at each update
                 * @return  {DG.Tweening.Tweener}
                 */
                Vector3: function (from, to, duration, onVirtualUpdate) {
if ( TRACE ) { TRACE( "DG.Tweening.DOVirtual#Vector3", this ); }

                    var val = from.$clone();
                    return DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.DOTween.To$12(function () {
                        return val;
                    }, function (x) {
                        val = x.$clone();
                    }, to.$clone(), duration), function () {
                        onVirtualUpdate(val.$clone());
                    });
                },
                /*DG.Tweening.DOVirtual.Vector3:static end.*/

                /*DG.Tweening.DOVirtual.Color:static start.*/
                /**
                 * Tweens a virtual Color.
                     You can add regular settings to the generated tween,
                     but do not use <pre><code>SetUpdate</code></pre> or you will overwrite the onVirtualUpdate parameter
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOVirtual
                 * @memberof DG.Tweening.DOVirtual
                 * @param   {UnityEngine.Color}            from               The value to start from
                 * @param   {UnityEngine.Color}            to                 The value to tween to
                 * @param   {number}                       duration           The duration of the tween
                 * @param   {DG.Tweening.TweenCallback}    onVirtualUpdate    A callback which must accept a parameter of type Color, called at each update
                 * @return  {DG.Tweening.Tweener}
                 */
                Color: function (from, to, duration, onVirtualUpdate) {
if ( TRACE ) { TRACE( "DG.Tweening.DOVirtual#Color", this ); }

                    var val = from.$clone();
                    return DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.DOTween.To$8(function () {
                        return val;
                    }, function (x) {
                        val = x.$clone();
                    }, to.$clone(), duration), function () {
                        onVirtualUpdate(val.$clone());
                    });
                },
                /*DG.Tweening.DOVirtual.Color:static end.*/

                /*DG.Tweening.DOVirtual.EasedValue:static start.*/
                /**
                 * Returns a value based on the given ease and lifetime percentage (0 to 1)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOVirtual
                 * @memberof DG.Tweening.DOVirtual
                 * @param   {number}              from                  The value to start from when lifetimePercentage is 0
                 * @param   {number}              to                    The value to reach when lifetimePercentage is 1
                 * @param   {number}              lifetimePercentage    The time percentage (0 to 1) at which the value should be taken
                 * @param   {DG.Tweening.Ease}    easeType              The type of ease
                 * @return  {number}
                 */
                EasedValue: function (from, to, lifetimePercentage, easeType) {
if ( TRACE ) { TRACE( "DG.Tweening.DOVirtual#EasedValue", this ); }

                    return from + (to - from) * DG.Tweening.Core.Easing.EaseManager.Evaluate(easeType, null, lifetimePercentage, 1, DG.Tweening.DOTween.defaultEaseOvershootOrAmplitude, DG.Tweening.DOTween.defaultEasePeriod);
                },
                /*DG.Tweening.DOVirtual.EasedValue:static end.*/

                /*DG.Tweening.DOVirtual.EasedValue$1:static start.*/
                /**
                 * Returns a value based on the given ease and lifetime percentage (0 to 1)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOVirtual
                 * @memberof DG.Tweening.DOVirtual
                 * @param   {number}              from                  The value to start from when lifetimePercentage is 0
                 * @param   {number}              to                    The value to reach when lifetimePercentage is 1
                 * @param   {number}              lifetimePercentage    The time percentage (0 to 1) at which the value should be taken
                 * @param   {DG.Tweening.Ease}    easeType              The type of ease
                 * @param   {number}              overshoot             Eventual overshoot to use with Back ease
                 * @return  {number}
                 */
                EasedValue$1: function (from, to, lifetimePercentage, easeType, overshoot) {
if ( TRACE ) { TRACE( "DG.Tweening.DOVirtual#EasedValue$1", this ); }

                    return from + (to - from) * DG.Tweening.Core.Easing.EaseManager.Evaluate(easeType, null, lifetimePercentage, 1, overshoot, DG.Tweening.DOTween.defaultEasePeriod);
                },
                /*DG.Tweening.DOVirtual.EasedValue$1:static end.*/

                /*DG.Tweening.DOVirtual.EasedValue$2:static start.*/
                /**
                 * Returns a value based on the given ease and lifetime percentage (0 to 1)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOVirtual
                 * @memberof DG.Tweening.DOVirtual
                 * @param   {number}              from                  The value to start from when lifetimePercentage is 0
                 * @param   {number}              to                    The value to reach when lifetimePercentage is 1
                 * @param   {number}              lifetimePercentage    The time percentage (0 to 1) at which the value should be taken
                 * @param   {DG.Tweening.Ease}    easeType              The type of ease
                 * @param   {number}              amplitude             Eventual amplitude to use with Elastic easeType
                 * @param   {number}              period                Eventual period to use with Elastic easeType
                 * @return  {number}
                 */
                EasedValue$2: function (from, to, lifetimePercentage, easeType, amplitude, period) {
if ( TRACE ) { TRACE( "DG.Tweening.DOVirtual#EasedValue$2", this ); }

                    return from + (to - from) * DG.Tweening.Core.Easing.EaseManager.Evaluate(easeType, null, lifetimePercentage, 1, amplitude, period);
                },
                /*DG.Tweening.DOVirtual.EasedValue$2:static end.*/

                /*DG.Tweening.DOVirtual.EasedValue$3:static start.*/
                /**
                 * Returns a value based on the given ease and lifetime percentage (0 to 1)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOVirtual
                 * @memberof DG.Tweening.DOVirtual
                 * @param   {number}               from                  The value to start from when lifetimePercentage is 0
                 * @param   {number}               to                    The value to reach when lifetimePercentage is 1
                 * @param   {number}               lifetimePercentage    The time percentage (0 to 1) at which the value should be taken
                 * @param   {pc.AnimationCurve}    easeCurve             The AnimationCurve to use for ease
                 * @return  {number}
                 */
                EasedValue$3: function (from, to, lifetimePercentage, easeCurve) {
if ( TRACE ) { TRACE( "DG.Tweening.DOVirtual#EasedValue$3", this ); }

                    return from + (to - from) * DG.Tweening.Core.Easing.EaseManager.Evaluate(DG.Tweening.Ease.INTERNAL_Custom, Bridge.fn.cacheBind(new DG.Tweening.Core.Easing.EaseCurve(easeCurve), new DG.Tweening.Core.Easing.EaseCurve(easeCurve).Evaluate), lifetimePercentage, 1, DG.Tweening.DOTween.defaultEaseOvershootOrAmplitude, DG.Tweening.DOTween.defaultEasePeriod);
                },
                /*DG.Tweening.DOVirtual.EasedValue$3:static end.*/

                /*DG.Tweening.DOVirtual.EasedValue$4:static start.*/
                /**
                 * Returns a value based on the given ease and lifetime percentage (0 to 1)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOVirtual
                 * @memberof DG.Tweening.DOVirtual
                 * @param   {UnityEngine.Vector3}    from                  The value to start from when lifetimePercentage is 0
                 * @param   {UnityEngine.Vector3}    to                    The value to reach when lifetimePercentage is 1
                 * @param   {number}                 lifetimePercentage    The time percentage (0 to 1) at which the value should be taken
                 * @param   {DG.Tweening.Ease}       easeType              The type of ease
                 * @return  {UnityEngine.Vector3}
                 */
                EasedValue$4: function (from, to, lifetimePercentage, easeType) {
if ( TRACE ) { TRACE( "DG.Tweening.DOVirtual#EasedValue$4", this ); }

                    return from.$clone().add( (to.$clone().sub( from )).clone().scale( DG.Tweening.Core.Easing.EaseManager.Evaluate(easeType, null, lifetimePercentage, 1, DG.Tweening.DOTween.defaultEaseOvershootOrAmplitude, DG.Tweening.DOTween.defaultEasePeriod) ) );
                },
                /*DG.Tweening.DOVirtual.EasedValue$4:static end.*/

                /*DG.Tweening.DOVirtual.EasedValue$5:static start.*/
                /**
                 * Returns a value based on the given ease and lifetime percentage (0 to 1)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOVirtual
                 * @memberof DG.Tweening.DOVirtual
                 * @param   {UnityEngine.Vector3}    from                  The value to start from when lifetimePercentage is 0
                 * @param   {UnityEngine.Vector3}    to                    The value to reach when lifetimePercentage is 1
                 * @param   {number}                 lifetimePercentage    The time percentage (0 to 1) at which the value should be taken
                 * @param   {DG.Tweening.Ease}       easeType              The type of ease
                 * @param   {number}                 overshoot             Eventual overshoot to use with Back ease
                 * @return  {UnityEngine.Vector3}
                 */
                EasedValue$5: function (from, to, lifetimePercentage, easeType, overshoot) {
if ( TRACE ) { TRACE( "DG.Tweening.DOVirtual#EasedValue$5", this ); }

                    return from.$clone().add( (to.$clone().sub( from )).clone().scale( DG.Tweening.Core.Easing.EaseManager.Evaluate(easeType, null, lifetimePercentage, 1, overshoot, DG.Tweening.DOTween.defaultEasePeriod) ) );
                },
                /*DG.Tweening.DOVirtual.EasedValue$5:static end.*/

                /*DG.Tweening.DOVirtual.EasedValue$6:static start.*/
                /**
                 * Returns a value based on the given ease and lifetime percentage (0 to 1)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOVirtual
                 * @memberof DG.Tweening.DOVirtual
                 * @param   {UnityEngine.Vector3}    from                  The value to start from when lifetimePercentage is 0
                 * @param   {UnityEngine.Vector3}    to                    The value to reach when lifetimePercentage is 1
                 * @param   {number}                 lifetimePercentage    The time percentage (0 to 1) at which the value should be taken
                 * @param   {DG.Tweening.Ease}       easeType              The type of ease
                 * @param   {number}                 amplitude             Eventual amplitude to use with Elastic easeType
                 * @param   {number}                 period                Eventual period to use with Elastic easeType
                 * @return  {UnityEngine.Vector3}
                 */
                EasedValue$6: function (from, to, lifetimePercentage, easeType, amplitude, period) {
if ( TRACE ) { TRACE( "DG.Tweening.DOVirtual#EasedValue$6", this ); }

                    return from.$clone().add( (to.$clone().sub( from )).clone().scale( DG.Tweening.Core.Easing.EaseManager.Evaluate(easeType, null, lifetimePercentage, 1, amplitude, period) ) );
                },
                /*DG.Tweening.DOVirtual.EasedValue$6:static end.*/

                /*DG.Tweening.DOVirtual.EasedValue$7:static start.*/
                /**
                 * Returns a value based on the given ease and lifetime percentage (0 to 1)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOVirtual
                 * @memberof DG.Tweening.DOVirtual
                 * @param   {UnityEngine.Vector3}    from                  The value to start from when lifetimePercentage is 0
                 * @param   {UnityEngine.Vector3}    to                    The value to reach when lifetimePercentage is 1
                 * @param   {number}                 lifetimePercentage    The time percentage (0 to 1) at which the value should be taken
                 * @param   {pc.AnimationCurve}      easeCurve             The AnimationCurve to use for ease
                 * @return  {UnityEngine.Vector3}
                 */
                EasedValue$7: function (from, to, lifetimePercentage, easeCurve) {
if ( TRACE ) { TRACE( "DG.Tweening.DOVirtual#EasedValue$7", this ); }

                    return from.$clone().add( (to.$clone().sub( from )).clone().scale( DG.Tweening.Core.Easing.EaseManager.Evaluate(DG.Tweening.Ease.INTERNAL_Custom, Bridge.fn.cacheBind(new DG.Tweening.Core.Easing.EaseCurve(easeCurve), new DG.Tweening.Core.Easing.EaseCurve(easeCurve).Evaluate), lifetimePercentage, 1, DG.Tweening.DOTween.defaultEaseOvershootOrAmplitude, DG.Tweening.DOTween.defaultEasePeriod) ) );
                },
                /*DG.Tweening.DOVirtual.EasedValue$7:static end.*/

                /*DG.Tweening.DOVirtual.DelayedCall:static start.*/
                /**
                 * Fires the given callback after the given time.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOVirtual
                 * @memberof DG.Tweening.DOVirtual
                 * @param   {number}                       delay              Callback delay
                 * @param   {DG.Tweening.TweenCallback}    callback           Callback to fire when the delay has expired
                 * @param   {boolean}                      ignoreTimeScale    If TRUE (default) ignores Unity's timeScale
                 * @return  {DG.Tweening.Tween}
                 */
                DelayedCall: function (delay, callback, ignoreTimeScale) {
if ( TRACE ) { TRACE( "DG.Tweening.DOVirtual#DelayedCall", this ); }

                    if (ignoreTimeScale === void 0) { ignoreTimeScale = true; }
                    return DG.Tweening.TweenSettingsExtensions.SetAutoKill$1(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetUpdate$2(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.OnStepComplete(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.AppendInterval(DG.Tweening.DOTween.Sequence(), delay), callback), DG.Tweening.UpdateType.Normal, ignoreTimeScale), true);
                },
                /*DG.Tweening.DOVirtual.DelayedCall:static end.*/


            }
        }
    });
    /*DG.Tweening.DOVirtual end.*/

    /*DG.Tweening.Ease start.*/
    Bridge.define("DG.Tweening.Ease", {
        $kind: 6,
        statics: {
            fields: {
                Unset: 0,
                Linear: 1,
                InSine: 2,
                OutSine: 3,
                InOutSine: 4,
                InQuad: 5,
                OutQuad: 6,
                InOutQuad: 7,
                InCubic: 8,
                OutCubic: 9,
                InOutCubic: 10,
                InQuart: 11,
                OutQuart: 12,
                InOutQuart: 13,
                InQuint: 14,
                OutQuint: 15,
                InOutQuint: 16,
                InExpo: 17,
                OutExpo: 18,
                InOutExpo: 19,
                InCirc: 20,
                OutCirc: 21,
                InOutCirc: 22,
                InElastic: 23,
                OutElastic: 24,
                InOutElastic: 25,
                InBack: 26,
                OutBack: 27,
                InOutBack: 28,
                InBounce: 29,
                OutBounce: 30,
                InOutBounce: 31,
                Flash: 32,
                InFlash: 33,
                OutFlash: 34,
                InOutFlash: 35,
                /**
                 * Don't assign this! It's assigned automatically when creating 0 duration tweens
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.Ease
                 * @constant
                 * @default 36
                 * @type DG.Tweening.Ease
                 */
                INTERNAL_Zero: 36,
                /**
                 * Don't assign this! It's assigned automatically when setting the ease to an AnimationCurve or to a custom ease
                     function
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.Ease
                 * @constant
                 * @default 37
                 * @type DG.Tweening.Ease
                 */
                INTERNAL_Custom: 37
            }
        }
    });
    /*DG.Tweening.Ease end.*/

    /*DG.Tweening.EaseFactory start.*/
    /**
     * Allows to wrap ease method in special ways, adding extra features
     *
     * @public
     * @class DG.Tweening.EaseFactory
     */
    Bridge.define("DG.Tweening.EaseFactory", {
        statics: {
            methods: {
                /*DG.Tweening.EaseFactory.StopMotion$1:static start.*/
                /**
                 * Converts the given ease so that it also creates a stop-motion effect, by playing the tween at the given FPS
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.EaseFactory
                 * @memberof DG.Tweening.EaseFactory
                 * @param   {number}                      motionFps    FPS at which the tween should be played
                 * @param   {?DG.Tweening.Ease}           ease         Ease type
                 * @return  {DG.Tweening.EaseFunction}
                 */
                StopMotion$1: function (motionFps, ease) {
if ( TRACE ) { TRACE( "DG.Tweening.EaseFactory#StopMotion$1", this ); }

                    if (ease === void 0) { ease = null; }
                    var easeFunc = DG.Tweening.Core.Easing.EaseManager.ToEaseFunction(ease == null ? DG.Tweening.DOTween.defaultEaseType : System.Nullable.getValue(ease));
                    return DG.Tweening.EaseFactory.StopMotion(motionFps, easeFunc);
                },
                /*DG.Tweening.EaseFactory.StopMotion$1:static end.*/

                /*DG.Tweening.EaseFactory.StopMotion$2:static start.*/
                /**
                 * Converts the given ease so that it also creates a stop-motion effect, by playing the tween at the given FPS
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.EaseFactory
                 * @memberof DG.Tweening.EaseFactory
                 * @param   {number}                      motionFps    FPS at which the tween should be played
                 * @param   {pc.AnimationCurve}           animCurve    AnimationCurve to use for the ease
                 * @return  {DG.Tweening.EaseFunction}
                 */
                StopMotion$2: function (motionFps, animCurve) {
if ( TRACE ) { TRACE( "DG.Tweening.EaseFactory#StopMotion$2", this ); }

                    return DG.Tweening.EaseFactory.StopMotion(motionFps, Bridge.fn.cacheBind(new DG.Tweening.Core.Easing.EaseCurve(animCurve), new DG.Tweening.Core.Easing.EaseCurve(animCurve).Evaluate));
                },
                /*DG.Tweening.EaseFactory.StopMotion$2:static end.*/

                /*DG.Tweening.EaseFactory.StopMotion:static start.*/
                /**
                 * Converts the given ease so that it also creates a stop-motion effect, by playing the tween at the given FPS
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.EaseFactory
                 * @memberof DG.Tweening.EaseFactory
                 * @param   {number}                      motionFps     FPS at which the tween should be played
                 * @param   {DG.Tweening.EaseFunction}    customEase    Custom ease function to use
                 * @return  {DG.Tweening.EaseFunction}
                 */
                StopMotion: function (motionFps, customEase) {
if ( TRACE ) { TRACE( "DG.Tweening.EaseFactory#StopMotion", this ); }

                    // Compute the time interval in which we must re-evaluate the value
                    var motionDelay = 1.0 / motionFps;

                    return function (time, duration, overshootOrAmplitude, period) {
                        // Adjust the time so it's in steps
                        var steptime = time < duration ? time - time % motionDelay : time;
                        // Evaluate the ease value based on the new step time
                        return customEase(steptime, duration, overshootOrAmplitude, period);
                    };
                },
                /*DG.Tweening.EaseFactory.StopMotion:static end.*/


            }
        }
    });
    /*DG.Tweening.EaseFactory end.*/

    /*DG.Tweening.HandlesDrawMode start.*/
    Bridge.define("DG.Tweening.HandlesDrawMode", {
        $kind: 6,
        statics: {
            fields: {
                Orthographic: 0,
                Perspective: 1
            }
        }
    });
    /*DG.Tweening.HandlesDrawMode end.*/

    /*DG.Tweening.HandlesType start.*/
    Bridge.define("DG.Tweening.HandlesType", {
        $kind: 6,
        statics: {
            fields: {
                Free: 0,
                Full: 1
            }
        }
    });
    /*DG.Tweening.HandlesType end.*/

    /*DG.Tweening.LinkBehaviour start.*/
    /**
     * Behaviour that can be assigned when chaining a SetLink to a tween
     *
     * @public
     * @class DG.Tweening.LinkBehaviour
     */
    Bridge.define("DG.Tweening.LinkBehaviour", {
        $kind: 6,
        statics: {
            fields: {
                /**
                 * Pauses the tween when the link target is disabled
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.LinkBehaviour
                 * @constant
                 * @default 0
                 * @type DG.Tweening.LinkBehaviour
                 */
                PauseOnDisable: 0,
                /**
                 * Pauses the tween when the link target is disabled, plays it when it's enabled
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.LinkBehaviour
                 * @constant
                 * @default 1
                 * @type DG.Tweening.LinkBehaviour
                 */
                PauseOnDisablePlayOnEnable: 1,
                /**
                 * Pauses the tween when the link target is disabled, restarts it when it's enabled
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.LinkBehaviour
                 * @constant
                 * @default 2
                 * @type DG.Tweening.LinkBehaviour
                 */
                PauseOnDisableRestartOnEnable: 2,
                /**
                 * Plays the tween when the link target is enabled
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.LinkBehaviour
                 * @constant
                 * @default 3
                 * @type DG.Tweening.LinkBehaviour
                 */
                PlayOnEnable: 3,
                /**
                 * Restarts the tween when the link target is enabled
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.LinkBehaviour
                 * @constant
                 * @default 4
                 * @type DG.Tweening.LinkBehaviour
                 */
                RestartOnEnable: 4,
                /**
                 * Kills the tween when the link target is disabled
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.LinkBehaviour
                 * @constant
                 * @default 5
                 * @type DG.Tweening.LinkBehaviour
                 */
                KillOnDisable: 5,
                /**
                 * Kills the tween when the link target is destroyed (becomes NULL). This is always active even if another
                     behaviour is chosen
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.LinkBehaviour
                 * @constant
                 * @default 6
                 * @type DG.Tweening.LinkBehaviour
                 */
                KillOnDestroy: 6,
                /**
                 * Completes the tween when the link target is disabled
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.LinkBehaviour
                 * @constant
                 * @default 7
                 * @type DG.Tweening.LinkBehaviour
                 */
                CompleteOnDisable: 7,
                /**
                 * Completes and kills the tween when the link target is disabled
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.LinkBehaviour
                 * @constant
                 * @default 8
                 * @type DG.Tweening.LinkBehaviour
                 */
                CompleteAndKillOnDisable: 8,
                /**
                 * Rewinds the tween (delay excluded) when the link target is disabled
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.LinkBehaviour
                 * @constant
                 * @default 9
                 * @type DG.Tweening.LinkBehaviour
                 */
                RewindOnDisable: 9,
                /**
                 * Rewinds and kills the tween when the link target is disabled
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.LinkBehaviour
                 * @constant
                 * @default 10
                 * @type DG.Tweening.LinkBehaviour
                 */
                RewindAndKillOnDisable: 10
            }
        }
    });
    /*DG.Tweening.LinkBehaviour end.*/

    /*DG.Tweening.LogBehaviour start.*/
    /**
     * Types of log behaviours
     *
     * @public
     * @class DG.Tweening.LogBehaviour
     */
    Bridge.define("DG.Tweening.LogBehaviour", {
        $kind: 6,
        statics: {
            fields: {
                /**
                 * Log only warnings and errors
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.LogBehaviour
                 * @constant
                 * @default 0
                 * @type DG.Tweening.LogBehaviour
                 */
                Default: 0,
                /**
                 * Log warnings, errors and additional infos
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.LogBehaviour
                 * @constant
                 * @default 1
                 * @type DG.Tweening.LogBehaviour
                 */
                Verbose: 1,
                /**
                 * Log only errors
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.LogBehaviour
                 * @constant
                 * @default 2
                 * @type DG.Tweening.LogBehaviour
                 */
                ErrorsOnly: 2
            }
        }
    });
    /*DG.Tweening.LogBehaviour end.*/

    /*DG.Tweening.LoopType start.*/
    /**
     * Types of loop
     *
     * @public
     * @class DG.Tweening.LoopType
     */
    Bridge.define("DG.Tweening.LoopType", {
        $kind: 6,
        statics: {
            fields: {
                /**
                 * Each loop cycle restarts from the beginning
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.LoopType
                 * @constant
                 * @default 0
                 * @type DG.Tweening.LoopType
                 */
                Restart: 0,
                /**
                 * The tween moves forward and backwards at alternate cycles
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.LoopType
                 * @constant
                 * @default 1
                 * @type DG.Tweening.LoopType
                 */
                Yoyo: 1,
                /**
                 * Continuously increments the tween at the end of each loop cycle (A to B, B to B+(A-B), and so on), thus always
                     moving "onward".
                     <p>In case of String tweens works only if the tween is set as relative</p>
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.LoopType
                 * @constant
                 * @default 2
                 * @type DG.Tweening.LoopType
                 */
                Incremental: 2
            }
        }
    });
    /*DG.Tweening.LoopType end.*/

    /*DG.Tweening.PathMode start.*/
    /**
     * Path mode (used to determine correct LookAt orientation)
     *
     * @public
     * @class DG.Tweening.PathMode
     */
    Bridge.define("DG.Tweening.PathMode", {
        $kind: 6,
        statics: {
            fields: {
                /**
                 * Ignores the path mode (and thus LookAt behaviour)
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.PathMode
                 * @constant
                 * @default 0
                 * @type DG.Tweening.PathMode
                 */
                Ignore: 0,
                /**
                 * Regular 3D path
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.PathMode
                 * @constant
                 * @default 1
                 * @type DG.Tweening.PathMode
                 */
                Full3D: 1,
                /**
                 * 2D top-down path
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.PathMode
                 * @constant
                 * @default 2
                 * @type DG.Tweening.PathMode
                 */
                TopDown2D: 2,
                /**
                 * 2D side-scroller path
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.PathMode
                 * @constant
                 * @default 3
                 * @type DG.Tweening.PathMode
                 */
                Sidescroller2D: 3
            }
        }
    });
    /*DG.Tweening.PathMode end.*/

    /*DG.Tweening.PathType start.*/
    /**
     * Type of path to use with DOPath tweens
     *
     * @public
     * @class DG.Tweening.PathType
     */
    Bridge.define("DG.Tweening.PathType", {
        $kind: 6,
        statics: {
            fields: {
                /**
                 * Linear, composed of straight segments between each waypoint
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.PathType
                 * @constant
                 * @default 0
                 * @type DG.Tweening.PathType
                 */
                Linear: 0,
                /**
                 * Curved path (which uses Catmull-Rom curves)
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.PathType
                 * @constant
                 * @default 1
                 * @type DG.Tweening.PathType
                 */
                CatmullRom: 1,
                /**
                 * <pre><code>EXPERIMENTAL:</code></pre>Curved path (which uses Cubic Bezier curves, where each point requires two extra
                     control points)
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.PathType
                 * @constant
                 * @default 2
                 * @type DG.Tweening.PathType
                 */
                CubicBezier: 2
            }
        }
    });
    /*DG.Tweening.PathType end.*/

    /*DG.Tweening.Plugins.Core.IPlugSetter$4 start.*/
    Bridge.definei("DG.Tweening.Plugins.Core.IPlugSetter$4", function (T1, T2, TPlugin, TPlugOptions) { return {
        $kind: 3,
        $variance: [0,1,0,1]
    }; });
    /*DG.Tweening.Plugins.Core.IPlugSetter$4 end.*/

    /*DG.Tweening.Plugins.Core.ITPlugin$4 start.*/
    Bridge.definei("DG.Tweening.Plugins.Core.ITPlugin$4", function (T1, T2, TPlugOptions, TPlugin) { return {
        $kind: 3,
        $variance: [0,1,1,0]
    }; });
    /*DG.Tweening.Plugins.Core.ITPlugin$4 end.*/

    /*DG.Tweening.Plugins.Core.PathCore.ABSPathDecoder start.*/
    Bridge.define("DG.Tweening.Plugins.Core.PathCore.ABSPathDecoder");
    /*DG.Tweening.Plugins.Core.PathCore.ABSPathDecoder end.*/

    /*DG.Tweening.Plugins.Core.PathCore.ControlPoint start.*/
    /** @namespace DG.Tweening.Plugins.Core.PathCore */

    /**
     * Path control point
     *
     * @public
     * @class DG.Tweening.Plugins.Core.PathCore.ControlPoint
     */
    Bridge.define("DG.Tweening.Plugins.Core.PathCore.ControlPoint", {
        $kind: 4,
        statics: {
            methods: {
                op_Addition: function (cp, v) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.ControlPoint#op_Addition", this ); }

                    return new DG.Tweening.Plugins.Core.PathCore.ControlPoint.$ctor1(cp.a.$clone().add( v ), cp.b.$clone().add( v ));
                },
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.ControlPoint#getDefaultValue", this ); }
 return new DG.Tweening.Plugins.Core.PathCore.ControlPoint(); }
            }
        },
        fields: {
            a: null,
            b: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.ControlPoint#init", this ); }

                this.a = new UnityEngine.Vector3();
                this.b = new UnityEngine.Vector3();
            },
            $ctor1: function (a, b) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.ControlPoint#$ctor1", this ); }

                this.$initialize();
                this.a = a.$clone();
                this.b = b.$clone();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.ControlPoint#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*DG.Tweening.Plugins.Core.PathCore.ControlPoint.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.ControlPoint#toString", this ); }

                return "[" + this.a + " | " + this.b + "]";
            },
            /*DG.Tweening.Plugins.Core.PathCore.ControlPoint.toString end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.ControlPoint#getHashCode", this ); }

                var h = Bridge.addHash([5256071204, this.a, this.b]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.ControlPoint#equals", this ); }

                if (!Bridge.is(o, DG.Tweening.Plugins.Core.PathCore.ControlPoint)) {
                    return false;
                }
                return Bridge.equals(this.a, o.a) && Bridge.equals(this.b, o.b);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.ControlPoint#$clone", this ); }

                var s = to || new DG.Tweening.Plugins.Core.PathCore.ControlPoint();
                s.a = this.a.$clone();
                s.b = this.b.$clone();
                return s;
            }
        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*DG.Tweening.Plugins.Core.PathCore.ControlPoint end.*/

    /*DG.Tweening.Plugins.Core.PathCore.Path start.*/
    Bridge.define("DG.Tweening.Plugins.Core.PathCore.Path", {
        statics: {
            fields: {
                _catmullRomDecoder: null,
                _linearDecoder: null,
                _cubicBezierDecoder: null
            },
            methods: {
                /*DG.Tweening.Plugins.Core.PathCore.Path.Draw:static start.*/
                Draw: function (p) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.Path#Draw", this ); }

                    if (p.timesTable == null) {
                        return;
                    }

                    var gizmosFadedCol = p.gizmoColor.$clone();
                    gizmosFadedCol.a *= 0.5;
                    UnityEngine.Gizmos.color = p.gizmoColor.$clone();
                    var wpsCount = p.wps.length;

                    if (p._changed || p.type !== DG.Tweening.PathType.Linear && p.nonLinearDrawWps == null) {
                        p._changed = false;
                        if (p.type !== DG.Tweening.PathType.Linear) {
                            // Store draw points
                            DG.Tweening.Plugins.Core.PathCore.Path.RefreshNonLinearDrawWps(p);
                        }
                    }

                    // Draw path
                    var currPt = new UnityEngine.Vector3();
                    var prevPt = new UnityEngine.Vector3();
                    switch (p.type) {
                        case DG.Tweening.PathType.Linear: 
                            prevPt = DG.Tweening.Plugins.Core.PathCore.Path.ConvertToDrawPoint(p.wps[0].$clone(), p.plugOptions.$clone());
                            for (var i = 0; i < wpsCount; ++i) {
                                currPt = DG.Tweening.Plugins.Core.PathCore.Path.ConvertToDrawPoint(p.wps[i].$clone(), p.plugOptions.$clone());
                                UnityEngine.Gizmos.DrawLine(currPt.$clone(), prevPt.$clone());
                                prevPt = currPt.$clone();
                            }
                            break;
                        default:  // Curved
                            prevPt = DG.Tweening.Plugins.Core.PathCore.Path.ConvertToDrawPoint(p.nonLinearDrawWps[0].$clone(), p.plugOptions.$clone());
                            var count = p.nonLinearDrawWps.length;
                            for (var i1 = 1; i1 < count; ++i1) {
                                currPt = DG.Tweening.Plugins.Core.PathCore.Path.ConvertToDrawPoint(p.nonLinearDrawWps[i1].$clone(), p.plugOptions.$clone());
                                UnityEngine.Gizmos.DrawLine(currPt.$clone(), prevPt.$clone());
                                prevPt = currPt.$clone();
                            }
                            break;
                    }

                    UnityEngine.Gizmos.color = gizmosFadedCol.$clone();
                    var spheresSize = 0.075;

                    // Draw path control points
                    for (var i2 = 0; i2 < wpsCount; ++i2) {
                        UnityEngine.Gizmos.DrawSphere(DG.Tweening.Plugins.Core.PathCore.Path.ConvertToDrawPoint(p.wps[i2].$clone(), p.plugOptions.$clone()), spheresSize);
                    }

                    // Draw eventual path lookAt
                    if (!pc.Vec3.equals( p.lookAtPosition, null )) {
                        var lookAtP = System.Nullable.getValue(p.lookAtPosition);
                        UnityEngine.Gizmos.DrawLine(p.targetPosition.$clone(), lookAtP.$clone());
                        UnityEngine.Gizmos.DrawWireSphere(lookAtP.$clone(), spheresSize);
                    }
                },
                /*DG.Tweening.Plugins.Core.PathCore.Path.Draw:static end.*/

                /*DG.Tweening.Plugins.Core.PathCore.Path.ConvertToDrawPoint:static start.*/
                ConvertToDrawPoint: function (wp, plugOptions) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.Path#ConvertToDrawPoint", this ); }

                    if (!plugOptions.useLocalPosition || UnityEngine.Component.op_Equality(plugOptions.parent, null)) {
                        return wp.$clone();
                    }

                    return plugOptions.parent.TransformPoint$1(wp);
                },
                /*DG.Tweening.Plugins.Core.PathCore.Path.ConvertToDrawPoint:static end.*/

                /*DG.Tweening.Plugins.Core.PathCore.Path.GetDrawPoints:static start.*/
                GetDrawPoints: function (p, drawSubdivisionsXSegment) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.Path#GetDrawPoints", this ); }

                    var wpsCount = p.wps.length;
                    if (p.type === DG.Tweening.PathType.Linear) {
                        return p.wps;
                    }

                    var gizmosSubdivisions = wpsCount * drawSubdivisionsXSegment;
                    var drawPoints = System.Array.init(gizmosSubdivisions + 1, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                    for (var i = 0; i <= gizmosSubdivisions; ++i) {
                        var perc = i / gizmosSubdivisions;
                        var wp = p.GetPoint(perc);
                        drawPoints[i] = wp.$clone();
                    }

                    return drawPoints;
                },
                /*DG.Tweening.Plugins.Core.PathCore.Path.GetDrawPoints:static end.*/

                /*DG.Tweening.Plugins.Core.PathCore.Path.RefreshNonLinearDrawWps:static start.*/
                RefreshNonLinearDrawWps: function (p) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.Path#RefreshNonLinearDrawWps", this ); }

                    var wpsCount = p.wps.length;

                    var gizmosSubdivisions = wpsCount * 10;
                    if (p.nonLinearDrawWps == null || p.nonLinearDrawWps.length !== gizmosSubdivisions + 1) {
                        p.nonLinearDrawWps = System.Array.init(gizmosSubdivisions + 1, function (){
                            return new UnityEngine.Vector3();
                        }, UnityEngine.Vector3);
                    }

                    for (var i = 0; i <= gizmosSubdivisions; ++i) {
                        var perc = i / gizmosSubdivisions;
                        var wp = p.GetPoint(perc);
                        p.nonLinearDrawWps[i] = wp.$clone();
                    }
                },
                /*DG.Tweening.Plugins.Core.PathCore.Path.RefreshNonLinearDrawWps:static end.*/


            }
        },
        fields: {
            wpLengths: null,
            /**
             * Path waypoints (modified by PathPlugin when setting relative end/change value or by CubicBezierDecoder) and by
                 DOTweenPathInspector
             *
             * @instance
             * @public
             * @memberof DG.Tweening.Plugins.Core.PathCore.Path
             * @type Array.<UnityEngine.Vector3>
             */
            wps: null,
            _changed: false,
            _decoder: null,
            _incrementalClone: null,
            _incrementalIndex: 0,
            addedExtraStartWp: false,
            addedExtraEndWp: false,
            controlPoints: null,
            gizmoColor: null,
            isFinalized: false,
            length: 0,
            lengthsTable: null,
            linearWPIndex: 0,
            lookAtPosition: null,
            nonLinearDrawWps: null,
            plugOptions: null,
            subdivisions: 0,
            subdivisionsXSegment: 0,
            targetPosition: null,
            timesTable: null,
            type: 0
        },
        props: {
            /**
             * Minimum input points necessary to create the path (doesn't correspond to actual waypoints required)
             *
             * @instance
             * @readonly
             * @memberof DG.Tweening.Plugins.Core.PathCore.Path
             * @function minInputWaypoints
             * @type number
             */
            minInputWaypoints: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.Path#minInputWaypoints#get", this ); }

                    return this._decoder.minInputWaypoints;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.Path#init", this ); }

                this.gizmoColor = new UnityEngine.Color();
                this.plugOptions = new DG.Tweening.Plugins.Options.PathOptions();
                this.targetPosition = new UnityEngine.Vector3();
                this.gizmoColor = new pc.Color( 1, 1, 1, 0.7 );
                this.linearWPIndex = -1;
            },
            $ctor1: function (type, waypoints, subdivisionsXSegment, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.Path#$ctor1", this ); }

                if (gizmoColor === void 0) { gizmoColor = null; }

                this.$initialize();
                this.type = type;
                this.subdivisionsXSegment = subdivisionsXSegment;
                if (!pc.Color.equals( gizmoColor, null )) {
                    this.gizmoColor = System.Nullable.getValue(gizmoColor);
                }

                this.AssignWaypoints(waypoints, true);
                this.AssignDecoder(type);

                if (DG.Tweening.Core.TweenManager.isUnityEditor) {
                    DG.Tweening.DOTween.GizmosDelegates.add(Bridge.fn.cacheBind(this, this.Draw));
                }
            },
            ctor: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.Path#ctor", this ); }

                this.$initialize();
                // Used when cloning it
            }
        },
        methods: {
            /*DG.Tweening.Plugins.Core.PathCore.Path.AssignWaypoints start.*/
            AssignWaypoints: function (newWps, cloneWps) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.Path#AssignWaypoints", this ); }

                if (cloneWps === void 0) { cloneWps = false; }
                if (cloneWps) {
                    var count = newWps.length;
                    this.wps = System.Array.init(count, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                    for (var i = 0; i < count; ++i) {
                        this.wps[i] = newWps[i].$clone();
                    }
                } else {
                    this.wps = newWps;
                }
            },
            /*DG.Tweening.Plugins.Core.PathCore.Path.AssignWaypoints end.*/

            /*DG.Tweening.Plugins.Core.PathCore.Path.AssignDecoder start.*/
            AssignDecoder: function (pathType) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.Path#AssignDecoder", this ); }

                this.type = pathType;
                switch (pathType) {
                    case DG.Tweening.PathType.Linear: 
                        if (DG.Tweening.Plugins.Core.PathCore.Path._linearDecoder == null) {
                            DG.Tweening.Plugins.Core.PathCore.Path._linearDecoder = new DG.Tweening.Plugins.Core.PathCore.LinearDecoder();
                        }
                        this._decoder = DG.Tweening.Plugins.Core.PathCore.Path._linearDecoder;
                        break;
                    case DG.Tweening.PathType.CubicBezier: 
                        if (DG.Tweening.Plugins.Core.PathCore.Path._cubicBezierDecoder == null) {
                            DG.Tweening.Plugins.Core.PathCore.Path._cubicBezierDecoder = new DG.Tweening.Plugins.Core.PathCore.CubicBezierDecoder();
                        }
                        this._decoder = DG.Tweening.Plugins.Core.PathCore.Path._cubicBezierDecoder;
                        break;
                    default:  // Catmull-Rom
                        if (DG.Tweening.Plugins.Core.PathCore.Path._catmullRomDecoder == null) {
                            DG.Tweening.Plugins.Core.PathCore.Path._catmullRomDecoder = new DG.Tweening.Plugins.Core.PathCore.CatmullRomDecoder();
                        }
                        this._decoder = DG.Tweening.Plugins.Core.PathCore.Path._catmullRomDecoder;
                        break;
                }
            },
            /*DG.Tweening.Plugins.Core.PathCore.Path.AssignDecoder end.*/

            /*DG.Tweening.Plugins.Core.PathCore.Path.Draw start.*/
            Draw: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.Path#Draw", this ); }

                DG.Tweening.Plugins.Core.PathCore.Path.Draw(this);
            },
            /*DG.Tweening.Plugins.Core.PathCore.Path.Draw end.*/

            /*DG.Tweening.Plugins.Core.PathCore.Path.FinalizePath start.*/
            FinalizePath: function (isClosedPath, lockPositionAxes, currTargetVal) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.Path#FinalizePath", this ); }

                // Rebuild path to lock eventual axes
                if (lockPositionAxes !== DG.Tweening.AxisConstraint.None) {
                    var lockX = (lockPositionAxes & DG.Tweening.AxisConstraint.X) === DG.Tweening.AxisConstraint.X;
                    var lockY = (lockPositionAxes & DG.Tweening.AxisConstraint.Y) === DG.Tweening.AxisConstraint.Y;
                    var lockZ = (lockPositionAxes & DG.Tweening.AxisConstraint.Z) === DG.Tweening.AxisConstraint.Z;
                    for (var i = 0; i < this.wps.length; ++i) {
                        var pt = this.wps[i].$clone();
                        this.wps[i] = new pc.Vec3( lockX ? currTargetVal.x : pt.x, lockY ? currTargetVal.y : pt.y, lockZ ? currTargetVal.z : pt.z );
                    }
                }

                this._decoder.FinalizePath(this, this.wps, isClosedPath);
                this.isFinalized = true;
            },
            /*DG.Tweening.Plugins.Core.PathCore.Path.FinalizePath end.*/

            /*DG.Tweening.Plugins.Core.PathCore.Path.GetPoint start.*/
            /**
             * Gets the point on the path at the given percentage (0 to 1)
             *
             * @instance
             * @this DG.Tweening.Plugins.Core.PathCore.Path
             * @memberof DG.Tweening.Plugins.Core.PathCore.Path
             * @param   {number}                 perc                     The percentage (0 to 1) at which to get the point
             * @param   {boolean}                convertToConstantPerc    If TRUE constant speed is taken into account, otherwise not
             * @return  {UnityEngine.Vector3}
             */
            GetPoint: function (perc, convertToConstantPerc) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.Path#GetPoint", this ); }

                if (convertToConstantPerc === void 0) { convertToConstantPerc = false; }
                if (convertToConstantPerc) {
                    perc = this.ConvertToConstantPathPerc(perc);
                }

                return this._decoder.GetPoint(perc, this.wps, this, this.controlPoints);
            },
            /*DG.Tweening.Plugins.Core.PathCore.Path.GetPoint end.*/

            /*DG.Tweening.Plugins.Core.PathCore.Path.ConvertToConstantPathPerc start.*/
            ConvertToConstantPathPerc: function (perc) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.Path#ConvertToConstantPathPerc", this ); }

                if (this.type === DG.Tweening.PathType.Linear) {
                    return perc;
                }

                if (perc > 0 && perc < 1) {
                    if (this.length <= 0) {
                        return perc; // Fix bug in case of 0-length path
                    }

                    var tLen = this.length * perc;
                    // Find point in time/length table
                    var t0 = 0, l0 = 0, t1 = 0, l1 = 0;
                    var count = this.lengthsTable.length;
                    for (var i = 0; i < count; ++i) {
                        if (this.lengthsTable[i] > tLen) {
                            t1 = this.timesTable[i];
                            l1 = this.lengthsTable[i];
                            if (i > 0) {
                                l0 = this.lengthsTable[i - 1];
                            }

                            break;
                        }

                        t0 = this.timesTable[i];
                    }

                    // Find correct time
                    perc = t0 + (tLen - l0) / (l1 - l0) * (t1 - t0);
                }

                // Clamp value because path has limited range of 0-1
                if (perc > 1) {
                    perc = 1;
                } else if (perc < 0) {
                    perc = 0;
                }

                return perc;
            },
            /*DG.Tweening.Plugins.Core.PathCore.Path.ConvertToConstantPathPerc end.*/

            /*DG.Tweening.Plugins.Core.PathCore.Path.GetWaypointIndexFromPerc start.*/
            GetWaypointIndexFromPerc: function (perc, isMovingForward) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.Path#GetWaypointIndexFromPerc", this ); }

                if (perc >= 1) {
                    return this.wps.length - 1;
                }

                if (perc <= 0) {
                    return 0;
                }

                var totPercLen = this.length * perc;
                var currLen = 0;
                for (var i = 0, count = this.wpLengths.length; i < count; i++) {
                    currLen += this.wpLengths[i];
                    if (i === count - 1) {
                        return isMovingForward ? i - 1 : i;
                    }

                    if (currLen < totPercLen) {
                        continue;
                    }

                    if (currLen > totPercLen) {
                        return isMovingForward ? i - 1 : i;
                    }

                    return i;
                }

                return 0;
            },
            /*DG.Tweening.Plugins.Core.PathCore.Path.GetWaypointIndexFromPerc end.*/

            /*DG.Tweening.Plugins.Core.PathCore.Path.Destroy start.*/
            Destroy: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.Path#Destroy", this ); }

                if (DG.Tweening.Core.TweenManager.isUnityEditor) {
                    DG.Tweening.DOTween.GizmosDelegates.remove(Bridge.fn.cacheBind(this, this.Draw));
                }

                this.wps = null;
                this.wpLengths = (this.timesTable = (this.lengthsTable = null));
                this.nonLinearDrawWps = null;
                this.isFinalized = false;
            },
            /*DG.Tweening.Plugins.Core.PathCore.Path.Destroy end.*/

            /*DG.Tweening.Plugins.Core.PathCore.Path.CloneIncremental start.*/
            CloneIncremental: function (loopIncrement) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.Path#CloneIncremental", this ); }

                if (this._incrementalClone != null) {
                    if (this._incrementalIndex === loopIncrement) {
                        return this._incrementalClone;
                    }

                    this._incrementalClone.Destroy();
                }

                var wpsLen = this.wps.length;
                var diff = this.wps[wpsLen - 1].$clone().sub( this.wps[0] );
                var incrWps = System.Array.init(this.wps.length, function (){
                    return new UnityEngine.Vector3();
                }, UnityEngine.Vector3);
                for (var i = 0; i < wpsLen; ++i) {
                    incrWps[i] = this.wps[i].$clone().add( diff.$clone().clone().scale( loopIncrement ) );
                }

                var cpsLen = this.controlPoints.length;
                var incrCps = System.Array.init(cpsLen, function (){
                    return new DG.Tweening.Plugins.Core.PathCore.ControlPoint();
                }, DG.Tweening.Plugins.Core.PathCore.ControlPoint);
                for (var i1 = 0; i1 < cpsLen; ++i1) {
                    incrCps[i1] = DG.Tweening.Plugins.Core.PathCore.ControlPoint.op_Addition(this.controlPoints[i1].$clone(), diff.$clone().clone().scale( loopIncrement ));
                }

                var incrNonLinearDrawWps = null;
                if (this.nonLinearDrawWps != null) {
                    var nldLen = this.nonLinearDrawWps.length;
                    incrNonLinearDrawWps = System.Array.init(nldLen, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                    for (var i2 = 0; i2 < nldLen; ++i2) {
                        incrNonLinearDrawWps[i2] = this.nonLinearDrawWps[i2].$clone().add( diff.$clone().clone().scale( loopIncrement ) );
                    }
                }

                this._incrementalClone = new DG.Tweening.Plugins.Core.PathCore.Path.ctor();
                this._incrementalIndex = loopIncrement;
                this._incrementalClone.type = this.type;
                this._incrementalClone.subdivisionsXSegment = this.subdivisionsXSegment;
                this._incrementalClone.subdivisions = this.subdivisions;
                this._incrementalClone.wps = incrWps;
                this._incrementalClone.controlPoints = incrCps;
                if (DG.Tweening.Core.TweenManager.isUnityEditor) {
                    DG.Tweening.DOTween.GizmosDelegates.add(Bridge.fn.cacheBind(this._incrementalClone, this._incrementalClone.Draw));
                }

                this._incrementalClone.length = this.length;
                this._incrementalClone.wpLengths = this.wpLengths;
                this._incrementalClone.timesTable = this.timesTable;
                this._incrementalClone.lengthsTable = this.lengthsTable;
                this._incrementalClone._decoder = this._decoder;
                this._incrementalClone.nonLinearDrawWps = incrNonLinearDrawWps;
                this._incrementalClone.targetPosition = this.targetPosition.$clone();
                this._incrementalClone.lookAtPosition = System.Nullable.lift1("$clone", this.lookAtPosition);

                this._incrementalClone.isFinalized = true;
                return this._incrementalClone;
            },
            /*DG.Tweening.Plugins.Core.PathCore.Path.CloneIncremental end.*/


        }
    });
    /*DG.Tweening.Plugins.Core.PathCore.Path end.*/

    /*DG.Tweening.Plugins.Core.PluginsManager start.*/
    Bridge.define("DG.Tweening.Plugins.Core.PluginsManager", {
        statics: {
            fields: {
                _MaxCustomPlugins: 0,
                _floatPlugin: null,
                _doublePlugin: null,
                _intPlugin: null,
                _uintPlugin: null,
                _longPlugin: null,
                _ulongPlugin: null,
                _vector2Plugin: null,
                _vector3Plugin: null,
                _vector4Plugin: null,
                _quaternionPlugin: null,
                _colorPlugin: null,
                _rectPlugin: null,
                _rectOffsetPlugin: null,
                _stringPlugin: null,
                _vector3ArrayPlugin: null,
                _color2Plugin: null,
                _customPlugins: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PluginsManager#init", this ); }

                    this._MaxCustomPlugins = 20;
                }
            },
            methods: {
                /*DG.Tweening.Plugins.Core.PluginsManager.GetDefaultPlugin:static start.*/
                GetDefaultPlugin: function (T1, T2, TPlugOptions) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PluginsManager#GetDefaultPlugin", this ); }

                    var t1 = T1;
                    var t2 = T2;
                    var plugin = null;
                    if (Bridge.referenceEquals(t1, UnityEngine.Vector3) && Bridge.referenceEquals(t1, t2)) {
                        if (DG.Tweening.Plugins.Core.PluginsManager._vector3Plugin == null) {
                            DG.Tweening.Plugins.Core.PluginsManager._vector3Plugin = new DG.Tweening.Plugins.Vector3Plugin();
                        }

                        plugin = DG.Tweening.Plugins.Core.PluginsManager._vector3Plugin;
                    } else if (Bridge.referenceEquals(t1, UnityEngine.Vector3) && Bridge.referenceEquals(t2, System.Array.type(UnityEngine.Vector3))) {
                        if (DG.Tweening.Plugins.Core.PluginsManager._vector3ArrayPlugin == null) {
                            DG.Tweening.Plugins.Core.PluginsManager._vector3ArrayPlugin = new DG.Tweening.Plugins.Vector3ArrayPlugin();
                        }

                        plugin = DG.Tweening.Plugins.Core.PluginsManager._vector3ArrayPlugin;
                    } else if (Bridge.referenceEquals(t1, UnityEngine.Quaternion)) {
                        if (Bridge.referenceEquals(t2, UnityEngine.Quaternion)) {
                            DG.Tweening.Core.Debugger.LogError("Quaternion tweens require a Vector3 endValue");
                        } else {
                            if (DG.Tweening.Plugins.Core.PluginsManager._quaternionPlugin == null) {
                                DG.Tweening.Plugins.Core.PluginsManager._quaternionPlugin = new DG.Tweening.Plugins.QuaternionPlugin();
                            }

                            plugin = DG.Tweening.Plugins.Core.PluginsManager._quaternionPlugin;
                        }
                    } else if (Bridge.referenceEquals(t1, UnityEngine.Vector2)) {
                        if (DG.Tweening.Plugins.Core.PluginsManager._vector2Plugin == null) {
                            DG.Tweening.Plugins.Core.PluginsManager._vector2Plugin = new DG.Tweening.Plugins.Vector2Plugin();
                        }

                        plugin = DG.Tweening.Plugins.Core.PluginsManager._vector2Plugin;
                    } else if (Bridge.referenceEquals(t1, System.Single)) {
                        if (DG.Tweening.Plugins.Core.PluginsManager._floatPlugin == null) {
                            DG.Tweening.Plugins.Core.PluginsManager._floatPlugin = new DG.Tweening.Plugins.FloatPlugin();
                        }

                        plugin = DG.Tweening.Plugins.Core.PluginsManager._floatPlugin;
                    } else if (Bridge.referenceEquals(t1, UnityEngine.Color)) {
                        if (DG.Tweening.Plugins.Core.PluginsManager._colorPlugin == null) {
                            DG.Tweening.Plugins.Core.PluginsManager._colorPlugin = new DG.Tweening.Plugins.ColorPlugin();
                        }

                        plugin = DG.Tweening.Plugins.Core.PluginsManager._colorPlugin;
                    } else if (Bridge.referenceEquals(t1, System.Int32)) {
                        if (DG.Tweening.Plugins.Core.PluginsManager._intPlugin == null) {
                            DG.Tweening.Plugins.Core.PluginsManager._intPlugin = new DG.Tweening.Plugins.IntPlugin();
                        }

                        plugin = DG.Tweening.Plugins.Core.PluginsManager._intPlugin;
                    } else if (Bridge.referenceEquals(t1, UnityEngine.Vector4)) {
                        if (DG.Tweening.Plugins.Core.PluginsManager._vector4Plugin == null) {
                            DG.Tweening.Plugins.Core.PluginsManager._vector4Plugin = new DG.Tweening.Plugins.Vector4Plugin();
                        }

                        plugin = DG.Tweening.Plugins.Core.PluginsManager._vector4Plugin;
                    } else if (Bridge.referenceEquals(t1, UnityEngine.Rect)) {
                        if (DG.Tweening.Plugins.Core.PluginsManager._rectPlugin == null) {
                            DG.Tweening.Plugins.Core.PluginsManager._rectPlugin = new DG.Tweening.Plugins.RectPlugin();
                        }

                        plugin = DG.Tweening.Plugins.Core.PluginsManager._rectPlugin;
                    } else if (Bridge.referenceEquals(t1, UnityEngine.RectOffset)) {
                        if (DG.Tweening.Plugins.Core.PluginsManager._rectOffsetPlugin == null) {
                            DG.Tweening.Plugins.Core.PluginsManager._rectOffsetPlugin = new DG.Tweening.Plugins.RectOffsetPlugin();
                        }

                        plugin = DG.Tweening.Plugins.Core.PluginsManager._rectOffsetPlugin;
                    } else if (Bridge.referenceEquals(t1, System.UInt32)) {
                        if (DG.Tweening.Plugins.Core.PluginsManager._uintPlugin == null) {
                            DG.Tweening.Plugins.Core.PluginsManager._uintPlugin = new DG.Tweening.Plugins.UintPlugin();
                        }

                        plugin = DG.Tweening.Plugins.Core.PluginsManager._uintPlugin;
                    } else if (Bridge.referenceEquals(t1, System.String)) {
                        if (DG.Tweening.Plugins.Core.PluginsManager._stringPlugin == null) {
                            DG.Tweening.Plugins.Core.PluginsManager._stringPlugin = new DG.Tweening.Plugins.StringPlugin();
                        }

                        plugin = DG.Tweening.Plugins.Core.PluginsManager._stringPlugin;
                    } else if (Bridge.referenceEquals(t1, DG.Tweening.Color2)) {
                        if (DG.Tweening.Plugins.Core.PluginsManager._color2Plugin == null) {
                            DG.Tweening.Plugins.Core.PluginsManager._color2Plugin = new DG.Tweening.Plugins.Color2Plugin();
                        }

                        plugin = DG.Tweening.Plugins.Core.PluginsManager._color2Plugin;
                    } else if (Bridge.referenceEquals(t1, System.Int64)) {
                        if (DG.Tweening.Plugins.Core.PluginsManager._longPlugin == null) {
                            DG.Tweening.Plugins.Core.PluginsManager._longPlugin = new DG.Tweening.Plugins.LongPlugin();
                        }

                        plugin = DG.Tweening.Plugins.Core.PluginsManager._longPlugin;
                    } else if (Bridge.referenceEquals(t1, System.UInt64)) {
                        if (DG.Tweening.Plugins.Core.PluginsManager._ulongPlugin == null) {
                            DG.Tweening.Plugins.Core.PluginsManager._ulongPlugin = new DG.Tweening.Plugins.UlongPlugin();
                        }

                        plugin = DG.Tweening.Plugins.Core.PluginsManager._ulongPlugin;
                    } else if (Bridge.referenceEquals(t1, System.Double)) {
                        if (DG.Tweening.Plugins.Core.PluginsManager._doublePlugin == null) {
                            DG.Tweening.Plugins.Core.PluginsManager._doublePlugin = new DG.Tweening.Plugins.DoublePlugin();
                        }

                        plugin = DG.Tweening.Plugins.Core.PluginsManager._doublePlugin;
                    }

                    if (plugin != null) {
                        return Bridge.as(plugin, DG.Tweening.Plugins.Core.ABSTweenPlugin$3(T1,T2,TPlugOptions));
                    }

                    return null;
                },
                /*DG.Tweening.Plugins.Core.PluginsManager.GetDefaultPlugin:static end.*/

                /*DG.Tweening.Plugins.Core.PluginsManager.GetCustomPlugin:static start.*/
                GetCustomPlugin: function (TPlugin, T1, T2, TPlugOptions) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PluginsManager#GetCustomPlugin", this ); }

                    var t = TPlugin;
                    var plugin = { };

                    if (DG.Tweening.Plugins.Core.PluginsManager._customPlugins == null) {
                        DG.Tweening.Plugins.Core.PluginsManager._customPlugins = new (System.Collections.Generic.Dictionary$2(System.Type,DG.Tweening.Plugins.Core.ITweenPlugin)).$ctor4(DG.Tweening.Plugins.Core.PluginsManager._MaxCustomPlugins);
                    } else if (DG.Tweening.Plugins.Core.PluginsManager._customPlugins.tryGetValue(t, plugin)) {
                        return Bridge.as(plugin.v, DG.Tweening.Plugins.Core.ABSTweenPlugin$3(T1,T2,TPlugOptions));
                    }

                    plugin.v = Bridge.createInstance(TPlugin);
                    DG.Tweening.Plugins.Core.PluginsManager._customPlugins.add(t, plugin.v);
                    return Bridge.as(plugin.v, DG.Tweening.Plugins.Core.ABSTweenPlugin$3(T1,T2,TPlugOptions));
                },
                /*DG.Tweening.Plugins.Core.PluginsManager.GetCustomPlugin:static end.*/

                /*DG.Tweening.Plugins.Core.PluginsManager.PurgeAll:static start.*/
                PurgeAll: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PluginsManager#PurgeAll", this ); }

                    DG.Tweening.Plugins.Core.PluginsManager._floatPlugin = null;
                    DG.Tweening.Plugins.Core.PluginsManager._intPlugin = null;
                    DG.Tweening.Plugins.Core.PluginsManager._uintPlugin = null;
                    DG.Tweening.Plugins.Core.PluginsManager._longPlugin = null;
                    DG.Tweening.Plugins.Core.PluginsManager._ulongPlugin = null;
                    DG.Tweening.Plugins.Core.PluginsManager._vector2Plugin = null;
                    DG.Tweening.Plugins.Core.PluginsManager._vector3Plugin = null;
                    DG.Tweening.Plugins.Core.PluginsManager._vector4Plugin = null;
                    DG.Tweening.Plugins.Core.PluginsManager._quaternionPlugin = null;
                    DG.Tweening.Plugins.Core.PluginsManager._colorPlugin = null;
                    DG.Tweening.Plugins.Core.PluginsManager._rectPlugin = null;
                    DG.Tweening.Plugins.Core.PluginsManager._rectOffsetPlugin = null;
                    DG.Tweening.Plugins.Core.PluginsManager._stringPlugin = null;
                    DG.Tweening.Plugins.Core.PluginsManager._vector3ArrayPlugin = null;
                    DG.Tweening.Plugins.Core.PluginsManager._color2Plugin = null;

                    if (DG.Tweening.Plugins.Core.PluginsManager._customPlugins != null) {
                        DG.Tweening.Plugins.Core.PluginsManager._customPlugins.clear();
                    }
                },
                /*DG.Tweening.Plugins.Core.PluginsManager.PurgeAll:static end.*/


            }
        }
    });
    /*DG.Tweening.Plugins.Core.PluginsManager end.*/

    /*DG.Tweening.Plugins.Core.SpecialPluginsUtils start.*/
    Bridge.define("DG.Tweening.Plugins.Core.SpecialPluginsUtils", {
        statics: {
            methods: {
                /*DG.Tweening.Plugins.Core.SpecialPluginsUtils.SetLookAt:static start.*/
                SetLookAt: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.SpecialPluginsUtils#SetLookAt", this ); }

                    var trans = Bridge.as(t.target, UnityEngine.Transform);
                    var towards = t.endValue.$clone();
                    towards = towards.$clone().sub( trans.position.$clone() );
                    switch (t.plugOptions.axisConstraint) {
                        case DG.Tweening.AxisConstraint.X: 
                            towards.x = 0;
                            break;
                        case DG.Tweening.AxisConstraint.Y: 
                            towards.y = 0;
                            break;
                        case DG.Tweening.AxisConstraint.Z: 
                            towards.z = 0;
                            break;
                    }

                    var lookAtRotation = new pc.Quat().setLookAt( towards, t.plugOptions.up ).getPositiveEulerAngles().$clone();
                    t.endValue = lookAtRotation.$clone();
                    return true;
                },
                /*DG.Tweening.Plugins.Core.SpecialPluginsUtils.SetLookAt:static end.*/

                /*DG.Tweening.Plugins.Core.SpecialPluginsUtils.SetPunch:static start.*/
                SetPunch: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.SpecialPluginsUtils#SetPunch", this ); }

                    var startupVal = new UnityEngine.Vector3();
                    try {
                        startupVal = t.getter().$clone();
                    } catch ($e1) {
                        $e1 = System.Exception.create($e1);
                        return false;
                    }

                    // Force specific settings
                    t.isRelative = (t.isSpeedBased = false);
                    t.easeType = DG.Tweening.Ease.OutQuad;
                    t.customEase = null;

                    var len = t.endValue.length;
                    for (var i = 0; i < len; i++) {
                        t.endValue[i] = t.endValue[i].$clone().add( startupVal );
                    }

                    return true;
                },
                /*DG.Tweening.Plugins.Core.SpecialPluginsUtils.SetPunch:static end.*/

                /*DG.Tweening.Plugins.Core.SpecialPluginsUtils.SetShake:static start.*/
                SetShake: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.SpecialPluginsUtils#SetShake", this ); }

                    if (!DG.Tweening.Plugins.Core.SpecialPluginsUtils.SetPunch(t)) {
                        return false;
                    }

                    t.easeType = DG.Tweening.Ease.Linear;
                    return true;
                },
                /*DG.Tweening.Plugins.Core.SpecialPluginsUtils.SetShake:static end.*/

                /*DG.Tweening.Plugins.Core.SpecialPluginsUtils.SetCameraShakePosition:static start.*/
                SetCameraShakePosition: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.SpecialPluginsUtils#SetCameraShakePosition", this ); }

                    if (!DG.Tweening.Plugins.Core.SpecialPluginsUtils.SetShake(t)) {
                        return false;
                    }

                    var target = Bridge.as(t.target, UnityEngine.Camera);
                    if (UnityEngine.Component.op_Equality(target, null)) {
                        return false;
                    }

                    var startupVal = t.getter().$clone();
                    var trans = target.transform;
                    var len = t.endValue.length;
                    for (var i = 0; i < len; i++) {
                        var endVal = t.endValue[i].$clone();
                        t.endValue[i] = trans.localRotation.transformVector( (endVal.$clone().sub( startupVal )) ).add( startupVal );
                    }

                    return true;
                },
                /*DG.Tweening.Plugins.Core.SpecialPluginsUtils.SetCameraShakePosition:static end.*/


            }
        }
    });
    /*DG.Tweening.Plugins.Core.SpecialPluginsUtils end.*/

    /*DG.Tweening.Plugins.Options.OrientType start.*/
    Bridge.define("DG.Tweening.Plugins.Options.OrientType", {
        $kind: 6,
        statics: {
            fields: {
                None: 0,
                ToPath: 1,
                LookAtTransform: 2,
                LookAtPosition: 3
            }
        }
    });
    /*DG.Tweening.Plugins.Options.OrientType end.*/

    /*DG.Tweening.Plugins.StringPluginExtensions start.*/
    Bridge.define("DG.Tweening.Plugins.StringPluginExtensions", {
        statics: {
            fields: {
                ScrambledCharsAll: null,
                ScrambledCharsUppercase: null,
                ScrambledCharsLowercase: null,
                ScrambledCharsNumerals: null,
                _lastRndSeed: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.StringPluginExtensions#init", this ); }

                    this.ScrambledCharsAll = System.Array.init([
                        65, 
                        66, 
                        67, 
                        68, 
                        69, 
                        70, 
                        71, 
                        72, 
                        73, 
                        74, 
                        75, 
                        76, 
                        77, 
                        78, 
                        79, 
                        80, 
                        81, 
                        82, 
                        83, 
                        84, 
                        85, 
                        86, 
                        88, 
                        89, 
                        90, 
                        97, 
                        98, 
                        99, 
                        100, 
                        101, 
                        102, 
                        103, 
                        104, 
                        105, 
                        106, 
                        107, 
                        108, 
                        109, 
                        110, 
                        111, 
                        112, 
                        113, 
                        114, 
                        115, 
                        116, 
                        117, 
                        118, 
                        120, 
                        121, 
                        122, 
                        49, 
                        50, 
                        51, 
                        52, 
                        53, 
                        54, 
                        55, 
                        56, 
                        57, 
                        48
                    ], System.Char);
                    this.ScrambledCharsUppercase = System.Array.init([
                        65, 
                        66, 
                        67, 
                        68, 
                        69, 
                        70, 
                        71, 
                        72, 
                        73, 
                        74, 
                        75, 
                        76, 
                        77, 
                        78, 
                        79, 
                        80, 
                        81, 
                        82, 
                        83, 
                        84, 
                        85, 
                        86, 
                        88, 
                        89, 
                        90
                    ], System.Char);
                    this.ScrambledCharsLowercase = System.Array.init([
                        97, 
                        98, 
                        99, 
                        100, 
                        101, 
                        102, 
                        103, 
                        104, 
                        105, 
                        106, 
                        107, 
                        108, 
                        109, 
                        110, 
                        111, 
                        112, 
                        113, 
                        114, 
                        115, 
                        116, 
                        117, 
                        118, 
                        120, 
                        121, 
                        122
                    ], System.Char);
                    this.ScrambledCharsNumerals = System.Array.init([
                        49, 
                        50, 
                        51, 
                        52, 
                        53, 
                        54, 
                        55, 
                        56, 
                        57, 
                        48
                    ], System.Char);
                },
                ctor: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.StringPluginExtensions#ctor", this ); }

                    DG.Tweening.Plugins.StringPluginExtensions.ScrambleChars(DG.Tweening.Plugins.StringPluginExtensions.ScrambledCharsAll);
                    DG.Tweening.Plugins.StringPluginExtensions.ScrambleChars(DG.Tweening.Plugins.StringPluginExtensions.ScrambledCharsUppercase);
                    DG.Tweening.Plugins.StringPluginExtensions.ScrambleChars(DG.Tweening.Plugins.StringPluginExtensions.ScrambledCharsLowercase);
                    DG.Tweening.Plugins.StringPluginExtensions.ScrambleChars(DG.Tweening.Plugins.StringPluginExtensions.ScrambledCharsNumerals);
                }
            },
            methods: {
                /*DG.Tweening.Plugins.StringPluginExtensions.ScrambleChars:static start.*/
                ScrambleChars: function (chars) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.StringPluginExtensions#ScrambleChars", this ); }

                    // Shuffle chars (uses Knuth shuggle algorithm)
                    var len = chars.length;
                    for (var i = 0; i < len; i++) {
                        var tmp = chars[i];
                        var r = UnityEngine.Random.Range(i, len);
                        chars[i] = chars[r];
                        chars[r] = tmp;
                    }
                },
                /*DG.Tweening.Plugins.StringPluginExtensions.ScrambleChars:static end.*/

                /*DG.Tweening.Plugins.StringPluginExtensions.AppendScrambledChars:static start.*/
                AppendScrambledChars: function (buffer, length, chars) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.StringPluginExtensions#AppendScrambledChars", this ); }

                    if (length <= 0) {
                        return buffer;
                    }

                    // Make sure random seed is different from previous one used
                    var len = chars.length;
                    var rndSeed = DG.Tweening.Plugins.StringPluginExtensions._lastRndSeed;
                    while (rndSeed === DG.Tweening.Plugins.StringPluginExtensions._lastRndSeed) {
                        rndSeed = UnityEngine.Random.Range(0, len);
                    }

                    DG.Tweening.Plugins.StringPluginExtensions._lastRndSeed = rndSeed;
                    // Append
                    for (var i = 0; i < length; ++i) {
                        if (rndSeed >= len) {
                            rndSeed = 0;
                        }

                        buffer.append(String.fromCharCode(chars[rndSeed]));
                        rndSeed += 1;
                    }

                    return buffer;
                },
                /*DG.Tweening.Plugins.StringPluginExtensions.AppendScrambledChars:static end.*/


            }
        }
    });
    /*DG.Tweening.Plugins.StringPluginExtensions end.*/

    /*DG.Tweening.RotateMode start.*/
    /**
     * Rotation mode used with DORotate methods
     *
     * @public
     * @class DG.Tweening.RotateMode
     */
    Bridge.define("DG.Tweening.RotateMode", {
        $kind: 6,
        statics: {
            fields: {
                /**
                 * Fastest way that never rotates beyond 360
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.RotateMode
                 * @constant
                 * @default 0
                 * @type DG.Tweening.RotateMode
                 */
                Fast: 0,
                /**
                 * Fastest way that rotates beyond 360
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.RotateMode
                 * @constant
                 * @default 1
                 * @type DG.Tweening.RotateMode
                 */
                FastBeyond360: 1,
                /**
                 * Adds the given rotation to the transform using world axis and an advanced precision mode
                     (like when using transform.Rotate(Space.World)).
                     <p>In this mode the end value is is always considered relative</p>
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.RotateMode
                 * @constant
                 * @default 2
                 * @type DG.Tweening.RotateMode
                 */
                WorldAxisAdd: 2,
                /**
                 * Adds the given rotation to the transform's local axis
                     (like when rotating an object with the "local" switch enabled in Unity's editor or using
                     transform.Rotate(Space.Self)).
                     <p>In this mode the end value is is always considered relative</p>
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.RotateMode
                 * @constant
                 * @default 3
                 * @type DG.Tweening.RotateMode
                 */
                LocalAxisAdd: 3
            }
        }
    });
    /*DG.Tweening.RotateMode end.*/

    /*DG.Tweening.ScrambleMode start.*/
    /**
     * Type of scramble to apply to string tweens
     *
     * @public
     * @class DG.Tweening.ScrambleMode
     */
    Bridge.define("DG.Tweening.ScrambleMode", {
        $kind: 6,
        statics: {
            fields: {
                /**
                 * No scrambling of characters
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.ScrambleMode
                 * @constant
                 * @default 0
                 * @type DG.Tweening.ScrambleMode
                 */
                None: 0,
                /**
                 * A-Z + a-z + 0-9 characters
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.ScrambleMode
                 * @constant
                 * @default 1
                 * @type DG.Tweening.ScrambleMode
                 */
                All: 1,
                /**
                 * A-Z characters
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.ScrambleMode
                 * @constant
                 * @default 2
                 * @type DG.Tweening.ScrambleMode
                 */
                Uppercase: 2,
                /**
                 * a-z characters
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.ScrambleMode
                 * @constant
                 * @default 3
                 * @type DG.Tweening.ScrambleMode
                 */
                Lowercase: 3,
                /**
                 * 0-9 characters
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.ScrambleMode
                 * @constant
                 * @default 4
                 * @type DG.Tweening.ScrambleMode
                 */
                Numerals: 4,
                /**
                 * Custom characters
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.ScrambleMode
                 * @constant
                 * @default 5
                 * @type DG.Tweening.ScrambleMode
                 */
                Custom: 5
            }
        }
    });
    /*DG.Tweening.ScrambleMode end.*/

    /*DG.Tweening.ShakeRandomnessMode start.*/
    /**
     * Type of randomness to apply to a shake tween
     *
     * @public
     * @class DG.Tweening.ShakeRandomnessMode
     */
    Bridge.define("DG.Tweening.ShakeRandomnessMode", {
        $kind: 6,
        statics: {
            fields: {
                /**
                 * Default, full randomness
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.ShakeRandomnessMode
                 * @constant
                 * @default 0
                 * @type DG.Tweening.ShakeRandomnessMode
                 */
                Full: 0,
                /**
                 * Creates a more balanced randomness that looks more harmonic
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.ShakeRandomnessMode
                 * @constant
                 * @default 1
                 * @type DG.Tweening.ShakeRandomnessMode
                 */
                Harmonic: 1
            }
        }
    });
    /*DG.Tweening.ShakeRandomnessMode end.*/

    /*DG.Tweening.ShortcutExtensions start.*/
    /**
     * Methods that extend known Unity objects and allow to directly create and control tweens from their instances
     *
     * @static
     * @abstract
     * @public
     * @class DG.Tweening.ShortcutExtensions
     */
    Bridge.define("DG.Tweening.ShortcutExtensions", {
        statics: {
            methods: {
                /*DG.Tweening.ShortcutExtensions.DOColor$5:static start.*/
                /**
                 * Tweens a LineRenderer's color to the given value.
                     Also stores the LineRenderer as the tween's target so it can be used for filtered operations.
                     <p>Note that this method requires to also insert the start colors for the tween,
                         since LineRenderers have no way to get them.</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.LineRenderer}    target        
                 * @param   {DG.Tweening.Color2}          startValue    The start value to tween from
                 * @param   {DG.Tweening.Color2}          endValue      The end value to reach
                 * @param   {number}                      duration      The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOColor$5: function (target, startValue, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOColor$5", this ); }

                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(DG.Tweening.Color2,DG.Tweening.Color2,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.DOTween.To$16(function () {
                        return startValue;
                    }, function (x) {
                        target.SetColors(x.ca.$clone(), x.cb.$clone());
                    }, endValue.$clone(), duration), target);
                },
                /*DG.Tweening.ShortcutExtensions.DOColor$5:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOColor:static start.*/
                /**
                 * Tweens a Camera's backgroundColor to the given value.
                     Also stores the camera as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Camera}                target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOColor", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.backgroundColor;
                    }, function (x) {
                        target.backgroundColor = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOColor:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOColor$1:static start.*/
                /**
                 * Tweens a Light's color to the given value.
                     Also stores the light as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Light}                 target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOColor$1", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOColor$1:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOColor$3:static start.*/
                /**
                 * Tweens a Material's color to the given value.
                     Also stores the material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Material}              target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor$3: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOColor$3", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOColor$3:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOColor$4:static start.*/
                /**
                 * Tweens a Material's named color property to the given value.
                     Also stores the material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Material}              target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {string}                            property    The name of the material property to tween (like _Tint or _SpecColor)
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor$4: function (target, endValue, property, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOColor$4", this ); }

                    if (!target.HasProperty$1(property)) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogMissingMaterialProperty$1(property);
                        }

                        return null;
                    }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.GetColor$1(property);
                    }, function (x) {
                        target.SetColor$1(property, x.$clone());
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOColor$4:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOColor$2:static start.*/
                /**
                 * Tweens a Material's named color property with the given ID to the given value.
                     Also stores the material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Material}              target        
                 * @param   {UnityEngine.Color}                 endValue      The end value to reach
                 * @param   {number}                            propertyID    The ID of the material property to tween (also called nameID in Unity's manual)
                 * @param   {number}                            duration      The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor$2: function (target, endValue, propertyID, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOColor$2", this ); }

                    if (!target.HasProperty(propertyID)) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogMissingMaterialProperty(propertyID);
                        }

                        return null;
                    }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.GetColor(propertyID);
                    }, function (x) {
                        target.SetColor(propertyID, x.$clone());
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOColor$2:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOTimeScale:static start.*/
                /**
                 * Tweens a Tween's timeScale to the given value.
                     Also stores the Tween as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {DG.Tweening.Tween}                 target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOTimeScale: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOTimeScale", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.timeScale;
                    }, function (x) {
                        target.timeScale = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOTimeScale:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOAspect:static start.*/
                /**
                 * Tweens a Camera's <pre><code>aspect</code></pre> to the given value.
                     Also stores the camera as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Camera}                target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAspect: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOAspect", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.aspect;
                    }, function (x) {
                        target.aspect = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOAspect:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOFarClipPlane:static start.*/
                /**
                 * Tweens a Camera's <pre><code>farClipPlane</code></pre> to the given value.
                     Also stores the camera as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Camera}                target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFarClipPlane: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOFarClipPlane", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.farClipPlane;
                    }, function (x) {
                        target.farClipPlane = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOFarClipPlane:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOFieldOfView:static start.*/
                /**
                 * Tweens a Camera's <pre><code>fieldOfView</code></pre> to the given value.
                     Also stores the camera as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Camera}                target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFieldOfView: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOFieldOfView", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.fieldOfView;
                    }, function (x) {
                        target.fieldOfView = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOFieldOfView:static end.*/

                /*DG.Tweening.ShortcutExtensions.DONearClipPlane:static start.*/
                /**
                 * Tweens a Camera's <pre><code>nearClipPlane</code></pre> to the given value.
                     Also stores the camera as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Camera}                target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DONearClipPlane: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DONearClipPlane", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.nearClipPlane;
                    }, function (x) {
                        target.nearClipPlane = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DONearClipPlane:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOOrthoSize:static start.*/
                /**
                 * Tweens a Camera's <pre><code>orthographicSize</code></pre> to the given value.
                     Also stores the camera as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Camera}                target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOOrthoSize: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOOrthoSize", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.orthographicSize;
                    }, function (x) {
                        target.orthographicSize = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOOrthoSize:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOPixelRect:static start.*/
                /**
                 * Tweens a Camera's <pre><code>pixelRect</code></pre> to the given value.
                     Also stores the camera as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Camera}                target      
                 * @param   {UnityEngine.Rect}                  endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPixelRect: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOPixelRect", this ); }

                    var t = DG.Tweening.DOTween.To$10(function () {
                        return target.pixelRect;
                    }, function (x) {
                        target.pixelRect = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Rect,UnityEngine.Rect,DG.Tweening.Plugins.Options.RectOptions), t, target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOPixelRect:static end.*/

                /*DG.Tweening.ShortcutExtensions.DORect:static start.*/
                /**
                 * Tweens a Camera's <pre><code>rect</code></pre> to the given value.
                     Also stores the camera as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Camera}                target      
                 * @param   {UnityEngine.Rect}                  endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DORect: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DORect", this ); }

                    var t = DG.Tweening.DOTween.To$10(function () {
                        return target.rect;
                    }, function (x) {
                        target.rect = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Rect,UnityEngine.Rect,DG.Tweening.Plugins.Options.RectOptions), t, target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DORect:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOShakePosition:static start.*/
                /**
                 * Shakes a Camera's localPosition along its relative X Y axes with the given values.
                     Also stores the camera as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Camera}                 target            
                 * @param   {number}                             duration          The duration of the tween
                 * @param   {number}                             strength          The shake strength
                 * @param   {number}                             vibrato           Indicates how much will the shake vibrate
                 * @param   {number}                             randomness        Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware).
                     Setting it to 0 will shake along a single direction.
                 * @param   {boolean}                            fadeOut           If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it
                     will not
                 * @param   {DG.Tweening.ShakeRandomnessMode}    randomnessMode    Randomness mode
                 * @return  {DG.Tweening.Tweener}
                 */
                DOShakePosition: function (target, duration, strength, vibrato, randomness, fadeOut, randomnessMode) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOShakePosition", this ); }

                    if (strength === void 0) { strength = 3.0; }
                    if (vibrato === void 0) { vibrato = 10; }
                    if (randomness === void 0) { randomness = 90.0; }
                    if (fadeOut === void 0) { fadeOut = true; }
                    if (randomnessMode === void 0) { randomnessMode = 0; }
                    if (duration <= 0) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            UnityEngine.Debug.LogWarning$1("DOShakePosition: duration can't be 0, returning NULL without creating a tween");
                        }

                        return null;
                    }

                    return DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Shake(function () {
                        return target.transform.localPosition;
                    }, function (x) {
                        target.transform.localPosition = x.$clone();
                    }, duration, strength, vibrato, randomness, true, fadeOut, randomnessMode), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetCameraShakePosition);
                },
                /*DG.Tweening.ShortcutExtensions.DOShakePosition:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOShakePosition$1:static start.*/
                /**
                 * Shakes a Camera's localPosition along its relative X Y axes with the given values.
                     Also stores the camera as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Camera}                 target            
                 * @param   {number}                             duration          The duration of the tween
                 * @param   {UnityEngine.Vector3}                strength          The shake strength on each axis
                 * @param   {number}                             vibrato           Indicates how much will the shake vibrate
                 * @param   {number}                             randomness        Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware).
                     Setting it to 0 will shake along a single direction.
                 * @param   {boolean}                            fadeOut           If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it
                     will not
                 * @param   {DG.Tweening.ShakeRandomnessMode}    randomnessMode    Randomness mode
                 * @return  {DG.Tweening.Tweener}
                 */
                DOShakePosition$1: function (target, duration, strength, vibrato, randomness, fadeOut, randomnessMode) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOShakePosition$1", this ); }

                    if (vibrato === void 0) { vibrato = 10; }
                    if (randomness === void 0) { randomness = 90.0; }
                    if (fadeOut === void 0) { fadeOut = true; }
                    if (randomnessMode === void 0) { randomnessMode = 0; }
                    if (duration <= 0) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            UnityEngine.Debug.LogWarning$1("DOShakePosition: duration can't be 0, returning NULL without creating a tween");
                        }

                        return null;
                    }

                    return DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Shake$1(function () {
                        return target.transform.localPosition;
                    }, function (x) {
                        target.transform.localPosition = x.$clone();
                    }, duration, strength.$clone(), vibrato, randomness, fadeOut, randomnessMode), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetCameraShakePosition);
                },
                /*DG.Tweening.ShortcutExtensions.DOShakePosition$1:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOShakePosition$2:static start.*/
                /**
                 * Shakes a Transform's localPosition with the given values.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}              target            
                 * @param   {number}                             duration          The duration of the tween
                 * @param   {number}                             strength          The shake strength
                 * @param   {number}                             vibrato           Indicates how much will the shake vibrate
                 * @param   {number}                             randomness        Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware).
                     Setting it to 0 will shake along a single direction.
                 * @param   {boolean}                            snapping          If TRUE the tween will smoothly snap all values to integers
                 * @param   {boolean}                            fadeOut           If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it
                     will not
                 * @param   {DG.Tweening.ShakeRandomnessMode}    randomnessMode
                 * @return  {DG.Tweening.Tweener}
                 */
                DOShakePosition$2: function (target, duration, strength, vibrato, randomness, snapping, fadeOut, randomnessMode) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOShakePosition$2", this ); }

                    if (strength === void 0) { strength = 1.0; }
                    if (vibrato === void 0) { vibrato = 10; }
                    if (randomness === void 0) { randomness = 90.0; }
                    if (snapping === void 0) { snapping = false; }
                    if (fadeOut === void 0) { fadeOut = true; }
                    if (randomnessMode === void 0) { randomnessMode = 0; }
                    if (duration <= 0) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            UnityEngine.Debug.LogWarning$1("DOShakePosition: duration can't be 0, returning NULL without creating a tween");
                        }

                        return null;
                    }

                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Shake(function () {
                        return target.localPosition;
                    }, function (x) {
                        target.localPosition = x.$clone();
                    }, duration, strength, vibrato, randomness, false, fadeOut, randomnessMode), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetShake), snapping);
                },
                /*DG.Tweening.ShortcutExtensions.DOShakePosition$2:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOShakePosition$3:static start.*/
                /**
                 * Shakes a Transform's localPosition with the given values.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}              target            
                 * @param   {number}                             duration          The duration of the tween
                 * @param   {UnityEngine.Vector3}                strength          The shake strength on each axis
                 * @param   {number}                             vibrato           Indicates how much will the shake vibrate
                 * @param   {number}                             randomness        Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware).
                     Setting it to 0 will shake along a single direction.
                 * @param   {boolean}                            snapping          If TRUE the tween will smoothly snap all values to integers
                 * @param   {boolean}                            fadeOut           If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it
                     will not
                 * @param   {DG.Tweening.ShakeRandomnessMode}    randomnessMode    Randomness mode
                 * @return  {DG.Tweening.Tweener}
                 */
                DOShakePosition$3: function (target, duration, strength, vibrato, randomness, snapping, fadeOut, randomnessMode) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOShakePosition$3", this ); }

                    if (vibrato === void 0) { vibrato = 10; }
                    if (randomness === void 0) { randomness = 90.0; }
                    if (snapping === void 0) { snapping = false; }
                    if (fadeOut === void 0) { fadeOut = true; }
                    if (randomnessMode === void 0) { randomnessMode = 0; }
                    if (duration <= 0) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            UnityEngine.Debug.LogWarning$1("DOShakePosition: duration can't be 0, returning NULL without creating a tween");
                        }

                        return null;
                    }

                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Shake$1(function () {
                        return target.localPosition;
                    }, function (x) {
                        target.localPosition = x.$clone();
                    }, duration, strength.$clone(), vibrato, randomness, fadeOut, randomnessMode), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetShake), snapping);
                },
                /*DG.Tweening.ShortcutExtensions.DOShakePosition$3:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOShakeRotation:static start.*/
                /**
                 * Shakes a Camera's localRotation.
                     Also stores the camera as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Camera}                 target            
                 * @param   {number}                             duration          The duration of the tween
                 * @param   {number}                             strength          The shake strength
                 * @param   {number}                             vibrato           Indicates how much will the shake vibrate
                 * @param   {number}                             randomness        Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware).
                     Setting it to 0 will shake along a single direction.
                 * @param   {boolean}                            fadeOut           If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it
                     will not
                 * @param   {DG.Tweening.ShakeRandomnessMode}    randomnessMode    Randomness mode
                 * @return  {DG.Tweening.Tweener}
                 */
                DOShakeRotation: function (target, duration, strength, vibrato, randomness, fadeOut, randomnessMode) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOShakeRotation", this ); }

                    if (strength === void 0) { strength = 90.0; }
                    if (vibrato === void 0) { vibrato = 10; }
                    if (randomness === void 0) { randomness = 90.0; }
                    if (fadeOut === void 0) { fadeOut = true; }
                    if (randomnessMode === void 0) { randomnessMode = 0; }
                    if (duration <= 0) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            UnityEngine.Debug.LogWarning$1("DOShakeRotation: duration can't be 0, returning NULL without creating a tween");
                        }

                        return null;
                    }

                    return DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Shake(function () {
                        return target.transform.localEulerAngles;
                    }, function (x) {
                        target.transform.localRotation = new pc.Quat().setFromEulerAngles_Unity( x.x, x.y, x.z );
                    }, duration, strength, vibrato, randomness, false, fadeOut, randomnessMode), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetShake);
                },
                /*DG.Tweening.ShortcutExtensions.DOShakeRotation:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOShakeRotation$1:static start.*/
                /**
                 * Shakes a Camera's localRotation.
                     Also stores the camera as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Camera}                 target            
                 * @param   {number}                             duration          The duration of the tween
                 * @param   {UnityEngine.Vector3}                strength          The shake strength on each axis
                 * @param   {number}                             vibrato           Indicates how much will the shake vibrate
                 * @param   {number}                             randomness        Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware).
                     Setting it to 0 will shake along a single direction.
                 * @param   {boolean}                            fadeOut           If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it
                     will not
                 * @param   {DG.Tweening.ShakeRandomnessMode}    randomnessMode    Randomness mode
                 * @return  {DG.Tweening.Tweener}
                 */
                DOShakeRotation$1: function (target, duration, strength, vibrato, randomness, fadeOut, randomnessMode) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOShakeRotation$1", this ); }

                    if (vibrato === void 0) { vibrato = 10; }
                    if (randomness === void 0) { randomness = 90.0; }
                    if (fadeOut === void 0) { fadeOut = true; }
                    if (randomnessMode === void 0) { randomnessMode = 0; }
                    if (duration <= 0) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            UnityEngine.Debug.LogWarning$1("DOShakeRotation: duration can't be 0, returning NULL without creating a tween");
                        }

                        return null;
                    }

                    return DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Shake$1(function () {
                        return target.transform.localEulerAngles;
                    }, function (x) {
                        target.transform.localRotation = new pc.Quat().setFromEulerAngles_Unity( x.x, x.y, x.z );
                    }, duration, strength.$clone(), vibrato, randomness, fadeOut, randomnessMode), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetShake);
                },
                /*DG.Tweening.ShortcutExtensions.DOShakeRotation$1:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOShakeRotation$2:static start.*/
                /**
                 * Shakes a Transform's localRotation.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}              target            
                 * @param   {number}                             duration          The duration of the tween
                 * @param   {number}                             strength          The shake strength
                 * @param   {number}                             vibrato           Indicates how much will the shake vibrate
                 * @param   {number}                             randomness        Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware).
                     Setting it to 0 will shake along a single direction.
                 * @param   {boolean}                            fadeOut           If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it
                     will not
                 * @param   {DG.Tweening.ShakeRandomnessMode}    randomnessMode    Randomness mode
                 * @return  {DG.Tweening.Tweener}
                 */
                DOShakeRotation$2: function (target, duration, strength, vibrato, randomness, fadeOut, randomnessMode) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOShakeRotation$2", this ); }

                    if (strength === void 0) { strength = 90.0; }
                    if (vibrato === void 0) { vibrato = 10; }
                    if (randomness === void 0) { randomness = 90.0; }
                    if (fadeOut === void 0) { fadeOut = true; }
                    if (randomnessMode === void 0) { randomnessMode = 0; }
                    if (duration <= 0) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            UnityEngine.Debug.LogWarning$1("DOShakeRotation: duration can't be 0, returning NULL without creating a tween");
                        }

                        return null;
                    }

                    return DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Shake(function () {
                        return target.localEulerAngles;
                    }, function (x) {
                        target.localRotation = new pc.Quat().setFromEulerAngles_Unity( x.x, x.y, x.z );
                    }, duration, strength, vibrato, randomness, false, fadeOut, randomnessMode), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetShake);
                },
                /*DG.Tweening.ShortcutExtensions.DOShakeRotation$2:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOShakeRotation$3:static start.*/
                /**
                 * Shakes a Transform's localRotation.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}              target            
                 * @param   {number}                             duration          The duration of the tween
                 * @param   {UnityEngine.Vector3}                strength          The shake strength on each axis
                 * @param   {number}                             vibrato           Indicates how much will the shake vibrate
                 * @param   {number}                             randomness        Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware).
                     Setting it to 0 will shake along a single direction.
                 * @param   {boolean}                            fadeOut           If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it
                     will not
                 * @param   {DG.Tweening.ShakeRandomnessMode}    randomnessMode    Randomness mode
                 * @return  {DG.Tweening.Tweener}
                 */
                DOShakeRotation$3: function (target, duration, strength, vibrato, randomness, fadeOut, randomnessMode) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOShakeRotation$3", this ); }

                    if (vibrato === void 0) { vibrato = 10; }
                    if (randomness === void 0) { randomness = 90.0; }
                    if (fadeOut === void 0) { fadeOut = true; }
                    if (randomnessMode === void 0) { randomnessMode = 0; }
                    if (duration <= 0) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            UnityEngine.Debug.LogWarning$1("DOShakeRotation: duration can't be 0, returning NULL without creating a tween");
                        }

                        return null;
                    }

                    return DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Shake$1(function () {
                        return target.localEulerAngles;
                    }, function (x) {
                        target.localRotation = new pc.Quat().setFromEulerAngles_Unity( x.x, x.y, x.z );
                    }, duration, strength.$clone(), vibrato, randomness, fadeOut, randomnessMode), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetShake);
                },
                /*DG.Tweening.ShortcutExtensions.DOShakeRotation$3:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOIntensity:static start.*/
                /**
                 * Tweens a Light's intensity to the given value.
                     Also stores the light as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Light}                 target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOIntensity: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOIntensity", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.intensity;
                    }, function (x) {
                        target.intensity = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOIntensity:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOShadowStrength:static start.*/
                /**
                 * Tweens a Light's shadowStrength to the given value.
                     Also stores the light as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Light}                 target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOShadowStrength: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOShadowStrength", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.shadowStrength;
                    }, function (x) {
                        target.shadowStrength = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOShadowStrength:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOFade$1:static start.*/
                /**
                 * Tweens a Material's alpha color to the given value
                     (will have no effect unless your material supports transparency).
                     Also stores the material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Material}              target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOFade$1", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOFade$1:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOFade$2:static start.*/
                /**
                 * Tweens a Material's alpha color to the given value
                     (will have no effect unless your material supports transparency).
                     Also stores the material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Material}              target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {string}                            property    The name of the material property to tween (like _Tint or _SpecColor)
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$2: function (target, endValue, property, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOFade$2", this ); }

                    if (!target.HasProperty$1(property)) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogMissingMaterialProperty$1(property);
                        }

                        return null;
                    }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.GetColor$1(property);
                    }, function (x) {
                        target.SetColor$1(property, x.$clone());
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOFade$2:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOFade:static start.*/
                /**
                 * Tweens a Material's alpha color with the given ID to the given value
                     (will have no effect unless your material supports transparency).
                     Also stores the material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Material}              target        
                 * @param   {number}                            endValue      The end value to reach
                 * @param   {number}                            propertyID    The ID of the material property to tween (also called nameID in Unity's manual)
                 * @param   {number}                            duration      The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade: function (target, endValue, propertyID, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOFade", this ); }

                    if (!target.HasProperty(propertyID)) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogMissingMaterialProperty(propertyID);
                        }

                        return null;
                    }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.GetColor(propertyID);
                    }, function (x) {
                        target.SetColor(propertyID, x.$clone());
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOFade:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOFloat$1:static start.*/
                /**
                 * Tweens a Material's named float property to the given value.
                     Also stores the material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Material}              target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {string}                            property    The name of the material property to tween
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFloat$1: function (target, endValue, property, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOFloat$1", this ); }

                    if (!target.HasProperty$1(property)) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogMissingMaterialProperty$1(property);
                        }

                        return null;
                    }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.GetFloat$1(property);
                    }, function (x) {
                        target.SetFloat$1(property, x);
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOFloat$1:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOFloat:static start.*/
                /**
                 * Tweens a Material's named float property with the given ID to the given value.
                     Also stores the material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Material}              target        
                 * @param   {number}                            endValue      The end value to reach
                 * @param   {number}                            propertyID    The ID of the material property to tween (also called nameID in Unity's manual)
                 * @param   {number}                            duration      The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFloat: function (target, endValue, propertyID, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOFloat", this ); }

                    if (!target.HasProperty(propertyID)) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogMissingMaterialProperty(propertyID);
                        }

                        return null;
                    }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.GetFloat(propertyID);
                    }, function (x) {
                        target.SetFloat(propertyID, x);
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOFloat:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOOffset:static start.*/
                /**
                 * Tweens a Material's texture offset to the given value.
                     Also stores the material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Material}              target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOOffset: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOOffset", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.mainTextureOffset;
                    }, function (x) {
                        target.mainTextureOffset = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOOffset:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOOffset$1:static start.*/
                /**
                 * Tweens a Material's named texture offset property to the given value.
                     Also stores the material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Material}              target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {string}                            property    The name of the material property to tween
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOOffset$1: function (target, endValue, property, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOOffset$1", this ); }

                    if (!target.HasProperty$1(property)) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogMissingMaterialProperty$1(property);
                        }

                        return null;
                    }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.GetTextureOffset$1(property);
                    }, function (x) {
                        target.SetTextureOffset$1(property, x.$clone());
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOOffset$1:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOTiling:static start.*/
                /**
                 * Tweens a Material's texture scale to the given value.
                     Also stores the material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Material}              target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOTiling: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOTiling", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.mainTextureScale;
                    }, function (x) {
                        target.mainTextureScale = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOTiling:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOTiling$1:static start.*/
                /**
                 * Tweens a Material's named texture scale property to the given value.
                     Also stores the material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Material}              target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {string}                            property    The name of the material property to tween
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOTiling$1: function (target, endValue, property, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOTiling$1", this ); }

                    if (!target.HasProperty$1(property)) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogMissingMaterialProperty$1(property);
                        }

                        return null;
                    }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.GetTextureScale$1(property);
                    }, function (x) {
                        target.SetTextureScale$1(property, x.$clone());
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOTiling$1:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOVector$1:static start.*/
                /**
                 * Tweens a Material's named Vector property to the given value.
                     Also stores the material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Material}              target      
                 * @param   {UnityEngine.Vector4}               endValue    The end value to reach
                 * @param   {string}                            property    The name of the material property to tween
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOVector$1: function (target, endValue, property, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOVector$1", this ); }

                    if (!target.HasProperty$1(property)) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogMissingMaterialProperty$1(property);
                        }

                        return null;
                    }

                    var t = DG.Tweening.DOTween.To$13(function () {
                        return target.GetVector$1(property);
                    }, function (x) {
                        target.SetVector$1(property, x.$clone());
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector4,UnityEngine.Vector4,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOVector$1:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOVector:static start.*/
                /**
                 * Tweens a Material's named Vector property with the given ID to the given value.
                     Also stores the material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Material}              target        
                 * @param   {UnityEngine.Vector4}               endValue      The end value to reach
                 * @param   {number}                            propertyID    The ID of the material property to tween (also called nameID in Unity's manual)
                 * @param   {number}                            duration      The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOVector: function (target, endValue, propertyID, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOVector", this ); }

                    if (!target.HasProperty(propertyID)) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogMissingMaterialProperty(propertyID);
                        }

                        return null;
                    }

                    var t = DG.Tweening.DOTween.To$13(function () {
                        return target.GetVector(propertyID);
                    }, function (x) {
                        target.SetVector(propertyID, x.$clone());
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector4,UnityEngine.Vector4,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOVector:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOResize:static start.*/
                /**
                 * Tweens a TrailRenderer's startWidth/endWidth to the given value.
                     Also stores the TrailRenderer as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.TrailRenderer}    target          
                 * @param   {number}                       toStartWidth    The end startWidth to reach
                 * @param   {number}                       toEndWidth      The end endWidth to reach
                 * @param   {number}                       duration        The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOResize: function (target, toStartWidth, toEndWidth, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOResize", this ); }

                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.startWidth, target.endWidth );
                    }, function (x) {
                        target.startWidth = x.x;
                        target.endWidth = x.y;
                    }, new pc.Vec2( toStartWidth, toEndWidth ), duration), target);
                },
                /*DG.Tweening.ShortcutExtensions.DOResize:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOTime:static start.*/
                /**
                 * Tweens a TrailRenderer's time to the given value.
                     Also stores the TrailRenderer as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.TrailRenderer}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOTime: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOTime", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.time;
                    }, function (x) {
                        target.time = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOTime:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOMove:static start.*/
                /**
                 * Tweens a Transform's position to the given value.
                     Also stores the transform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}             target      
                 * @param   {UnityEngine.Vector3}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMove: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOMove", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, function (x) {
                        target.position = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$13(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOMove:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOMoveX:static start.*/
                /**
                 * Tweens a Transform's X position to the given value.
                     Also stores the transform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOMoveX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, function (x) {
                        target.position = x.$clone();
                    }, new pc.Vec3( endValue, 0, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOMoveX:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOMoveY:static start.*/
                /**
                 * Tweens a Transform's Y position to the given value.
                     Also stores the transform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOMoveY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, function (x) {
                        target.position = x.$clone();
                    }, new pc.Vec3( 0, endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOMoveY:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOMoveZ:static start.*/
                /**
                 * Tweens a Transform's Z position to the given value.
                     Also stores the transform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveZ: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOMoveZ", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, function (x) {
                        target.position = x.$clone();
                    }, new pc.Vec3( 0, 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Z, snapping), target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOMoveZ:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOLocalMove:static start.*/
                /**
                 * Tweens a Transform's localPosition to the given value.
                     Also stores the transform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}             target      
                 * @param   {UnityEngine.Vector3}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOLocalMove: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOLocalMove", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.localPosition;
                    }, function (x) {
                        target.localPosition = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$13(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOLocalMove:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOLocalMoveX:static start.*/
                /**
                 * Tweens a Transform's X localPosition to the given value.
                     Also stores the transform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOLocalMoveX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOLocalMoveX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.localPosition;
                    }, function (x) {
                        target.localPosition = x.$clone();
                    }, new pc.Vec3( endValue, 0, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOLocalMoveX:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOLocalMoveY:static start.*/
                /**
                 * Tweens a Transform's Y localPosition to the given value.
                     Also stores the transform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOLocalMoveY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOLocalMoveY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.localPosition;
                    }, function (x) {
                        target.localPosition = x.$clone();
                    }, new pc.Vec3( 0, endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOLocalMoveY:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOLocalMoveZ:static start.*/
                /**
                 * Tweens a Transform's Z localPosition to the given value.
                     Also stores the transform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOLocalMoveZ: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOLocalMoveZ", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.localPosition;
                    }, function (x) {
                        target.localPosition = x.$clone();
                    }, new pc.Vec3( 0, 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Z, snapping), target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOLocalMoveZ:static end.*/

                /*DG.Tweening.ShortcutExtensions.DORotate:static start.*/
                /**
                 * Tweens a Transform's rotation to the given value.
                     Also stores the transform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}             target      
                 * @param   {UnityEngine.Vector3}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {DG.Tweening.RotateMode}            mode        Rotation mode
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DORotate: function (target, endValue, duration, mode) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DORotate", this ); }

                    if (mode === void 0) { mode = 0; }
                    var t = DG.Tweening.DOTween.To$9(function () {
                        return target.rotation;
                    }, function (x) {
                        target.rotation = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), t, target);
                    t.plugOptions.rotateMode = mode;
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DORotate:static end.*/

                /*DG.Tweening.ShortcutExtensions.DORotateQuaternion:static start.*/
                /**
                 * Tweens a Transform's rotation to the given value using pure quaternion values.
                     Also stores the transform as the tween's target so it can be used for filtered operations.
                     <p>PLEASE NOTE: DORotate, which takes Vector3 values, is the preferred rotation method.
                         This method was implemented for very special cases, and doesn't support LoopType.Incremental loops
                         (neither for itself nor if placed inside a LoopType.Incremental Sequence)</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}             target      
                 * @param   {UnityEngine.Quaternion}            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DORotateQuaternion: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DORotateQuaternion", this ); }

                    var t = DG.Tweening.DOTween.To(UnityEngine.Quaternion, UnityEngine.Quaternion, DG.Tweening.Plugins.Options.NoOptions, DG.Tweening.CustomPlugins.PureQuaternionPlugin.Plug(), function () {
                        return target.rotation;
                    }, function (x) {
                        target.rotation = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Quaternion,DG.Tweening.Plugins.Options.NoOptions), t, target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DORotateQuaternion:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOLocalRotate:static start.*/
                /**
                 * Tweens a Transform's localRotation to the given value.
                     Also stores the transform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}             target      
                 * @param   {UnityEngine.Vector3}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {DG.Tweening.RotateMode}            mode        Rotation mode
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOLocalRotate: function (target, endValue, duration, mode) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOLocalRotate", this ); }

                    if (mode === void 0) { mode = 0; }
                    var t = DG.Tweening.DOTween.To$9(function () {
                        return target.localRotation;
                    }, function (x) {
                        target.localRotation = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), t, target);
                    t.plugOptions.rotateMode = mode;
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOLocalRotate:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOLocalRotateQuaternion:static start.*/
                /**
                 * Tweens a Transform's rotation to the given value using pure quaternion values.
                     Also stores the transform as the tween's target so it can be used for filtered operations.
                     <p>PLEASE NOTE: DOLocalRotate, which takes Vector3 values, is the preferred rotation method.
                         This method was implemented for very special cases, and doesn't support LoopType.Incremental loops
                         (neither for itself nor if placed inside a LoopType.Incremental Sequence)</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}             target      
                 * @param   {UnityEngine.Quaternion}            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOLocalRotateQuaternion: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOLocalRotateQuaternion", this ); }

                    var t = DG.Tweening.DOTween.To(UnityEngine.Quaternion, UnityEngine.Quaternion, DG.Tweening.Plugins.Options.NoOptions, DG.Tweening.CustomPlugins.PureQuaternionPlugin.Plug(), function () {
                        return target.localRotation;
                    }, function (x) {
                        target.localRotation = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Quaternion,DG.Tweening.Plugins.Options.NoOptions), t, target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOLocalRotateQuaternion:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOScale$1:static start.*/
                /**
                 * Tweens a Transform's localScale to the given value.
                     Also stores the transform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}             target      
                 * @param   {UnityEngine.Vector3}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOScale$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOScale$1", this ); }

                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.localScale;
                    }, function (x) {
                        target.localScale = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOScale$1:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOScale:static start.*/
                /**
                 * Tweens a Transform's localScale uniformly to the given value.
                     Also stores the transform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOScale: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOScale", this ); }

                    var endValueV3 = new pc.Vec3( endValue, endValue, endValue );
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.localScale;
                    }, function (x) {
                        target.localScale = x.$clone();
                    }, endValueV3.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOScale:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOScaleX:static start.*/
                /**
                 * Tweens a Transform's X localScale to the given value.
                     Also stores the transform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOScaleX: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOScaleX", this ); }

                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.localScale;
                    }, function (x) {
                        target.localScale = x.$clone();
                    }, new pc.Vec3( endValue, 0, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.X), target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOScaleX:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOScaleY:static start.*/
                /**
                 * Tweens a Transform's Y localScale to the given value.
                     Also stores the transform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOScaleY: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOScaleY", this ); }

                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.localScale;
                    }, function (x) {
                        target.localScale = x.$clone();
                    }, new pc.Vec3( 0, endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Y), target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOScaleY:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOScaleZ:static start.*/
                /**
                 * Tweens a Transform's Z localScale to the given value.
                     Also stores the transform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOScaleZ: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOScaleZ", this ); }

                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.localScale;
                    }, function (x) {
                        target.localScale = x.$clone();
                    }, new pc.Vec3( 0, 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Z), target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOScaleZ:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOLookAt:static start.*/
                /**
                 * Tweens a Transform's rotation so that it will look towards the given world position.
                     Also stores the transform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}         target            
                 * @param   {UnityEngine.Vector3}           towards           The position to look at
                 * @param   {number}                        duration          The duration of the tween
                 * @param   {DG.Tweening.AxisConstraint}    axisConstraint    Eventual axis constraint for the rotation
                 * @param   {?UnityEngine.Vector3}          up                The vector that defines in which direction up is (default: Vector3.up)
                 * @return  {DG.Tweening.Tweener}
                 */
                DOLookAt: function (target, towards, duration, axisConstraint, up) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOLookAt", this ); }

                    if (axisConstraint === void 0) { axisConstraint = 0; }
                    if (up === void 0) { up = null; }
                    return DG.Tweening.ShortcutExtensions.LookAt(target, towards.$clone(), duration, axisConstraint, System.Nullable.lift1("$clone", up), false);
                },
                /*DG.Tweening.ShortcutExtensions.DOLookAt:static end.*/

                /*DG.Tweening.ShortcutExtensions.DODynamicLookAt:static start.*/
                /**
                 * <pre><code>EXPERIMENTAL</code></pre> Tweens a Transform's rotation so that it will look towards the given world position,
                     while also updating the lookAt position every frame
                     (contrary to {@link } which calculates the lookAt rotation only once, when the tween starts).
                     Also stores the transform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}         target            
                 * @param   {UnityEngine.Vector3}           towards           The position to look at
                 * @param   {number}                        duration          The duration of the tween
                 * @param   {DG.Tweening.AxisConstraint}    axisConstraint    Eventual axis constraint for the rotation
                 * @param   {?UnityEngine.Vector3}          up                The vector that defines in which direction up is (default: Vector3.up)
                 * @return  {DG.Tweening.Tweener}
                 */
                DODynamicLookAt: function (target, towards, duration, axisConstraint, up) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DODynamicLookAt", this ); }

                    if (axisConstraint === void 0) { axisConstraint = 0; }
                    if (up === void 0) { up = null; }
                    return DG.Tweening.ShortcutExtensions.LookAt(target, towards.$clone(), duration, axisConstraint, System.Nullable.lift1("$clone", up), true);
                },
                /*DG.Tweening.ShortcutExtensions.DODynamicLookAt:static end.*/

                /*DG.Tweening.ShortcutExtensions.LookAt:static start.*/
                LookAt: function (target, towards, duration, axisConstraint, up, dynamic) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#LookAt", this ); }

                    var t = DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.DOTween.To$9(function () {
                        return target.rotation;
                    }, function (x) {
                        target.rotation = x.$clone();
                    }, towards.$clone(), duration), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetLookAt);
                    t.plugOptions.axisConstraint = axisConstraint;
                    t.plugOptions.up = pc.Vec3.equals( up, null ) ? pc.Vec3.UP.clone() : System.Nullable.getValue(up);
                    if (dynamic) {
                        t.plugOptions.dynamicLookAt = true;
                        t.plugOptions.dynamicLookAtWorldPosition = towards.$clone();
                    } else {
                        t.plugOptions.dynamicLookAt = false;
                    }

                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.LookAt:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOPunchPosition:static start.*/
                /**
                 * Punches a Transform's localPosition towards the given direction and then back to the starting one
                     as if it was connected to the starting position via an elastic.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}    target        
                 * @param   {UnityEngine.Vector3}      punch         The direction and strength of the punch (added to the Transform's current position)
                 * @param   {number}                   duration      The duration of the tween
                 * @param   {number}                   vibrato       Indicates how much will the punch vibrate
                 * @param   {number}                   elasticity    Represents how much (0 to 1) the vector will go beyond the starting position when bouncing backwards.
                     1 creates a full oscillation between the punch direction and the opposite direction,
                     while 0 oscillates only between the punch and the start position
                 * @param   {boolean}                  snapping      If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DOPunchPosition: function (target, punch, duration, vibrato, elasticity, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOPunchPosition", this ); }

                    if (vibrato === void 0) { vibrato = 10; }
                    if (elasticity === void 0) { elasticity = 1.0; }
                    if (snapping === void 0) { snapping = false; }
                    if (duration <= 0) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            UnityEngine.Debug.LogWarning$1("DOPunchPosition: duration can't be 0, returning NULL without creating a tween");
                        }

                        return null;
                    }

                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Punch(function () {
                        return target.localPosition;
                    }, function (x) {
                        target.localPosition = x.$clone();
                    }, punch.$clone(), duration, vibrato, elasticity), target), snapping);
                },
                /*DG.Tweening.ShortcutExtensions.DOPunchPosition:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOPunchScale:static start.*/
                /**
                 * Punches a Transform's localScale towards the given size and then back to the starting one
                     as if it was connected to the starting scale via an elastic.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}    target        
                 * @param   {UnityEngine.Vector3}      punch         The punch strength (added to the Transform's current scale)
                 * @param   {number}                   duration      The duration of the tween
                 * @param   {number}                   vibrato       Indicates how much will the punch vibrate
                 * @param   {number}                   elasticity    Represents how much (0 to 1) the vector will go beyond the starting size when bouncing backwards.
                     1 creates a full oscillation between the punch scale and the opposite scale,
                     while 0 oscillates only between the punch scale and the start scale
                 * @return  {DG.Tweening.Tweener}
                 */
                DOPunchScale: function (target, punch, duration, vibrato, elasticity) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOPunchScale", this ); }

                    if (vibrato === void 0) { vibrato = 10; }
                    if (elasticity === void 0) { elasticity = 1.0; }
                    if (duration <= 0) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            UnityEngine.Debug.LogWarning$1("DOPunchScale: duration can't be 0, returning NULL without creating a tween");
                        }

                        return null;
                    }

                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Punch(function () {
                        return target.localScale;
                    }, function (x) {
                        target.localScale = x.$clone();
                    }, punch.$clone(), duration, vibrato, elasticity), target);
                },
                /*DG.Tweening.ShortcutExtensions.DOPunchScale:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOPunchRotation:static start.*/
                /**
                 * Punches a Transform's localRotation towards the given size and then back to the starting one
                     as if it was connected to the starting rotation via an elastic.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}    target        
                 * @param   {UnityEngine.Vector3}      punch         The punch strength (added to the Transform's current rotation)
                 * @param   {number}                   duration      The duration of the tween
                 * @param   {number}                   vibrato       Indicates how much will the punch vibrate
                 * @param   {number}                   elasticity    Represents how much (0 to 1) the vector will go beyond the starting rotation when bouncing backwards.
                     1 creates a full oscillation between the punch rotation and the opposite rotation,
                     while 0 oscillates only between the punch and the start rotation
                 * @return  {DG.Tweening.Tweener}
                 */
                DOPunchRotation: function (target, punch, duration, vibrato, elasticity) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOPunchRotation", this ); }

                    if (vibrato === void 0) { vibrato = 10; }
                    if (elasticity === void 0) { elasticity = 1.0; }
                    if (duration <= 0) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            UnityEngine.Debug.LogWarning$1("DOPunchRotation: duration can't be 0, returning NULL without creating a tween");
                        }

                        return null;
                    }

                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Punch(function () {
                        return target.localEulerAngles;
                    }, function (x) {
                        target.localRotation = new pc.Quat().setFromEulerAngles_Unity( x.x, x.y, x.z );
                    }, punch.$clone(), duration, vibrato, elasticity), target);
                },
                /*DG.Tweening.ShortcutExtensions.DOPunchRotation:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOShakeScale:static start.*/
                /**
                 * Shakes a Transform's localScale.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}              target            
                 * @param   {number}                             duration          The duration of the tween
                 * @param   {number}                             strength          The shake strength
                 * @param   {number}                             vibrato           Indicates how much will the shake vibrate
                 * @param   {number}                             randomness        Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware).
                     Setting it to 0 will shake along a single direction.
                 * @param   {boolean}                            fadeOut           If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it
                     will not
                 * @param   {DG.Tweening.ShakeRandomnessMode}    randomnessMode    Randomness mode
                 * @return  {DG.Tweening.Tweener}
                 */
                DOShakeScale: function (target, duration, strength, vibrato, randomness, fadeOut, randomnessMode) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOShakeScale", this ); }

                    if (strength === void 0) { strength = 1.0; }
                    if (vibrato === void 0) { vibrato = 10; }
                    if (randomness === void 0) { randomness = 90.0; }
                    if (fadeOut === void 0) { fadeOut = true; }
                    if (randomnessMode === void 0) { randomnessMode = 0; }
                    if (duration <= 0) {
                        UnityEngine.Debug.Log(DG.Tweening.Core.Debugger.logPriority);
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            UnityEngine.Debug.LogWarning$1("DOShakeScale: duration can't be 0, returning NULL without creating a tween");
                        }

                        return null;
                    }

                    return DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Shake(function () {
                        return target.localScale;
                    }, function (x) {
                        target.localScale = x.$clone();
                    }, duration, strength, vibrato, randomness, false, fadeOut, randomnessMode), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetShake);
                },
                /*DG.Tweening.ShortcutExtensions.DOShakeScale:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOShakeScale$1:static start.*/
                /**
                 * Shakes a Transform's localScale.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}              target            
                 * @param   {number}                             duration          The duration of the tween
                 * @param   {UnityEngine.Vector3}                strength          The shake strength on each axis
                 * @param   {number}                             vibrato           Indicates how much will the shake vibrate
                 * @param   {number}                             randomness        Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware).
                     Setting it to 0 will shake along a single direction.
                 * @param   {boolean}                            fadeOut           If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it
                     will not
                 * @param   {DG.Tweening.ShakeRandomnessMode}    randomnessMode    Randomness mode
                 * @return  {DG.Tweening.Tweener}
                 */
                DOShakeScale$1: function (target, duration, strength, vibrato, randomness, fadeOut, randomnessMode) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOShakeScale$1", this ); }

                    if (vibrato === void 0) { vibrato = 10; }
                    if (randomness === void 0) { randomness = 90.0; }
                    if (fadeOut === void 0) { fadeOut = true; }
                    if (randomnessMode === void 0) { randomnessMode = 0; }
                    if (duration <= 0) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            UnityEngine.Debug.LogWarning$1("DOShakeScale: duration can't be 0, returning NULL without creating a tween");
                        }

                        return null;
                    }

                    return DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Shake$1(function () {
                        return target.localScale;
                    }, function (x) {
                        target.localScale = x.$clone();
                    }, duration, strength.$clone(), vibrato, randomness, fadeOut, randomnessMode), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetShake);
                },
                /*DG.Tweening.ShortcutExtensions.DOShakeScale$1:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOJump:static start.*/
                /**
                 * Tweens a Transform's position to the given value, while also applying a jump effect along the Y axis.
                     Returns a Sequence instead of a Tweener.
                     Also stores the transform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}    target       
                 * @param   {UnityEngine.Vector3}      endValue     The end value to reach
                 * @param   {number}                   jumpPower    Power of the jump (the max height of the jump is represented by this plus the final Y offset)
                 * @param   {number}                   numJumps     Total number of jumps
                 * @param   {number}                   duration     The duration of the tween
                 * @param   {boolean}                  snapping     If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Sequence}
                 */
                DOJump: function (target, endValue, jumpPower, numJumps, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOJump", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (numJumps < 1) {
                        numJumps = 1;
                    }

                    var startPosY = target.position.y; // Temporary fix for OnStart not being called when using Goto instead of GotoWithCallbacks
                    var offsetY = -1;
                    var offsetYSet = false;

                    // Separate Y Tween so we can elaborate elapsedPercentage on that instead of on the Sequence
                    // (in case users add a delay or other elements to the Sequence)
                    var s = DG.Tweening.DOTween.Sequence();
                    var yTween = DG.Tweening.TweenSettingsExtensions.OnStart(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetRelative(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, function (x) {
                        target.position = x.$clone();
                    }, new pc.Vec3( 0, jumpPower, 0 ), duration / (numJumps * 2)), DG.Tweening.AxisConstraint.Y, snapping), DG.Tweening.Ease.OutQuad)), numJumps * 2, DG.Tweening.LoopType.Yoyo), function () {
                        startPosY = target.position.y;
                    }); // FIXME not called if you only use Goto (and not GotoWithCallbacks)
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, function (x) {
                        target.position = x.$clone();
                    }, new pc.Vec3( endValue.x, 0, 0 ), duration), DG.Tweening.AxisConstraint.X, snapping), DG.Tweening.Ease.Linear)), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, function (x) {
                        target.position = x.$clone();
                    }, new pc.Vec3( 0, 0, endValue.z ), duration), DG.Tweening.AxisConstraint.Z, snapping), DG.Tweening.Ease.Linear)), yTween), target), DG.Tweening.DOTween.defaultEaseType);
                    DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Tween, yTween, function () {
                        if (!offsetYSet) {
                            offsetYSet = true;
                            offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                        }

                        var pos = target.position.$clone();
                        pos.y += DG.Tweening.DOVirtual.EasedValue(0, offsetY, DG.Tweening.TweenExtensions.ElapsedPercentage(yTween), DG.Tweening.Ease.OutQuad);
                        target.position = pos.$clone();
                    });
                    return s;

                    // Old incorrect method
                    //            Sequence s = DOTween.Sequence();
                    //            s.Append(DOTween.To(() => target.position, x => target.position = x, new Vector3(endValue.x, 0, 0), duration)
                    //                    .SetOptions(AxisConstraint.X, snapping).SetEase(Ease.Linear)
                    //                ).Join(DOTween.To(() => target.position, x => target.position = x, new Vector3(0, 0, endValue.z), duration)
                    //                    .SetOptions(AxisConstraint.Z, snapping).SetEase(Ease.Linear)
                    //                ).Join(DOTween.To(() => target.position, x => target.position = x, new Vector3(0, jumpPower, 0), duration / (numJumps * 2))
                    //                    .SetOptions(AxisConstraint.Y, snapping).SetEase(Ease.OutQuad).SetRelative()
                    //                    .SetLoops(numJumps * 2, LoopType.Yoyo)
                    //                ).SetTarget(target).SetEase(DOTween.defaultEaseType)
                    //                .OnUpdate(() => {
                    //                    if (!offsetYSet) {
                    //                        offsetYSet = true;
                    //                        offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                    //                    }
                    //                    Vector3 pos = target.position;
                    //                    Debug.Log(offsetY + " > " + s.ElapsedDirectionalPercentage());
                    //                    pos.y += DOVirtual.EasedValue(0, offsetY, s.ElapsedDirectionalPercentage(), Ease.OutQuad);
                    //                    target.position = pos;
                    //                });
                    //            return s;
                },
                /*DG.Tweening.ShortcutExtensions.DOJump:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOLocalJump:static start.*/
                /**
                 * Tweens a Transform's localPosition to the given value, while also applying a jump effect along the Y axis.
                     Returns a Sequence instead of a Tweener.
                     Also stores the transform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}    target       
                 * @param   {UnityEngine.Vector3}      endValue     The end value to reach
                 * @param   {number}                   jumpPower    Power of the jump (the max height of the jump is represented by this plus the final Y offset)
                 * @param   {number}                   numJumps     Total number of jumps
                 * @param   {number}                   duration     The duration of the tween
                 * @param   {boolean}                  snapping     If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Sequence}
                 */
                DOLocalJump: function (target, endValue, jumpPower, numJumps, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOLocalJump", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (numJumps < 1) {
                        numJumps = 1;
                    }

                    var startPosY = target.localPosition.y; // Temporary fix for OnStart not being called when using Goto instead of GotoWithCallbacks
                    var offsetY = -1;
                    var offsetYSet = false;

                    // Separate Y Tween so we can elaborate elapsedPercentage on that instead of on the Sequence
                    // (in case users add a delay or other elements to the Sequence)
                    var s = DG.Tweening.DOTween.Sequence();
                    var yTween = DG.Tweening.TweenSettingsExtensions.OnStart(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetRelative(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(DG.Tweening.DOTween.To$12(function () {
                        return target.localPosition;
                    }, function (x) {
                        target.localPosition = x.$clone();
                    }, new pc.Vec3( 0, jumpPower, 0 ), duration / (numJumps * 2)), DG.Tweening.AxisConstraint.Y, snapping), DG.Tweening.Ease.OutQuad)), numJumps * 2, DG.Tweening.LoopType.Yoyo), function () {
                        startPosY = target.localPosition.y;
                    }); // FIXME not called if you only use Goto (and not GotoWithCallbacks)
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(DG.Tweening.DOTween.To$12(function () {
                        return target.localPosition;
                    }, function (x) {
                        target.localPosition = x.$clone();
                    }, new pc.Vec3( endValue.x, 0, 0 ), duration), DG.Tweening.AxisConstraint.X, snapping), DG.Tweening.Ease.Linear)), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(DG.Tweening.DOTween.To$12(function () {
                        return target.localPosition;
                    }, function (x) {
                        target.localPosition = x.$clone();
                    }, new pc.Vec3( 0, 0, endValue.z ), duration), DG.Tweening.AxisConstraint.Z, snapping), DG.Tweening.Ease.Linear)), yTween), target), DG.Tweening.DOTween.defaultEaseType);
                    DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Tween, yTween, function () {
                        if (!offsetYSet) {
                            offsetYSet = true;
                            offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                        }

                        var pos = target.localPosition.$clone();
                        pos.y += DG.Tweening.DOVirtual.EasedValue(0, offsetY, DG.Tweening.TweenExtensions.ElapsedPercentage(yTween), DG.Tweening.Ease.OutQuad);
                        target.localPosition = pos.$clone();
                    });
                    return s;

                    // Old incorrect method
                    // if (numJumps < 1) numJumps = 1;
                    // float startPosY = target.localPosition.y;
                    // float offsetY = -1;
                    // bool offsetYSet = false;
                    // Sequence s = DOTween.Sequence();
                    // s.Append(DOTween.To(() => target.localPosition, x => target.localPosition = x, new Vector3(endValue.x, 0, 0), duration)
                    //         .SetOptions(AxisConstraint.X, snapping).SetEase(Ease.Linear)
                    //     ).Join(DOTween.To(() => target.localPosition, x => target.localPosition = x, new Vector3(0, 0, endValue.z), duration)
                    //         .SetOptions(AxisConstraint.Z, snapping).SetEase(Ease.Linear)
                    //     ).Join(DOTween.To(() => target.localPosition, x => target.localPosition = x, new Vector3(0, jumpPower, 0), duration / (numJumps * 2))
                    //         .SetOptions(AxisConstraint.Y, snapping).SetEase(Ease.OutQuad).SetRelative()
                    //         .SetLoops(numJumps * 2, LoopType.Yoyo)
                    //     ).SetTarget(target).SetEase(DOTween.defaultEaseType)
                    //     .OnUpdate(() => {
                    //         if (!offsetYSet) {
                    //             offsetYSet = false;
                    //             offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                    //         }
                    //         Vector3 pos = target.localPosition;
                    //         pos.y += DOVirtual.EasedValue(0, offsetY, s.ElapsedDirectionalPercentage(), Ease.OutQuad);
                    //         target.localPosition = pos;
                    //     });
                    // return s;
                },
                /*DG.Tweening.ShortcutExtensions.DOLocalJump:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOPath$1:static start.*/
                /**
                 * Tweens a Transform's position through the given path waypoints, using the chosen path algorithm.
                     Also stores the transform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}             target        
                 * @param   {Array.<UnityEngine.Vector3>}       path          The waypoints to go through
                 * @param   {number}                            duration      The duration of the tween
                 * @param   {DG.Tweening.PathType}              pathType      The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier
                     (curved with control points)
                 * @param   {DG.Tweening.PathMode}              pathMode      The path mode: 3D, side-scroller 2D, top-down 2D
                 * @param   {number}                            resolution    The resolution of the path (useless in case of Linear paths): higher resolutions make for more detailed curved
                     paths but are more expensive.
                     Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints
                 * @param   {?UnityEngine.Color}                gizmoColor    The color of the path (shown when gizmos are active in the Play panel and the tween is
                     running)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPath$1: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOPath$1", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }

                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return target.position;
                    }, function (x) {
                        target.position = x.$clone();
                    }, new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target);

                    t.plugOptions.mode = pathMode;
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOPath$1:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOPath:static start.*/
                /**
                 * IMPORTANT: Unless you really know what you're doing, you should use the overload that accepts a Vector3 array
                     instead.
                     <p />
                     Tweens a Transform's position via the given path.
                     Also stores the transform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}                     target      
                 * @param   {DG.Tweening.Plugins.Core.PathCore.Path}    path        The path to use
                 * @param   {number}                                    duration    The duration of the tween
                 * @param   {DG.Tweening.PathMode}                      pathMode    The path mode: 3D, side-scroller 2D, top-down 2D
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPath: function (target, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOPath", this ); }

                    if (pathMode === void 0) { pathMode = 1; }
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return target.position;
                    }, function (x) {
                        target.position = x.$clone();
                    }, path, duration), target);

                    t.plugOptions.mode = pathMode;
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOPath:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOLocalPath$1:static start.*/
                /**
                 * Tweens a Transform's localPosition through the given path waypoints, using the chosen path algorithm.
                     Also stores the transform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}             target        
                 * @param   {Array.<UnityEngine.Vector3>}       path          The waypoint to go through
                 * @param   {number}                            duration      The duration of the tween
                 * @param   {DG.Tweening.PathType}              pathType      The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier
                     (curved with control points)
                 * @param   {DG.Tweening.PathMode}              pathMode      The path mode: 3D, side-scroller 2D, top-down 2D
                 * @param   {number}                            resolution    The resolution of the path: higher resolutions make for more detailed curved paths but are more expensive.
                     Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints
                 * @param   {?UnityEngine.Color}                gizmoColor    The color of the path (shown when gizmos are active in the Play panel and the tween is
                     running)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOLocalPath$1: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOLocalPath$1", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }

                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return target.localPosition;
                    }, function (x) {
                        target.localPosition = x.$clone();
                    }, new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target);

                    t.plugOptions.mode = pathMode;
                    t.plugOptions.useLocalPosition = true;
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOLocalPath$1:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOLocalPath:static start.*/
                /**
                 * IMPORTANT: Unless you really know what you're doing, you should use the overload that accepts a Vector3 array
                     instead.
                     <p />
                     Tweens a Transform's localPosition via the given path.
                     Also stores the transform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}                     target      
                 * @param   {DG.Tweening.Plugins.Core.PathCore.Path}    path        The path to use
                 * @param   {number}                                    duration    The duration of the tween
                 * @param   {DG.Tweening.PathMode}                      pathMode    The path mode: 3D, side-scroller 2D, top-down 2D
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOLocalPath: function (target, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOLocalPath", this ); }

                    if (pathMode === void 0) { pathMode = 1; }
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return target.localPosition;
                    }, function (x) {
                        target.localPosition = x.$clone();
                    }, path, duration), target);

                    t.plugOptions.mode = pathMode;
                    t.plugOptions.useLocalPosition = true;
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOLocalPath:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOBlendableColor:static start.*/
                /**
                 * Tweens a Light's color to the given value,
                     in a way that allows other DOBlendableColor tweens to work together on the same target,
                     instead than fight each other as multiple DOColor would do.
                     Also stores the Light as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Light}      target      
                 * @param   {UnityEngine.Color}      endValue    The value to tween to
                 * @param   {number}                 duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOBlendableColor", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.ShortcutExtensions.DOBlendableColor:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOBlendableColor$2:static start.*/
                /**
                 * Tweens a Material's color to the given value,
                     in a way that allows other DOBlendableColor tweens to work together on the same target,
                     instead than fight each other as multiple DOColor would do.
                     Also stores the Material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Material}    target      
                 * @param   {UnityEngine.Color}       endValue    The value to tween to
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor$2: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOBlendableColor$2", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.ShortcutExtensions.DOBlendableColor$2:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOBlendableColor$3:static start.*/
                /**
                 * Tweens a Material's named color property to the given value,
                     in a way that allows other DOBlendableColor tweens to work together on the same target,
                     instead than fight each other as multiple DOColor would do.
                     Also stores the Material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Material}    target      
                 * @param   {UnityEngine.Color}       endValue    The value to tween to
                 * @param   {string}                  property    The name of the material property to tween (like _Tint or _SpecColor)
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor$3: function (target, endValue, property, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOBlendableColor$3", this ); }

                    var $t;
                    if (!target.HasProperty$1(property)) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogMissingMaterialProperty$1(property);
                        }

                        return null;
                    }

                    endValue = ($t = target.GetColor$1(property), new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.SetColor$1(property, ($t1 = target.GetColor$1(property), new pc.Color( $t1.r + diff.r, $t1.g + diff.g, $t1.b + diff.b, $t1.a + diff.a )));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.ShortcutExtensions.DOBlendableColor$3:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOBlendableColor$1:static start.*/
                /**
                 * Tweens a Material's named color property with the given ID to the given value,
                     in a way that allows other DOBlendableColor tweens to work together on the same target,
                     instead than fight each other as multiple DOColor would do.
                     Also stores the Material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Material}    target        
                 * @param   {UnityEngine.Color}       endValue      The value to tween to
                 * @param   {number}                  propertyID    The ID of the material property to tween (also called nameID in Unity's manual)
                 * @param   {number}                  duration      The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor$1: function (target, endValue, propertyID, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOBlendableColor$1", this ); }

                    var $t;
                    if (!target.HasProperty(propertyID)) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogMissingMaterialProperty(propertyID);
                        }

                        return null;
                    }

                    endValue = ($t = target.GetColor(propertyID), new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.SetColor(propertyID, ($t1 = target.GetColor(propertyID), new pc.Color( $t1.r + diff.r, $t1.g + diff.g, $t1.b + diff.b, $t1.a + diff.a )));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.ShortcutExtensions.DOBlendableColor$1:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOBlendableMoveBy:static start.*/
                /**
                 * Tweens a Transform's position BY the given value (as if you chained a <pre><code>SetRelative</code></pre>),
                     in a way that allows other DOBlendableMove tweens to work together on the same target,
                     instead than fight each other as multiple DOMove would do.
                     Also stores the transform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}    target      
                 * @param   {UnityEngine.Vector3}      byValue     The value to tween by
                 * @param   {number}                   duration    The duration of the tween
                 * @param   {boolean}                  snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableMoveBy: function (target, byValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOBlendableMoveBy", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var to = pc.Vec3.ZERO.clone();
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$13(DG.Tweening.Core.Extensions.Blendable(UnityEngine.Vector3, UnityEngine.Vector3, DG.Tweening.Plugins.Options.VectorOptions, DG.Tweening.DOTween.To$12(function () {
                        return to;
                    }, function (x) {
                        var diff = x.$clone().sub( to );
                        to = x.$clone();
                        target.position = target.position.$clone().add( diff.$clone() );
                    }, byValue.$clone(), duration)), snapping), target);
                },
                /*DG.Tweening.ShortcutExtensions.DOBlendableMoveBy:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOBlendableLocalMoveBy:static start.*/
                /**
                 * Tweens a Transform's localPosition BY the given value (as if you chained a <pre><code>SetRelative</code></pre>),
                     in a way that allows other DOBlendableMove tweens to work together on the same target,
                     instead than fight each other as multiple DOMove would do.
                     Also stores the transform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}    target      
                 * @param   {UnityEngine.Vector3}      byValue     The value to tween by
                 * @param   {number}                   duration    The duration of the tween
                 * @param   {boolean}                  snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableLocalMoveBy: function (target, byValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOBlendableLocalMoveBy", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var to = pc.Vec3.ZERO.clone();
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$13(DG.Tweening.Core.Extensions.Blendable(UnityEngine.Vector3, UnityEngine.Vector3, DG.Tweening.Plugins.Options.VectorOptions, DG.Tweening.DOTween.To$12(function () {
                        return to;
                    }, function (x) {
                        var diff = x.$clone().sub( to );
                        to = x.$clone();
                        target.localPosition = target.localPosition.$clone().add( diff.$clone() );
                    }, byValue.$clone(), duration)), snapping), target);
                },
                /*DG.Tweening.ShortcutExtensions.DOBlendableLocalMoveBy:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOBlendableRotateBy:static start.*/
                /**
                 * EXPERIMENTAL METHOD - Tweens a Transform's rotation BY the given value (as if you chained a
                     <pre><code>SetRelative</code></pre>),
                     in a way that allows other DOBlendableRotate tweens to work together on the same target,
                     instead than fight each other as multiple DORotate would do.
                     Also stores the transform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}     target      
                 * @param   {UnityEngine.Vector3}       byValue     The value to tween by
                 * @param   {number}                    duration    The duration of the tween
                 * @param   {DG.Tweening.RotateMode}    mode        Rotation mode
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableRotateBy: function (target, byValue, duration, mode) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOBlendableRotateBy", this ); }

                    if (mode === void 0) { mode = 0; }
                    //            Quaternion to = target.rotation;
                    var to = pc.Quat.IDENTITY.clone();
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Quaternion, UnityEngine.Vector3, DG.Tweening.Plugins.Options.QuaternionOptions, DG.Tweening.DOTween.To$9(function () {
                        return to;
                    }, function (x) {
                        var diff = x.clone().mul( to.clone().invert() );
                        to = x.$clone();
                        var currRot = target.rotation.$clone();
                        target.rotation = currRot.clone().mul( currRot.clone().invert() ).clone().mul( diff ).clone().mul( currRot );
                    }, byValue.$clone(), duration)), target);
                    t.plugOptions.rotateMode = mode;
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOBlendableRotateBy:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOBlendableLocalRotateBy:static start.*/
                /**
                 * EXPERIMENTAL METHOD - Tweens a Transform's lcoalRotation BY the given value (as if you chained a
                     <pre><code>SetRelative</code></pre>),
                     in a way that allows other DOBlendableRotate tweens to work together on the same target,
                     instead than fight each other as multiple DORotate would do.
                     Also stores the transform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}     target      
                 * @param   {UnityEngine.Vector3}       byValue     The value to tween by
                 * @param   {number}                    duration    The duration of the tween
                 * @param   {DG.Tweening.RotateMode}    mode        Rotation mode
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableLocalRotateBy: function (target, byValue, duration, mode) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOBlendableLocalRotateBy", this ); }

                    if (mode === void 0) { mode = 0; }
                    //            Quaternion to = target.localRotation;
                    var to = pc.Quat.IDENTITY.clone();
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Quaternion, UnityEngine.Vector3, DG.Tweening.Plugins.Options.QuaternionOptions, DG.Tweening.DOTween.To$9(function () {
                        return to;
                    }, function (x) {
                        var diff = x.clone().mul( to.clone().invert() );
                        to = x.$clone();
                        var currRot = target.localRotation.$clone();
                        target.localRotation = currRot.clone().mul( currRot.clone().invert() ).clone().mul( diff ).clone().mul( currRot );
                    }, byValue.$clone(), duration)), target);
                    t.plugOptions.rotateMode = mode;
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOBlendableLocalRotateBy:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOBlendablePunchRotation:static start.*/
                /**
                 * Punches a Transform's localRotation BY the given value and then back to the starting one
                     as if it was connected to the starting rotation via an elastic. Does it in a way that allows other
                     DOBlendableRotate tweens to work together on the same target
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}    target        
                 * @param   {UnityEngine.Vector3}      punch         The punch strength (added to the Transform's current rotation)
                 * @param   {number}                   duration      The duration of the tween
                 * @param   {number}                   vibrato       Indicates how much will the punch vibrate
                 * @param   {number}                   elasticity    Represents how much (0 to 1) the vector will go beyond the starting rotation when bouncing backwards.
                     1 creates a full oscillation between the punch rotation and the opposite rotation,
                     while 0 oscillates only between the punch and the start rotation
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendablePunchRotation: function (target, punch, duration, vibrato, elasticity) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOBlendablePunchRotation", this ); }

                    if (vibrato === void 0) { vibrato = 10; }
                    if (elasticity === void 0) { elasticity = 1.0; }
                    if (duration <= 0) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            UnityEngine.Debug.LogWarning$1("DOBlendablePunchRotation: duration can't be 0, returning NULL without creating a tween");
                        }

                        return null;
                    }

                    var to = pc.Vec3.ZERO.clone();
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Vector3, System.Array.type(UnityEngine.Vector3), DG.Tweening.Plugins.Options.Vector3ArrayOptions, DG.Tweening.DOTween.Punch(function () {
                        return to;
                    }, function (v) {
                        var qto = new pc.Quat().setFromEulerAngles_Unity( to.x, to.y, to.z );
                        var qnew = new pc.Quat().setFromEulerAngles_Unity( v.x, v.y, v.z );
                        var diff = qnew.clone().mul( qto.clone().invert() );
                        to = v.$clone();
                        var currRot = target.rotation.$clone();
                        target.rotation = currRot.clone().mul( currRot.clone().invert() ).clone().mul( diff ).clone().mul( currRot );
                    }, punch.$clone(), duration, vibrato, elasticity)), target);
                    return t;
                },
                /*DG.Tweening.ShortcutExtensions.DOBlendablePunchRotation:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOBlendableScaleBy:static start.*/
                /**
                 * Tweens a Transform's localScale BY the given value (as if you chained a <pre><code>SetRelative</code></pre>),
                     in a way that allows other DOBlendableScale tweens to work together on the same target,
                     instead than fight each other as multiple DOScale would do.
                     Also stores the transform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Transform}    target      
                 * @param   {UnityEngine.Vector3}      byValue     The value to tween by
                 * @param   {number}                   duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableScaleBy: function (target, byValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOBlendableScaleBy", this ); }

                    var to = pc.Vec3.ZERO.clone();
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Vector3, UnityEngine.Vector3, DG.Tweening.Plugins.Options.VectorOptions, DG.Tweening.DOTween.To$12(function () {
                        return to;
                    }, function (x) {
                        var diff = x.$clone().sub( to );
                        to = x.$clone();
                        target.localScale = target.localScale.$clone().add( diff.$clone() );
                    }, byValue.$clone(), duration)), target);
                },
                /*DG.Tweening.ShortcutExtensions.DOBlendableScaleBy:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOComplete:static start.*/
                /**
                 * Completes all tweens that have this target as a reference
                     (meaning tweens that were started from this target, or that had this target added as an Id)
                     and returns the total number of tweens completed
                     (meaning the tweens that don't have infinite loops and were not already complete)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Component}    target           
                 * @param   {boolean}                  withCallbacks    For Sequences only: if TRUE also internal Sequence callbacks will be fired,
                     otherwise they will be ignored
                 * @return  {number}
                 */
                DOComplete: function (target, withCallbacks) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOComplete", this ); }

                    if (withCallbacks === void 0) { withCallbacks = false; }
                    return DG.Tweening.DOTween.Complete(target, withCallbacks);
                },
                /*DG.Tweening.ShortcutExtensions.DOComplete:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOComplete$1:static start.*/
                /**
                 * Completes all tweens that have this target as a reference
                     (meaning tweens that were started from this target, or that had this target added as an Id)
                     and returns the total number of tweens completed
                     (meaning the tweens that don't have infinite loops and were not already complete)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Material}    target           
                 * @param   {boolean}                 withCallbacks    For Sequences only: if TRUE also internal Sequence callbacks will be fired,
                     otherwise they will be ignored
                 * @return  {number}
                 */
                DOComplete$1: function (target, withCallbacks) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOComplete$1", this ); }

                    if (withCallbacks === void 0) { withCallbacks = false; }
                    return DG.Tweening.DOTween.Complete(target, withCallbacks);
                },
                /*DG.Tweening.ShortcutExtensions.DOComplete$1:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOKill:static start.*/
                /**
                 * Kills all tweens that have this target as a reference
                     (meaning tweens that were started from this target, or that had this target added as an Id)
                     and returns the total number of tweens killed.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Component}    target      
                 * @param   {boolean}                  complete    If TRUE completes the tween before killing it
                 * @return  {number}
                 */
                DOKill: function (target, complete) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOKill", this ); }

                    if (complete === void 0) { complete = false; }
                    //            int tot = complete ? DOTween.CompleteAndReturnKilledTot(target) : 0;
                    //            return tot + DOTween.Kill(target);
                    return DG.Tweening.DOTween.Kill(target, complete);
                },
                /*DG.Tweening.ShortcutExtensions.DOKill:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOKill$1:static start.*/
                /**
                 * Kills all tweens that have this target as a reference
                     (meaning tweens that were started from this target, or that had this target added as an Id)
                     and returns the total number of tweens killed.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Material}    target      
                 * @param   {boolean}                 complete    If TRUE completes the tween before killing it
                 * @return  {number}
                 */
                DOKill$1: function (target, complete) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOKill$1", this ); }

                    if (complete === void 0) { complete = false; }
                    return DG.Tweening.DOTween.Kill(target, complete);
                },
                /*DG.Tweening.ShortcutExtensions.DOKill$1:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOFlip:static start.*/
                /**
                 * Flips the direction (backwards if it was going forward or viceversa) of all tweens that have this target as a
                     reference
                     (meaning tweens that were started from this target, or that had this target added as an Id)
                     and returns the total number of tweens flipped.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Component}    target
                 * @return  {number}
                 */
                DOFlip: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOFlip", this ); }

                    return DG.Tweening.DOTween.Flip(target);
                },
                /*DG.Tweening.ShortcutExtensions.DOFlip:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOFlip$1:static start.*/
                /**
                 * Flips the direction (backwards if it was going forward or viceversa) of all tweens that have this target as a
                     reference
                     (meaning tweens that were started from this target, or that had this target added as an Id)
                     and returns the total number of tweens flipped.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Material}    target
                 * @return  {number}
                 */
                DOFlip$1: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOFlip$1", this ); }

                    return DG.Tweening.DOTween.Flip(target);
                },
                /*DG.Tweening.ShortcutExtensions.DOFlip$1:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOGoto:static start.*/
                /**
                 * Sends to the given position all tweens that have this target as a reference
                     (meaning tweens that were started from this target, or that had this target added as an Id)
                     and returns the total number of tweens involved.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Component}    target     
                 * @param   {number}                   to         Time position to reach
                     (if higher than the whole tween duration the tween will simply reach its end)
                 * @param   {boolean}                  andPlay    If TRUE will play the tween after reaching the given position, otherwise it will pause it
                 * @return  {number}
                 */
                DOGoto: function (target, to, andPlay) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOGoto", this ); }

                    if (andPlay === void 0) { andPlay = false; }
                    return DG.Tweening.DOTween.Goto(target, to, andPlay);
                },
                /*DG.Tweening.ShortcutExtensions.DOGoto:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOGoto$1:static start.*/
                /**
                 * Sends to the given position all tweens that have this target as a reference
                     (meaning tweens that were started from this target, or that had this target added as an Id)
                     and returns the total number of tweens involved.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Material}    target     
                 * @param   {number}                  to         Time position to reach
                     (if higher than the whole tween duration the tween will simply reach its end)
                 * @param   {boolean}                 andPlay    If TRUE will play the tween after reaching the given position, otherwise it will pause it
                 * @return  {number}
                 */
                DOGoto$1: function (target, to, andPlay) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOGoto$1", this ); }

                    if (andPlay === void 0) { andPlay = false; }
                    return DG.Tweening.DOTween.Goto(target, to, andPlay);
                },
                /*DG.Tweening.ShortcutExtensions.DOGoto$1:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOPause:static start.*/
                /**
                 * Pauses all tweens that have this target as a reference
                     (meaning tweens that were started from this target, or that had this target added as an Id)
                     and returns the total number of tweens paused.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Component}    target
                 * @return  {number}
                 */
                DOPause: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOPause", this ); }

                    return DG.Tweening.DOTween.Pause(target);
                },
                /*DG.Tweening.ShortcutExtensions.DOPause:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOPause$1:static start.*/
                /**
                 * Pauses all tweens that have this target as a reference
                     (meaning tweens that were started from this target, or that had this target added as an Id)
                     and returns the total number of tweens paused.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Material}    target
                 * @return  {number}
                 */
                DOPause$1: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOPause$1", this ); }

                    return DG.Tweening.DOTween.Pause(target);
                },
                /*DG.Tweening.ShortcutExtensions.DOPause$1:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOPlay:static start.*/
                /**
                 * Plays all tweens that have this target as a reference
                     (meaning tweens that were started from this target, or that had this target added as an Id)
                     and returns the total number of tweens played.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Component}    target
                 * @return  {number}
                 */
                DOPlay: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOPlay", this ); }

                    return DG.Tweening.DOTween.Play(target);
                },
                /*DG.Tweening.ShortcutExtensions.DOPlay:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOPlay$1:static start.*/
                /**
                 * Plays all tweens that have this target as a reference
                     (meaning tweens that were started from this target, or that had this target added as an Id)
                     and returns the total number of tweens played.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Material}    target
                 * @return  {number}
                 */
                DOPlay$1: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOPlay$1", this ); }

                    return DG.Tweening.DOTween.Play(target);
                },
                /*DG.Tweening.ShortcutExtensions.DOPlay$1:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOPlayBackwards:static start.*/
                /**
                 * Plays backwards all tweens that have this target as a reference
                     (meaning tweens that were started from this target, or that had this target added as an Id)
                     and returns the total number of tweens played.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Component}    target
                 * @return  {number}
                 */
                DOPlayBackwards: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOPlayBackwards", this ); }

                    return DG.Tweening.DOTween.PlayBackwards(target);
                },
                /*DG.Tweening.ShortcutExtensions.DOPlayBackwards:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOPlayBackwards$1:static start.*/
                /**
                 * Plays backwards all tweens that have this target as a reference
                     (meaning tweens that were started from this target, or that had this target added as an Id)
                     and returns the total number of tweens played.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Material}    target
                 * @return  {number}
                 */
                DOPlayBackwards$1: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOPlayBackwards$1", this ); }

                    return DG.Tweening.DOTween.PlayBackwards(target);
                },
                /*DG.Tweening.ShortcutExtensions.DOPlayBackwards$1:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOPlayForward:static start.*/
                /**
                 * Plays forward all tweens that have this target as a reference
                     (meaning tweens that were started from this target, or that had this target added as an Id)
                     and returns the total number of tweens played.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Component}    target
                 * @return  {number}
                 */
                DOPlayForward: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOPlayForward", this ); }

                    return DG.Tweening.DOTween.PlayForward(target);
                },
                /*DG.Tweening.ShortcutExtensions.DOPlayForward:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOPlayForward$1:static start.*/
                /**
                 * Plays forward all tweens that have this target as a reference
                     (meaning tweens that were started from this target, or that had this target added as an Id)
                     and returns the total number of tweens played.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Material}    target
                 * @return  {number}
                 */
                DOPlayForward$1: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOPlayForward$1", this ); }

                    return DG.Tweening.DOTween.PlayForward(target);
                },
                /*DG.Tweening.ShortcutExtensions.DOPlayForward$1:static end.*/

                /*DG.Tweening.ShortcutExtensions.DORestart:static start.*/
                /**
                 * Restarts all tweens that have this target as a reference
                     (meaning tweens that were started from this target, or that had this target added as an Id)
                     and returns the total number of tweens restarted.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Component}    target          
                 * @param   {boolean}                  includeDelay
                 * @return  {number}
                 */
                DORestart: function (target, includeDelay) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DORestart", this ); }

                    if (includeDelay === void 0) { includeDelay = true; }
                    return DG.Tweening.DOTween.Restart(target, includeDelay);
                },
                /*DG.Tweening.ShortcutExtensions.DORestart:static end.*/

                /*DG.Tweening.ShortcutExtensions.DORestart$1:static start.*/
                /**
                 * Restarts all tweens that have this target as a reference
                     (meaning tweens that were started from this target, or that had this target added as an Id)
                     and returns the total number of tweens restarted.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Material}    target          
                 * @param   {boolean}                 includeDelay
                 * @return  {number}
                 */
                DORestart$1: function (target, includeDelay) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DORestart$1", this ); }

                    if (includeDelay === void 0) { includeDelay = true; }
                    return DG.Tweening.DOTween.Restart(target, includeDelay);
                },
                /*DG.Tweening.ShortcutExtensions.DORestart$1:static end.*/

                /*DG.Tweening.ShortcutExtensions.DORewind:static start.*/
                /**
                 * Rewinds all tweens that have this target as a reference
                     (meaning tweens that were started from this target, or that had this target added as an Id)
                     and returns the total number of tweens rewinded.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Component}    target          
                 * @param   {boolean}                  includeDelay
                 * @return  {number}
                 */
                DORewind: function (target, includeDelay) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DORewind", this ); }

                    if (includeDelay === void 0) { includeDelay = true; }
                    return DG.Tweening.DOTween.Rewind(target, includeDelay);
                },
                /*DG.Tweening.ShortcutExtensions.DORewind:static end.*/

                /*DG.Tweening.ShortcutExtensions.DORewind$1:static start.*/
                /**
                 * Rewinds all tweens that have this target as a reference
                     (meaning tweens that were started from this target, or that had this target added as an Id)
                     and returns the total number of tweens rewinded.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Material}    target          
                 * @param   {boolean}                 includeDelay
                 * @return  {number}
                 */
                DORewind$1: function (target, includeDelay) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DORewind$1", this ); }

                    if (includeDelay === void 0) { includeDelay = true; }
                    return DG.Tweening.DOTween.Rewind(target, includeDelay);
                },
                /*DG.Tweening.ShortcutExtensions.DORewind$1:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOSmoothRewind:static start.*/
                /**
                 * Smoothly rewinds all tweens that have this target as a reference
                     (meaning tweens that were started from this target, or that had this target added as an Id)
                     and returns the total number of tweens rewinded.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Component}    target
                 * @return  {number}
                 */
                DOSmoothRewind: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOSmoothRewind", this ); }

                    return DG.Tweening.DOTween.SmoothRewind(target);
                },
                /*DG.Tweening.ShortcutExtensions.DOSmoothRewind:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOSmoothRewind$1:static start.*/
                /**
                 * Smoothly rewinds all tweens that have this target as a reference
                     (meaning tweens that were started from this target, or that had this target added as an Id)
                     and returns the total number of tweens rewinded.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Material}    target
                 * @return  {number}
                 */
                DOSmoothRewind$1: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOSmoothRewind$1", this ); }

                    return DG.Tweening.DOTween.SmoothRewind(target);
                },
                /*DG.Tweening.ShortcutExtensions.DOSmoothRewind$1:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOTogglePause:static start.*/
                /**
                 * Toggles the paused state (plays if it was paused, pauses if it was playing) of all tweens that have this target as
                     a reference
                     (meaning tweens that were started from this target, or that had this target added as an Id)
                     and returns the total number of tweens involved.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Component}    target
                 * @return  {number}
                 */
                DOTogglePause: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOTogglePause", this ); }

                    return DG.Tweening.DOTween.TogglePause(target);
                },
                /*DG.Tweening.ShortcutExtensions.DOTogglePause:static end.*/

                /*DG.Tweening.ShortcutExtensions.DOTogglePause$1:static start.*/
                /**
                 * Toggles the paused state (plays if it was paused, pauses if it was playing) of all tweens that have this target as
                     a reference
                     (meaning tweens that were started from this target, or that had this target added as an Id)
                     and returns the total number of tweens involved.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.ShortcutExtensions
                 * @memberof DG.Tweening.ShortcutExtensions
                 * @param   {UnityEngine.Material}    target
                 * @return  {number}
                 */
                DOTogglePause$1: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.ShortcutExtensions#DOTogglePause$1", this ); }

                    return DG.Tweening.DOTween.TogglePause(target);
                },
                /*DG.Tweening.ShortcutExtensions.DOTogglePause$1:static end.*/


            }
        }
    });
    /*DG.Tweening.ShortcutExtensions end.*/

    /*DG.Tweening.SpiralMode start.*/
    /**
     * Spiral tween mode
     *
     * @public
     * @class DG.Tweening.SpiralMode
     */
    Bridge.define("DG.Tweening.SpiralMode", {
        $kind: 6,
        statics: {
            fields: {
                /**
                 * The spiral motion will expand outwards for the whole the tween
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.SpiralMode
                 * @constant
                 * @default 0
                 * @type DG.Tweening.SpiralMode
                 */
                Expand: 0,
                /**
                 * The spiral motion will expand outwards for half the tween and then will spiral back to the starting position
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.SpiralMode
                 * @constant
                 * @default 1
                 * @type DG.Tweening.SpiralMode
                 */
                ExpandThenContract: 1
            }
        }
    });
    /*DG.Tweening.SpiralMode end.*/

    /*DG.Tweening.TweenExtensions start.*/
    /**
     * Methods that extend Tween objects and allow to control or get data from them
     *
     * @static
     * @abstract
     * @public
     * @class DG.Tweening.TweenExtensions
     */
    Bridge.define("DG.Tweening.TweenExtensions", {
        statics: {
            methods: {
                /*DG.Tweening.TweenExtensions.Complete:static start.*/
                /**
                 * Completes the tween
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}    t
                 * @return  {void}
                 */
                Complete: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#Complete", this ); }

                    DG.Tweening.TweenExtensions.Complete$1(t, false);
                },
                /*DG.Tweening.TweenExtensions.Complete:static end.*/

                /*DG.Tweening.TweenExtensions.Complete$1:static start.*/
                /**
                 * Completes the tween
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}    t                
                 * @param   {boolean}              withCallbacks    For Sequences only: if TRUE also internal Sequence callbacks will be fired,
                     otherwise they will be ignored
                 * @return  {void}
                 */
                Complete$1: function (t, withCallbacks) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#Complete$1", this ); }

                    if (t == null) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNullTween(t);
                        }

                        return;
                    }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }

                        return;
                    }

                    if (t.isSequenced) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNestedTween(t);
                        }

                        return;
                    }

                    // Previously disused in favor of bottom code because otherwise OnComplete was called twice when fired inside am OnUpdate call,
                    // but that created another recent issue where events (OnComplete and any other) weren't called anymore
                    // if called from another tween's internal callbacks.
                    // Reinstated because thanks to other fixes this now works correctly
                    DG.Tweening.Core.TweenManager.Complete(t, true, withCallbacks ? DG.Tweening.Core.Enums.UpdateMode.Update : DG.Tweening.Core.Enums.UpdateMode.Goto);
                    // See above note for reason why this was commented
                    // UpdateMode updateMode = TweenManager.isUpdateLoop ? UpdateMode.IgnoreOnComplete
                    //     : withCallbacks ? UpdateMode.Update : UpdateMode.Goto;
                    // TweenManager.Complete(t, true, updateMode);
                },
                /*DG.Tweening.TweenExtensions.Complete$1:static end.*/

                /*DG.Tweening.TweenExtensions.Flip:static start.*/
                /**
                 * Flips the direction of this tween (backwards if it was going forward or viceversa)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}    t
                 * @return  {void}
                 */
                Flip: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#Flip", this ); }

                    if (t == null) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNullTween(t);
                        }

                        return;
                    }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }

                        return;
                    }

                    if (t.isSequenced) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNestedTween(t);
                        }

                        return;
                    }

                    DG.Tweening.Core.TweenManager.Flip(t);
                },
                /*DG.Tweening.TweenExtensions.Flip:static end.*/

                /*DG.Tweening.TweenExtensions.ForceInit:static start.*/
                /**
                 * Forces the tween to initialize its settings immediately
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}    t
                 * @return  {void}
                 */
                ForceInit: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#ForceInit", this ); }

                    if (t == null) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNullTween(t);
                        }

                        return;
                    }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }

                        return;
                    }

                    if (t.isSequenced) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNestedTween(t);
                        }

                        return;
                    }

                    DG.Tweening.Core.TweenManager.ForceInit(t);
                },
                /*DG.Tweening.TweenExtensions.ForceInit:static end.*/

                /*DG.Tweening.TweenExtensions.Goto:static start.*/
                /**
                 * Send the tween to the given position in time
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}    t          
                 * @param   {number}               to         Time position to reach
                     (if higher than the whole tween duration the tween will simply reach its end)
                 * @param   {boolean}              andPlay    If TRUE will play the tween after reaching the given position, otherwise it will pause it
                 * @return  {void}
                 */
                Goto: function (t, to, andPlay) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#Goto", this ); }

                    if (andPlay === void 0) { andPlay = false; }
                    DG.Tweening.TweenExtensions.DoGoto(t, to, andPlay, false);
                },
                /*DG.Tweening.TweenExtensions.Goto:static end.*/

                /*DG.Tweening.TweenExtensions.GotoWithCallbacks:static start.*/
                /**
                 * Send the tween to the given position in time while also executing any callback between the previous time
                     position and the new one
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}    t          
                 * @param   {number}               to         Time position to reach
                     (if higher than the whole tween duration the tween will simply reach its end)
                 * @param   {boolean}              andPlay    If TRUE will play the tween after reaching the given position, otherwise it will pause it
                 * @return  {void}
                 */
                GotoWithCallbacks: function (t, to, andPlay) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#GotoWithCallbacks", this ); }

                    if (andPlay === void 0) { andPlay = false; }
                    DG.Tweening.TweenExtensions.DoGoto(t, to, andPlay, true);
                },
                /*DG.Tweening.TweenExtensions.GotoWithCallbacks:static end.*/

                /*DG.Tweening.TweenExtensions.DoGoto:static start.*/
                DoGoto: function (t, to, andPlay, withCallbacks) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#DoGoto", this ); }

                    if (t == null) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNullTween(t);
                        }

                        return;
                    }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }

                        return;
                    }

                    if (t.isSequenced) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNestedTween(t);
                        }

                        return;
                    }

                    if (to < 0) {
                        to = 0;
                    }

                    if (!t.startupDone) {
                        DG.Tweening.Core.TweenManager.ForceInit(t); // Initialize the tween if it's not initialized already (required)
                    }

                    DG.Tweening.Core.TweenManager.Goto(t, to, andPlay, withCallbacks ? DG.Tweening.Core.Enums.UpdateMode.Update : DG.Tweening.Core.Enums.UpdateMode.Goto);
                },
                /*DG.Tweening.TweenExtensions.DoGoto:static end.*/

                /*DG.Tweening.TweenExtensions.Kill:static start.*/
                /**
                 * Kills the tween
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}    t           
                 * @param   {boolean}              complete    If TRUE completes the tween before killing it
                 * @return  {void}
                 */
                Kill: function (t, complete) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#Kill", this ); }

                    if (complete === void 0) { complete = false; }
                    if (!DG.Tweening.DOTween.initialized) {
                        return;
                    }

                    if (t == null || !t.active) {
                        return;
                    }

                    if (t.isSequenced) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNestedTween(t);
                        }

                        return;
                    }

                    if (complete) {
                        DG.Tweening.Core.TweenManager.Complete(t);
                        if (t.autoKill && t.loops >= 0) {
                            return; // Already killed by Complete, so no need to go on
                        }
                    }

                    if (DG.Tweening.Core.TweenManager.isUpdateLoop) {
                        // Just mark it for killing, so the update loop will take care of it
                        t.active = false;
                    } else {
                        DG.Tweening.Core.TweenManager.Despawn(t);
                    }
                },
                /*DG.Tweening.TweenExtensions.Kill:static end.*/

                /*DG.Tweening.TweenExtensions.ManualUpdate:static start.*/
                /**
                 * Forces this tween to update manually, regardless of the {@link } set via SetUpdate.
                     Note that the tween will still be subject to normal tween rules, so if for example it's paused this method will do
                     nothing.
                     <p />
                     Also note that if you only want to update this tween instance manually you'll have to set it to
                     {@link } anyway,
                     so that it's not updated automatically.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}    t                    
                 * @param   {number}               deltaTime            Manual deltaTime
                 * @param   {number}               unscaledDeltaTime    Unscaled delta time (used with tweens set as timeScaleIndependent)
                 * @return  {void}
                 */
                ManualUpdate: function (t, deltaTime, unscaledDeltaTime) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#ManualUpdate", this ); }

                    if (t == null) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNullTween(t);
                        }

                        return;
                    }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }

                        return;
                    }

                    if (t.isSequenced) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNestedTween(t);
                        }

                        return;
                    }

                    DG.Tweening.Core.TweenManager.Update(t, deltaTime, unscaledDeltaTime, true);
                },
                /*DG.Tweening.TweenExtensions.ManualUpdate:static end.*/

                /*DG.Tweening.TweenExtensions.Pause:static start.*/
                /**
                 * Pauses the tween
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {Function}    T    
                 * @param   {T}           t
                 * @return  {T}
                 */
                Pause: function (T, t) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#Pause", this ); }

                    if (Bridge.rValue(t) == null) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNullTween(Bridge.rValue(t));
                        }

                        return Bridge.rValue(t);
                    }

                    if (!Bridge.rValue(t).active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(Bridge.rValue(t));
                        }

                        return Bridge.rValue(t);
                    }

                    if (Bridge.rValue(t).isSequenced) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNestedTween(Bridge.rValue(t));
                        }

                        return Bridge.rValue(t);
                    }

                    DG.Tweening.Core.TweenManager.Pause(Bridge.rValue(t));
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenExtensions.Pause:static end.*/

                /*DG.Tweening.TweenExtensions.Play:static start.*/
                /**
                 * Plays the tween
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {Function}    T    
                 * @param   {T}           t
                 * @return  {T}
                 */
                Play: function (T, t) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#Play", this ); }

                    if (Bridge.rValue(t) == null) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNullTween(Bridge.rValue(t));
                        }

                        return Bridge.rValue(t);
                    }

                    if (!Bridge.rValue(t).active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(Bridge.rValue(t));
                        }

                        return Bridge.rValue(t);
                    }

                    if (Bridge.rValue(t).isSequenced) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNestedTween(Bridge.rValue(t));
                        }

                        return Bridge.rValue(t);
                    }

                    DG.Tweening.Core.TweenManager.Play(Bridge.rValue(t));
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenExtensions.Play:static end.*/

                /*DG.Tweening.TweenExtensions.PlayBackwards:static start.*/
                /**
                 * Sets the tween in a backwards direction and plays it
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}    t
                 * @return  {void}
                 */
                PlayBackwards: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#PlayBackwards", this ); }

                    if (t == null) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNullTween(t);
                        }

                        return;
                    }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }

                        return;
                    }

                    if (t.isSequenced) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNestedTween(t);
                        }

                        return;
                    }

                    DG.Tweening.Core.TweenManager.PlayBackwards(t);
                },
                /*DG.Tweening.TweenExtensions.PlayBackwards:static end.*/

                /*DG.Tweening.TweenExtensions.PlayForward:static start.*/
                /**
                 * Sets the tween in a forward direction and plays it
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}    t
                 * @return  {void}
                 */
                PlayForward: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#PlayForward", this ); }

                    if (t == null) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNullTween(t);
                        }

                        return;
                    }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }

                        return;
                    }

                    if (t.isSequenced) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNestedTween(t);
                        }

                        return;
                    }

                    DG.Tweening.Core.TweenManager.PlayForward(t);
                },
                /*DG.Tweening.TweenExtensions.PlayForward:static end.*/

                /*DG.Tweening.TweenExtensions.Restart:static start.*/
                /**
                 * Restarts the tween from the beginning
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}    t                
                 * @param   {boolean}              includeDelay     Ignored in case of Sequences. If TRUE includes the eventual tween delay, otherwise skips it
                 * @param   {number}               changeDelayTo    Ignored in case of Sequences. If &gt;= 0 changes the startup delay to this value, otherwise
                     doesn't touch it
                 * @return  {void}
                 */
                Restart: function (t, includeDelay, changeDelayTo) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#Restart", this ); }

                    if (includeDelay === void 0) { includeDelay = true; }
                    if (changeDelayTo === void 0) { changeDelayTo = -1.0; }
                    if (t == null) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNullTween(t);
                        }

                        return;
                    }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }

                        return;
                    }

                    if (t.isSequenced) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNestedTween(t);
                        }

                        return;
                    }

                    DG.Tweening.Core.TweenManager.Restart(t, includeDelay, changeDelayTo);
                },
                /*DG.Tweening.TweenExtensions.Restart:static end.*/

                /*DG.Tweening.TweenExtensions.Rewind:static start.*/
                /**
                 * Rewinds and pauses the tween
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}    t               
                 * @param   {boolean}              includeDelay    Ignored in case of Sequences. If TRUE includes the eventual tween delay, otherwise skips it
                 * @return  {void}
                 */
                Rewind: function (t, includeDelay) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#Rewind", this ); }

                    if (includeDelay === void 0) { includeDelay = true; }
                    if (t == null) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNullTween(t);
                        }

                        return;
                    }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }

                        return;
                    }

                    if (t.isSequenced) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNestedTween(t);
                        }

                        return;
                    }

                    DG.Tweening.Core.TweenManager.Rewind(t, includeDelay);
                },
                /*DG.Tweening.TweenExtensions.Rewind:static end.*/

                /*DG.Tweening.TweenExtensions.SmoothRewind:static start.*/
                /**
                 * Smoothly rewinds the tween (delays excluded).
                     A "smooth rewind" animates the tween to its start position,
                     skipping all elapsed loops (except in case of LoopType.Incremental) while keeping the animation fluent.
                     If called on a tween who is still waiting for its delay to happen, it will simply set the delay to 0 and pause the
                     tween.
                     <p>Note that a tween that was smoothly rewinded will have its play direction flipped</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}    t
                 * @return  {void}
                 */
                SmoothRewind: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#SmoothRewind", this ); }

                    if (t == null) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNullTween(t);
                        }

                        return;
                    }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }

                        return;
                    }

                    if (t.isSequenced) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNestedTween(t);
                        }

                        return;
                    }

                    DG.Tweening.Core.TweenManager.SmoothRewind(t);
                },
                /*DG.Tweening.TweenExtensions.SmoothRewind:static end.*/

                /*DG.Tweening.TweenExtensions.TogglePause:static start.*/
                /**
                 * Plays the tween if it was paused, pauses it if it was playing
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}    t
                 * @return  {void}
                 */
                TogglePause: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#TogglePause", this ); }

                    if (t == null) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNullTween(t);
                        }

                        return;
                    }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }

                        return;
                    }

                    if (t.isSequenced) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNestedTween(t);
                        }

                        return;
                    }

                    DG.Tweening.Core.TweenManager.TogglePause(t);
                },
                /*DG.Tweening.TweenExtensions.TogglePause:static end.*/

                /*DG.Tweening.TweenExtensions.GotoWaypoint:static start.*/
                /**
                 * Send a path tween to the given waypoint.
                     Has no effect if this is not a path tween.
                     <p>BEWARE, this is a special utility method:
                         it works only with Linear eases. Also, the lookAt direction might be wrong after calling this and might need to
                         be set manually
                         (because it relies on a smooth path movement and doesn't work well with jumps that encompass dramatic direction
                         changes)</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}    t                
                 * @param   {number}               waypointIndex    Waypoint index to reach
                     (if higher than the max waypoint index the tween will simply go to the last one)
                 * @param   {boolean}              andPlay          If TRUE will play the tween after reaching the given waypoint, otherwise it will pause it
                 * @return  {void}
                 */
                GotoWaypoint: function (t, waypointIndex, andPlay) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#GotoWaypoint", this ); }

                    var $t;
                    if (andPlay === void 0) { andPlay = false; }
                    if (t == null) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNullTween(t);
                        }

                        return;
                    }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }

                        return;
                    }

                    if (t.isSequenced) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNestedTween(t);
                        }

                        return;
                    }

                    var pathTween = Bridge.as(t, DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions));
                    if (pathTween == null) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNonPathTween(t);
                        }

                        return;
                    }

                    if (!t.startupDone) {
                        DG.Tweening.Core.TweenManager.ForceInit(t); // Initialize the tween if it's not initialized already (required)
                    }

                    if (waypointIndex < 0) {
                        waypointIndex = 0;
                    } else if (waypointIndex > pathTween.changeValue.wps.length - 1) {
                        waypointIndex = pathTween.changeValue.wps.length - 1;
                    }

                    // Find path percentage relative to given waypoint
                    var wpLength = 0; // Total length from start to the given waypoint
                    for (var i = 0; i < waypointIndex + 1; i++) {
                        wpLength += ($t = pathTween.changeValue.wpLengths)[i];
                    }

                    var wpPerc = wpLength / pathTween.changeValue.length;
                    // Convert to time taking eventual inverse direction into account
                    var useInversePosition = t.hasLoops && t.loopType === DG.Tweening.LoopType.Yoyo && (t.position < t.duration ? t.completedLoops % 2 !== 0 : t.completedLoops % 2 === 0);
                    if (useInversePosition) {
                        wpPerc = 1 - wpPerc;
                    }

                    var to = (t.isComplete ? t.completedLoops - 1 : t.completedLoops) * t.duration + wpPerc * t.duration;
                    DG.Tweening.Core.TweenManager.Goto(t, to, andPlay);
                },
                /*DG.Tweening.TweenExtensions.GotoWaypoint:static end.*/

                /*DG.Tweening.TweenExtensions.WaitForCompletion:static start.*/
                /**
                 * Creates a yield instruction that waits until the tween is killed or complete.
                     It can be used inside a coroutine as a yield.
                     <p>Example usage:</p><pre><code>yield return myTween.WaitForCompletion();</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}               t
                 * @return  {UnityEngine.YieldInstruction}
                 */
                WaitForCompletion: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#WaitForCompletion", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }

                        return null;
                    }

                    return DG.Tweening.DOTween.instance.StartCoroutine$1(DG.Tweening.DOTween.instance.WaitForCompletion(t));
                },
                /*DG.Tweening.TweenExtensions.WaitForCompletion:static end.*/

                /*DG.Tweening.TweenExtensions.WaitForRewind:static start.*/
                /**
                 * Creates a yield instruction that waits until the tween is killed or rewinded.
                     It can be used inside a coroutine as a yield.
                     <p>Example usage:</p><pre><code>yield return myTween.WaitForRewind();</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}               t
                 * @return  {UnityEngine.YieldInstruction}
                 */
                WaitForRewind: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#WaitForRewind", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }

                        return null;
                    }

                    return DG.Tweening.DOTween.instance.StartCoroutine$1(DG.Tweening.DOTween.instance.WaitForRewind(t));
                },
                /*DG.Tweening.TweenExtensions.WaitForRewind:static end.*/

                /*DG.Tweening.TweenExtensions.WaitForKill:static start.*/
                /**
                 * Creates a yield instruction that waits until the tween is killed.
                     It can be used inside a coroutine as a yield.
                     <p>Example usage:</p><pre><code>yield return myTween.WaitForKill();</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}               t
                 * @return  {UnityEngine.YieldInstruction}
                 */
                WaitForKill: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#WaitForKill", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }

                        return null;
                    }

                    return DG.Tweening.DOTween.instance.StartCoroutine$1(DG.Tweening.DOTween.instance.WaitForKill(t));
                },
                /*DG.Tweening.TweenExtensions.WaitForKill:static end.*/

                /*DG.Tweening.TweenExtensions.WaitForElapsedLoops:static start.*/
                /**
                 * Creates a yield instruction that waits until the tween is killed or has gone through the given amount of loops.
                     It can be used inside a coroutine as a yield.
                     <p>Example usage:</p><pre><code>yield return myTween.WaitForElapsedLoops(2);</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}               t               
                 * @param   {number}                          elapsedLoops    Elapsed loops to wait for
                 * @return  {UnityEngine.YieldInstruction}
                 */
                WaitForElapsedLoops: function (t, elapsedLoops) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#WaitForElapsedLoops", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }

                        return null;
                    }

                    return DG.Tweening.DOTween.instance.StartCoroutine$1(DG.Tweening.DOTween.instance.WaitForElapsedLoops(t, elapsedLoops));
                },
                /*DG.Tweening.TweenExtensions.WaitForElapsedLoops:static end.*/

                /*DG.Tweening.TweenExtensions.WaitForPosition:static start.*/
                /**
                 * Creates a yield instruction that waits until the tween is killed or has reached the given position (loops included,
                     delays excluded).
                     It can be used inside a coroutine as a yield.
                     <p>Example usage:</p><pre><code>yield return myTween.WaitForPosition(2.5f);</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}               t           
                 * @param   {number}                          position    Position (loops included, delays excluded) to wait for
                 * @return  {UnityEngine.YieldInstruction}
                 */
                WaitForPosition: function (t, position) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#WaitForPosition", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }

                        return null;
                    }

                    return DG.Tweening.DOTween.instance.StartCoroutine$1(DG.Tweening.DOTween.instance.WaitForPosition(t, position));
                },
                /*DG.Tweening.TweenExtensions.WaitForPosition:static end.*/

                /*DG.Tweening.TweenExtensions.WaitForStart:static start.*/
                /**
                 * Creates a yield instruction that waits until the tween is killed or started
                     (meaning when the tween is set in a playing state the first time, after any eventual delay).
                     It can be used inside a coroutine as a yield.
                     <p>Example usage:</p><pre><code>yield return myTween.WaitForStart();</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}        t
                 * @return  {UnityEngine.Coroutine}
                 */
                WaitForStart: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#WaitForStart", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }

                        return null;
                    }

                    return DG.Tweening.DOTween.instance.StartCoroutine$1(DG.Tweening.DOTween.instance.WaitForStart(t));
                },
                /*DG.Tweening.TweenExtensions.WaitForStart:static end.*/

                /*DG.Tweening.TweenExtensions.CompletedLoops:static start.*/
                /**
                 * Returns the total number of loops completed by this tween
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}    t
                 * @return  {number}
                 */
                CompletedLoops: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#CompletedLoops", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }

                        return 0;
                    }

                    return t.completedLoops;
                },
                /*DG.Tweening.TweenExtensions.CompletedLoops:static end.*/

                /*DG.Tweening.TweenExtensions.Delay:static start.*/
                /**
                 * Returns the eventual delay set for this tween
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}    t
                 * @return  {number}
                 */
                Delay: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#Delay", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }

                        return 0;
                    }

                    return t.delay;
                },
                /*DG.Tweening.TweenExtensions.Delay:static end.*/

                /*DG.Tweening.TweenExtensions.ElapsedDelay:static start.*/
                /**
                 * Returns the eventual elapsed delay set for this tween
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}    t
                 * @return  {number}
                 */
                ElapsedDelay: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#ElapsedDelay", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }

                        return 0;
                    }

                    return t.elapsedDelay;
                },
                /*DG.Tweening.TweenExtensions.ElapsedDelay:static end.*/

                /*DG.Tweening.TweenExtensions.Duration:static start.*/
                /**
                 * Returns the duration of this tween (delays excluded).
                     <p>NOTE: when using settings like SpeedBased, the duration will be recalculated when the tween starts</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}    t               
                 * @param   {boolean}              includeLoops    If TRUE returns the full duration loops included,
                     otherwise the duration of a single loop cycle
                 * @return  {number}
                 */
                Duration: function (t, includeLoops) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#Duration", this ); }

                    if (includeLoops === void 0) { includeLoops = true; }
                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }

                        return 0;
                    }

                    // Calculate duration here instead than getting fullDuration because fullDuration might
                    // not be set yet, since it's set inside DoStartup
                    if (includeLoops) {
                        return t.loops === -1 ? window.Infinity : t.duration * t.loops;
                    }

                    return t.duration;
                },
                /*DG.Tweening.TweenExtensions.Duration:static end.*/

                /*DG.Tweening.TweenExtensions.Elapsed:static start.*/
                /**
                 * Returns the elapsed time for this tween (delays exluded)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}    t               
                 * @param   {boolean}              includeLoops    If TRUE returns the elapsed time since startup loops included,
                     otherwise the elapsed time within the current loop cycle
                 * @return  {number}
                 */
                Elapsed: function (t, includeLoops) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#Elapsed", this ); }

                    if (includeLoops === void 0) { includeLoops = true; }
                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }

                        return 0;
                    }

                    if (includeLoops) {
                        var loopsToCount = t.position >= t.duration ? t.completedLoops - 1 : t.completedLoops;
                        return loopsToCount * t.duration + t.position;
                    }

                    return t.position;
                },
                /*DG.Tweening.TweenExtensions.Elapsed:static end.*/

                /*DG.Tweening.TweenExtensions.ElapsedPercentage:static start.*/
                /**
                 * Returns the elapsed percentage (0 to 1) of this tween (delays exluded)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}    t               
                 * @param   {boolean}              includeLoops    If TRUE returns the elapsed percentage since startup loops included,
                     otherwise the elapsed percentage within the current loop cycle
                 * @return  {number}
                 */
                ElapsedPercentage: function (t, includeLoops) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#ElapsedPercentage", this ); }

                    if (includeLoops === void 0) { includeLoops = true; }
                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }

                        return 0;
                    }

                    if (includeLoops) {
                        if (t.fullDuration <= 0) {
                            return 0;
                        }

                        var loopsToCount = t.position >= t.duration ? t.completedLoops - 1 : t.completedLoops;
                        return (loopsToCount * t.duration + t.position) / t.fullDuration;
                    }

                    return t.position / t.duration;
                },
                /*DG.Tweening.TweenExtensions.ElapsedPercentage:static end.*/

                /*DG.Tweening.TweenExtensions.ElapsedDirectionalPercentage:static start.*/
                /**
                 * Returns the elapsed percentage (0 to 1) of this tween (delays exluded),
                     based on a single loop, and calculating eventual backwards Yoyo loops as 1 to 0 instead of 0 to 1
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}    t
                 * @return  {number}
                 */
                ElapsedDirectionalPercentage: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#ElapsedDirectionalPercentage", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }

                        return 0;
                    }

                    var perc = t.position / t.duration;
                    var isInverse = t.completedLoops > 0 && t.hasLoops && t.loopType === DG.Tweening.LoopType.Yoyo && (!t.isComplete && t.completedLoops % 2 !== 0 || t.isComplete && t.completedLoops % 2 === 0);
                    return isInverse ? 1 - perc : perc;
                },
                /*DG.Tweening.TweenExtensions.ElapsedDirectionalPercentage:static end.*/

                /*DG.Tweening.TweenExtensions.IsActive:static start.*/
                /**
                 * Returns FALSE if this tween has been killed or is NULL, TRUE otherwise.
                     <p>BEWARE: if this tween is recyclable it might have been spawned again for another use and thus return TRUE
                         anyway.</p>
                     When working with recyclable tweens you should take care to know when a tween has been killed and manually set your
                     references to NULL.
                     If you want to be sure your references are set to NULL when a tween is killed you can use the <pre><code>OnKill</code></pre>
                     callback like this:
                     <p><pre><code>.OnKill(()=&gt; myTweenReference = null)</code></pre></p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}    t
                 * @return  {boolean}
                 */
                IsActive: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#IsActive", this ); }

                    return t != null && t.active;
                },
                /*DG.Tweening.TweenExtensions.IsActive:static end.*/

                /*DG.Tweening.TweenExtensions.IsBackwards:static start.*/
                /**
                 * Returns TRUE if this tween was reversed and is set to go backwards
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}    t
                 * @return  {boolean}
                 */
                IsBackwards: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#IsBackwards", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }

                        return false;
                    }

                    return t.isBackwards;
                },
                /*DG.Tweening.TweenExtensions.IsBackwards:static end.*/

                /*DG.Tweening.TweenExtensions.IsComplete:static start.*/
                /**
                 * Returns TRUE if the tween is complete
                     (silently fails and returns FALSE if the tween has been killed)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}    t
                 * @return  {boolean}
                 */
                IsComplete: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#IsComplete", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }

                        return false;
                    }

                    return t.isComplete;
                },
                /*DG.Tweening.TweenExtensions.IsComplete:static end.*/

                /*DG.Tweening.TweenExtensions.IsInitialized:static start.*/
                /**
                 * Returns TRUE if this tween has been initialized
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}    t
                 * @return  {boolean}
                 */
                IsInitialized: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#IsInitialized", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }

                        return false;
                    }

                    return t.startupDone;
                },
                /*DG.Tweening.TweenExtensions.IsInitialized:static end.*/

                /*DG.Tweening.TweenExtensions.IsPlaying:static start.*/
                /**
                 * Returns TRUE if this tween is playing
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}    t
                 * @return  {boolean}
                 */
                IsPlaying: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#IsPlaying", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }

                        return false;
                    }

                    return t.isPlaying;
                },
                /*DG.Tweening.TweenExtensions.IsPlaying:static end.*/

                /*DG.Tweening.TweenExtensions.Loops:static start.*/
                /**
                 * Returns the total number of loops set for this tween
                     (returns -1 if the loops are infinite)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}    t
                 * @return  {number}
                 */
                Loops: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#Loops", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }

                        return 0;
                    }

                    return t.loops;
                },
                /*DG.Tweening.TweenExtensions.Loops:static end.*/

                /*DG.Tweening.TweenExtensions.PathGetPoint:static start.*/
                /**
                 * Returns a point on a path based on the given path percentage.
                     Returns <pre><code>Vector3.zero</code></pre> if this is not a path tween, if the tween is invalid, or if the path is not yet
                     initialized.
                     A path is initialized after its tween starts, or immediately if the tween was created with the Path Editor (DOTween
                     Pro feature).
                     You can force a path to be initialized by calling <pre><code>myTween.ForceInit()</code></pre>.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}      t                 
                 * @param   {number}                 pathPercentage    Percentage of the path (0 to 1) on which to get the point
                 * @return  {UnityEngine.Vector3}
                 */
                PathGetPoint: function (t, pathPercentage) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#PathGetPoint", this ); }

                    if (pathPercentage > 1) {
                        pathPercentage = 1;
                    } else if (pathPercentage < 0) {
                        pathPercentage = 0;
                    }

                    if (t == null) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNullTween(t);
                        }

                        return pc.Vec3.ZERO.clone();
                    }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }

                        return pc.Vec3.ZERO.clone();
                    }

                    if (t.isSequenced) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNestedTween(t);
                        }

                        return pc.Vec3.ZERO.clone();
                    }

                    var pathTween = Bridge.as(t, DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions));
                    if (pathTween == null) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNonPathTween(t);
                        }

                        return pc.Vec3.ZERO.clone();
                    }

                    if (!pathTween.endValue.isFinalized) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogWarning("The path is not finalized yet", t);
                        }

                        return pc.Vec3.ZERO.clone();
                    }

                    return pathTween.endValue.GetPoint(pathPercentage, true);
                },
                /*DG.Tweening.TweenExtensions.PathGetPoint:static end.*/

                /*DG.Tweening.TweenExtensions.PathGetDrawPoints:static start.*/
                /**
                 * Returns an array of points that can be used to draw the path.
                     Note that this method generates allocations, because it creates a new array.
                     Returns <pre><code>NULL</code></pre> if this is not a path tween, if the tween is invalid, or if the path is not yet
                     initialized.
                     A path is initialized after its tween starts, or immediately if the tween was created with the Path Editor (DOTween
                     Pro feature).
                     You can force a path to be initialized by calling <pre><code>myTween.ForceInit()</code></pre>.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}              t                       
                 * @param   {number}                         subdivisionsXSegment    How many points to create for each path segment (waypoint to waypoint).
                     Only used in case of non-Linear paths
                 * @return  {Array.<UnityEngine.Vector3>}
                 */
                PathGetDrawPoints: function (t, subdivisionsXSegment) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#PathGetDrawPoints", this ); }

                    if (subdivisionsXSegment === void 0) { subdivisionsXSegment = 10; }
                    if (t == null) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNullTween(t);
                        }

                        return null;
                    }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }

                        return null;
                    }

                    if (t.isSequenced) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNestedTween(t);
                        }

                        return null;
                    }

                    var pathTween = Bridge.as(t, DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions));
                    if (pathTween == null) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNonPathTween(t);
                        }

                        return null;
                    }

                    if (!pathTween.endValue.isFinalized) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogWarning("The path is not finalized yet", t);
                        }

                        return null;
                    }

                    return DG.Tweening.Plugins.Core.PathCore.Path.GetDrawPoints(pathTween.endValue, subdivisionsXSegment);
                },
                /*DG.Tweening.TweenExtensions.PathGetDrawPoints:static end.*/

                /*DG.Tweening.TweenExtensions.PathLength:static start.*/
                /**
                 * Returns the length of a path.
                     Returns -1 if this is not a path tween, if the tween is invalid, or if the path is not yet initialized.
                     A path is initialized after its tween starts, or immediately if the tween was created with the Path Editor (DOTween
                     Pro feature).
                     You can force a path to be initialized by calling <pre><code>myTween.ForceInit()</code></pre>.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenExtensions
                 * @memberof DG.Tweening.TweenExtensions
                 * @param   {DG.Tweening.Tween}    t
                 * @return  {number}
                 */
                PathLength: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenExtensions#PathLength", this ); }

                    if (t == null) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNullTween(t);
                        }

                        return -1;
                    }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }

                        return -1;
                    }

                    if (t.isSequenced) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNestedTween(t);
                        }

                        return -1;
                    }

                    var pathTween = Bridge.as(t, DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions));
                    if (pathTween == null) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogNonPathTween(t);
                        }

                        return -1;
                    }

                    if (!pathTween.endValue.isFinalized) {
                        if (DG.Tweening.Core.Debugger.logPriority > 1) {
                            DG.Tweening.Core.Debugger.LogWarning("The path is not finalized yet", t);
                        }

                        return -1;
                    }

                    return pathTween.endValue.length;
                },
                /*DG.Tweening.TweenExtensions.PathLength:static end.*/


            }
        }
    });
    /*DG.Tweening.TweenExtensions end.*/

    /*DG.Tweening.TweenParams start.*/
    /**
     * This class serves only as a utility class to store tween settings to apply on multiple tweens.
         It is in no way needed otherwise, since you can directly apply tween settings to a tween via chaining
     *
     * @public
     * @class DG.Tweening.TweenParams
     */
    Bridge.define("DG.Tweening.TweenParams", {
        statics: {
            fields: {
                /**
                 * A variable you can eventually Clear and reuse when needed,
                     to avoid instantiating TweenParams objects
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof DG.Tweening.TweenParams
                 * @type DG.Tweening.TweenParams
                 */
                Params: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.TweenParams#init", this ); }

                    this.Params = new DG.Tweening.TweenParams();
                }
            }
        },
        fields: {
            autoKill: false,
            customEase: null,
            delay: 0,
            easeOvershootOrAmplitude: 0,
            easePeriod: 0,
            easeType: 0,
            id: null,
            intId: 0,
            isIndependentUpdate: false,
            isRecyclable: false,
            isRelative: false,
            isSpeedBased: false,
            loops: 0,
            loopType: 0,
            onComplete: null,
            onKill: null,
            onPlay: null,
            onRewind: null,
            onStart: null,
            onStepComplete: null,
            onUpdate: null,
            onWaypointChange: null,
            stringId: null,
            target: null,
            updateType: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.TweenParams#init", this ); }

                this.intId = -999;
            },
            /**
             * Creates a new TweenParams object, which you can use to store tween settings
                 to pass to multiple tweens via <pre><code>myTween.SetAs(myTweenParms)</code></pre>
             *
             * @instance
             * @public
             * @this DG.Tweening.TweenParams
             * @memberof DG.Tweening.TweenParams
             * @return  {void}
             */
            ctor: function () {
if ( TRACE ) { TRACE( "DG.Tweening.TweenParams#ctor", this ); }

                this.$initialize();
                this.Clear();
            }
        },
        methods: {
            /*DG.Tweening.TweenParams.Clear start.*/
            /**
             * Clears and resets this TweenParams instance using default values,
                 so it can be reused without instantiating another one
             *
             * @instance
             * @public
             * @this DG.Tweening.TweenParams
             * @memberof DG.Tweening.TweenParams
             * @return  {DG.Tweening.TweenParams}
             */
            Clear: function () {
if ( TRACE ) { TRACE( "DG.Tweening.TweenParams#Clear", this ); }

                this.id = (this.target = null);
                this.stringId = null;
                this.intId = -999;
                this.updateType = DG.Tweening.DOTween.defaultUpdateType;
                this.isIndependentUpdate = DG.Tweening.DOTween.defaultTimeScaleIndependent;
                this.onStart = (this.onPlay = (this.onRewind = (this.onUpdate = (this.onStepComplete = (this.onComplete = (this.onKill = null))))));
                this.onWaypointChange = null;
                this.isRecyclable = DG.Tweening.DOTween.defaultRecyclable;
                this.isSpeedBased = false;
                this.autoKill = DG.Tweening.DOTween.defaultAutoKill;
                this.loops = 1;
                this.loopType = DG.Tweening.DOTween.defaultLoopType;
                this.delay = 0;
                this.isRelative = false;
                this.easeType = DG.Tweening.Ease.Unset;
                this.customEase = null;
                this.easeOvershootOrAmplitude = DG.Tweening.DOTween.defaultEaseOvershootOrAmplitude;
                this.easePeriod = DG.Tweening.DOTween.defaultEasePeriod;

                return this;
            },
            /*DG.Tweening.TweenParams.Clear end.*/

            /*DG.Tweening.TweenParams.SetAutoKill start.*/
            /**
             * Sets the autoKill behaviour of the tween.
                 Has no effect if the tween has already started
             *
             * @instance
             * @public
             * @this DG.Tweening.TweenParams
             * @memberof DG.Tweening.TweenParams
             * @param   {boolean}                    autoKillOnCompletion    If TRUE the tween will be automatically killed when complete
             * @return  {DG.Tweening.TweenParams}
             */
            SetAutoKill: function (autoKillOnCompletion) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenParams#SetAutoKill", this ); }

                if (autoKillOnCompletion === void 0) { autoKillOnCompletion = true; }
                this.autoKill = autoKillOnCompletion;
                return this;
            },
            /*DG.Tweening.TweenParams.SetAutoKill end.*/

            /*DG.Tweening.TweenParams.SetId$1 start.*/
            /**
             * Sets an ID for the tween, which can then be used as a filter with DOTween's static methods.
             *
             * @instance
             * @public
             * @this DG.Tweening.TweenParams
             * @memberof DG.Tweening.TweenParams
             * @param   {System.Object}              objectId    The ID to assign to this tween. Can be an int, a string, an object or anything else.
             * @return  {DG.Tweening.TweenParams}
             */
            SetId$1: function (objectId) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenParams#SetId$1", this ); }

                this.id = objectId;
                return this;
            },
            /*DG.Tweening.TweenParams.SetId$1 end.*/

            /*DG.Tweening.TweenParams.SetId$2 start.*/
            /**
             * Sets an ID for the tween, which can then be used as a filter with DOTween's static methods.
             *
             * @instance
             * @public
             * @this DG.Tweening.TweenParams
             * @memberof DG.Tweening.TweenParams
             * @param   {string}                     stringId    The ID to assign to this tween. Can be an int, a string, an object or anything else.
             * @return  {DG.Tweening.TweenParams}
             */
            SetId$2: function (stringId) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenParams#SetId$2", this ); }

                this.stringId = stringId;
                return this;
            },
            /*DG.Tweening.TweenParams.SetId$2 end.*/

            /*DG.Tweening.TweenParams.SetId start.*/
            /**
             * Sets an ID for the tween, which can then be used as a filter with DOTween's static methods.
             *
             * @instance
             * @public
             * @this DG.Tweening.TweenParams
             * @memberof DG.Tweening.TweenParams
             * @param   {number}                     intId    The ID to assign to this tween. Can be an int, a string, an object or anything else.
             * @return  {DG.Tweening.TweenParams}
             */
            SetId: function (intId) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenParams#SetId", this ); }

                this.intId = intId;
                return this;
            },
            /*DG.Tweening.TweenParams.SetId end.*/

            /*DG.Tweening.TweenParams.SetTarget start.*/
            /**
             * Sets the target for the tween, which can then be used as a filter with DOTween's static methods.
                 <p>IMPORTANT: use it with caution. If you just want to set an ID for the tween use <pre><code>SetId</code></pre> instead.</p>
                 When using shorcuts the shortcut target is already assigned as the tween's target,
                 so using this method will overwrite it and prevent shortcut-operations like myTarget.DOPause from working
                 correctly.
             *
             * @instance
             * @public
             * @this DG.Tweening.TweenParams
             * @memberof DG.Tweening.TweenParams
             * @param   {System.Object}              target    The target to assign to this tween. Can be an int, a string, an object or anything else.
             * @return  {DG.Tweening.TweenParams}
             */
            SetTarget: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenParams#SetTarget", this ); }

                this.target = target;
                return this;
            },
            /*DG.Tweening.TweenParams.SetTarget end.*/

            /*DG.Tweening.TweenParams.SetLoops start.*/
            /**
             * Sets the looping options for the tween.
                 Has no effect if the tween has already started
             *
             * @instance
             * @public
             * @this DG.Tweening.TweenParams
             * @memberof DG.Tweening.TweenParams
             * @param   {number}                     loops       Number of cycles to play (-1 for infinite - will be converted to 1 in case the tween is nested in a
                 Sequence)
             * @param   {?DG.Tweening.LoopType}      loopType    Loop behaviour type (default: LoopType.Restart)
             * @return  {DG.Tweening.TweenParams}
             */
            SetLoops: function (loops, loopType) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenParams#SetLoops", this ); }

                if (loopType === void 0) { loopType = null; }
                if (loops < -1) {
                    loops = -1;
                } else if (loops === 0) {
                    loops = 1;
                }

                this.loops = loops;
                if (loopType != null) {
                    this.loopType = System.Nullable.getValue(loopType);
                }

                return this;
            },
            /*DG.Tweening.TweenParams.SetLoops end.*/

            /*DG.Tweening.TweenParams.SetEase start.*/
            /**
             * Sets the ease of the tween.
                 <p>If applied to Sequences eases the whole sequence animation</p>
             *
             * @instance
             * @public
             * @this DG.Tweening.TweenParams
             * @memberof DG.Tweening.TweenParams
             * @param   {DG.Tweening.Ease}           ease                    
             * @param   {?number}                    overshootOrAmplitude    Eventual overshoot or amplitude to use with Back or Elastic easeType (default is
                 1.70158)
             * @param   {?number}                    period                  Eventual period to use with Elastic easeType (default is 0)
             * @return  {DG.Tweening.TweenParams}
             */
            SetEase: function (ease, overshootOrAmplitude, period) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenParams#SetEase", this ); }

                if (overshootOrAmplitude === void 0) { overshootOrAmplitude = null; }
                if (period === void 0) { period = null; }
                this.easeType = ease;
                this.easeOvershootOrAmplitude = overshootOrAmplitude != null ? System.Nullable.getValue(overshootOrAmplitude) : DG.Tweening.DOTween.defaultEaseOvershootOrAmplitude;
                this.easePeriod = period != null ? System.Nullable.getValue(period) : DG.Tweening.DOTween.defaultEasePeriod;
                this.customEase = null;
                return this;
            },
            /*DG.Tweening.TweenParams.SetEase end.*/

            /*DG.Tweening.TweenParams.SetEase$2 start.*/
            /**
             * Sets the ease of the tween using an AnimationCurve.
                 <p>If applied to Sequences eases the whole sequence animation</p>
             *
             * @instance
             * @public
             * @this DG.Tweening.TweenParams
             * @memberof DG.Tweening.TweenParams
             * @param   {pc.AnimationCurve}          animCurve
             * @return  {DG.Tweening.TweenParams}
             */
            SetEase$2: function (animCurve) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenParams#SetEase$2", this ); }

                this.easeType = DG.Tweening.Ease.INTERNAL_Custom;
                this.customEase = Bridge.fn.cacheBind(new DG.Tweening.Core.Easing.EaseCurve(animCurve), new DG.Tweening.Core.Easing.EaseCurve(animCurve).Evaluate);
                return this;
            },
            /*DG.Tweening.TweenParams.SetEase$2 end.*/

            /*DG.Tweening.TweenParams.SetEase$1 start.*/
            /**
             * Sets the ease of the tween using a custom ease function.
                 <p>If applied to Sequences eases the whole sequence animation</p>
             *
             * @instance
             * @public
             * @this DG.Tweening.TweenParams
             * @memberof DG.Tweening.TweenParams
             * @param   {DG.Tweening.EaseFunction}    customEase
             * @return  {DG.Tweening.TweenParams}
             */
            SetEase$1: function (customEase) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenParams#SetEase$1", this ); }

                this.easeType = DG.Tweening.Ease.INTERNAL_Custom;
                this.customEase = customEase;
                return this;
            },
            /*DG.Tweening.TweenParams.SetEase$1 end.*/

            /*DG.Tweening.TweenParams.SetRecyclable start.*/
            /**
             * Sets the recycling behaviour for the tween.
             *
             * @instance
             * @public
             * @this DG.Tweening.TweenParams
             * @memberof DG.Tweening.TweenParams
             * @param   {boolean}                    recyclable    If TRUE the tween will be recycled after being killed, otherwise it will be destroyed.
             * @return  {DG.Tweening.TweenParams}
             */
            SetRecyclable: function (recyclable) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenParams#SetRecyclable", this ); }

                if (recyclable === void 0) { recyclable = true; }
                this.isRecyclable = recyclable;
                return this;
            },
            /*DG.Tweening.TweenParams.SetRecyclable end.*/

            /*DG.Tweening.TweenParams.SetUpdate$1 start.*/
            /**
             * Sets the update type to the one defined in DOTween.defaultUpdateType (UpdateType.Normal unless changed)
                 and lets you choose if it should be independent from Unity's Time.timeScale
             *
             * @instance
             * @public
             * @this DG.Tweening.TweenParams
             * @memberof DG.Tweening.TweenParams
             * @param   {boolean}                    isIndependentUpdate    If TRUE the tween will ignore Unity's Time.timeScale
             * @return  {DG.Tweening.TweenParams}
             */
            SetUpdate$1: function (isIndependentUpdate) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenParams#SetUpdate$1", this ); }

                this.updateType = DG.Tweening.DOTween.defaultUpdateType;
                this.isIndependentUpdate = isIndependentUpdate;
                return this;
            },
            /*DG.Tweening.TweenParams.SetUpdate$1 end.*/

            /*DG.Tweening.TweenParams.SetUpdate start.*/
            /**
             * Sets the type of update (default or independent) for the tween
             *
             * @instance
             * @public
             * @this DG.Tweening.TweenParams
             * @memberof DG.Tweening.TweenParams
             * @param   {DG.Tweening.UpdateType}     updateType             The type of update (default: UpdateType.Normal)
             * @param   {boolean}                    isIndependentUpdate    If TRUE the tween will ignore Unity's Time.timeScale
             * @return  {DG.Tweening.TweenParams}
             */
            SetUpdate: function (updateType, isIndependentUpdate) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenParams#SetUpdate", this ); }

                if (isIndependentUpdate === void 0) { isIndependentUpdate = false; }
                this.updateType = updateType;
                this.isIndependentUpdate = isIndependentUpdate;
                return this;
            },
            /*DG.Tweening.TweenParams.SetUpdate end.*/

            /*DG.Tweening.TweenParams.OnStart start.*/
            /**
             * Sets the onStart callback for the tween.
                 Called the first time the tween is set in a playing state, after any eventual delay
             *
             * @instance
             * @public
             * @this DG.Tweening.TweenParams
             * @memberof DG.Tweening.TweenParams
             * @param   {DG.Tweening.TweenCallback}    action
             * @return  {DG.Tweening.TweenParams}
             */
            OnStart: function (action) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenParams#OnStart", this ); }

                this.onStart = action;
                return this;
            },
            /*DG.Tweening.TweenParams.OnStart end.*/

            /*DG.Tweening.TweenParams.OnPlay start.*/
            /**
             * Sets the onPlay callback for the tween.
                 Called when the tween is set in a playing state, after any eventual delay.
                 Also called each time the tween resumes playing from a paused state
             *
             * @instance
             * @public
             * @this DG.Tweening.TweenParams
             * @memberof DG.Tweening.TweenParams
             * @param   {DG.Tweening.TweenCallback}    action
             * @return  {DG.Tweening.TweenParams}
             */
            OnPlay: function (action) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenParams#OnPlay", this ); }

                this.onPlay = action;
                return this;
            },
            /*DG.Tweening.TweenParams.OnPlay end.*/

            /*DG.Tweening.TweenParams.OnRewind start.*/
            /**
             * Sets the onRewind callback for the tween.
                 Called when the tween is rewinded,
                 either by calling <pre><code>Rewind</code></pre> or by reaching the start position while playing backwards.
                 Rewinding a tween that is already rewinded will not fire this callback
             *
             * @instance
             * @public
             * @this DG.Tweening.TweenParams
             * @memberof DG.Tweening.TweenParams
             * @param   {DG.Tweening.TweenCallback}    action
             * @return  {DG.Tweening.TweenParams}
             */
            OnRewind: function (action) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenParams#OnRewind", this ); }

                this.onRewind = action;
                return this;
            },
            /*DG.Tweening.TweenParams.OnRewind end.*/

            /*DG.Tweening.TweenParams.OnUpdate start.*/
            /**
             * Sets the onUpdate callback for the tween.
                 Called each time the tween updates
             *
             * @instance
             * @public
             * @this DG.Tweening.TweenParams
             * @memberof DG.Tweening.TweenParams
             * @param   {DG.Tweening.TweenCallback}    action
             * @return  {DG.Tweening.TweenParams}
             */
            OnUpdate: function (action) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenParams#OnUpdate", this ); }

                this.onUpdate = action;
                return this;
            },
            /*DG.Tweening.TweenParams.OnUpdate end.*/

            /*DG.Tweening.TweenParams.OnStepComplete start.*/
            /**
             * Sets the onStepComplete callback for the tween.
                 Called the moment the tween completes one loop cycle, even when going backwards
             *
             * @instance
             * @public
             * @this DG.Tweening.TweenParams
             * @memberof DG.Tweening.TweenParams
             * @param   {DG.Tweening.TweenCallback}    action
             * @return  {DG.Tweening.TweenParams}
             */
            OnStepComplete: function (action) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenParams#OnStepComplete", this ); }

                this.onStepComplete = action;
                return this;
            },
            /*DG.Tweening.TweenParams.OnStepComplete end.*/

            /*DG.Tweening.TweenParams.OnComplete start.*/
            /**
             * Sets the onComplete callback for the tween.
                 Called the moment the tween reaches its final forward position, loops included
             *
             * @instance
             * @public
             * @this DG.Tweening.TweenParams
             * @memberof DG.Tweening.TweenParams
             * @param   {DG.Tweening.TweenCallback}    action
             * @return  {DG.Tweening.TweenParams}
             */
            OnComplete: function (action) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenParams#OnComplete", this ); }

                this.onComplete = action;
                return this;
            },
            /*DG.Tweening.TweenParams.OnComplete end.*/

            /*DG.Tweening.TweenParams.OnKill start.*/
            /**
             * Sets the onKill callback for the tween.
                 Called the moment the tween is killed
             *
             * @instance
             * @public
             * @this DG.Tweening.TweenParams
             * @memberof DG.Tweening.TweenParams
             * @param   {DG.Tweening.TweenCallback}    action
             * @return  {DG.Tweening.TweenParams}
             */
            OnKill: function (action) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenParams#OnKill", this ); }

                this.onKill = action;
                return this;
            },
            /*DG.Tweening.TweenParams.OnKill end.*/

            /*DG.Tweening.TweenParams.OnWaypointChange start.*/
            /**
             * Sets the onWaypointChange callback for the tween.
                 Called when a path tween reaches a new waypoint
             *
             * @instance
             * @public
             * @this DG.Tweening.TweenParams
             * @memberof DG.Tweening.TweenParams
             * @param   {DG.Tweening.TweenCallback}    action
             * @return  {DG.Tweening.TweenParams}
             */
            OnWaypointChange: function (action) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenParams#OnWaypointChange", this ); }

                this.onWaypointChange = action;
                return this;
            },
            /*DG.Tweening.TweenParams.OnWaypointChange end.*/

            /*DG.Tweening.TweenParams.SetDelay start.*/
            /**
             * Sets a delayed startup for the tween.
                 <p>Has no effect on Sequences or if the tween has already started</p>
             *
             * @instance
             * @public
             * @this DG.Tweening.TweenParams
             * @memberof DG.Tweening.TweenParams
             * @param   {number}                     delay
             * @return  {DG.Tweening.TweenParams}
             */
            SetDelay: function (delay) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenParams#SetDelay", this ); }

                this.delay = delay;
                return this;
            },
            /*DG.Tweening.TweenParams.SetDelay end.*/

            /*DG.Tweening.TweenParams.SetRelative start.*/
            /**
             * If isRelative is TRUE sets the tween as relative
                 (the endValue will be calculated as <pre><code>startValue + endValue</code></pre> instead than being used directly).
                 <p>Has no effect on Sequences or if the tween has already started</p>
             *
             * @instance
             * @public
             * @this DG.Tweening.TweenParams
             * @memberof DG.Tweening.TweenParams
             * @param   {boolean}                    isRelative
             * @return  {DG.Tweening.TweenParams}
             */
            SetRelative: function (isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenParams#SetRelative", this ); }

                if (isRelative === void 0) { isRelative = true; }
                this.isRelative = isRelative;
                return this;
            },
            /*DG.Tweening.TweenParams.SetRelative end.*/

            /*DG.Tweening.TweenParams.SetSpeedBased start.*/
            /**
             * If isSpeedBased is TRUE sets the tween as speed based
                 (the duration will represent the number of units the tween moves x second).
                 <p>Has no effect on Sequences, nested tweens, or if the tween has already started</p>
             *
             * @instance
             * @public
             * @this DG.Tweening.TweenParams
             * @memberof DG.Tweening.TweenParams
             * @param   {boolean}                    isSpeedBased
             * @return  {DG.Tweening.TweenParams}
             */
            SetSpeedBased: function (isSpeedBased) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenParams#SetSpeedBased", this ); }

                if (isSpeedBased === void 0) { isSpeedBased = true; }
                this.isSpeedBased = isSpeedBased;
                return this;
            },
            /*DG.Tweening.TweenParams.SetSpeedBased end.*/


        },
        overloads: {
            "SetId(object)": "SetId$1",
            "SetId(string)": "SetId$2",
            "SetEase(AnimationCurve)": "SetEase$2",
            "SetEase(EaseFunction)": "SetEase$1",
            "SetUpdate(bool)": "SetUpdate$1"
        }
    });
    /*DG.Tweening.TweenParams end.*/

    /*DG.Tweening.TweenSettingsExtensions start.*/
    /**
     * Methods that extend Tween objects and allow to set their parameters
     *
     * @static
     * @abstract
     * @public
     * @class DG.Tweening.TweenSettingsExtensions
     */
    Bridge.define("DG.Tweening.TweenSettingsExtensions", {
        statics: {
            methods: {
                /*DG.Tweening.TweenSettingsExtensions.SetAutoKill:static start.*/
                /**
                 * Sets the autoKill behaviour of the tween to TRUE.
                     <pre><code>Has no effect</code></pre> if the tween has already started or if it's added to a Sequence
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}    T    
                 * @param   {T}           t
                 * @return  {T}
                 */
                SetAutoKill: function (T, t) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetAutoKill", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active || Bridge.rValue(t).creationLocked) {
                        return Bridge.rValue(t);
                    }

Bridge.rValue(                    t).autoKill = true;
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.SetAutoKill:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetAutoKill$1:static start.*/
                /**
                 * Sets the autoKill behaviour of the tween.
                     <pre><code>Has no effect</code></pre> if the tween has already started or if it's added to a Sequence
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}    T                       
                 * @param   {T}           t                       
                 * @param   {boolean}     autoKillOnCompletion    If TRUE the tween will be automatically killed when complete
                 * @return  {T}
                 */
                SetAutoKill$1: function (T, t, autoKillOnCompletion) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetAutoKill$1", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active || Bridge.rValue(t).creationLocked) {
                        return Bridge.rValue(t);
                    }

Bridge.rValue(                    t).autoKill = autoKillOnCompletion;
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.SetAutoKill$1:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetId$1:static start.*/
                /**
                 * Sets an ID for the tween ({@link }), which can then be used as a filter with DOTween's static
                     methods.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}         T           
                 * @param   {T}                t           
                 * @param   {System.Object}    objectId    The ID to assign to this tween. Can be an int, a string, an object or anything else.
                 * @return  {T}
                 */
                SetId$1: function (T, t, objectId) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetId$1", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active) {
                        return Bridge.rValue(t);
                    }

Bridge.rValue(                    t).id = objectId;
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.SetId$1:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetId$2:static start.*/
                /**
                 * Sets a string ID for the tween ({@link }), which can then be used as a filter with DOTween's
                     static methods.
                     <p />
                     Filtering via string is 2X faster than using an object as an ID (using the alternate obejct overload)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}    T           
                 * @param   {T}           t           
                 * @param   {string}      stringId    The string ID to assign to this tween.
                 * @return  {T}
                 */
                SetId$2: function (T, t, stringId) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetId$2", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active) {
                        return Bridge.rValue(t);
                    }

Bridge.rValue(                    t).stringId = stringId;
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.SetId$2:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetId:static start.*/
                /**
                 * Sets an int ID for the tween ({@link }), which can then be used as a filter with DOTween's static
                     methods.
                     <p />
                     Filtering via int is 4X faster than via object, 2X faster than via string (using the alternate object/string
                     overloads)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}    T        
                 * @param   {T}           t        
                 * @param   {number}      intId    The int ID to assign to this tween.
                 * @return  {T}
                 */
                SetId: function (T, t, intId) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetId", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active) {
                        return Bridge.rValue(t);
                    }

Bridge.rValue(                    t).intId = intId;
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.SetId:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetLink:static start.*/
                /**
                 * Allows to link this tween to a GameObject
                     so that it will be automatically killed when the GameObject is destroyed.
                     <pre><code>Has no effect</code></pre> if the tween is added to a Sequence
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}                  T             
                 * @param   {T}                         t             
                 * @param   {UnityEngine.GameObject}    gameObject    The link target (unrelated to the target set via <pre><code>SetTarget</code></pre>)
                 * @return  {T}
                 */
                SetLink: function (T, t, gameObject) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetLink", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active || Bridge.rValue(t).isSequenced || UnityEngine.GameObject.op_Equality(gameObject, null)) {
                        return Bridge.rValue(t);
                    }

                    DG.Tweening.Core.TweenManager.AddTweenLink(Bridge.rValue(t), new DG.Tweening.Core.TweenLink(gameObject, DG.Tweening.LinkBehaviour.KillOnDestroy));
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.SetLink:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetLink$1:static start.*/
                /**
                 * Allows to link this tween to a GameObject and assign a behaviour depending on it.
                     This will also automatically kill the tween when the GameObject is destroyed.
                     <pre><code>Has no effect</code></pre> if the tween is added to a Sequence
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}                     T             
                 * @param   {T}                            t             
                 * @param   {UnityEngine.GameObject}       gameObject    The link target (unrelated to the target set via <pre><code>SetTarget</code></pre>)
                 * @param   {DG.Tweening.LinkBehaviour}    behaviour     The behaviour to use ({@link } is always evaluated even if
                     you choose another one)
                 * @return  {T}
                 */
                SetLink$1: function (T, t, gameObject, behaviour) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetLink$1", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active || Bridge.rValue(t).isSequenced || UnityEngine.GameObject.op_Equality(gameObject, null)) {
                        return Bridge.rValue(t);
                    }

                    DG.Tweening.Core.TweenManager.AddTweenLink(Bridge.rValue(t), new DG.Tweening.Core.TweenLink(gameObject, behaviour));
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.SetLink$1:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetTarget:static start.*/
                /**
                 * Sets the target for the tween, which can then be used as a filter with DOTween's static methods.
                     <p>IMPORTANT: use it with caution. If you just want to set an ID for the tween use <pre><code>SetId</code></pre> instead.</p>
                     When using shorcuts the shortcut target is already assigned as the tween's target,
                     so using this method will overwrite it and prevent shortcut-operations like myTarget.DOPause from working
                     correctly.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}         T         
                 * @param   {T}                t         
                 * @param   {System.Object}    target    The target to assign to this tween. Can be an int, a string, an object or anything else.
                 * @return  {T}
                 */
                SetTarget: function (T, t, target) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetTarget", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active) {
                        return Bridge.rValue(t);
                    }

                    if (DG.Tweening.DOTween.debugStoreTargetId) {
                        var comp = Bridge.as(target, UnityEngine.Component);
Bridge.rValue(                        t).debugTargetId = UnityEngine.Component.op_Inequality(comp, null) ? comp.name : Bridge.toString(target);
                    }

Bridge.rValue(                    t).target = target;
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.SetTarget:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetLoops:static start.*/
                /**
                 * Sets the looping options for the tween.
                     Has no effect if the tween has already started
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}    T        
                 * @param   {T}           t        
                 * @param   {number}      loops    Number of cycles to play (-1 for infinite - will be converted to 1 in case the tween is nested in a
                     Sequence)
                 * @return  {T}
                 */
                SetLoops: function (T, t, loops) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetLoops", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active || Bridge.rValue(t).creationLocked) {
                        return Bridge.rValue(t);
                    }

                    if (loops < -1) {
                        loops = -1;
                    } else if (loops === 0) {
                        loops = 1;
                    }

Bridge.rValue(                    t).loops = loops;
                    //            if (t.tweenType == TweenType.Tweener) t.fullDuration = loops > -1 ? t.duration * loops : Mathf.Infinity; // Mysteriously Unity doesn't like this form
                    if (Bridge.rValue(t).tweenType === DG.Tweening.TweenType.Tweener) {
                        if (loops > -1) {
Bridge.rValue(                            t).fullDuration = Bridge.rValue(t).duration * loops;
                        } else {
Bridge.rValue(                            t).fullDuration = window.Infinity;
                        }
                    }

                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.SetLoops:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetLoops$1:static start.*/
                /**
                 * Sets the looping options for the tween.
                     Has no effect if the tween has already started
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}                T           
                 * @param   {T}                       t           
                 * @param   {number}                  loops       Number of cycles to play (-1 for infinite - will be converted to 1 in case the tween is nested in a
                     Sequence)
                 * @param   {DG.Tweening.LoopType}    loopType    Loop behaviour type (default: LoopType.Restart)
                 * @return  {T}
                 */
                SetLoops$1: function (T, t, loops, loopType) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetLoops$1", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active || Bridge.rValue(t).creationLocked) {
                        return Bridge.rValue(t);
                    }

                    if (loops < -1) {
                        loops = -1;
                    } else if (loops === 0) {
                        loops = 1;
                    }

Bridge.rValue(                    t).loops = loops;
Bridge.rValue(                    t).loopType = loopType;
                    //            if (t.tweenType == TweenType.Tweener) t.fullDuration = loops > -1 ? t.duration * loops : Mathf.Infinity;
                    if (Bridge.rValue(t).tweenType === DG.Tweening.TweenType.Tweener) {
                        if (loops > -1) {
Bridge.rValue(                            t).fullDuration = Bridge.rValue(t).duration * loops;
                        } else {
Bridge.rValue(                            t).fullDuration = window.Infinity;
                        }
                    }

                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.SetLoops$1:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetEase$2:static start.*/
                /**
                 * Sets the ease of the tween.
                     <p>If applied to Sequences eases the whole sequence animation</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}            T       
                 * @param   {T}                   t       
                 * @param   {DG.Tweening.Ease}    ease
                 * @return  {T}
                 */
                SetEase$2: function (T, t, ease) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetEase$2", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active) {
                        return Bridge.rValue(t);
                    }

Bridge.rValue(                    t).easeType = ease;
                    if (DG.Tweening.Core.Easing.EaseManager.IsFlashEase(ease)) {
Bridge.rValue(                        t).easeOvershootOrAmplitude = Math.floor(Bridge.rValue(t).easeOvershootOrAmplitude);
                    }

Bridge.rValue(                    t).customEase = null;
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.SetEase$2:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetEase$4:static start.*/
                /**
                 * Sets the ease of the tween.
                     <p>If applied to Sequences eases the whole sequence animation</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}            T            
                 * @param   {T}                   t            
                 * @param   {DG.Tweening.Ease}    ease         
                 * @param   {number}              overshoot    Eventual overshoot to use with Back or Flash ease (default is 1.70158 - 1 for Flash).
                     <p>In case of Flash ease it must be an intenger and sets the total number of flashes that will happen.
                         Using an even number will complete the tween on the starting value, while an odd one will complete it on the
                         end value.</p>
                 * @return  {T}
                 */
                SetEase$4: function (T, t, ease, overshoot) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetEase$4", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active) {
                        return Bridge.rValue(t);
                    }

Bridge.rValue(                    t).easeType = ease;
                    if (DG.Tweening.Core.Easing.EaseManager.IsFlashEase(ease)) {
                        overshoot = Math.floor(overshoot);
                    }

Bridge.rValue(                    t).easeOvershootOrAmplitude = overshoot;
Bridge.rValue(                    t).customEase = null;
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.SetEase$4:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetEase$3:static start.*/
                /**
                 * Sets the ease of the tween.
                     <p>If applied to Sequences eases the whole sequence animation</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}            T            
                 * @param   {T}                   t            
                 * @param   {DG.Tweening.Ease}    ease         
                 * @param   {number}              amplitude    Eventual amplitude to use with Elastic easeType or overshoot to use with Flash easeType (default is 1.70158 - 1 for
                     Flash).
                     <p>In case of Flash ease it must be an integer and sets the total number of flashes that will happen.
                         Using an even number will complete the tween on the starting value, while an odd one will complete it on the
                         end value.</p>
                 * @param   {number}              period       Eventual period to use with Elastic or Flash easeType (default is 0).
                     <p>In case of Flash ease it indicates the power in time of the ease, and must be between -1 and 1.
                         0 is balanced, 1 weakens the ease with time, -1 starts the ease weakened and gives it power towards the end.</p>
                 * @return  {T}
                 */
                SetEase$3: function (T, t, ease, amplitude, period) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetEase$3", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active) {
                        return Bridge.rValue(t);
                    }

Bridge.rValue(                    t).easeType = ease;
                    if (DG.Tweening.Core.Easing.EaseManager.IsFlashEase(ease)) {
                        amplitude = Math.floor(amplitude);
                    }

Bridge.rValue(                    t).easeOvershootOrAmplitude = amplitude;
Bridge.rValue(                    t).easePeriod = period;
Bridge.rValue(                    t).customEase = null;
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.SetEase$3:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetEase:static start.*/
                /**
                 * Sets the ease of the tween using an AnimationCurve.
                     <p>If applied to Sequences eases the whole sequence animation</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}             T            
                 * @param   {T}                    t            
                 * @param   {pc.AnimationCurve}    animCurve
                 * @return  {T}
                 */
                SetEase: function (T, t, animCurve) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetEase", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active) {
                        return Bridge.rValue(t);
                    }

Bridge.rValue(                    t).easeType = DG.Tweening.Ease.INTERNAL_Custom;
Bridge.rValue(                    t).customEase = Bridge.fn.cacheBind(new DG.Tweening.Core.Easing.EaseCurve(animCurve), new DG.Tweening.Core.Easing.EaseCurve(animCurve).Evaluate);
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.SetEase:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetEase$1:static start.*/
                /**
                 * Sets the ease of the tween using a custom ease function (which must return a value between 0 and 1).
                     <p>If applied to Sequences eases the whole sequence animation</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}                    T             
                 * @param   {T}                           t             
                 * @param   {DG.Tweening.EaseFunction}    customEase
                 * @return  {T}
                 */
                SetEase$1: function (T, t, customEase) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetEase$1", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active) {
                        return Bridge.rValue(t);
                    }

Bridge.rValue(                    t).easeType = DG.Tweening.Ease.INTERNAL_Custom;
Bridge.rValue(                    t).customEase = customEase;
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.SetEase$1:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetRecyclable:static start.*/
                /**
                 * Allows the tween to be recycled after being killed.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}    T    
                 * @param   {T}           t
                 * @return  {T}
                 */
                SetRecyclable: function (T, t) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetRecyclable", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active) {
                        return Bridge.rValue(t);
                    }

Bridge.rValue(                    t).isRecyclable = true;
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.SetRecyclable:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetRecyclable$1:static start.*/
                /**
                 * Sets the recycling behaviour for the tween.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}    T             
                 * @param   {T}           t             
                 * @param   {boolean}     recyclable    If TRUE the tween will be recycled after being killed, otherwise it will be destroyed.
                 * @return  {T}
                 */
                SetRecyclable$1: function (T, t, recyclable) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetRecyclable$1", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active) {
                        return Bridge.rValue(t);
                    }

Bridge.rValue(                    t).isRecyclable = recyclable;
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.SetRecyclable$1:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetUpdate:static start.*/
                /**
                 * Sets the update type to UpdateType.Normal and lets you choose if it should be independent from Unity's
                     Time.timeScale
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}    T                      
                 * @param   {T}           t                      
                 * @param   {boolean}     isIndependentUpdate    If TRUE the tween will ignore Unity's Time.timeScale
                 * @return  {T}
                 */
                SetUpdate: function (T, t, isIndependentUpdate) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetUpdate", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active) {
                        return Bridge.rValue(t);
                    }

                    DG.Tweening.Core.TweenManager.SetUpdateType(Bridge.rValue(t), DG.Tweening.DOTween.defaultUpdateType, isIndependentUpdate);
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.SetUpdate:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetUpdate$1:static start.*/
                /**
                 * Sets the type of update for the tween
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}                  T             
                 * @param   {T}                         t             
                 * @param   {DG.Tweening.UpdateType}    updateType    The type of update (defalt: UpdateType.Normal)
                 * @return  {T}
                 */
                SetUpdate$1: function (T, t, updateType) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetUpdate$1", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active) {
                        return Bridge.rValue(t);
                    }

                    DG.Tweening.Core.TweenManager.SetUpdateType(Bridge.rValue(t), updateType, DG.Tweening.DOTween.defaultTimeScaleIndependent);
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.SetUpdate$1:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetUpdate$2:static start.*/
                /**
                 * Sets the type of update for the tween and lets you choose if it should be independent from Unity's
                     Time.timeScale
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}                  T                      
                 * @param   {T}                         t                      
                 * @param   {DG.Tweening.UpdateType}    updateType             The type of update
                 * @param   {boolean}                   isIndependentUpdate    If TRUE the tween will ignore Unity's Time.timeScale
                 * @return  {T}
                 */
                SetUpdate$2: function (T, t, updateType, isIndependentUpdate) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetUpdate$2", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active) {
                        return Bridge.rValue(t);
                    }

                    DG.Tweening.Core.TweenManager.SetUpdateType(Bridge.rValue(t), updateType, isIndependentUpdate);
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.SetUpdate$2:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetInverted:static start.*/
                /**
                 * EXPERIMENTAL: inverts this tween, so that it will play from the end to the beginning
                     (playing it backwards will actually play it from the beginning to the end).
                     <pre><code>Has no effect</code></pre> if the tween has already started or if it's added to a Sequence
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}    T    
                 * @param   {T}           t
                 * @return  {T}
                 */
                SetInverted: function (T, t) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetInverted", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active || Bridge.rValue(t).creationLocked) {
                        return Bridge.rValue(t);
                    }

Bridge.rValue(                    t).isInverted = true;
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.SetInverted:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetInverted$1:static start.*/
                /**
                 * EXPERIMENTAL: inverts this tween, so that it will play from the end to the beginning
                     (playing it backwards will actually play it from the beginning to the end).
                     <pre><code>Has no effect</code></pre> if the tween has already started or if it's added to a Sequence
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}    T           
                 * @param   {T}           t           
                 * @param   {boolean}     inverted    If TRUE the tween will be inverted, otherwise it won't
                 * @return  {T}
                 */
                SetInverted$1: function (T, t, inverted) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetInverted$1", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active || Bridge.rValue(t).creationLocked) {
                        return Bridge.rValue(t);
                    }

Bridge.rValue(                    t).isInverted = inverted;
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.SetInverted$1:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.OnStart:static start.*/
                /**
                 * Sets the <pre><code>onStart</code></pre> callback for the tween, clearing any previous <pre><code>onStart</code></pre> callback that was
                     set.
                     Called the first time the tween is set in a playing state, after any eventual delay
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}                     T         
                 * @param   {T}                            t         
                 * @param   {DG.Tweening.TweenCallback}    action
                 * @return  {T}
                 */
                OnStart: function (T, t, action) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#OnStart", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active) {
                        return Bridge.rValue(t);
                    }

Bridge.rValue(                    t).onStart = action;
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.OnStart:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.OnPlay:static start.*/
                /**
                 * Sets the <pre><code>onPlay</code></pre> callback for the tween, clearing any previous <pre><code>onPlay</code></pre> callback that was
                     set.
                     Called when the tween is set in a playing state, after any eventual delay.
                     Also called each time the tween resumes playing from a paused state
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}                     T         
                 * @param   {T}                            t         
                 * @param   {DG.Tweening.TweenCallback}    action
                 * @return  {T}
                 */
                OnPlay: function (T, t, action) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#OnPlay", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active) {
                        return Bridge.rValue(t);
                    }

Bridge.rValue(                    t).onPlay = action;
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.OnPlay:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.OnPause:static start.*/
                /**
                 * Sets the <pre><code>onPause</code></pre> callback for the tween, clearing any previous <pre><code>onPause</code></pre> callback that was
                     set.
                     Called when the tween state changes from playing to paused.
                     If the tween has autoKill set to FALSE, this is called also when the tween reaches completion.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}                     T         
                 * @param   {T}                            t         
                 * @param   {DG.Tweening.TweenCallback}    action
                 * @return  {T}
                 */
                OnPause: function (T, t, action) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#OnPause", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active) {
                        return Bridge.rValue(t);
                    }

Bridge.rValue(                    t).onPause = action;
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.OnPause:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.OnRewind:static start.*/
                /**
                 * Sets the <pre><code>onRewind</code></pre> callback for the tween, clearing any previous <pre><code>onRewind</code></pre> callback that
                     was set.
                     Called when the tween is rewinded,
                     either by calling <pre><code>Rewind</code></pre> or by reaching the start position while playing backwards.
                     Rewinding a tween that is already rewinded will not fire this callback
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}                     T         
                 * @param   {T}                            t         
                 * @param   {DG.Tweening.TweenCallback}    action
                 * @return  {T}
                 */
                OnRewind: function (T, t, action) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#OnRewind", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active) {
                        return Bridge.rValue(t);
                    }

Bridge.rValue(                    t).onRewind = action;
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.OnRewind:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.OnUpdate:static start.*/
                /**
                 * Sets the <pre><code>onUpdate</code></pre> callback for the tween, clearing any previous <pre><code>onUpdate</code></pre> callback that
                     was set.
                     Called each time the tween updates
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}                     T         
                 * @param   {T}                            t         
                 * @param   {DG.Tweening.TweenCallback}    action
                 * @return  {T}
                 */
                OnUpdate: function (T, t, action) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#OnUpdate", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active) {
                        return Bridge.rValue(t);
                    }

Bridge.rValue(                    t).onUpdate = action;
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.OnUpdate:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.OnStepComplete:static start.*/
                /**
                 * Sets the <pre><code>onStepComplete</code></pre> callback for the tween, clearing any previous <pre><code>onStepComplete</code></pre>
                     callback that was set.
                     Called the moment the tween completes one loop cycle, even when going backwards
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}                     T         
                 * @param   {T}                            t         
                 * @param   {DG.Tweening.TweenCallback}    action
                 * @return  {T}
                 */
                OnStepComplete: function (T, t, action) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#OnStepComplete", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active) {
                        return Bridge.rValue(t);
                    }

Bridge.rValue(                    t).onStepComplete = action;
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.OnStepComplete:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.OnComplete:static start.*/
                /**
                 * Sets the <pre><code>onComplete</code></pre> callback for the tween, clearing any previous <pre><code>onComplete</code></pre> callback
                     that was set.
                     Called the moment the tween reaches its final forward position, loops included
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}                     T         
                 * @param   {T}                            t         
                 * @param   {DG.Tweening.TweenCallback}    action
                 * @return  {T}
                 */
                OnComplete: function (T, t, action) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#OnComplete", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active) {
                        return Bridge.rValue(t);
                    }

Bridge.rValue(                    t).onComplete = action;
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.OnComplete:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.OnKill:static start.*/
                /**
                 * Sets the <pre><code>onKill</code></pre> callback for the tween, clearing any previous <pre><code>onKill</code></pre> callback that was
                     set.
                     Called the moment the tween is killed
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}                     T         
                 * @param   {T}                            t         
                 * @param   {DG.Tweening.TweenCallback}    action
                 * @return  {T}
                 */
                OnKill: function (T, t, action) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#OnKill", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active) {
                        return Bridge.rValue(t);
                    }

Bridge.rValue(                    t).onKill = action;
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.OnKill:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.OnWaypointChange:static start.*/
                /**
                 * Sets the <pre><code>onWaypointChange</code></pre> callback for the tween, clearing any previous <pre><code>onWaypointChange</code></pre>
                     callback that was set.
                     Called when a path tween's current waypoint changes
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}                     T         
                 * @param   {T}                            t         
                 * @param   {DG.Tweening.TweenCallback}    action
                 * @return  {T}
                 */
                OnWaypointChange: function (T, t, action) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#OnWaypointChange", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active) {
                        return Bridge.rValue(t);
                    }

Bridge.rValue(                    t).onWaypointChange = action;
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.OnWaypointChange:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetAs:static start.*/
                /**
                 * Sets the parameters of the tween (id, ease, loops, delay, timeScale, callbacks, etc) as the parameters of the given
                     one.
                     Doesn't copy specific SetOptions settings: those will need to be applied manually each time.
                     <p>Has no effect if the tween has already started.</p>
                     NOTE: the tween's <pre><code>target</code></pre> will not be changed
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}             T          
                 * @param   {T}                    t          
                 * @param   {DG.Tweening.Tween}    asTween    Tween from which to copy the parameters
                 * @return  {T}
                 */
                SetAs: function (T, t, asTween) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetAs", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active || Bridge.rValue(t).creationLocked) {
                        return Bridge.rValue(t);
                    }

                    //            t.isFrom = asTween.isFrom;
                    //            t.target = asTween.target;

Bridge.rValue(                    t).timeScale = asTween.timeScale;
Bridge.rValue(                    t).isBackwards = asTween.isBackwards;
                    DG.Tweening.Core.TweenManager.SetUpdateType(Bridge.rValue(t), asTween.updateType, asTween.isIndependentUpdate);
Bridge.rValue(                    t).id = asTween.id;
Bridge.rValue(                    t).stringId = asTween.stringId;
Bridge.rValue(                    t).intId = asTween.intId;
Bridge.rValue(                    t).onStart = asTween.onStart;
Bridge.rValue(                    t).onPlay = asTween.onPlay;
Bridge.rValue(                    t).onRewind = asTween.onRewind;
Bridge.rValue(                    t).onUpdate = asTween.onUpdate;
Bridge.rValue(                    t).onStepComplete = asTween.onStepComplete;
Bridge.rValue(                    t).onComplete = asTween.onComplete;
Bridge.rValue(                    t).onKill = asTween.onKill;
Bridge.rValue(                    t).onWaypointChange = asTween.onWaypointChange;

Bridge.rValue(                    t).isRecyclable = asTween.isRecyclable;
Bridge.rValue(                    t).isSpeedBased = asTween.isSpeedBased;
Bridge.rValue(                    t).autoKill = asTween.autoKill;
Bridge.rValue(                    t).loops = asTween.loops;
Bridge.rValue(                    t).loopType = asTween.loopType;
                    if (Bridge.rValue(t).tweenType === DG.Tweening.TweenType.Tweener) {
                        if (Bridge.rValue(t).loops > -1) {
Bridge.rValue(                            t).fullDuration = Bridge.rValue(t).duration * Bridge.rValue(t).loops;
                        } else {
Bridge.rValue(                            t).fullDuration = window.Infinity;
                        }
                    }

Bridge.rValue(                    t).delay = asTween.delay;
Bridge.rValue(                    t).delayComplete = Bridge.rValue(t).delay <= 0;
Bridge.rValue(                    t).isRelative = asTween.isRelative;
Bridge.rValue(                    t).easeType = asTween.easeType;
Bridge.rValue(                    t).customEase = asTween.customEase;
Bridge.rValue(                    t).easeOvershootOrAmplitude = asTween.easeOvershootOrAmplitude;
Bridge.rValue(                    t).easePeriod = asTween.easePeriod;

                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.SetAs:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetAs$1:static start.*/
                /**
                 * Sets the parameters of the tween (id, ease, loops, delay, timeScale, callbacks, etc) as the parameters of the given
                     TweenParams.
                     <p>Has no effect if the tween has already started.</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}                   T              
                 * @param   {T}                          t              
                 * @param   {DG.Tweening.TweenParams}    tweenParams    TweenParams from which to copy the parameters
                 * @return  {T}
                 */
                SetAs$1: function (T, t, tweenParams) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetAs$1", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active || Bridge.rValue(t).creationLocked) {
                        return Bridge.rValue(t);
                    }

                    DG.Tweening.Core.TweenManager.SetUpdateType(Bridge.rValue(t), tweenParams.updateType, tweenParams.isIndependentUpdate);
Bridge.rValue(                    t).id = tweenParams.id;
Bridge.rValue(                    t).stringId = tweenParams.stringId;
Bridge.rValue(                    t).intId = tweenParams.intId;
Bridge.rValue(                    t).onStart = tweenParams.onStart;
Bridge.rValue(                    t).onPlay = tweenParams.onPlay;
Bridge.rValue(                    t).onRewind = tweenParams.onRewind;
Bridge.rValue(                    t).onUpdate = tweenParams.onUpdate;
Bridge.rValue(                    t).onStepComplete = tweenParams.onStepComplete;
Bridge.rValue(                    t).onComplete = tweenParams.onComplete;
Bridge.rValue(                    t).onKill = tweenParams.onKill;
Bridge.rValue(                    t).onWaypointChange = tweenParams.onWaypointChange;

Bridge.rValue(                    t).isRecyclable = tweenParams.isRecyclable;
Bridge.rValue(                    t).isSpeedBased = tweenParams.isSpeedBased;
Bridge.rValue(                    t).autoKill = tweenParams.autoKill;
Bridge.rValue(                    t).loops = tweenParams.loops;
Bridge.rValue(                    t).loopType = tweenParams.loopType;
                    if (Bridge.rValue(t).tweenType === DG.Tweening.TweenType.Tweener) {
                        if (Bridge.rValue(t).loops > -1) {
Bridge.rValue(                            t).fullDuration = Bridge.rValue(t).duration * Bridge.rValue(t).loops;
                        } else {
Bridge.rValue(                            t).fullDuration = window.Infinity;
                        }
                    }

Bridge.rValue(                    t).delay = tweenParams.delay;
Bridge.rValue(                    t).delayComplete = Bridge.rValue(t).delay <= 0;
Bridge.rValue(                    t).isRelative = tweenParams.isRelative;
                    if (tweenParams.easeType === DG.Tweening.Ease.Unset) {
                        if (Bridge.rValue(t).tweenType === DG.Tweening.TweenType.Sequence) {
Bridge.rValue(                            t).easeType = DG.Tweening.Ease.Linear;
                        } else {
Bridge.rValue(                            t).easeType = DG.Tweening.DOTween.defaultEaseType;
                        }

                        //                t.easeType = t.tweenType == TweenType.Sequence ? Ease.Linear : DOTween.defaultEaseType; // Doesn't work w webplayer (why?)
                    } else {
Bridge.rValue(                        t).easeType = tweenParams.easeType;
                    }

Bridge.rValue(                    t).customEase = tweenParams.customEase;
Bridge.rValue(                    t).easeOvershootOrAmplitude = tweenParams.easeOvershootOrAmplitude;
Bridge.rValue(                    t).easePeriod = tweenParams.easePeriod;

                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.SetAs$1:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.Append:static start.*/
                /**
                 * Adds the given tween to the end of the Sequence.
                     Has no effect if the Sequence has already started
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {DG.Tweening.Sequence}    s    
                 * @param   {DG.Tweening.Tween}       t    The tween to append
                 * @return  {DG.Tweening.Sequence}
                 */
                Append: function (s, t) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#Append", this ); }

                    if (!DG.Tweening.TweenSettingsExtensions.ValidateAddToSequence(s, t)) {
                        return s;
                    }

                    DG.Tweening.Sequence.DoInsert(s, t, s.duration);
                    return s;
                },
                /*DG.Tweening.TweenSettingsExtensions.Append:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.Prepend:static start.*/
                /**
                 * Adds the given tween to the beginning of the Sequence, pushing forward the other nested content.
                     Has no effect if the Sequence has already started
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {DG.Tweening.Sequence}    s    
                 * @param   {DG.Tweening.Tween}       t    The tween to prepend
                 * @return  {DG.Tweening.Sequence}
                 */
                Prepend: function (s, t) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#Prepend", this ); }

                    if (!DG.Tweening.TweenSettingsExtensions.ValidateAddToSequence(s, t)) {
                        return s;
                    }

                    DG.Tweening.Sequence.DoPrepend(s, t);
                    return s;
                },
                /*DG.Tweening.TweenSettingsExtensions.Prepend:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.Join:static start.*/
                /**
                 * Inserts the given tween at the same time position of the last tween, callback or intervale added to the Sequence.
                     Note that, in case of a Join after an interval, the insertion time will be the time where the interval starts, not
                     where it finishes.
                     Has no effect if the Sequence has already started
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {DG.Tweening.Sequence}    s    
                 * @param   {DG.Tweening.Tween}       t
                 * @return  {DG.Tweening.Sequence}
                 */
                Join: function (s, t) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#Join", this ); }

                    if (!DG.Tweening.TweenSettingsExtensions.ValidateAddToSequence(s, t)) {
                        return s;
                    }

                    DG.Tweening.Sequence.DoInsert(s, t, s.lastTweenInsertTime);
                    return s;
                },
                /*DG.Tweening.TweenSettingsExtensions.Join:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.Insert:static start.*/
                /**
                 * Inserts the given tween at the given time position in the Sequence,
                     automatically adding an interval if needed.
                     Has no effect if the Sequence has already started
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {DG.Tweening.Sequence}    s             
                 * @param   {number}                  atPosition    The time position where the tween will be placed
                 * @param   {DG.Tweening.Tween}       t             The tween to insert
                 * @return  {DG.Tweening.Sequence}
                 */
                Insert: function (s, atPosition, t) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#Insert", this ); }

                    if (!DG.Tweening.TweenSettingsExtensions.ValidateAddToSequence(s, t)) {
                        return s;
                    }

                    DG.Tweening.Sequence.DoInsert(s, t, atPosition);
                    return s;
                },
                /*DG.Tweening.TweenSettingsExtensions.Insert:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.AppendInterval:static start.*/
                /**
                 * Adds the given interval to the end of the Sequence.
                     Has no effect if the Sequence has already started
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {DG.Tweening.Sequence}    s           
                 * @param   {number}                  interval    The interval duration
                 * @return  {DG.Tweening.Sequence}
                 */
                AppendInterval: function (s, interval) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#AppendInterval", this ); }

                    if (!DG.Tweening.TweenSettingsExtensions.ValidateAddToSequence(s, null, true)) {
                        return s;
                    }

                    DG.Tweening.Sequence.DoAppendInterval(s, interval);
                    return s;
                },
                /*DG.Tweening.TweenSettingsExtensions.AppendInterval:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.PrependInterval:static start.*/
                /**
                 * Adds the given interval to the beginning of the Sequence, pushing forward the other nested content.
                     Has no effect if the Sequence has already started
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {DG.Tweening.Sequence}    s           
                 * @param   {number}                  interval    The interval duration
                 * @return  {DG.Tweening.Sequence}
                 */
                PrependInterval: function (s, interval) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#PrependInterval", this ); }

                    if (!DG.Tweening.TweenSettingsExtensions.ValidateAddToSequence(s, null, true)) {
                        return s;
                    }

                    DG.Tweening.Sequence.DoPrependInterval(s, interval);
                    return s;
                },
                /*DG.Tweening.TweenSettingsExtensions.PrependInterval:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.AppendCallback:static start.*/
                /**
                 * Adds the given callback to the end of the Sequence.
                     Has no effect if the Sequence has already started
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {DG.Tweening.Sequence}         s           
                 * @param   {DG.Tweening.TweenCallback}    callback    The callback to append
                 * @return  {DG.Tweening.Sequence}
                 */
                AppendCallback: function (s, callback) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#AppendCallback", this ); }

                    if (!DG.Tweening.TweenSettingsExtensions.ValidateAddToSequence(s, null, true)) {
                        return s;
                    }

                    if (Bridge.staticEquals(callback, null)) {
                        return s;
                    }

                    DG.Tweening.Sequence.DoInsertCallback(s, callback, s.duration);
                    return s;
                },
                /*DG.Tweening.TweenSettingsExtensions.AppendCallback:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.PrependCallback:static start.*/
                /**
                 * Adds the given callback to the beginning of the Sequence, pushing forward the other nested content.
                     Has no effect if the Sequence has already started
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {DG.Tweening.Sequence}         s           
                 * @param   {DG.Tweening.TweenCallback}    callback    The callback to prepend
                 * @return  {DG.Tweening.Sequence}
                 */
                PrependCallback: function (s, callback) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#PrependCallback", this ); }

                    if (!DG.Tweening.TweenSettingsExtensions.ValidateAddToSequence(s, null, true)) {
                        return s;
                    }

                    if (Bridge.staticEquals(callback, null)) {
                        return s;
                    }

                    DG.Tweening.Sequence.DoInsertCallback(s, callback, 0);
                    return s;
                },
                /*DG.Tweening.TweenSettingsExtensions.PrependCallback:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.InsertCallback:static start.*/
                /**
                 * Inserts the given callback at the given time position in the Sequence,
                     automatically adding an interval if needed.
                     Has no effect if the Sequence has already started
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {DG.Tweening.Sequence}         s             
                 * @param   {number}                       atPosition    The time position where the callback will be placed
                 * @param   {DG.Tweening.TweenCallback}    callback      The callback to insert
                 * @return  {DG.Tweening.Sequence}
                 */
                InsertCallback: function (s, atPosition, callback) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#InsertCallback", this ); }

                    if (!DG.Tweening.TweenSettingsExtensions.ValidateAddToSequence(s, null, true)) {
                        return s;
                    }

                    if (Bridge.staticEquals(callback, null)) {
                        return s;
                    }

                    DG.Tweening.Sequence.DoInsertCallback(s, callback, atPosition);
                    return s;
                },
                /*DG.Tweening.TweenSettingsExtensions.InsertCallback:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.ValidateAddToSequence:static start.*/
                ValidateAddToSequence: function (s, t, ignoreTween) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#ValidateAddToSequence", this ); }

                    if (ignoreTween === void 0) { ignoreTween = false; }
                    if (s == null) {
                        DG.Tweening.Core.Debugger.Sequence.LogAddToNullSequence();
                        return false;
                    }

                    if (!s.active) {
                        DG.Tweening.Core.Debugger.Sequence.LogAddToInactiveSequence();
                        return false;
                    }

                    if (s.creationLocked) {
                        DG.Tweening.Core.Debugger.Sequence.LogAddToLockedSequence();
                        return false;
                    }

                    if (!ignoreTween) {
                        if (t == null) {
                            DG.Tweening.Core.Debugger.Sequence.LogAddNullTween();
                            return false;
                        }

                        if (!t.active) {
                            DG.Tweening.Core.Debugger.Sequence.LogAddInactiveTween(t);
                            return false;
                        }

                        if (t.isSequenced) {
                            DG.Tweening.Core.Debugger.Sequence.LogAddAlreadySequencedTween(t);
                            return false;
                        }
                    }

                    return true;
                },
                /*DG.Tweening.TweenSettingsExtensions.ValidateAddToSequence:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.From:static start.*/
                /**
                 * Changes a TO tween into a FROM tween: sets the current target's position as the tween's endValue
                     then immediately sends the target to the previously set endValue.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}    T    
                 * @param   {T}           t
                 * @return  {T}
                 */
                From: function (T, t) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#From", this ); }

                    return DG.Tweening.TweenSettingsExtensions.From$2(T, Bridge.rValue(t), true, false);
                },
                /*DG.Tweening.TweenSettingsExtensions.From:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.From$1:static start.*/
                /**
                 * Changes a TO tween into a FROM tween: sets the current target's position as the tween's endValue
                     then immediately sends the target to the previously set endValue.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}    T             
                 * @param   {T}           t             
                 * @param   {boolean}     isRelative    If TRUE the FROM value will be calculated as relative to the current one
                 * @return  {T}
                 */
                From$1: function (T, t, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#From$1", this ); }

                    {
                        return DG.Tweening.TweenSettingsExtensions.From$2(T, Bridge.rValue(t), true, isRelative);
                    }
                },
                /*DG.Tweening.TweenSettingsExtensions.From$1:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.From$2:static start.*/
                /**
                 * Changes a TO tween into a FROM tween: sets the current value of the target as the endValue,
                     and the previously passed endValue as the actual startValue.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}    T                 
                 * @param   {T}           t                 
                 * @param   {boolean}     setImmediately    If TRUE sets the target to from value immediately, otherwise waits for the tween to start
                 * @param   {boolean}     isRelative        If TRUE the FROM value will be calculated as relative to the current one
                 * @return  {T}
                 */
                From$2: function (T, t, setImmediately, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#From$2", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active || Bridge.rValue(t).creationLocked || !Bridge.rValue(t).isFromAllowed) {
                        return Bridge.rValue(t);
                    }

Bridge.rValue(                    t).isFrom = true;
                    if (setImmediately) {
Bridge.rValue(                        t).SetFrom(isRelative && !Bridge.rValue(t).isBlendable);
                    } else {
                        // Just mark the tween as relative (will be reset to FALSE once the From is applied at startup)
                        // and let the startup routine set the From values
Bridge.rValue(                        t).isRelative = isRelative;
                    }

                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.From$2:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.From$3:static start.*/
                /**
                 * Changes a TO tween into a FROM tween: sets the tween's starting value to the given one
                     and eventually sets the tween's target to that value immediately.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}                          T1                
                 * @param   {Function}                          T2                
                 * @param   {Function}                          TPlugOptions      
                 * @param   {DG.Tweening.Core.TweenerCore$3}    t                 
                 * @param   {T2}                                fromValue         Value to start from
                 * @param   {boolean}                           setImmediately    If TRUE sets the target to from value immediately, otherwise waits for the tween to start
                 * @param   {boolean}                           isRelative        If TRUE the FROM/TO values will be calculated as relative to the current ones
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                From$3: function (T1, T2, TPlugOptions, t, fromValue, setImmediately, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#From$3", this ); }

                    if (setImmediately === void 0) { setImmediately = true; }
                    if (isRelative === void 0) { isRelative = false; }
                    if (t == null || !t.active || t.creationLocked || !t.isFromAllowed) {
                        return t;
                    }

                    t.isFrom = true;
                    t.SetFrom$1(Bridge.rValue(fromValue), setImmediately, isRelative);
                    return t;
                },
                /*DG.Tweening.TweenSettingsExtensions.From$3:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.From$4:static start.*/
                /**
                 * Changes a TO tween into a FROM tween: sets the tween's starting value to the given one
                     and eventually sets the tween's target to that value immediately.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {DG.Tweening.Core.TweenerCore$3}    t                 
                 * @param   {number}                            fromAlphaValue    Alpha value to start from (in case of Fade tweens)
                 * @param   {boolean}                           setImmediately    If TRUE sets the target to from value immediately, otherwise waits for the tween to start
                 * @param   {boolean}                           isRelative        If TRUE the FROM/TO values will be calculated as relative to the current ones
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                From$4: function (t, fromAlphaValue, setImmediately, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#From$4", this ); }

                    if (setImmediately === void 0) { setImmediately = true; }
                    if (isRelative === void 0) { isRelative = false; }
                    if (t == null || !t.active || t.creationLocked || !t.isFromAllowed) {
                        return t;
                    }

                    t.isFrom = true;
                    t.SetFrom$1(new pc.Color( 0, 0, 0, fromAlphaValue ), setImmediately, isRelative);
                    return t;
                },
                /*DG.Tweening.TweenSettingsExtensions.From$4:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.From$6:static start.*/
                /**
                 * Changes a TO tween into a FROM tween: sets the tween's starting value to the given one
                     and eventually sets the tween's target to that value immediately.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {DG.Tweening.Core.TweenerCore$3}    t                 
                 * @param   {number}                            fromValue         Value to start from (in case of Vector tweens that act on a single coordinate or scale tweens)
                 * @param   {boolean}                           setImmediately    If TRUE sets the target to from value immediately, otherwise waits for the tween to start
                 * @param   {boolean}                           isRelative        If TRUE the FROM/TO values will be calculated as relative to the current ones
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                From$6: function (t, fromValue, setImmediately, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#From$6", this ); }

                    if (setImmediately === void 0) { setImmediately = true; }
                    if (isRelative === void 0) { isRelative = false; }
                    if (t == null || !t.active || t.creationLocked || !t.isFromAllowed) {
                        return t;
                    }

                    t.isFrom = true;
                    t.SetFrom$1(new pc.Vec3( fromValue, fromValue, fromValue ), setImmediately, isRelative);
                    return t;
                },
                /*DG.Tweening.TweenSettingsExtensions.From$6:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.From$5:static start.*/
                /**
                 * Changes a TO tween into a FROM tween: sets the tween's starting value to the given one
                     and eventually sets the tween's target to that value immediately.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {DG.Tweening.Core.TweenerCore$3}    t                   
                 * @param   {number}                            fromValueDegrees    Value to start from (in case of Vector tweens that act on a single coordinate or scale
                     tweens)
                 * @param   {boolean}                           setImmediately      If TRUE sets the target to from value immediately, otherwise waits for the tween to start
                 * @param   {boolean}                           isRelative          If TRUE the FROM/TO values will be calculated as relative to the current ones
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                From$5: function (t, fromValueDegrees, setImmediately, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#From$5", this ); }

                    if (setImmediately === void 0) { setImmediately = true; }
                    if (isRelative === void 0) { isRelative = false; }
                    if (t == null || !t.active || t.creationLocked || !t.isFromAllowed) {
                        return t;
                    }

                    t.isFrom = true;
                    t.SetFrom$1(new pc.Vec2( fromValueDegrees, 0 ), setImmediately, isRelative);
                    return t;
                },
                /*DG.Tweening.TweenSettingsExtensions.From$5:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetDelay:static start.*/
                /**
                 * Sets a delayed startup for the tween.
                     <p />
                     In case of Sequences behaves the same as {@link },
                     which means the delay will repeat in case of loops (while with tweens it's ignored after the first loop cycle).
                     <p />
                     Has no effect if the tween has already started
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}    T        
                 * @param   {T}           t        
                 * @param   {number}      delay
                 * @return  {T}
                 */
                SetDelay: function (T, t, delay) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetDelay", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active || Bridge.rValue(t).creationLocked) {
                        return Bridge.rValue(t);
                    }

                    if (Bridge.rValue(t).tweenType === DG.Tweening.TweenType.Sequence) {
                        DG.Tweening.TweenSettingsExtensions.PrependInterval((Bridge.as(Bridge.rValue(t), DG.Tweening.Sequence)), delay);
                    } else {
Bridge.rValue(                        t).delay = delay;
Bridge.rValue(                        t).delayComplete = delay <= 0;
                    }

                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.SetDelay:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetDelay$1:static start.*/
                /**
                 * EXPERIMENTAL: implemented in v1.2.340.
                     <p />
                     Sets a delayed startup for the tween with options to choose how the delay is applied in case of Sequences.
                     <p />
                     Has no effect if the tween has already started
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}    T                                
                 * @param   {T}           t                                
                 * @param   {number}      delay                            
                 * @param   {boolean}     asPrependedIntervalIfSequence    Only used by {@link } types: If FALSE sets the delay as a one-time occurrence
                     (defaults to this for {@link } types),
                     otherwise as a Sequence interval which will repeat at the beginning of every loop cycle
                 * @return  {T}
                 */
                SetDelay$1: function (T, t, delay, asPrependedIntervalIfSequence) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetDelay$1", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active || Bridge.rValue(t).creationLocked) {
                        return Bridge.rValue(t);
                    }

                    var isSequence = Bridge.rValue(t).tweenType === DG.Tweening.TweenType.Sequence;
                    if (!isSequence || !asPrependedIntervalIfSequence) {
Bridge.rValue(                        t).delay = delay;
Bridge.rValue(                        t).delayComplete = delay <= 0;
                    } else {
                        DG.Tweening.TweenSettingsExtensions.PrependInterval((Bridge.as(Bridge.rValue(t), DG.Tweening.Sequence)), delay);
                    }

                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.SetDelay$1:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetRelative:static start.*/
                /**
                 * Sets the tween as relative
                     (the endValue will be calculated as <pre><code>startValue + endValue</code></pre> instead than being used directly).
                     <p>Has no effect on Sequences or if the tween has already started</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}    T    
                 * @param   {T}           t
                 * @return  {T}
                 */
                SetRelative: function (T, t) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetRelative", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active || Bridge.rValue(t).creationLocked || Bridge.rValue(t).isFrom || Bridge.rValue(t).isBlendable) {
                        return Bridge.rValue(t);
                    }

Bridge.rValue(                    t).isRelative = true;
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.SetRelative:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetRelative$1:static start.*/
                /**
                 * If isRelative is TRUE sets the tween as relative
                     (the endValue will be calculated as <pre><code>startValue + endValue</code></pre> instead than being used directly).
                     <p>Has no effect on Sequences or if the tween has already started</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}    T             
                 * @param   {T}           t             
                 * @param   {boolean}     isRelative
                 * @return  {T}
                 */
                SetRelative$1: function (T, t, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetRelative$1", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active || Bridge.rValue(t).creationLocked || Bridge.rValue(t).isFrom || Bridge.rValue(t).isBlendable) {
                        return Bridge.rValue(t);
                    }

Bridge.rValue(                    t).isRelative = isRelative;
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.SetRelative$1:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetSpeedBased:static start.*/
                /**
                 * If isSpeedBased is TRUE sets the tween as speed based
                     (the duration will represent the number of units the tween moves x second).
                     <p>Has no effect on Sequences, nested tweens, or if the tween has already started</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}    T    
                 * @param   {T}           t
                 * @return  {T}
                 */
                SetSpeedBased: function (T, t) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetSpeedBased", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active || Bridge.rValue(t).creationLocked) {
                        return Bridge.rValue(t);
                    }

Bridge.rValue(                    t).isSpeedBased = true;
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.SetSpeedBased:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetSpeedBased$1:static start.*/
                /**
                 * If isSpeedBased is TRUE sets the tween as speed based
                     (the duration will represent the number of units the tween moves x second).
                     <p>Has no effect on Sequences, nested tweens, or if the tween has already started</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {Function}    T               
                 * @param   {T}           t               
                 * @param   {boolean}     isSpeedBased
                 * @return  {T}
                 */
                SetSpeedBased$1: function (T, t, isSpeedBased) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetSpeedBased$1", this ); }

                    if (Bridge.rValue(t) == null || !Bridge.rValue(t).active || Bridge.rValue(t).creationLocked) {
                        return Bridge.rValue(t);
                    }

Bridge.rValue(                    t).isSpeedBased = isSpeedBased;
                    return Bridge.rValue(t);
                },
                /*DG.Tweening.TweenSettingsExtensions.SetSpeedBased$1:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetOptions$2:static start.*/
                /**
                 * Options for float tweens
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {DG.Tweening.Core.TweenerCore$3}    t           
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                SetOptions$2: function (t, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetOptions$2", this ); }

                    if (t == null || !t.active) {
                        return t;
                    }

                    t.plugOptions.snapping = snapping;
                    return t;
                },
                /*DG.Tweening.TweenSettingsExtensions.SetOptions$2:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetOptions$9:static start.*/
                /**
                 * Options for Vector2 tweens
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {DG.Tweening.Core.TweenerCore$3}    t           
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                SetOptions$9: function (t, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetOptions$9", this ); }

                    if (t == null || !t.active) {
                        return t;
                    }

                    t.plugOptions.snapping = snapping;
                    return t;
                },
                /*DG.Tweening.TweenSettingsExtensions.SetOptions$9:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetOptions$8:static start.*/
                /**
                 * Options for Vector2 tweens
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {DG.Tweening.Core.TweenerCore$3}    t                 
                 * @param   {DG.Tweening.AxisConstraint}        axisConstraint    Selecting an axis will tween the vector only on that axis, leaving the others untouched
                 * @param   {boolean}                           snapping          If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                SetOptions$8: function (t, axisConstraint, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetOptions$8", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (t == null || !t.active) {
                        return t;
                    }

                    t.plugOptions.axisConstraint = axisConstraint;
                    t.plugOptions.snapping = snapping;
                    return t;
                },
                /*DG.Tweening.TweenSettingsExtensions.SetOptions$8:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetOptions$13:static start.*/
                /**
                 * Options for Vector3 tweens
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {DG.Tweening.Core.TweenerCore$3}    t           
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                SetOptions$13: function (t, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetOptions$13", this ); }

                    if (t == null || !t.active) {
                        return t;
                    }

                    t.plugOptions.snapping = snapping;
                    return t;
                },
                /*DG.Tweening.TweenSettingsExtensions.SetOptions$13:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetOptions$12:static start.*/
                /**
                 * Options for Vector3 tweens
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {DG.Tweening.Core.TweenerCore$3}    t                 
                 * @param   {DG.Tweening.AxisConstraint}        axisConstraint    Selecting an axis will tween the vector only on that axis, leaving the others untouched
                 * @param   {boolean}                           snapping          If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                SetOptions$12: function (t, axisConstraint, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetOptions$12", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (t == null || !t.active) {
                        return t;
                    }

                    t.plugOptions.axisConstraint = axisConstraint;
                    t.plugOptions.snapping = snapping;
                    return t;
                },
                /*DG.Tweening.TweenSettingsExtensions.SetOptions$12:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetOptions$15:static start.*/
                /**
                 * Options for Vector4 tweens
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {DG.Tweening.Core.TweenerCore$3}    t           
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                SetOptions$15: function (t, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetOptions$15", this ); }

                    if (t == null || !t.active) {
                        return t;
                    }

                    t.plugOptions.snapping = snapping;
                    return t;
                },
                /*DG.Tweening.TweenSettingsExtensions.SetOptions$15:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetOptions$14:static start.*/
                /**
                 * Options for Vector4 tweens
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {DG.Tweening.Core.TweenerCore$3}    t                 
                 * @param   {DG.Tweening.AxisConstraint}        axisConstraint    Selecting an axis will tween the vector only on that axis, leaving the others untouched
                 * @param   {boolean}                           snapping          If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                SetOptions$14: function (t, axisConstraint, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetOptions$14", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (t == null || !t.active) {
                        return t;
                    }

                    t.plugOptions.axisConstraint = axisConstraint;
                    t.plugOptions.snapping = snapping;
                    return t;
                },
                /*DG.Tweening.TweenSettingsExtensions.SetOptions$14:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetOptions$5:static start.*/
                /**
                 * Options for Quaternion tweens
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {DG.Tweening.Core.TweenerCore$3}    t                      
                 * @param   {boolean}                           useShortest360Route    If TRUE (default) the rotation will take the shortest route, and will not rotate more than 360.
                     If FALSE the rotation will be fully accounted. Is always FALSE if the tween is set as relative
                 * @return  {DG.Tweening.Tweener}
                 */
                SetOptions$5: function (t, useShortest360Route) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetOptions$5", this ); }

                    if (useShortest360Route === void 0) { useShortest360Route = true; }
                    if (t == null || !t.active) {
                        return t;
                    }

                    t.plugOptions.rotateMode = useShortest360Route ? DG.Tweening.RotateMode.Fast : DG.Tweening.RotateMode.FastBeyond360;
                    return t;
                },
                /*DG.Tweening.TweenSettingsExtensions.SetOptions$5:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetOptions$4:static start.*/
                /**
                 * Options for Color tweens
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {DG.Tweening.Core.TweenerCore$3}    t            
                 * @param   {boolean}                           alphaOnly    If TRUE only the alpha value of the color will be tweened
                 * @return  {DG.Tweening.Tweener}
                 */
                SetOptions$4: function (t, alphaOnly) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetOptions$4", this ); }

                    if (t == null || !t.active) {
                        return t;
                    }

                    t.plugOptions.alphaOnly = alphaOnly;
                    return t;
                },
                /*DG.Tweening.TweenSettingsExtensions.SetOptions$4:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetOptions$6:static start.*/
                /**
                 * Options for Vector4 tweens
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {DG.Tweening.Core.TweenerCore$3}    t           
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                SetOptions$6: function (t, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetOptions$6", this ); }

                    if (t == null || !t.active) {
                        return t;
                    }

                    t.plugOptions.snapping = snapping;
                    return t;
                },
                /*DG.Tweening.TweenSettingsExtensions.SetOptions$6:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetOptions$3:static start.*/
                /**
                 * Options for Vector4 tweens
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {DG.Tweening.Core.TweenerCore$3}    t                  
                 * @param   {boolean}                           richTextEnabled    If TRUE, rich text will be interpreted correctly while animated,
                     otherwise all tags will be considered as normal text
                 * @param   {DG.Tweening.ScrambleMode}          scrambleMode       The type of scramble to use, if any
                 * @param   {string}                            scrambleChars      A string containing the characters to use for scrambling.
                     Use as many characters as possible (minimum 10) because DOTween uses a fast scramble mode which gives better
                     results with more characters.
                     Leave it to NULL to use default ones
                 * @return  {DG.Tweening.Tweener}
                 */
                SetOptions$3: function (t, richTextEnabled, scrambleMode, scrambleChars) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetOptions$3", this ); }

                    if (scrambleMode === void 0) { scrambleMode = 0; }
                    if (scrambleChars === void 0) { scrambleChars = null; }
                    if (t == null || !t.active) {
                        return t;
                    }

                    t.plugOptions.richTextEnabled = richTextEnabled;
                    t.plugOptions.scrambleMode = scrambleMode;
                    if (!System.String.isNullOrEmpty(scrambleChars)) {
                        if (scrambleChars.length <= 1) {
                            scrambleChars = (scrambleChars || "") + (scrambleChars || "");
                        }

                        t.plugOptions.scrambledChars = System.String.toCharArray(scrambleChars, 0, scrambleChars.length);
                        DG.Tweening.Plugins.StringPluginExtensions.ScrambleChars(t.plugOptions.scrambledChars);
                    }

                    return t;
                },
                /*DG.Tweening.TweenSettingsExtensions.SetOptions$3:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetOptions$11:static start.*/
                /**
                 * Options for Vector3Array tweens
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {DG.Tweening.Core.TweenerCore$3}    t           
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                SetOptions$11: function (t, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetOptions$11", this ); }

                    if (t == null || !t.active) {
                        return t;
                    }

                    t.plugOptions.snapping = snapping;
                    return t;
                },
                /*DG.Tweening.TweenSettingsExtensions.SetOptions$11:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetOptions$10:static start.*/
                /**
                 * Options for Vector3Array tweens
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {DG.Tweening.Core.TweenerCore$3}    t                 
                 * @param   {DG.Tweening.AxisConstraint}        axisConstraint    
                 * @param   {boolean}                           snapping          If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                SetOptions$10: function (t, axisConstraint, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetOptions$10", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (t == null || !t.active) {
                        return t;
                    }

                    t.plugOptions.axisConstraint = axisConstraint;
                    t.plugOptions.snapping = snapping;
                    return t;
                },
                /*DG.Tweening.TweenSettingsExtensions.SetOptions$10:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetOptions$7:static start.*/
                /**
                 * Options for ShapeCircle tweens
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {DG.Tweening.Core.TweenerCore$3}    t                  
                 * @param   {number}                            endValueDegrees    
                 * @param   {boolean}                           relativeCenter     If TRUE the center you set in the DOTween.To method will be considered as relative
                     to the starting position of the target
                 * @param   {boolean}                           snapping           If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                SetOptions$7: function (t, endValueDegrees, relativeCenter, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetOptions$7", this ); }

                    if (relativeCenter === void 0) { relativeCenter = true; }
                    if (snapping === void 0) { snapping = false; }
                    if (t == null || !t.active) {
                        return t;
                    }

                    t.plugOptions.endValueDegrees = endValueDegrees;
                    t.plugOptions.relativeCenter = relativeCenter;
                    t.plugOptions.snapping = snapping;
                    return t;
                },
                /*DG.Tweening.TweenSettingsExtensions.SetOptions$7:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetOptions:static start.*/
                /**
                 * Options for Path tweens (created via the <pre><code>DOPath</code></pre> shortcut)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {DG.Tweening.Core.TweenerCore$3}    t               
                 * @param   {DG.Tweening.AxisConstraint}        lockPosition    The eventual movement axis to lock. You can input multiple axis if you separate them like this:
                     <p>AxisConstrain.X | AxisConstraint.Y</p>
                 * @param   {DG.Tweening.AxisConstraint}        lockRotation    The eventual rotation axis to lock. You can input multiple axis if you separate them like this:
                     <p>AxisConstrain.X | AxisConstraint.Y</p>
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                SetOptions: function (t, lockPosition, lockRotation) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetOptions", this ); }

                    if (lockRotation === void 0) { lockRotation = 0; }
                    return DG.Tweening.TweenSettingsExtensions.SetOptions$1(t, false, lockPosition, lockRotation);
                },
                /*DG.Tweening.TweenSettingsExtensions.SetOptions:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetOptions$1:static start.*/
                /**
                 * Options for Path tweens (created via the <pre><code>DOPath</code></pre> shortcut)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {DG.Tweening.Core.TweenerCore$3}    t               
                 * @param   {boolean}                           closePath       If TRUE the path will be automatically closed
                 * @param   {DG.Tweening.AxisConstraint}        lockPosition    The eventual movement axis to lock. You can input multiple axis if you separate them like this:
                     <p>AxisConstrain.X | AxisConstraint.Y</p>
                 * @param   {DG.Tweening.AxisConstraint}        lockRotation    The eventual rotation axis to lock. You can input multiple axis if you separate them like this:
                     <p>AxisConstrain.X | AxisConstraint.Y</p>
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                SetOptions$1: function (t, closePath, lockPosition, lockRotation) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetOptions$1", this ); }

                    if (lockPosition === void 0) { lockPosition = 0; }
                    if (lockRotation === void 0) { lockRotation = 0; }
                    if (t == null || !t.active) {
                        return t;
                    }

                    t.plugOptions.isClosedPath = closePath;
                    t.plugOptions.lockPositionAxis = lockPosition;
                    t.plugOptions.lockRotationAxis = lockRotation;
                    return t;
                },
                /*DG.Tweening.TweenSettingsExtensions.SetOptions$1:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetLookAt$5:static start.*/
                /**
                 * Additional LookAt options for Path tweens (created via the <pre><code>DOPath</code></pre> shortcut).
                     Orients the target towards the given position.
                     Must be chained directly to the tween creation method or to a <pre><code>SetOptions</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {DG.Tweening.Core.TweenerCore$3}    t                   
                 * @param   {UnityEngine.Vector3}               lookAtPosition      The position to look at
                 * @param   {?UnityEngine.Vector3}              forwardDirection    The eventual direction to consider as "forward".
                     If left to NULL defaults to the regular forward side of the transform
                 * @param   {?UnityEngine.Vector3}              up                  The vector that defines in which direction up is (default: Vector3.up)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                SetLookAt$5: function (t, lookAtPosition, forwardDirection, up) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetLookAt$5", this ); }

                    if (forwardDirection === void 0) { forwardDirection = null; }
                    if (up === void 0) { up = null; }
                    return DG.Tweening.TweenSettingsExtensions.SetLookAt$6(t, DG.Tweening.Plugins.Options.OrientType.LookAtPosition, lookAtPosition.$clone(), null, -1, System.Nullable.lift1("$clone", forwardDirection), System.Nullable.lift1("$clone", up));
                },
                /*DG.Tweening.TweenSettingsExtensions.SetLookAt$5:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetLookAt$4:static start.*/
                /**
                 * Additional LookAt options for Path tweens (created via the <pre><code>DOPath</code></pre> shortcut).
                     Orients the target towards the given position with options to keep the Z rotation stable.
                     Must be chained directly to the tween creation method or to a <pre><code>SetOptions</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {DG.Tweening.Core.TweenerCore$3}    t                  
                 * @param   {UnityEngine.Vector3}               lookAtPosition     The position to look at
                 * @param   {boolean}                           stableZRotation    If TRUE doesn't rotate the target along the Z axis
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                SetLookAt$4: function (t, lookAtPosition, stableZRotation) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetLookAt$4", this ); }

                    return DG.Tweening.TweenSettingsExtensions.SetLookAt$6(t, DG.Tweening.Plugins.Options.OrientType.LookAtPosition, lookAtPosition.$clone(), null, -1, null, null, stableZRotation);
                },
                /*DG.Tweening.TweenSettingsExtensions.SetLookAt$4:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetLookAt$3:static start.*/
                /**
                 * Additional LookAt options for Path tweens (created via the <pre><code>DOPath</code></pre> shortcut).
                     Orients the target towards another transform.
                     Must be chained directly to the tween creation method or to a <pre><code>SetOptions</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {DG.Tweening.Core.TweenerCore$3}    t                   
                 * @param   {UnityEngine.Transform}             lookAtTransform     The transform to look at
                 * @param   {?UnityEngine.Vector3}              forwardDirection    The eventual direction to consider as "forward".
                     If left to NULL defaults to the regular forward side of the transform
                 * @param   {?UnityEngine.Vector3}              up                  The vector that defines in which direction up is (default: Vector3.up)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                SetLookAt$3: function (t, lookAtTransform, forwardDirection, up) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetLookAt$3", this ); }

                    if (forwardDirection === void 0) { forwardDirection = null; }
                    if (up === void 0) { up = null; }
                    return DG.Tweening.TweenSettingsExtensions.SetLookAt$6(t, DG.Tweening.Plugins.Options.OrientType.LookAtTransform, pc.Vec3.ZERO.clone(), lookAtTransform, -1, System.Nullable.lift1("$clone", forwardDirection), System.Nullable.lift1("$clone", up));
                },
                /*DG.Tweening.TweenSettingsExtensions.SetLookAt$3:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetLookAt$2:static start.*/
                /**
                 * Additional LookAt options for Path tweens (created via the <pre><code>DOPath</code></pre> shortcut).
                     Orients the target towards another transform with options to keep the Z rotation stable.
                     Must be chained directly to the tween creation method or to a <pre><code>SetOptions</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {DG.Tweening.Core.TweenerCore$3}    t                  
                 * @param   {UnityEngine.Transform}             lookAtTransform    The transform to look at
                 * @param   {boolean}                           stableZRotation    If TRUE doesn't rotate the target along the Z axis
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                SetLookAt$2: function (t, lookAtTransform, stableZRotation) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetLookAt$2", this ); }

                    return DG.Tweening.TweenSettingsExtensions.SetLookAt$6(t, DG.Tweening.Plugins.Options.OrientType.LookAtTransform, pc.Vec3.ZERO.clone(), lookAtTransform, -1, null, null, stableZRotation);
                },
                /*DG.Tweening.TweenSettingsExtensions.SetLookAt$2:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetLookAt$1:static start.*/
                /**
                 * Additional LookAt options for Path tweens (created via the <pre><code>DOPath</code></pre> shortcut).
                     Orients the target to the path, with the given lookAhead.
                     Must be chained directly to the tween creation method or to a <pre><code>SetOptions</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {DG.Tweening.Core.TweenerCore$3}    t                   
                 * @param   {number}                            lookAhead           The percentage of lookAhead to use (0 to 1)
                 * @param   {?UnityEngine.Vector3}              forwardDirection    The eventual direction to consider as "forward".
                     If left to NULL defaults to the regular forward side of the transform
                 * @param   {?UnityEngine.Vector3}              up                  The vector that defines in which direction up is (default: Vector3.up)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                SetLookAt$1: function (t, lookAhead, forwardDirection, up) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetLookAt$1", this ); }

                    if (forwardDirection === void 0) { forwardDirection = null; }
                    if (up === void 0) { up = null; }
                    return DG.Tweening.TweenSettingsExtensions.SetLookAt$6(t, DG.Tweening.Plugins.Options.OrientType.ToPath, pc.Vec3.ZERO.clone(), null, lookAhead, System.Nullable.lift1("$clone", forwardDirection), System.Nullable.lift1("$clone", up));
                },
                /*DG.Tweening.TweenSettingsExtensions.SetLookAt$1:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetLookAt:static start.*/
                /**
                 * Additional LookAt options for Path tweens (created via the <pre><code>DOPath</code></pre> shortcut).
                     Orients the path with options to keep the Z rotation stable.
                     Must be chained directly to the tween creation method or to a <pre><code>SetOptions</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.TweenSettingsExtensions
                 * @memberof DG.Tweening.TweenSettingsExtensions
                 * @param   {DG.Tweening.Core.TweenerCore$3}    t                  
                 * @param   {number}                            lookAhead          The percentage of lookAhead to use (0 to 1)
                 * @param   {boolean}                           stableZRotation    If TRUE doesn't rotate the target along the Z axis
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                SetLookAt: function (t, lookAhead, stableZRotation) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetLookAt", this ); }

                    return DG.Tweening.TweenSettingsExtensions.SetLookAt$6(t, DG.Tweening.Plugins.Options.OrientType.ToPath, pc.Vec3.ZERO.clone(), null, lookAhead, null, null, stableZRotation);
                },
                /*DG.Tweening.TweenSettingsExtensions.SetLookAt:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetLookAt$6:static start.*/
                SetLookAt$6: function (t, orientType, lookAtPosition, lookAtTransform, lookAhead, forwardDirection, up, stableZRotation) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetLookAt$6", this ); }

                    if (forwardDirection === void 0) { forwardDirection = null; }
                    if (up === void 0) { up = null; }
                    if (stableZRotation === void 0) { stableZRotation = false; }
                    if (t == null || !t.active) {
                        return t;
                    }

                    t.plugOptions.orientType = orientType;
                    switch (orientType) {
                        case DG.Tweening.Plugins.Options.OrientType.LookAtPosition: 
                            t.plugOptions.lookAtPosition = lookAtPosition.$clone();
                            break;
                        case DG.Tweening.Plugins.Options.OrientType.LookAtTransform: 
                            t.plugOptions.lookAtTransform = lookAtTransform;
                            break;
                        case DG.Tweening.Plugins.Options.OrientType.ToPath: 
                            if (lookAhead < DG.Tweening.Plugins.PathPlugin.MinLookAhead) {
                                lookAhead = DG.Tweening.Plugins.PathPlugin.MinLookAhead;
                            }
                            t.plugOptions.lookAhead = lookAhead;
                            break;
                    }

                    t.plugOptions.lookAtPosition = lookAtPosition.$clone();
                    t.plugOptions.stableZRotation = stableZRotation;
                    DG.Tweening.TweenSettingsExtensions.SetPathForwardDirection(t, System.Nullable.lift1("$clone", forwardDirection), System.Nullable.lift1("$clone", up));
                    return t;
                },
                /*DG.Tweening.TweenSettingsExtensions.SetLookAt$6:static end.*/

                /*DG.Tweening.TweenSettingsExtensions.SetPathForwardDirection:static start.*/
                SetPathForwardDirection: function (t, forwardDirection, up) {
if ( TRACE ) { TRACE( "DG.Tweening.TweenSettingsExtensions#SetPathForwardDirection", this ); }

                    if (forwardDirection === void 0) { forwardDirection = null; }
                    if (up === void 0) { up = null; }
                    if (t == null || !t.active) {
                        return;
                    }

                    t.plugOptions.hasCustomForwardDirection = !pc.Vec3.equals( forwardDirection, null ) && !pc.Vec3.equals( forwardDirection, pc.Vec3.ZERO.clone() ) || !pc.Vec3.equals( up, null ) && !pc.Vec3.equals( up, pc.Vec3.ZERO.clone() );
                    if (t.plugOptions.hasCustomForwardDirection) {
                        if (pc.Vec3.equals( forwardDirection, pc.Vec3.ZERO.clone() )) {
                            forwardDirection = new pc.Vec3( 0, 0, 1 );
                        }

                        t.plugOptions.forward = new pc.Quat().setLookAt( pc.Vec3.equals( forwardDirection, null ) ? new pc.Vec3( 0, 0, 1 ) : System.Nullable.getValue(forwardDirection), pc.Vec3.equals( up, null ) ? pc.Vec3.UP.clone() : System.Nullable.getValue(up) );
                    }
                },
                /*DG.Tweening.TweenSettingsExtensions.SetPathForwardDirection:static end.*/


            }
        }
    });
    /*DG.Tweening.TweenSettingsExtensions end.*/

    /*DG.Tweening.TweenType start.*/
    /**
     * Used internally
     *
     * @public
     * @class DG.Tweening.TweenType
     */
    Bridge.define("DG.Tweening.TweenType", {
        $kind: 6,
        statics: {
            fields: {
                Tweener: 0,
                Sequence: 1,
                Callback: 2
            }
        }
    });
    /*DG.Tweening.TweenType end.*/

    /*DG.Tweening.UpdateType start.*/
    /**
     * Update type
     *
     * @public
     * @class DG.Tweening.UpdateType
     */
    Bridge.define("DG.Tweening.UpdateType", {
        $kind: 6,
        statics: {
            fields: {
                /**
                 * Updates every frame during Update calls
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.UpdateType
                 * @constant
                 * @default 0
                 * @type DG.Tweening.UpdateType
                 */
                Normal: 0,
                /**
                 * Updates every frame during LateUpdate calls
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.UpdateType
                 * @constant
                 * @default 1
                 * @type DG.Tweening.UpdateType
                 */
                Late: 1,
                /**
                 * Updates using FixedUpdate calls
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.UpdateType
                 * @constant
                 * @default 2
                 * @type DG.Tweening.UpdateType
                 */
                Fixed: 2,
                /**
                 * Updates using manual update calls
                 *
                 * @static
                 * @public
                 * @memberof DG.Tweening.UpdateType
                 * @constant
                 * @default 3
                 * @type DG.Tweening.UpdateType
                 */
                Manual: 3
            }
        }
    });
    /*DG.Tweening.UpdateType end.*/

    /*DG.Tweening.Core.DOTweenComponent start.*/
    /**
     * Used to separate DOTween class from the MonoBehaviour instance (in order to use static constructors on DOTween).
         Contains all instance-based methods
     *
     * @public
     * @class DG.Tweening.Core.DOTweenComponent
     * @augments UnityEngine.MonoBehaviour
     * @implements  DG.Tweening.IDOTweenInit
     */
    Bridge.define("DG.Tweening.Core.DOTweenComponent", {
        inherits: [UnityEngine.MonoBehaviour,DG.Tweening.IDOTweenInit],
        statics: {
            methods: {
                /*DG.Tweening.Core.DOTweenComponent.Create:static start.*/
                Create: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.DOTweenComponent#Create", this ); }

                    if (UnityEngine.MonoBehaviour.op_Inequality(DG.Tweening.DOTween.instance, null)) {
                        return;
                    }

                    var go = new UnityEngine.GameObject.$ctor2("[DOTween]");
                    UnityEngine.Object.DontDestroyOnLoad(go);
                    DG.Tweening.DOTween.instance = go.AddComponent(DG.Tweening.Core.DOTweenComponent);
                },
                /*DG.Tweening.Core.DOTweenComponent.Create:static end.*/

                /*DG.Tweening.Core.DOTweenComponent.DestroyInstance:static start.*/
                DestroyInstance: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.DOTweenComponent#DestroyInstance", this ); }

                    if (UnityEngine.MonoBehaviour.op_Inequality(DG.Tweening.DOTween.instance, null)) {
                        UnityEngine.MonoBehaviour.Destroy(DG.Tweening.DOTween.instance.gameObject);
                    }

                    DG.Tweening.DOTween.instance = null;
                },
                /*DG.Tweening.Core.DOTweenComponent.DestroyInstance:static end.*/


            }
        },
        fields: {
            /**
             * Used internally inside Unity Editor, as a trick to update DOTween's inspector at every frame
             *
             * @instance
             * @public
             * @memberof DG.Tweening.Core.DOTweenComponent
             * @type number
             */
            inspectorUpdater: 0,
            _duplicateToDestroy: false,
            _isQuitting: false,
            _paused: false,
            _pausedTime: 0,
            _unscaledDeltaTime: 0,
            _unscaledTime: 0
        },
        alias: ["SetCapacity", "DG$Tweening$IDOTweenInit$SetCapacity"],
        methods: {
            /*DG.Tweening.Core.DOTweenComponent.SetCapacity start.*/
            /**
             * Directly sets the current max capacity of Tweeners and Sequences
                 (meaning how many Tweeners and Sequences can be running at the same time),
                 so that DOTween doesn't need to automatically increase them in case the max is reached
                 (which might lead to hiccups when that happens).
                 Sequences capacity must be less or equal to Tweeners capacity
                 (if you pass a low Tweener capacity it will be automatically increased to match the Sequence's).
                 Beware: use this method only when there are no tweens running.
             *
             * @instance
             * @public
             * @this DG.Tweening.Core.DOTweenComponent
             * @memberof DG.Tweening.Core.DOTweenComponent
             * @param   {number}                      tweenersCapacity     Max Tweeners capacity.
                 Default: 200
             * @param   {number}                      sequencesCapacity    Max Sequences capacity.
                 Default: 50
             * @return  {DG.Tweening.IDOTweenInit}
             */
            SetCapacity: function (tweenersCapacity, sequencesCapacity) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.DOTweenComponent#SetCapacity", this ); }

                DG.Tweening.Core.TweenManager.SetCapacities(tweenersCapacity, sequencesCapacity);
                return this;
            },
            /*DG.Tweening.Core.DOTweenComponent.SetCapacity end.*/

            /*DG.Tweening.Core.DOTweenComponent.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.DOTweenComponent#Awake", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(DG.Tweening.DOTween.instance, null)) {
                    DG.Tweening.DOTween.instance = this;
                } else {
                    if (DG.Tweening.Core.Debugger.logPriority >= 1) {
                        DG.Tweening.Core.Debugger.LogWarning("Duplicate DOTweenComponent instance found in scene: destroying it");
                    }

                    UnityEngine.MonoBehaviour.Destroy(this.gameObject);
                    return;
                }

                this.inspectorUpdater = 0;
                this._unscaledTime = UnityEngine.Time.realtimeSinceStartup;

                // Initialize DOTweenModuleUtils via Reflection
                var modules = DG.Tweening.Core.DOTweenUtils.GetLooseScriptType("DG.Tweening.DOTweenModuleUtils");
                if (modules == null) {
                    DG.Tweening.Core.Debugger.LogError("Couldn't load Modules system");
                    return;
                }

                var mi = Bridge.Reflection.getMembers(modules, 8, 24 | 256, "Init");
                Bridge.Reflection.midel(mi, null, null)(null);
            },
            /*DG.Tweening.Core.DOTweenComponent.Awake end.*/

            /*DG.Tweening.Core.DOTweenComponent.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.DOTweenComponent#Start", this ); }

                // Check if there's a leftover persistent DOTween object
                // (should be impossible but some weird Unity freeze caused that to happen on Seith's project
                if (UnityEngine.MonoBehaviour.op_Inequality(DG.Tweening.DOTween.instance, this)) {
                    this._duplicateToDestroy = true;
                    UnityEngine.MonoBehaviour.Destroy(this.gameObject);
                }
            },
            /*DG.Tweening.Core.DOTweenComponent.Start end.*/

            /*DG.Tweening.Core.DOTweenComponent.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.DOTweenComponent#Update", this ); }

                this._unscaledDeltaTime = UnityEngine.Time.realtimeSinceStartup - this._unscaledTime;
                if (DG.Tweening.DOTween.useSmoothDeltaTime && this._unscaledDeltaTime > DG.Tweening.DOTween.maxSmoothUnscaledTime) {
                    this._unscaledDeltaTime = DG.Tweening.DOTween.maxSmoothUnscaledTime;
                }

                if (DG.Tweening.Core.TweenManager.hasActiveDefaultTweens) {
                    DG.Tweening.Core.TweenManager.Update$1(DG.Tweening.UpdateType.Normal, (DG.Tweening.DOTween.useSmoothDeltaTime ? UnityEngine.Time.smoothDeltaTime : UnityEngine.Time.deltaTime) * DG.Tweening.DOTween.timeScale, this._unscaledDeltaTime * DG.Tweening.DOTween.unscaledTimeScale * DG.Tweening.DOTween.timeScale);
                }

                this._unscaledTime = UnityEngine.Time.realtimeSinceStartup;

                if (DG.Tweening.Core.TweenManager.isUnityEditor) {
                    this.inspectorUpdater++;
                    if (DG.Tweening.DOTween.showUnityEditorReport && DG.Tweening.Core.TweenManager.hasActiveTweens) {
                        if (DG.Tweening.Core.TweenManager.totActiveTweeners > DG.Tweening.DOTween.maxActiveTweenersReached) {
                            DG.Tweening.DOTween.maxActiveTweenersReached = DG.Tweening.Core.TweenManager.totActiveTweeners;
                        }

                        if (DG.Tweening.Core.TweenManager.totActiveSequences > DG.Tweening.DOTween.maxActiveSequencesReached) {
                            DG.Tweening.DOTween.maxActiveSequencesReached = DG.Tweening.Core.TweenManager.totActiveSequences;
                        }
                    }
                }
            },
            /*DG.Tweening.Core.DOTweenComponent.Update end.*/

            /*DG.Tweening.Core.DOTweenComponent.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.DOTweenComponent#LateUpdate", this ); }

                if (DG.Tweening.Core.TweenManager.hasActiveLateTweens) {
                    DG.Tweening.Core.TweenManager.Update$1(DG.Tweening.UpdateType.Late, (DG.Tweening.DOTween.useSmoothDeltaTime ? UnityEngine.Time.smoothDeltaTime : UnityEngine.Time.deltaTime) * DG.Tweening.DOTween.timeScale, this._unscaledDeltaTime * DG.Tweening.DOTween.unscaledTimeScale * DG.Tweening.DOTween.timeScale);
                }
            },
            /*DG.Tweening.Core.DOTweenComponent.LateUpdate end.*/

            /*DG.Tweening.Core.DOTweenComponent.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.DOTweenComponent#FixedUpdate", this ); }

                if (DG.Tweening.Core.TweenManager.hasActiveFixedTweens && UnityEngine.Time.timeScale > 0) {
                    DG.Tweening.Core.TweenManager.Update$1(DG.Tweening.UpdateType.Fixed, (DG.Tweening.DOTween.useSmoothDeltaTime ? UnityEngine.Time.smoothDeltaTime : UnityEngine.Time.deltaTime) * DG.Tweening.DOTween.timeScale, (DG.Tweening.DOTween.useSmoothDeltaTime ? UnityEngine.Time.smoothDeltaTime : UnityEngine.Time.deltaTime) / UnityEngine.Time.timeScale * DG.Tweening.DOTween.unscaledTimeScale * DG.Tweening.DOTween.timeScale);
                }
            },
            /*DG.Tweening.Core.DOTweenComponent.FixedUpdate end.*/

            /*DG.Tweening.Core.DOTweenComponent.OnDrawGizmos start.*/
            OnDrawGizmos: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.DOTweenComponent#OnDrawGizmos", this ); }

                if (!DG.Tweening.DOTween.drawGizmos || !DG.Tweening.Core.TweenManager.isUnityEditor) {
                    return;
                }

                var len = DG.Tweening.DOTween.GizmosDelegates.Count;
                if (len === 0) {
                    return;
                }

                for (var i = 0; i < len; ++i) {
                    DG.Tweening.DOTween.GizmosDelegates.getItem(i)();
                }
            },
            /*DG.Tweening.Core.DOTweenComponent.OnDrawGizmos end.*/

            /*DG.Tweening.Core.DOTweenComponent.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.DOTweenComponent#OnDestroy", this ); }

                if (this._duplicateToDestroy) {
                    return;
                }

                if (DG.Tweening.DOTween.showUnityEditorReport) {
                    var s = "Max overall simultaneous active Tweeners/Sequences: " + DG.Tweening.DOTween.maxActiveTweenersReached + "/" + DG.Tweening.DOTween.maxActiveSequencesReached;
                    DG.Tweening.Core.Debugger.LogReport(s);
                }

                if (DG.Tweening.DOTween.useSafeMode) {
                    var totSafeModeErrors = DG.Tweening.DOTween.safeModeReport.GetTotErrors();
                    if (totSafeModeErrors > 0) {
                        var s1 = System.String.format("DOTween's safe mode captured {0} errors. This is usually ok (it's what safe mode is there for) but if your game is encountering issues you should set Log Behaviour to Default in DOTween Utility Panel in order to get detailed warnings when an error is captured (consider that these errors are always on the user side).", [totSafeModeErrors]);
                        if (DG.Tweening.DOTween.safeModeReport.totMissingTargetOrFieldErrors > 0) {
                            s1 = (s1 || "") + (("\n- " + DG.Tweening.DOTween.safeModeReport.totMissingTargetOrFieldErrors + " missing target or field errors") || "");
                        }

                        if (DG.Tweening.DOTween.safeModeReport.totStartupErrors > 0) {
                            s1 = (s1 || "") + (("\n- " + DG.Tweening.DOTween.safeModeReport.totStartupErrors + " startup errors") || "");
                        }

                        if (DG.Tweening.DOTween.safeModeReport.totCallbackErrors > 0) {
                            s1 = (s1 || "") + (("\n- " + DG.Tweening.DOTween.safeModeReport.totCallbackErrors + " errors inside callbacks (these might be important)") || "");
                        }

                        if (DG.Tweening.DOTween.safeModeReport.totUnsetErrors > 0) {
                            s1 = (s1 || "") + (("\n- " + DG.Tweening.DOTween.safeModeReport.totUnsetErrors + " undetermined errors (these might be important)") || "");
                        }

                        DG.Tweening.Core.Debugger.LogSafeModeReport(s1);
                    }
                }

                //            DOTween.initialized = false;
                //            DOTween.instance = null;

                if (UnityEngine.MonoBehaviour.op_Equality(DG.Tweening.DOTween.instance, this)) {
                    DG.Tweening.DOTween.instance = null;
                }

                DG.Tweening.DOTween.Clear$1(true, this._isQuitting);
            },
            /*DG.Tweening.Core.DOTweenComponent.OnDestroy end.*/

            /*DG.Tweening.Core.DOTweenComponent.OnApplicationPause start.*/
            OnApplicationPause: function (pauseStatus) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.DOTweenComponent#OnApplicationPause", this ); }

                if (pauseStatus) {
                    this._paused = true;
                    this._pausedTime = UnityEngine.Time.realtimeSinceStartup;
                } else if (this._paused) {
                    this._paused = false;
                    this._unscaledTime += UnityEngine.Time.realtimeSinceStartup - this._pausedTime;
                }
            },
            /*DG.Tweening.Core.DOTweenComponent.OnApplicationPause end.*/

            /*DG.Tweening.Core.DOTweenComponent.OnApplicationQuit start.*/
            OnApplicationQuit: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.DOTweenComponent#OnApplicationQuit", this ); }

                this._isQuitting = true;
                DG.Tweening.DOTween.isQuitting = true;
            },
            /*DG.Tweening.Core.DOTweenComponent.OnApplicationQuit end.*/

            /*DG.Tweening.Core.DOTweenComponent.WaitForCompletion start.*/
            WaitForCompletion: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.DOTweenComponent#WaitForCompletion", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if ( t.active && !t.isComplete ) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 3;
                                        continue;
                                }
                                case 1: {
                                    $enumerator.current = null;
                                        $step = 2;
                                        return true;
                                }
                                case 2: {
                                    
                                        $step = 0;
                                        continue;
                                }
                                case 3: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*DG.Tweening.Core.DOTweenComponent.WaitForCompletion end.*/

            /*DG.Tweening.Core.DOTweenComponent.WaitForRewind start.*/
            WaitForRewind: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.DOTweenComponent#WaitForRewind", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if ( t.active && (!t.playedOnce || t.position * (t.completedLoops + 1) > 0) ) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 3;
                                        continue;
                                }
                                case 1: {
                                    $enumerator.current = null;
                                        $step = 2;
                                        return true;
                                }
                                case 2: {
                                    
                                        $step = 0;
                                        continue;
                                }
                                case 3: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*DG.Tweening.Core.DOTweenComponent.WaitForRewind end.*/

            /*DG.Tweening.Core.DOTweenComponent.WaitForKill start.*/
            WaitForKill: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.DOTweenComponent#WaitForKill", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if ( t.active ) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 3;
                                        continue;
                                }
                                case 1: {
                                    $enumerator.current = null;
                                        $step = 2;
                                        return true;
                                }
                                case 2: {
                                    
                                        $step = 0;
                                        continue;
                                }
                                case 3: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*DG.Tweening.Core.DOTweenComponent.WaitForKill end.*/

            /*DG.Tweening.Core.DOTweenComponent.WaitForElapsedLoops start.*/
            WaitForElapsedLoops: function (t, elapsedLoops) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.DOTweenComponent#WaitForElapsedLoops", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if ( t.active && t.completedLoops < elapsedLoops ) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 3;
                                        continue;
                                }
                                case 1: {
                                    $enumerator.current = null;
                                        $step = 2;
                                        return true;
                                }
                                case 2: {
                                    
                                        $step = 0;
                                        continue;
                                }
                                case 3: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*DG.Tweening.Core.DOTweenComponent.WaitForElapsedLoops end.*/

            /*DG.Tweening.Core.DOTweenComponent.WaitForPosition start.*/
            WaitForPosition: function (t, position) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.DOTweenComponent#WaitForPosition", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if ( t.active && t.position * (t.completedLoops + 1) < position ) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 3;
                                        continue;
                                }
                                case 1: {
                                    $enumerator.current = null;
                                        $step = 2;
                                        return true;
                                }
                                case 2: {
                                    
                                        $step = 0;
                                        continue;
                                }
                                case 3: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*DG.Tweening.Core.DOTweenComponent.WaitForPosition end.*/

            /*DG.Tweening.Core.DOTweenComponent.WaitForStart start.*/
            WaitForStart: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.DOTweenComponent#WaitForStart", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if ( t.active && !t.playedOnce ) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 3;
                                        continue;
                                }
                                case 1: {
                                    $enumerator.current = null;
                                        $step = 2;
                                        return true;
                                }
                                case 2: {
                                    
                                        $step = 0;
                                        continue;
                                }
                                case 3: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*DG.Tweening.Core.DOTweenComponent.WaitForStart end.*/


        }
    });
    /*DG.Tweening.Core.DOTweenComponent end.*/

    /*DG.Tweening.Core.SequenceCallback start.*/
    Bridge.define("DG.Tweening.Core.SequenceCallback", {
        inherits: [DG.Tweening.Core.ABSSequentiable],
        ctors: {
            ctor: function (sequencedPosition, callback) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.SequenceCallback#ctor", this ); }

                this.$initialize();
                DG.Tweening.Core.ABSSequentiable.ctor.call(this);
                this.tweenType = DG.Tweening.TweenType.Callback;
                this.sequencedPosition = sequencedPosition;
                this.onStart = callback;
            }
        }
    });
    /*DG.Tweening.Core.SequenceCallback end.*/

    /*DG.Tweening.Tween start.*/
    /**
     * Indicates either a Tweener or a Sequence
     *
     * @abstract
     * @public
     * @class DG.Tweening.Tween
     * @augments DG.Tweening.Core.ABSSequentiable
     */
    Bridge.define("DG.Tweening.Tween", {
        inherits: [DG.Tweening.Core.ABSSequentiable],
        statics: {
            methods: {
                /*DG.Tweening.Tween.DoGoto:static start.*/
                DoGoto: function (t, toPosition, toCompletedLoops, updateMode) {
if ( TRACE ) { TRACE( "DG.Tweening.Tween#DoGoto", this ); }

                    // Startup
                    if (!t.startupDone) {
                        if (!t.Startup()) {
                            return true;
                        }
                    }

                    // OnStart and first OnPlay callbacks
                    if (!t.playedOnce && updateMode === DG.Tweening.Core.Enums.UpdateMode.Update) {
                        t.playedOnce = true;
                        if (!Bridge.staticEquals(t.onStart, null)) {
                            DG.Tweening.Tween.OnTweenCallback(t.onStart, t);
                            if (!t.active) {
                                return true; // Tween might have been killed by onStart callback
                            }
                        }

                        if (!Bridge.staticEquals(t.onPlay, null)) {
                            DG.Tweening.Tween.OnTweenCallback(t.onPlay, t);
                            if (!t.active) {
                                return true; // Tween might have been killed by onPlay callback
                            }
                        }
                    }

                    var prevPosition = t.position;
                    var prevCompletedLoops = t.completedLoops;
                    t.completedLoops = toCompletedLoops;
                    var wasRewinded = t.position <= 0 && prevCompletedLoops <= 0;
                    var wasComplete = t.isComplete;
                    // Determine if it will be complete after update
                    if (t.loops !== -1) {
                        t.isComplete = t.completedLoops === t.loops;
                    }

                    // Calculate newCompletedSteps (always useful with Sequences)
                    var newCompletedSteps = 0;
                    if (updateMode === DG.Tweening.Core.Enums.UpdateMode.Update) {
                        if (t.isBackwards) {
                            newCompletedSteps = t.completedLoops < prevCompletedLoops ? prevCompletedLoops - t.completedLoops : toPosition <= 0 && !wasRewinded ? 1 : 0;
                            if (wasComplete) {
                                newCompletedSteps--;
                            }
                        } else {
                            newCompletedSteps = t.completedLoops > prevCompletedLoops ? t.completedLoops - prevCompletedLoops : 0;
                        }
                    } else if (t.tweenType === DG.Tweening.TweenType.Sequence) {
                        newCompletedSteps = prevCompletedLoops - toCompletedLoops;
                        if (newCompletedSteps < 0) {
                            newCompletedSteps = -newCompletedSteps;
                        }
                    }

                    // Set position (makes position 0 equal to position "end" when looping)
                    t.position = toPosition;
                    if (t.position > t.duration) {
                        t.position = t.duration;
                    } else if (t.position <= 0) {
                        if (t.completedLoops > 0 || t.isComplete) {
                            t.position = t.duration;
                        } else {
                            t.position = 0;
                        }
                    }

                    // Set playing state after update
                    var wasPlaying = t.isPlaying;
                    if (t.isPlaying) {
                        if (!t.isBackwards) {
                            t.isPlaying = !t.isComplete; // Reached the end
                        } else {
                            t.isPlaying = !(t.completedLoops === 0 && t.position <= 0); // Rewinded
                        }
                    }

                    // updatePosition is different in case of Yoyo loop under certain circumstances
                    var useInversePosition = t.hasLoops && t.loopType === DG.Tweening.LoopType.Yoyo && (t.position < t.duration ? t.completedLoops % 2 !== 0 : t.completedLoops % 2 === 0);

                    // Get values from plugin and set them
                    var isRewindStep = !wasRewinded && (t.loopType === DG.Tweening.LoopType.Restart && t.completedLoops !== prevCompletedLoops && (t.loops === -1 || t.completedLoops < t.loops) || t.position <= 0 && t.completedLoops <= 0);
                    var updateNotice = isRewindStep ? DG.Tweening.Core.Enums.UpdateNotice.RewindStep : DG.Tweening.Core.Enums.UpdateNotice.None;
                    if (t.ApplyTween(prevPosition, prevCompletedLoops, newCompletedSteps, useInversePosition, updateMode, updateNotice)) {
                        return true;
                    }

                    // Additional callbacks
                    if (!Bridge.staticEquals(t.onUpdate, null) && updateMode !== DG.Tweening.Core.Enums.UpdateMode.IgnoreOnUpdate) {
                        DG.Tweening.Tween.OnTweenCallback(t.onUpdate, t);
                    }

                    if (t.position <= 0 && t.completedLoops <= 0 && !wasRewinded && !Bridge.staticEquals(t.onRewind, null)) {
                        DG.Tweening.Tween.OnTweenCallback(t.onRewind, t);
                    }

                    if (newCompletedSteps > 0 && updateMode === DG.Tweening.Core.Enums.UpdateMode.Update && !Bridge.staticEquals(t.onStepComplete, null)) {
                        for (var i = 0; i < newCompletedSteps; ++i) {
                            DG.Tweening.Tween.OnTweenCallback(t.onStepComplete, t);
                            if (!t.active) {
                                break; // A stepComplete killed the tween
                            }
                        }
                    }

                    if (t.isComplete && !wasComplete && updateMode !== DG.Tweening.Core.Enums.UpdateMode.IgnoreOnComplete && !Bridge.staticEquals(t.onComplete, null)) {
                        DG.Tweening.Tween.OnTweenCallback(t.onComplete, t);
                    }

                    if (!t.isPlaying && wasPlaying && (!t.isComplete || !t.autoKill) && !Bridge.staticEquals(t.onPause, null)) {
                        DG.Tweening.Tween.OnTweenCallback(t.onPause, t);
                    }

                    // Return
                    return t.autoKill && t.isComplete;
                },
                /*DG.Tweening.Tween.DoGoto:static end.*/

                /*DG.Tweening.Tween.OnTweenCallback:static start.*/
                OnTweenCallback: function (callback, t) {
if ( TRACE ) { TRACE( "DG.Tweening.Tween#OnTweenCallback", this ); }

                    if (DG.Tweening.DOTween.useSafeMode) {
                        try {
                            callback();
                        } catch (e) {
                            e = System.Exception.create(e);
                            if (DG.Tweening.Core.Debugger.ShouldLogSafeModeCapturedError()) {
                                DG.Tweening.Core.Debugger.LogSafeModeCapturedError(System.String.format("An error inside a tween callback was taken care of ({0}) \u25ba {1}\n\n{2}\n\n", e.TargetSite, e.Message, e.StackTrace), t);
                            }

                            DG.Tweening.DOTween.safeModeReport.Add(DG.Tweening.Core.SafeModeReport.SafeModeReportType.Callback);
                            return false; // Callback error
                        }
                    } else {
                        callback();
                    }

                    return true;
                },
                /*DG.Tweening.Tween.OnTweenCallback:static end.*/

                /*DG.Tweening.Tween.OnTweenCallback$1:static start.*/
                OnTweenCallback$1: function (T, callback, t, param) {
if ( TRACE ) { TRACE( "DG.Tweening.Tween#OnTweenCallback$1", this ); }

                    if (DG.Tweening.DOTween.useSafeMode) {
                        try {
                            callback(Bridge.rValue(param));
                        } catch (e) {
                            e = System.Exception.create(e);
                            if (DG.Tweening.Core.Debugger.ShouldLogSafeModeCapturedError()) {
                                DG.Tweening.Core.Debugger.LogSafeModeCapturedError(System.String.format("An error inside a tween callback was taken care of ({0}) \u25ba {1}", e.TargetSite, e.Message), t);
                            }

                            DG.Tweening.DOTween.safeModeReport.Add(DG.Tweening.Core.SafeModeReport.SafeModeReportType.Callback);
                            return false; // Callback error
                        }
                    } else {
                        callback(Bridge.rValue(param));
                    }

                    return true;
                },
                /*DG.Tweening.Tween.OnTweenCallback$1:static end.*/


            }
        },
        fields: {
            activeId: 0,
            autoKill: false,
            completedLoops: 0,
            creationLocked: false,
            customEase: null,
            /**
             * Set by SetTarget if DOTween's Debug Mode is on (see DOTween Utility Panel -&gt; "Store GameObject's ID" debug option
             *
             * @instance
             * @public
             * @memberof DG.Tweening.Tween
             * @type string
             */
            debugTargetId: null,
            delay: 0,
            delayComplete: false,
            duration: 0,
            easeType: 0,
            elapsedDelay: 0,
            fullDuration: 0,
            /**
             * Object ID (usable for filtering with DOTween static methods). Can be anything except a string or an int
                 (use {@link } or {@link } for those)
             *
             * @instance
             * @public
             * @memberof DG.Tweening.Tween
             * @type System.Object
             */
            id: null,
            /**
             * Int ID (usable for filtering with DOTween static methods). 4X faster than using an object id, 2X faster than using
                 a string id.
                 Default is -999 so avoid using an ID like that or it will capture all unset intIds
             *
             * @instance
             * @public
             * @memberof DG.Tweening.Tween
             * @type number
             */
            intId: 0,
            /**
             * If TRUE the tween will play backwards
             *
             * @instance
             * @public
             * @memberof DG.Tweening.Tween
             * @type boolean
             */
            isBackwards: false,
            isBlendable: false,
            isComplete: false,
            isFrom: false,
            isIndependentUpdate: false,
            /**
             * If TRUE the tween is completely inverted but without playing it backwards
                 (play backwards will actually play the tween in the original direction)
             *
             * @instance
             * @memberof DG.Tweening.Tween
             * @type boolean
             */
            isInverted: false,
            isPlaying: false,
            isRecyclable: false,
            isSequenced: false,
            isSpeedBased: false,
            loops: 0,
            loopType: 0,
            miscInt: 0,
            /**
             * Called the moment the tween reaches completion (loops included)
             *
             * @instance
             * @public
             * @memberof DG.Tweening.Tween
             * @type DG.Tweening.TweenCallback
             */
            onComplete: null,
            /**
             * Called the moment the tween is killed
             *
             * @instance
             * @public
             * @memberof DG.Tweening.Tween
             * @type DG.Tweening.TweenCallback
             */
            onKill: null,
            /**
             * Called when the tween state changes from playing to paused.
                 If the tween has autoKill set to FALSE, this is called also when the tween reaches completion.
             *
             * @instance
             * @public
             * @memberof DG.Tweening.Tween
             * @type DG.Tweening.TweenCallback
             */
            onPause: null,
            /**
             * Called when the tween is set in a playing state, after any eventual delay.
                 Also called each time the tween resumes playing from a paused state
             *
             * @instance
             * @public
             * @memberof DG.Tweening.Tween
             * @type DG.Tweening.TweenCallback
             */
            onPlay: null,
            /**
             * Called when the tween is rewinded,
                 either by calling <pre><code>Rewind</code></pre> or by reaching the start position while playing backwards.
                 Rewinding a tween that is already rewinded will not fire this callback
             *
             * @instance
             * @public
             * @memberof DG.Tweening.Tween
             * @type DG.Tweening.TweenCallback
             */
            onRewind: null,
            /**
             * Called the moment the tween completes one loop cycle
             *
             * @instance
             * @public
             * @memberof DG.Tweening.Tween
             * @type DG.Tweening.TweenCallback
             */
            onStepComplete: null,
            /**
             * Called each time the tween updates
             *
             * @instance
             * @public
             * @memberof DG.Tweening.Tween
             * @type DG.Tweening.TweenCallback
             */
            onUpdate: null,
            /**
             * Called when a path tween's current waypoint changes
             *
             * @instance
             * @public
             * @memberof DG.Tweening.Tween
             * @type DG.Tweening.TweenCallback
             */
            onWaypointChange: null,
            sequenceParent: null,
            specialStartupMode: 0,
            startupDone: false,
            /**
             * String ID (usable for filtering with DOTween static methods). 2X faster than using an object id
             *
             * @instance
             * @public
             * @memberof DG.Tweening.Tween
             * @type string
             */
            stringId: null,
            /**
             * Tween target (usable for filtering with DOTween static methods). Automatically set by tween creation shortcuts
             *
             * @instance
             * @public
             * @memberof DG.Tweening.Tween
             * @type System.Object
             */
            target: null,
            /**
             * TimeScale for the tween
             *
             * @instance
             * @public
             * @memberof DG.Tweening.Tween
             * @type number
             */
            timeScale: 0,
            typeofT1: null,
            typeofT2: null,
            typeofTPlugOptions: null,
            updateType: 0,
            /**
             * Tweeners-only (ignored by Sequences), returns TRUE if the tween was set as relative
             *
             * @instance
             * @public
             * @memberof DG.Tweening.Tween
             * @function isRelative
             * @type boolean
             */
            isRelative: false,
            /**
             * FALSE when tween is (or should be) despawned - set only by TweenManager
             *
             * @instance
             * @public
             * @memberof DG.Tweening.Tween
             * @function active
             * @type boolean
             */
            active: false,
            /**
             * TRUE after the tween was set in a play state at least once, AFTER any delay is elapsed
             *
             * @instance
             * @public
             * @memberof DG.Tweening.Tween
             * @function playedOnce
             * @type boolean
             */
            playedOnce: false,
            /**
             * Time position within a single loop cycle
             *
             * @instance
             * @public
             * @memberof DG.Tweening.Tween
             * @function position
             * @type number
             */
            position: 0,
            easeOvershootOrAmplitude: 0,
            easePeriod: 0
        },
        props: {
            /**
             * Gets and sets the time position (loops included, delays excluded) of the tween
             *
             * @instance
             * @public
             * @memberof DG.Tweening.Tween
             * @function fullPosition
             * @type number
             */
            fullPosition: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Tween#fullPosition#get", this ); }

                    return DG.Tweening.TweenExtensions.Elapsed(this);
                },
                set: function (value) {
if ( TRACE ) { TRACE( "DG.Tweening.Tween#fullPosition#set", this ); }

                    DG.Tweening.TweenExtensions.Goto(this, value, this.isPlaying);
                }
            },
            /**
             * Returns TRUE if the tween is set to loop (either a set number of times or infinitely)
             *
             * @instance
             * @public
             * @readonly
             * @memberof DG.Tweening.Tween
             * @function hasLoops
             * @type boolean
             */
            hasLoops: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Tween#hasLoops#get", this ); }

                    return this.loops === -1 || this.loops > 1;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Tween#init", this ); }

                this.activeId = -1;
                this.delayComplete = true;
                this.intId = -999;
                this.miscInt = -1;
            }
        },
        methods: {
            /*DG.Tweening.Tween.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Tween#Reset", this ); }

                this.timeScale = 1;
                this.isBackwards = false;
                this.id = null;
                this.stringId = null;
                this.intId = -999;
                this.isIndependentUpdate = false;
                this.onStart = (this.onPlay = (this.onRewind = (this.onUpdate = (this.onComplete = (this.onStepComplete = (this.onKill = null))))));
                this.onWaypointChange = null;

                this.debugTargetId = null;

                this.target = null;
                this.isFrom = false;
                this.isBlendable = false;
                this.isSpeedBased = false;
                this.duration = 0;
                this.loops = 1;
                this.delay = 0;
                this.isRelative = false;
                this.customEase = null;
                this.isSequenced = false;
                this.sequenceParent = null;
                this.specialStartupMode = DG.Tweening.Core.Enums.SpecialStartupMode.None;
                this.creationLocked = (this.startupDone = (this.playedOnce = false, false));
                this.position = (this.fullDuration = (this.completedLoops = 0));
                this.isPlaying = (this.isComplete = false);
                this.elapsedDelay = 0;
                this.delayComplete = true;

                this.miscInt = -1;

                // The following are set during a tween's Setup
                //            isRecyclable = DOTween.defaultRecyclable;
                //            autoKill = DOTween.defaultAutoKill;
                //            loopType = DOTween.defaultLoopType;
                //            easeType = DOTween.defaultEaseType;
                //            easeOvershootOrAmplitude = DOTween.defaultEaseOvershootOrAmplitude;
                //            easePeriod = DOTween.defaultEasePeriod

                // The following are set during TweenManager.AddActiveTween
                // (so the previous updateType is still stored while removing tweens)
                //            updateType = UpdateType.Normal;
            },
            /*DG.Tweening.Tween.Reset end.*/

            /*DG.Tweening.Tween.UpdateDelay start.*/
            UpdateDelay: function (elapsed) {
if ( TRACE ) { TRACE( "DG.Tweening.Tween#UpdateDelay", this ); }

                return 0;
            },
            /*DG.Tweening.Tween.UpdateDelay end.*/


        }
    });
    /*DG.Tweening.Tween end.*/

    /*DG.Tweening.Plugins.Core.ABSTweenPlugin$3 start.*/
    Bridge.define("DG.Tweening.Plugins.Core.ABSTweenPlugin$3", function (T1, T2, TPlugOptions) { return {
        inherits: [DG.Tweening.Plugins.Core.ITweenPlugin],
        methods: {
            /*DG.Tweening.Plugins.Core.ABSTweenPlugin$3.EvaluateAndApply start.*/
            EvaluateAndApply: function (options, t, isRelative, getter, setter, elapsed, startValue, changeValue, duration, usingInversePosition, updateNotice) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.ABSTweenPlugin$3#EvaluateAndApply", this ); }
 },
            /*DG.Tweening.Plugins.Core.ABSTweenPlugin$3.EvaluateAndApply end.*/

            /*DG.Tweening.Plugins.Core.ABSTweenPlugin$3.EvaluateAndApply$1 start.*/
            EvaluateAndApply$1: function (options, t, isRelative, getter, setter, elapsed, startValue, changeValue, duration, usingInversePosition, newCompletedSteps, updateNotice) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.ABSTweenPlugin$3#EvaluateAndApply$1", this ); }
 },
            /*DG.Tweening.Plugins.Core.ABSTweenPlugin$3.EvaluateAndApply$1 end.*/


        },
        overloads: {
            "EvaluateAndApply(TPlugOptions, Tween, bool, DOGetter<T1>, DOSetter<T1>, float, T2, T2, float, bool, int, UpdateNotice)": "EvaluateAndApply$1"
        }
    }; });
    /*DG.Tweening.Plugins.Core.ABSTweenPlugin$3 end.*/

    /*DG.Tweening.DOTweenPath start.*/
    Bridge.define("DG.Tweening.DOTweenPath", {
        inherits: [DG.Tweening.Core.ABSAnimationComponent],
        fields: {
            delay: 0,
            duration: 0,
            easeType: 0,
            easeCurve: null,
            loops: 0,
            id: null,
            loopType: 0,
            orientType: 0,
            lookAtTransform: null,
            lookAtPosition: null,
            lookAhead: 0,
            autoPlay: false,
            autoKill: false,
            relative: false,
            isLocal: false,
            isClosedPath: false,
            pathResolution: 0,
            pathMode: 0,
            lockRotation: 0,
            assignForwardAndUp: false,
            forwardDirection: null,
            upDirection: null,
            tweenRigidbody: false,
            wps: null,
            fullWps: null,
            path: null,
            inspectorMode: 0,
            pathType: 0,
            handlesType: 0,
            livePreview: false,
            handlesDrawMode: 0,
            perspectiveHandleSize: 0,
            showIndexes: false,
            showWpLength: false,
            pathColor: null,
            lastSrcPosition: null,
            lastSrcRotation: null,
            wpsDropdown: false,
            dropToFloorOffset: 0
        },
        events: {
            OnReset: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenPath#init", this ); }

                this.lookAtPosition = new UnityEngine.Vector3();
                this.forwardDirection = new UnityEngine.Vector3();
                this.upDirection = new UnityEngine.Vector3();
                this.pathColor = new UnityEngine.Color();
                this.lastSrcPosition = new UnityEngine.Vector3();
                this.lastSrcRotation = new UnityEngine.Quaternion();
            }
        },
        methods: {
            /*DG.Tweening.DOTweenPath.DOPlay start.*/
            DOPlay: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenPath#DOPlay", this ); }

                throw new System.NotImplementedException.ctor();
            },
            /*DG.Tweening.DOTweenPath.DOPlay end.*/

            /*DG.Tweening.DOTweenPath.DOPlayById start.*/
            DOPlayById: function (id) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenPath#DOPlayById", this ); }

                throw new System.NotImplementedException.ctor();
            },
            /*DG.Tweening.DOTweenPath.DOPlayById end.*/

            /*DG.Tweening.DOTweenPath.DOPlayAllById start.*/
            DOPlayAllById: function (id) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenPath#DOPlayAllById", this ); }

                throw new System.NotImplementedException.ctor();
            },
            /*DG.Tweening.DOTweenPath.DOPlayAllById end.*/

            /*DG.Tweening.DOTweenPath.DOPlayBackwards start.*/
            DOPlayBackwards: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenPath#DOPlayBackwards", this ); }

                throw new System.NotImplementedException.ctor();
            },
            /*DG.Tweening.DOTweenPath.DOPlayBackwards end.*/

            /*DG.Tweening.DOTweenPath.DOPlayForward start.*/
            DOPlayForward: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenPath#DOPlayForward", this ); }

                throw new System.NotImplementedException.ctor();
            },
            /*DG.Tweening.DOTweenPath.DOPlayForward end.*/

            /*DG.Tweening.DOTweenPath.DOPause start.*/
            DOPause: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenPath#DOPause", this ); }

                throw new System.NotImplementedException.ctor();
            },
            /*DG.Tweening.DOTweenPath.DOPause end.*/

            /*DG.Tweening.DOTweenPath.DOTogglePause start.*/
            DOTogglePause: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenPath#DOTogglePause", this ); }

                throw new System.NotImplementedException.ctor();
            },
            /*DG.Tweening.DOTweenPath.DOTogglePause end.*/

            /*DG.Tweening.DOTweenPath.DORewind start.*/
            DORewind: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenPath#DORewind", this ); }

                throw new System.NotImplementedException.ctor();
            },
            /*DG.Tweening.DOTweenPath.DORewind end.*/

            /*DG.Tweening.DOTweenPath.DORestart start.*/
            DORestart: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenPath#DORestart", this ); }

                throw new System.NotImplementedException.ctor();
            },
            /*DG.Tweening.DOTweenPath.DORestart end.*/

            /*DG.Tweening.DOTweenPath.DORestart$1 start.*/
            DORestart$1: function (fromHere) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenPath#DORestart$1", this ); }

                throw new System.NotImplementedException.ctor();
            },
            /*DG.Tweening.DOTweenPath.DORestart$1 end.*/

            /*DG.Tweening.DOTweenPath.DOComplete start.*/
            DOComplete: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenPath#DOComplete", this ); }

                throw new System.NotImplementedException.ctor();
            },
            /*DG.Tweening.DOTweenPath.DOComplete end.*/

            /*DG.Tweening.DOTweenPath.DOKill start.*/
            DOKill: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenPath#DOKill", this ); }

                throw new System.NotImplementedException.ctor();
            },
            /*DG.Tweening.DOTweenPath.DOKill end.*/

            /*DG.Tweening.DOTweenPath.DOKillAllById start.*/
            DOKillAllById: function (id) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenPath#DOKillAllById", this ); }

                throw new System.NotImplementedException.ctor();
            },
            /*DG.Tweening.DOTweenPath.DOKillAllById end.*/

            /*DG.Tweening.DOTweenPath.GetTween start.*/
            GetTween: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenPath#GetTween", this ); }

                throw new System.NotImplementedException.ctor();
            },
            /*DG.Tweening.DOTweenPath.GetTween end.*/

            /*DG.Tweening.DOTweenPath.GetDrawPoints start.*/
            GetDrawPoints: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenPath#GetDrawPoints", this ); }

                throw new System.NotImplementedException.ctor();
            },
            /*DG.Tweening.DOTweenPath.GetDrawPoints end.*/

            /*DG.Tweening.DOTweenPath.GetFullWps start.*/
            GetFullWps: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenPath#GetFullWps", this ); }

                throw new System.NotImplementedException.ctor();
            },
            /*DG.Tweening.DOTweenPath.GetFullWps end.*/


        },
        overloads: {
            "DORestart(bool)": "DORestart$1"
        }
    });
    /*DG.Tweening.DOTweenPath end.*/

    /*DG.Tweening.Plugins.CircleOptions start.*/
    Bridge.define("DG.Tweening.Plugins.CircleOptions", {
        inherits: [DG.Tweening.Plugins.Options.IPlugOptions],
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.CircleOptions#getDefaultValue", this ); }
 return new DG.Tweening.Plugins.CircleOptions(); }
            }
        },
        fields: {
            endValueDegrees: 0,
            relativeCenter: false,
            snapping: false,
            center: null,
            radius: 0,
            startValueDegrees: 0,
            initialized: false
        },
        alias: ["Reset", "DG$Tweening$Plugins$Options$IPlugOptions$Reset"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.CircleOptions#init", this ); }

                this.center = new UnityEngine.Vector2();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.CircleOptions#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*DG.Tweening.Plugins.CircleOptions.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.CircleOptions#Reset", this ); }

                this.initialized = false;
                this.startValueDegrees = (this.endValueDegrees = 0);
                this.relativeCenter = false;
                this.snapping = false;
            },
            /*DG.Tweening.Plugins.CircleOptions.Reset end.*/

            /*DG.Tweening.Plugins.CircleOptions.Initialize start.*/
            Initialize: function (startValue, endValue) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.CircleOptions#Initialize", this ); }

                this.initialized = true;
                this.center = endValue.$clone();
                if (this.relativeCenter) {
                    this.center = startValue.$clone().add( this.center );
                }

                this.radius = this.center.$clone().sub( startValue ).length();
                var semiNormalizedP = startValue.$clone().sub( this.center );
                this.startValueDegrees = Math.atan2(semiNormalizedP.x, semiNormalizedP.y) * UnityEngine.Mathf.Rad2Deg;
            },
            /*DG.Tweening.Plugins.CircleOptions.Initialize end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.CircleOptions#getHashCode", this ); }

                var h = Bridge.addHash([5405489302, this.endValueDegrees, this.relativeCenter, this.snapping, this.center, this.radius, this.startValueDegrees, this.initialized]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.CircleOptions#equals", this ); }

                if (!Bridge.is(o, DG.Tweening.Plugins.CircleOptions)) {
                    return false;
                }
                return Bridge.equals(this.endValueDegrees, o.endValueDegrees) && Bridge.equals(this.relativeCenter, o.relativeCenter) && Bridge.equals(this.snapping, o.snapping) && Bridge.equals(this.center, o.center) && Bridge.equals(this.radius, o.radius) && Bridge.equals(this.startValueDegrees, o.startValueDegrees) && Bridge.equals(this.initialized, o.initialized);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.CircleOptions#$clone", this ); }

                var s = to || new DG.Tweening.Plugins.CircleOptions();
                s.endValueDegrees = this.endValueDegrees;
                s.relativeCenter = this.relativeCenter;
                s.snapping = this.snapping;
                s.center = this.center.$clone();
                s.radius = this.radius;
                s.startValueDegrees = this.startValueDegrees;
                s.initialized = this.initialized;
                return s;
            }
        }
    });
    /*DG.Tweening.Plugins.CircleOptions end.*/

    /*DG.Tweening.Plugins.Core.PathCore.CatmullRomDecoder start.*/
    Bridge.define("DG.Tweening.Plugins.Core.PathCore.CatmullRomDecoder", {
        inherits: [DG.Tweening.Plugins.Core.PathCore.ABSPathDecoder],
        statics: {
            fields: {
                _PartialControlPs: null,
                _PartialWps: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.CatmullRomDecoder#init", this ); }

                    this._PartialControlPs = System.Array.init(2, function (){
                        return new DG.Tweening.Plugins.Core.PathCore.ControlPoint();
                    }, DG.Tweening.Plugins.Core.PathCore.ControlPoint);
                    this._PartialWps = System.Array.init(2, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                }
            }
        },
        props: {
            minInputWaypoints: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.CatmullRomDecoder#minInputWaypoints#get", this ); }

                    return 1;
                }
            }
        },
        methods: {
            /*DG.Tweening.Plugins.Core.PathCore.CatmullRomDecoder.FinalizePath start.*/
            FinalizePath: function (p, wps, isClosedPath) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.CatmullRomDecoder#FinalizePath", this ); }

                // Add starting and ending control points (uses only one vector per control point)
                var wpsLen = wps.length;
                if (p.controlPoints == null || p.controlPoints.length !== 2) {
                    p.controlPoints = System.Array.init(2, function (){
                        return new DG.Tweening.Plugins.Core.PathCore.ControlPoint();
                    }, DG.Tweening.Plugins.Core.PathCore.ControlPoint);
                }

                if (isClosedPath) {
                    p.controlPoints[0] = new DG.Tweening.Plugins.Core.PathCore.ControlPoint.$ctor1(wps[wpsLen - 2].$clone(), pc.Vec3.ZERO.clone());
                    p.controlPoints[1] = new DG.Tweening.Plugins.Core.PathCore.ControlPoint.$ctor1(wps[1].$clone(), pc.Vec3.ZERO.clone());
                } else {
                    p.controlPoints[0] = new DG.Tweening.Plugins.Core.PathCore.ControlPoint.$ctor1(wps[1].$clone(), pc.Vec3.ZERO.clone());
                    var lastP = wps[wpsLen - 1].$clone();
                    var diffV = lastP.$clone().sub( wps[wpsLen - 2] );
                    p.controlPoints[1] = new DG.Tweening.Plugins.Core.PathCore.ControlPoint.$ctor1(lastP.$clone().add( diffV ), pc.Vec3.ZERO.clone());
                }

                // Store total subdivisions
                //            p.subdivisions = (wpsLen + 2) * p.subdivisionsXSegment;
                p.subdivisions = wpsLen * p.subdivisionsXSegment;
                // Store time to len tables
                this.SetTimeToLengthTables(p, p.subdivisions);
                // Store waypoints lengths
                this.SetWaypointsLengths(p, p.subdivisionsXSegment);
            },
            /*DG.Tweening.Plugins.Core.PathCore.CatmullRomDecoder.FinalizePath end.*/

            /*DG.Tweening.Plugins.Core.PathCore.CatmullRomDecoder.GetPoint start.*/
            GetPoint: function (perc, wps, p, controlPoints) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.CatmullRomDecoder#GetPoint", this ); }

                var numSections = wps.length - 1; // Considering also control points
                var tSec = Math.floor(perc * numSections);
                var currPt = numSections - 1;
                if (currPt > tSec) {
                    currPt = tSec;
                }

                var u = perc * numSections - currPt;

                var a = currPt === 0 ? controlPoints[0].a.$clone() : wps[currPt - 1].$clone();
                var b = wps[currPt].$clone();
                var c = wps[currPt + 1].$clone();
                var d = currPt + 2 > wps.length - 1 ? controlPoints[1].a.$clone() : wps[currPt + 2].$clone();

                return ((a.$clone().scale( -1 ).add( b.clone().scale( 3.0 ) ).sub( c.clone().scale( 3.0 ) ).add( d )).clone().scale( (u * u * u) ).add( (a.clone().scale( 2.0 ).sub( b.clone().scale( 5.0 ) ).add( c.clone().scale( 4.0 ) ).sub( d )).clone().scale( (u * u) ) ).add( (a.$clone().scale( -1 ).add( c )).clone().scale( u ) ).add( b.clone().scale( 2.0 ) )).clone().scale( 0.5 );
            },
            /*DG.Tweening.Plugins.Core.PathCore.CatmullRomDecoder.GetPoint end.*/

            /*DG.Tweening.Plugins.Core.PathCore.CatmullRomDecoder.SetTimeToLengthTables start.*/
            SetTimeToLengthTables: function (p, subdivisions) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.CatmullRomDecoder#SetTimeToLengthTables", this ); }

                var pathLen = 0;
                var incr = 1.0 / subdivisions;
                var timesTable = System.Array.init(subdivisions, 0, System.Single);
                var lengthsTable = System.Array.init(subdivisions, 0, System.Single);
                var prevP = this.GetPoint(0, p.wps, p, p.controlPoints);
                for (var i = 1; i < subdivisions + 1; ++i) {
                    var perc = incr * i;
                    var currP = this.GetPoint(perc, p.wps, p, p.controlPoints);
                    pathLen += pc.Vec3.distance( currP, prevP );
                    prevP = currP.$clone();
                    timesTable[i - 1] = perc;
                    lengthsTable[i - 1] = pathLen;
                }

                // Assign
                p.length = pathLen;
                p.timesTable = timesTable;
                p.lengthsTable = lengthsTable;
            },
            /*DG.Tweening.Plugins.Core.PathCore.CatmullRomDecoder.SetTimeToLengthTables end.*/

            /*DG.Tweening.Plugins.Core.PathCore.CatmullRomDecoder.SetWaypointsLengths start.*/
            SetWaypointsLengths: function (p, subdivisions) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.CatmullRomDecoder#SetWaypointsLengths", this ); }

                // Create a relative path between each waypoint,
                // with its start and end control lines coinciding with the next/prev waypoints.
                var count = p.wps.length;
                var wpLengths = System.Array.init(count, 0, System.Single);
                wpLengths[0] = 0;
                for (var i = 1; i < count; ++i) {
                    // Create partial path
                    DG.Tweening.Plugins.Core.PathCore.CatmullRomDecoder._PartialControlPs[0].a = i === 1 ? p.controlPoints[0].a.$clone() : p.wps[i - 2].$clone();
                    DG.Tweening.Plugins.Core.PathCore.CatmullRomDecoder._PartialWps[0] = p.wps[i - 1].$clone();
                    DG.Tweening.Plugins.Core.PathCore.CatmullRomDecoder._PartialWps[1] = p.wps[i].$clone();
                    DG.Tweening.Plugins.Core.PathCore.CatmullRomDecoder._PartialControlPs[1].a = i === count - 1 ? p.controlPoints[1].a.$clone() : p.wps[i + 1].$clone();
                    // Calculate length of partial path
                    var partialLen = 0;
                    var incr = 1.0 / subdivisions;
                    var prevP = this.GetPoint(0, DG.Tweening.Plugins.Core.PathCore.CatmullRomDecoder._PartialWps, p, DG.Tweening.Plugins.Core.PathCore.CatmullRomDecoder._PartialControlPs);
                    for (var c = 1; c < subdivisions + 1; ++c) {
                        var perc = incr * c;
                        var currP = this.GetPoint(perc, DG.Tweening.Plugins.Core.PathCore.CatmullRomDecoder._PartialWps, p, DG.Tweening.Plugins.Core.PathCore.CatmullRomDecoder._PartialControlPs);
                        partialLen += pc.Vec3.distance( currP, prevP );
                        prevP = currP.$clone();
                    }

                    wpLengths[i] = partialLen;
                }

                // Assign
                p.wpLengths = wpLengths;
            },
            /*DG.Tweening.Plugins.Core.PathCore.CatmullRomDecoder.SetWaypointsLengths end.*/


        }
    });
    /*DG.Tweening.Plugins.Core.PathCore.CatmullRomDecoder end.*/

    /*DG.Tweening.Plugins.Core.PathCore.CubicBezierDecoder start.*/
    Bridge.define("DG.Tweening.Plugins.Core.PathCore.CubicBezierDecoder", {
        inherits: [DG.Tweening.Plugins.Core.PathCore.ABSPathDecoder],
        statics: {
            fields: {
                _PartialControlPs: null,
                _PartialWps: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.CubicBezierDecoder#init", this ); }

                    this._PartialControlPs = System.Array.init(1, function (){
                        return new DG.Tweening.Plugins.Core.PathCore.ControlPoint();
                    }, DG.Tweening.Plugins.Core.PathCore.ControlPoint);
                    this._PartialWps = System.Array.init(2, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                }
            }
        },
        props: {
            minInputWaypoints: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.CubicBezierDecoder#minInputWaypoints#get", this ); }

                    return 3;
                }
            }
        },
        methods: {
            /*DG.Tweening.Plugins.Core.PathCore.CubicBezierDecoder.FinalizePath start.*/
            FinalizePath: function (p, wps, isClosedPath) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.CubicBezierDecoder#FinalizePath", this ); }

                if (isClosedPath && !p.addedExtraEndWp) {
                    isClosedPath = false;
                }

                // Normally there's an extra wp without control points for the starting wp added by DOTween,
                // but if isClosedPath consider an extra wp without control points at the end
                var wpsLen = wps.length;
                var diff = p.addedExtraStartWp ? 1 : 0;
                if (p.addedExtraEndWp) {
                    diff++;
                }

                if (wpsLen < 3 + diff || (wpsLen - diff) % 3 !== 0) {
                    // Report multiple of 3s error even if we're checking for multiple of 3 + starting point,
                    // because starting point is assigned by DOTween and not by user
                    UnityEngine.Debug.LogError$2("CubicBezier paths must contain waypoints in multiple of 3 excluding the starting point added automatically by DOTween (1: waypoint, 2: IN control point, 3: OUT control point \u2014 the minimum amount of waypoints for a single curve is 3)");
                    return;
                }

                //            // DEBUG
                //            for (int i = 0; i < wps.Length; ++i) {
                //                Debug.Log("WP " + i + "  " + wps[i]);
                //            }
                //            Debug.Log("--------------------------------------");
                //            // DEBUG END

                var wpsOnlyLen = diff + (wpsLen - diff) / 3;
                // Store control points and stripped version of wps
                var strippedWps = System.Array.init(wpsOnlyLen, function (){
                    return new UnityEngine.Vector3();
                }, UnityEngine.Vector3);
                p.controlPoints = System.Array.init(wpsOnlyLen - 1, function (){
                    return new DG.Tweening.Plugins.Core.PathCore.ControlPoint();
                }, DG.Tweening.Plugins.Core.PathCore.ControlPoint); // Exclude control points for first wp
                strippedWps[0] = wps[0].$clone();
                var strippedWpIndex = 1;
                var cpIndex = 0;
                for (var i = 3 + (p.addedExtraStartWp ? 0 : 2); i < wpsLen; i += 3) {
                    strippedWps[strippedWpIndex] = wps[i - 2].$clone();
                    strippedWpIndex++;
                    p.controlPoints[cpIndex] = new DG.Tweening.Plugins.Core.PathCore.ControlPoint.$ctor1(wps[i - 1].$clone(), wps[i].$clone());
                    cpIndex++;
                }

                p.wps = strippedWps; // Reassign stripped wps to path's wps
                //            // DEBUG
                //            for (int i = 0; i < strippedWps.Length; ++i) {
                //                Debug.Log("WP " + i + "  " + strippedWps[i]);
                //            }
                //            for (int i = 0; i < p.controlPoints.Length; ++i) {
                //                Debug.Log("CP " + i + "  " + p.controlPoints[i]);
                //            }
                //            // DEBUG END
                // Manage closed path
                if (isClosedPath) {
                    // Add control points for closed path
                    var wpEnd = p.wps[p.wps.length - 2].$clone();
                    var wpStart = p.wps[0].$clone();
                    var cEnd = p.controlPoints[p.controlPoints.length - 2].b.$clone();
                    var cStart = p.controlPoints[0].a.$clone();
                    var maxMagnitude = (wpStart.$clone().sub( wpEnd )).length();
                    p.controlPoints[p.controlPoints.length - 1] = new DG.Tweening.Plugins.Core.PathCore.ControlPoint.$ctor1(wpEnd.$clone().add( pc.Vec3.clampMagnitude( wpEnd.$clone().sub( cEnd ), maxMagnitude ) ), wpStart.$clone().add( pc.Vec3.clampMagnitude( wpStart.$clone().sub( cStart ), maxMagnitude ) ));
                }

                // Store total subdivisions
                p.subdivisions = wpsOnlyLen * p.subdivisionsXSegment;
                // Store time to len tables
                this.SetTimeToLengthTables(p, p.subdivisions);
                // Store waypoints lengths
                this.SetWaypointsLengths(p, p.subdivisionsXSegment);
            },
            /*DG.Tweening.Plugins.Core.PathCore.CubicBezierDecoder.FinalizePath end.*/

            /*DG.Tweening.Plugins.Core.PathCore.CubicBezierDecoder.GetPoint start.*/
            GetPoint: function (perc, wps, p, controlPoints) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.CubicBezierDecoder#GetPoint", this ); }

                var numSections = wps.length - 1;
                var tSec = Math.floor(perc * numSections);
                var currPt = numSections - 1;
                if (currPt > tSec) {
                    currPt = tSec;
                }

                var t = perc * numSections - currPt;

                var p0 = wps[currPt].$clone();
                var p1 = controlPoints[currPt].a.$clone();
                var p2 = controlPoints[currPt].b.$clone();
                var p3 = wps[currPt + 1].$clone();

                var u = 1 - t;
                var tt = t * t;
                var uu = u * u;
                var uuu = uu * u;
                var ttt = tt * t;

                var result = p0.clone().scale( uuu ).add( p1.clone().scale( 3 * uu * t ) ).add( p2.clone().scale( 3 * u * tt ) ).add( p3.clone().scale( ttt ) );

                return result.$clone();
            },
            /*DG.Tweening.Plugins.Core.PathCore.CubicBezierDecoder.GetPoint end.*/

            /*DG.Tweening.Plugins.Core.PathCore.CubicBezierDecoder.SetTimeToLengthTables start.*/
            SetTimeToLengthTables: function (p, subdivisions) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.CubicBezierDecoder#SetTimeToLengthTables", this ); }

                var pathLen = 0;
                var incr = 1.0 / subdivisions;
                var timesTable = System.Array.init(subdivisions, 0, System.Single);
                var lengthsTable = System.Array.init(subdivisions, 0, System.Single);
                var prevP = this.GetPoint(0, p.wps, p, p.controlPoints);
                for (var i = 1; i < subdivisions + 1; ++i) {
                    var perc = incr * i;
                    var currP = this.GetPoint(perc, p.wps, p, p.controlPoints);
                    pathLen += pc.Vec3.distance( currP, prevP );
                    prevP = currP.$clone();
                    timesTable[i - 1] = perc;
                    lengthsTable[i - 1] = pathLen;
                }

                // Assign
                p.length = pathLen;
                p.timesTable = timesTable;
                p.lengthsTable = lengthsTable;
            },
            /*DG.Tweening.Plugins.Core.PathCore.CubicBezierDecoder.SetTimeToLengthTables end.*/

            /*DG.Tweening.Plugins.Core.PathCore.CubicBezierDecoder.SetWaypointsLengths start.*/
            SetWaypointsLengths: function (p, subdivisions) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.CubicBezierDecoder#SetWaypointsLengths", this ); }

                // Create a relative path between each waypoint,
                // with its start and end control lines coinciding with the next/prev waypoints.
                var count = p.wps.length;
                var wpLengths = System.Array.init(count, 0, System.Single);
                wpLengths[0] = 0;
                for (var i = 1; i < count; ++i) {
                    // Create partial path
                    //                _PartialControlPs[0].a = i == 1 ? p.controlPoints[0].a : p.wps[i - 2];
                    DG.Tweening.Plugins.Core.PathCore.CubicBezierDecoder._PartialControlPs[0] = p.controlPoints[i - 1].$clone();
                    DG.Tweening.Plugins.Core.PathCore.CubicBezierDecoder._PartialWps[0] = p.wps[i - 1].$clone();
                    DG.Tweening.Plugins.Core.PathCore.CubicBezierDecoder._PartialWps[1] = p.wps[i].$clone();
                    //                _PartialControlPs[1].a = i == count - 1 ? p.controlPoints[1].a : p.wps[i + 1];
                    // Calculate length of partial path
                    var partialLen = 0;
                    var incr = 1.0 / subdivisions;
                    var prevP = this.GetPoint(0, DG.Tweening.Plugins.Core.PathCore.CubicBezierDecoder._PartialWps, p, DG.Tweening.Plugins.Core.PathCore.CubicBezierDecoder._PartialControlPs);
                    for (var c = 1; c < subdivisions + 1; ++c) {
                        var perc = incr * c;
                        var currP = this.GetPoint(perc, DG.Tweening.Plugins.Core.PathCore.CubicBezierDecoder._PartialWps, p, DG.Tweening.Plugins.Core.PathCore.CubicBezierDecoder._PartialControlPs);
                        partialLen += pc.Vec3.distance( currP, prevP );
                        prevP = currP.$clone();
                    }

                    wpLengths[i] = partialLen;
                }

                // Assign
                p.wpLengths = wpLengths;
            },
            /*DG.Tweening.Plugins.Core.PathCore.CubicBezierDecoder.SetWaypointsLengths end.*/


        }
    });
    /*DG.Tweening.Plugins.Core.PathCore.CubicBezierDecoder end.*/

    /*DG.Tweening.Plugins.Core.PathCore.LinearDecoder start.*/
    Bridge.define("DG.Tweening.Plugins.Core.PathCore.LinearDecoder", {
        inherits: [DG.Tweening.Plugins.Core.PathCore.ABSPathDecoder],
        props: {
            minInputWaypoints: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.LinearDecoder#minInputWaypoints#get", this ); }

                    return 1;
                }
            }
        },
        methods: {
            /*DG.Tweening.Plugins.Core.PathCore.LinearDecoder.FinalizePath start.*/
            FinalizePath: function (p, wps, isClosedPath) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.LinearDecoder#FinalizePath", this ); }

                p.controlPoints = null;
                // Store time to len tables
                p.subdivisions = wps.length * p.subdivisionsXSegment; // Unused
                this.SetTimeToLengthTables(p, p.subdivisions);
            },
            /*DG.Tweening.Plugins.Core.PathCore.LinearDecoder.FinalizePath end.*/

            /*DG.Tweening.Plugins.Core.PathCore.LinearDecoder.GetPoint start.*/
            GetPoint: function (perc, wps, p, controlPoints) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.LinearDecoder#GetPoint", this ); }

                if (perc <= 0) {
                    p.linearWPIndex = 1;
                    return wps[0].$clone();
                }

                var startPIndex = 0;
                var endPIndex = 0;
                var count = p.timesTable.length;
                for (var i = 1; i < count; i++) {
                    if (p.timesTable[i] >= perc) {
                        startPIndex = i - 1;
                        endPIndex = i;
                        break;
                    }
                }

                var startPPerc = p.timesTable[startPIndex];
                var partialPerc = perc - startPPerc;
                var partialLen = p.length * partialPerc;
                var wp0 = wps[startPIndex].$clone();
                var wp1 = wps[endPIndex].$clone();
                p.linearWPIndex = endPIndex;
                return wp0.$clone().add( pc.Vec3.clampMagnitude( wp1.$clone().sub( wp0 ), partialLen ) );
            },
            /*DG.Tweening.Plugins.Core.PathCore.LinearDecoder.GetPoint end.*/

            /*DG.Tweening.Plugins.Core.PathCore.LinearDecoder.SetTimeToLengthTables start.*/
            SetTimeToLengthTables: function (p, subdivisions) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.LinearDecoder#SetTimeToLengthTables", this ); }

                var pathLen = 0;
                var wpsLen = p.wps.length;
                var wpLengths = System.Array.init(wpsLen, 0, System.Single);
                var prevP = p.wps[0].$clone();
                for (var i = 0; i < wpsLen; i++) {
                    var currP = p.wps[i].$clone();
                    var dist = pc.Vec3.distance( currP, prevP );
                    pathLen += dist;
                    prevP = currP.$clone();
                    wpLengths[i] = dist;
                }

                var timesTable = System.Array.init(wpsLen, 0, System.Single);
                var tmpLen = 0;
                for (var i1 = 1; i1 < wpsLen; i1++) {
                    tmpLen += wpLengths[i1];
                    timesTable[i1] = tmpLen / pathLen;
                }

                // Assign
                p.length = pathLen;
                p.wpLengths = wpLengths;
                p.timesTable = timesTable;
            },
            /*DG.Tweening.Plugins.Core.PathCore.LinearDecoder.SetTimeToLengthTables end.*/

            /*DG.Tweening.Plugins.Core.PathCore.LinearDecoder.SetWaypointsLengths start.*/
            SetWaypointsLengths: function (p, subdivisions) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Core.PathCore.LinearDecoder#SetWaypointsLengths", this ); }

                // Does nothing (waypoints lenghts were stored inside SetTimeToLengthTables)
            },
            /*DG.Tweening.Plugins.Core.PathCore.LinearDecoder.SetWaypointsLengths end.*/


        }
    });
    /*DG.Tweening.Plugins.Core.PathCore.LinearDecoder end.*/

    /*DG.Tweening.Plugins.Options.PathOptions start.*/
    Bridge.define("DG.Tweening.Plugins.Options.PathOptions", {
        inherits: [DG.Tweening.Plugins.Options.IPlugOptions],
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.PathOptions#getDefaultValue", this ); }
 return new DG.Tweening.Plugins.Options.PathOptions(); }
            }
        },
        fields: {
            mode: 0,
            orientType: 0,
            lockPositionAxis: 0,
            lockRotationAxis: 0,
            isClosedPath: false,
            lookAtPosition: null,
            lookAtTransform: null,
            lookAhead: 0,
            hasCustomForwardDirection: false,
            forward: null,
            useLocalPosition: false,
            parent: null,
            isRigidbody: false,
            isRigidbody2D: false,
            stableZRotation: false,
            startupRot: null,
            startupZRot: 0,
            addedExtraStartWp: false,
            addedExtraEndWp: false
        },
        alias: ["Reset", "DG$Tweening$Plugins$Options$IPlugOptions$Reset"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.PathOptions#init", this ); }

                this.lookAtPosition = new UnityEngine.Vector3();
                this.forward = new UnityEngine.Quaternion();
                this.startupRot = new UnityEngine.Quaternion();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.PathOptions#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*DG.Tweening.Plugins.Options.PathOptions.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.PathOptions#Reset", this ); }

                this.mode = DG.Tweening.PathMode.Ignore;
                this.orientType = DG.Tweening.Plugins.Options.OrientType.None;
                this.lockPositionAxis = (this.lockRotationAxis = DG.Tweening.AxisConstraint.None);
                this.isClosedPath = false;
                this.lookAtPosition = pc.Vec3.ZERO.clone();
                this.lookAtTransform = null;
                this.lookAhead = 0;
                this.hasCustomForwardDirection = false;
                this.forward = pc.Quat.IDENTITY.clone();
                this.useLocalPosition = false;
                this.parent = null;
                this.isRigidbody = (this.isRigidbody2D = false);
                this.stableZRotation = false;
                this.startupRot = pc.Quat.IDENTITY.clone();
                this.startupZRot = 0;
                this.addedExtraStartWp = (this.addedExtraEndWp = false);
            },
            /*DG.Tweening.Plugins.Options.PathOptions.Reset end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.PathOptions#getHashCode", this ); }

                var h = Bridge.addHash([3529261070, this.mode, this.orientType, this.lockPositionAxis, this.lockRotationAxis, this.isClosedPath, this.lookAtPosition, this.lookAtTransform, this.lookAhead, this.hasCustomForwardDirection, this.forward, this.useLocalPosition, this.parent, this.isRigidbody, this.isRigidbody2D, this.stableZRotation, this.startupRot, this.startupZRot, this.addedExtraStartWp, this.addedExtraEndWp]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.PathOptions#equals", this ); }

                if (!Bridge.is(o, DG.Tweening.Plugins.Options.PathOptions)) {
                    return false;
                }
                return Bridge.equals(this.mode, o.mode) && Bridge.equals(this.orientType, o.orientType) && Bridge.equals(this.lockPositionAxis, o.lockPositionAxis) && Bridge.equals(this.lockRotationAxis, o.lockRotationAxis) && Bridge.equals(this.isClosedPath, o.isClosedPath) && Bridge.equals(this.lookAtPosition, o.lookAtPosition) && Bridge.equals(this.lookAtTransform, o.lookAtTransform) && Bridge.equals(this.lookAhead, o.lookAhead) && Bridge.equals(this.hasCustomForwardDirection, o.hasCustomForwardDirection) && Bridge.equals(this.forward, o.forward) && Bridge.equals(this.useLocalPosition, o.useLocalPosition) && Bridge.equals(this.parent, o.parent) && Bridge.equals(this.isRigidbody, o.isRigidbody) && Bridge.equals(this.isRigidbody2D, o.isRigidbody2D) && Bridge.equals(this.stableZRotation, o.stableZRotation) && Bridge.equals(this.startupRot, o.startupRot) && Bridge.equals(this.startupZRot, o.startupZRot) && Bridge.equals(this.addedExtraStartWp, o.addedExtraStartWp) && Bridge.equals(this.addedExtraEndWp, o.addedExtraEndWp);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.PathOptions#$clone", this ); }

                var s = to || new DG.Tweening.Plugins.Options.PathOptions();
                s.mode = this.mode;
                s.orientType = this.orientType;
                s.lockPositionAxis = this.lockPositionAxis;
                s.lockRotationAxis = this.lockRotationAxis;
                s.isClosedPath = this.isClosedPath;
                s.lookAtPosition = this.lookAtPosition.$clone();
                s.lookAtTransform = this.lookAtTransform;
                s.lookAhead = this.lookAhead;
                s.hasCustomForwardDirection = this.hasCustomForwardDirection;
                s.forward = this.forward.$clone();
                s.useLocalPosition = this.useLocalPosition;
                s.parent = this.parent;
                s.isRigidbody = this.isRigidbody;
                s.isRigidbody2D = this.isRigidbody2D;
                s.stableZRotation = this.stableZRotation;
                s.startupRot = this.startupRot.$clone();
                s.startupZRot = this.startupZRot;
                s.addedExtraStartWp = this.addedExtraStartWp;
                s.addedExtraEndWp = this.addedExtraEndWp;
                return s;
            }
        }
    });
    /*DG.Tweening.Plugins.Options.PathOptions end.*/

    /*DG.Tweening.Plugins.Options.QuaternionOptions start.*/
    Bridge.define("DG.Tweening.Plugins.Options.QuaternionOptions", {
        inherits: [DG.Tweening.Plugins.Options.IPlugOptions],
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.QuaternionOptions#getDefaultValue", this ); }
 return new DG.Tweening.Plugins.Options.QuaternionOptions(); }
            }
        },
        fields: {
            rotateMode: 0,
            axisConstraint: 0,
            up: null,
            dynamicLookAt: false,
            dynamicLookAtWorldPosition: null
        },
        alias: ["Reset", "DG$Tweening$Plugins$Options$IPlugOptions$Reset"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.QuaternionOptions#init", this ); }

                this.up = new UnityEngine.Vector3();
                this.dynamicLookAtWorldPosition = new UnityEngine.Vector3();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.QuaternionOptions#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*DG.Tweening.Plugins.Options.QuaternionOptions.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.QuaternionOptions#Reset", this ); }

                this.rotateMode = DG.Tweening.RotateMode.Fast;
                this.axisConstraint = DG.Tweening.AxisConstraint.None;
                this.up = pc.Vec3.ZERO.clone();
                this.dynamicLookAt = false;
                this.dynamicLookAtWorldPosition = pc.Vec3.ZERO.clone();
            },
            /*DG.Tweening.Plugins.Options.QuaternionOptions.Reset end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.QuaternionOptions#getHashCode", this ); }

                var h = Bridge.addHash([7458439180, this.rotateMode, this.axisConstraint, this.up, this.dynamicLookAt, this.dynamicLookAtWorldPosition]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.QuaternionOptions#equals", this ); }

                if (!Bridge.is(o, DG.Tweening.Plugins.Options.QuaternionOptions)) {
                    return false;
                }
                return Bridge.equals(this.rotateMode, o.rotateMode) && Bridge.equals(this.axisConstraint, o.axisConstraint) && Bridge.equals(this.up, o.up) && Bridge.equals(this.dynamicLookAt, o.dynamicLookAt) && Bridge.equals(this.dynamicLookAtWorldPosition, o.dynamicLookAtWorldPosition);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.QuaternionOptions#$clone", this ); }

                var s = to || new DG.Tweening.Plugins.Options.QuaternionOptions();
                s.rotateMode = this.rotateMode;
                s.axisConstraint = this.axisConstraint;
                s.up = this.up.$clone();
                s.dynamicLookAt = this.dynamicLookAt;
                s.dynamicLookAtWorldPosition = this.dynamicLookAtWorldPosition.$clone();
                return s;
            }
        }
    });
    /*DG.Tweening.Plugins.Options.QuaternionOptions end.*/

    /*DG.Tweening.Plugins.Options.RectOptions start.*/
    Bridge.define("DG.Tweening.Plugins.Options.RectOptions", {
        inherits: [DG.Tweening.Plugins.Options.IPlugOptions],
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.RectOptions#getDefaultValue", this ); }
 return new DG.Tweening.Plugins.Options.RectOptions(); }
            }
        },
        fields: {
            snapping: false
        },
        alias: ["Reset", "DG$Tweening$Plugins$Options$IPlugOptions$Reset"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.RectOptions#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*DG.Tweening.Plugins.Options.RectOptions.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.RectOptions#Reset", this ); }

                this.snapping = false;
            },
            /*DG.Tweening.Plugins.Options.RectOptions.Reset end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.RectOptions#getHashCode", this ); }

                var h = Bridge.addHash([3729474576, this.snapping]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.RectOptions#equals", this ); }

                if (!Bridge.is(o, DG.Tweening.Plugins.Options.RectOptions)) {
                    return false;
                }
                return Bridge.equals(this.snapping, o.snapping);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.RectOptions#$clone", this ); }

                var s = to || new DG.Tweening.Plugins.Options.RectOptions();
                s.snapping = this.snapping;
                return s;
            }
        }
    });
    /*DG.Tweening.Plugins.Options.RectOptions end.*/

    /*DG.Tweening.Plugins.Options.StringOptions start.*/
    Bridge.define("DG.Tweening.Plugins.Options.StringOptions", {
        inherits: [DG.Tweening.Plugins.Options.IPlugOptions],
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.StringOptions#getDefaultValue", this ); }
 return new DG.Tweening.Plugins.Options.StringOptions(); }
            }
        },
        fields: {
            richTextEnabled: false,
            scrambleMode: 0,
            scrambledChars: null,
            startValueStrippedLength: 0,
            changeValueStrippedLength: 0
        },
        alias: ["Reset", "DG$Tweening$Plugins$Options$IPlugOptions$Reset"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.StringOptions#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*DG.Tweening.Plugins.Options.StringOptions.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.StringOptions#Reset", this ); }

                this.richTextEnabled = false;
                this.scrambleMode = DG.Tweening.ScrambleMode.None;
                this.scrambledChars = null;
                this.startValueStrippedLength = (this.changeValueStrippedLength = 0);
            },
            /*DG.Tweening.Plugins.Options.StringOptions.Reset end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.StringOptions#getHashCode", this ); }

                var h = Bridge.addHash([5506155944, this.richTextEnabled, this.scrambleMode, this.scrambledChars, this.startValueStrippedLength, this.changeValueStrippedLength]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.StringOptions#equals", this ); }

                if (!Bridge.is(o, DG.Tweening.Plugins.Options.StringOptions)) {
                    return false;
                }
                return Bridge.equals(this.richTextEnabled, o.richTextEnabled) && Bridge.equals(this.scrambleMode, o.scrambleMode) && Bridge.equals(this.scrambledChars, o.scrambledChars) && Bridge.equals(this.startValueStrippedLength, o.startValueStrippedLength) && Bridge.equals(this.changeValueStrippedLength, o.changeValueStrippedLength);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.StringOptions#$clone", this ); }

                var s = to || new DG.Tweening.Plugins.Options.StringOptions();
                s.richTextEnabled = this.richTextEnabled;
                s.scrambleMode = this.scrambleMode;
                s.scrambledChars = this.scrambledChars;
                s.startValueStrippedLength = this.startValueStrippedLength;
                s.changeValueStrippedLength = this.changeValueStrippedLength;
                return s;
            }
        }
    });
    /*DG.Tweening.Plugins.Options.StringOptions end.*/

    /*DG.Tweening.Plugins.Options.UintOptions start.*/
    Bridge.define("DG.Tweening.Plugins.Options.UintOptions", {
        inherits: [DG.Tweening.Plugins.Options.IPlugOptions],
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.UintOptions#getDefaultValue", this ); }
 return new DG.Tweening.Plugins.Options.UintOptions(); }
            }
        },
        fields: {
            isNegativeChangeValue: false
        },
        alias: ["Reset", "DG$Tweening$Plugins$Options$IPlugOptions$Reset"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.UintOptions#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*DG.Tweening.Plugins.Options.UintOptions.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.UintOptions#Reset", this ); }

                this.isNegativeChangeValue = false;
            },
            /*DG.Tweening.Plugins.Options.UintOptions.Reset end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.UintOptions#getHashCode", this ); }

                var h = Bridge.addHash([3730196499, this.isNegativeChangeValue]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.UintOptions#equals", this ); }

                if (!Bridge.is(o, DG.Tweening.Plugins.Options.UintOptions)) {
                    return false;
                }
                return Bridge.equals(this.isNegativeChangeValue, o.isNegativeChangeValue);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.UintOptions#$clone", this ); }

                var s = to || new DG.Tweening.Plugins.Options.UintOptions();
                s.isNegativeChangeValue = this.isNegativeChangeValue;
                return s;
            }
        }
    });
    /*DG.Tweening.Plugins.Options.UintOptions end.*/

    /*DG.Tweening.Plugins.Options.Vector3ArrayOptions start.*/
    Bridge.define("DG.Tweening.Plugins.Options.Vector3ArrayOptions", {
        inherits: [DG.Tweening.Plugins.Options.IPlugOptions],
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.Vector3ArrayOptions#getDefaultValue", this ); }
 return new DG.Tweening.Plugins.Options.Vector3ArrayOptions(); }
            }
        },
        fields: {
            axisConstraint: 0,
            snapping: false,
            durations: null
        },
        alias: ["Reset", "DG$Tweening$Plugins$Options$IPlugOptions$Reset"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.Vector3ArrayOptions#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*DG.Tweening.Plugins.Options.Vector3ArrayOptions.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.Vector3ArrayOptions#Reset", this ); }

                this.axisConstraint = DG.Tweening.AxisConstraint.None;
                this.snapping = false;
                this.durations = null;
            },
            /*DG.Tweening.Plugins.Options.Vector3ArrayOptions.Reset end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.Vector3ArrayOptions#getHashCode", this ); }

                var h = Bridge.addHash([6859794677, this.axisConstraint, this.snapping, this.durations]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.Vector3ArrayOptions#equals", this ); }

                if (!Bridge.is(o, DG.Tweening.Plugins.Options.Vector3ArrayOptions)) {
                    return false;
                }
                return Bridge.equals(this.axisConstraint, o.axisConstraint) && Bridge.equals(this.snapping, o.snapping) && Bridge.equals(this.durations, o.durations);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.Vector3ArrayOptions#$clone", this ); }

                var s = to || new DG.Tweening.Plugins.Options.Vector3ArrayOptions();
                s.axisConstraint = this.axisConstraint;
                s.snapping = this.snapping;
                s.durations = this.durations;
                return s;
            }
        }
    });
    /*DG.Tweening.Plugins.Options.Vector3ArrayOptions end.*/

    /*DG.Tweening.Plugins.Options.VectorOptions start.*/
    Bridge.define("DG.Tweening.Plugins.Options.VectorOptions", {
        inherits: [DG.Tweening.Plugins.Options.IPlugOptions],
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.VectorOptions#getDefaultValue", this ); }
 return new DG.Tweening.Plugins.Options.VectorOptions(); }
            }
        },
        fields: {
            axisConstraint: 0,
            snapping: false
        },
        alias: ["Reset", "DG$Tweening$Plugins$Options$IPlugOptions$Reset"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.VectorOptions#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*DG.Tweening.Plugins.Options.VectorOptions.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.VectorOptions#Reset", this ); }

                this.axisConstraint = DG.Tweening.AxisConstraint.None;
                this.snapping = false;
            },
            /*DG.Tweening.Plugins.Options.VectorOptions.Reset end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.VectorOptions#getHashCode", this ); }

                var h = Bridge.addHash([5689721260, this.axisConstraint, this.snapping]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.VectorOptions#equals", this ); }

                if (!Bridge.is(o, DG.Tweening.Plugins.Options.VectorOptions)) {
                    return false;
                }
                return Bridge.equals(this.axisConstraint, o.axisConstraint) && Bridge.equals(this.snapping, o.snapping);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.VectorOptions#$clone", this ); }

                var s = to || new DG.Tweening.Plugins.Options.VectorOptions();
                s.axisConstraint = this.axisConstraint;
                s.snapping = this.snapping;
                return s;
            }
        }
    });
    /*DG.Tweening.Plugins.Options.VectorOptions end.*/

    /*DG.Tweening.Plugins.SpiralOptions start.*/
    Bridge.define("DG.Tweening.Plugins.SpiralOptions", {
        inherits: [DG.Tweening.Plugins.Options.IPlugOptions],
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.SpiralOptions#getDefaultValue", this ); }
 return new DG.Tweening.Plugins.SpiralOptions(); }
            }
        },
        fields: {
            depth: 0,
            frequency: 0,
            speed: 0,
            mode: 0,
            snapping: false,
            unit: 0,
            axisQ: null
        },
        alias: ["Reset", "DG$Tweening$Plugins$Options$IPlugOptions$Reset"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.SpiralOptions#init", this ); }

                this.axisQ = new UnityEngine.Quaternion();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.SpiralOptions#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*DG.Tweening.Plugins.SpiralOptions.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.SpiralOptions#Reset", this ); }

                this.depth = (this.frequency = (this.speed = 0.0));
                this.mode = DG.Tweening.SpiralMode.Expand;
                this.snapping = false;
            },
            /*DG.Tweening.Plugins.SpiralOptions.Reset end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.SpiralOptions#getHashCode", this ); }

                var h = Bridge.addHash([5656561307, this.depth, this.frequency, this.speed, this.mode, this.snapping, this.unit, this.axisQ]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.SpiralOptions#equals", this ); }

                if (!Bridge.is(o, DG.Tweening.Plugins.SpiralOptions)) {
                    return false;
                }
                return Bridge.equals(this.depth, o.depth) && Bridge.equals(this.frequency, o.frequency) && Bridge.equals(this.speed, o.speed) && Bridge.equals(this.mode, o.mode) && Bridge.equals(this.snapping, o.snapping) && Bridge.equals(this.unit, o.unit) && Bridge.equals(this.axisQ, o.axisQ);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.SpiralOptions#$clone", this ); }

                var s = to || new DG.Tweening.Plugins.SpiralOptions();
                s.depth = this.depth;
                s.frequency = this.frequency;
                s.speed = this.speed;
                s.mode = this.mode;
                s.snapping = this.snapping;
                s.unit = this.unit;
                s.axisQ = this.axisQ.$clone();
                return s;
            }
        }
    });
    /*DG.Tweening.Plugins.SpiralOptions end.*/

    /*DG.Tweening.Tweener start.*/
    /**
     * Animates a single value
     *
     * @abstract
     * @public
     * @class DG.Tweening.Tweener
     * @augments DG.Tweening.Tween
     */
    Bridge.define("DG.Tweening.Tweener", {
        inherits: [DG.Tweening.Tween],
        statics: {
            methods: {
                /*DG.Tweening.Tweener.Setup:static start.*/
                Setup: function (T1, T2, TPlugOptions, t, getter, setter, endValue, duration, plugin) {
if ( TRACE ) { TRACE( "DG.Tweening.Tweener#Setup", this ); }

                    if (plugin === void 0) { plugin = null; }
                    if (plugin != null) {
                        t.tweenPlugin = plugin;
                    } else {
                        if (t.tweenPlugin == null) {
                            t.tweenPlugin = DG.Tweening.Plugins.Core.PluginsManager.GetDefaultPlugin(T1, T2, TPlugOptions);
                        }

                        if (t.tweenPlugin == null) {
                            // No suitable plugin found. Kill
                            DG.Tweening.Core.Debugger.LogError("No suitable plugin found for this type");
                            return false;
                        }
                    }

                    t.getter = getter;
                    t.setter = setter;
                    t.endValue = Bridge.rValue(endValue);
                    t.duration = duration;
                    // Defaults
                    t.autoKill = DG.Tweening.DOTween.defaultAutoKill;
                    t.isRecyclable = DG.Tweening.DOTween.defaultRecyclable;
                    t.easeType = DG.Tweening.DOTween.defaultEaseType; // Set to INTERNAL_Zero in case of 0 duration, but in DoStartup
                    t.easeOvershootOrAmplitude = DG.Tweening.DOTween.defaultEaseOvershootOrAmplitude;
                    t.easePeriod = DG.Tweening.DOTween.defaultEasePeriod;
                    t.loopType = DG.Tweening.DOTween.defaultLoopType;
                    t.isPlaying = DG.Tweening.DOTween.defaultAutoPlay === DG.Tweening.AutoPlay.All || DG.Tweening.DOTween.defaultAutoPlay === DG.Tweening.AutoPlay.AutoPlayTweeners;
                    return true;
                },
                /*DG.Tweening.Tweener.Setup:static end.*/

                /*DG.Tweening.Tweener.DoUpdateDelay:static start.*/
                DoUpdateDelay: function (T1, T2, TPlugOptions, t, elapsed) {
if ( TRACE ) { TRACE( "DG.Tweening.Tweener#DoUpdateDelay", this ); }

                    var tweenDelay = t.delay;
                    if (elapsed > tweenDelay) {
                        // Delay complete
                        t.elapsedDelay = tweenDelay;
                        t.delayComplete = true;
                        return elapsed - tweenDelay;
                    }

                    t.elapsedDelay = elapsed;
                    return 0;
                },
                /*DG.Tweening.Tweener.DoUpdateDelay:static end.*/

                /*DG.Tweening.Tweener.DoStartup:static start.*/
                DoStartup: function (T1, T2, TPlugOptions, t) {
if ( TRACE ) { TRACE( "DG.Tweening.Tweener#DoStartup", this ); }

                    t.startupDone = true;

                    // Special startup operations
                    if (t.specialStartupMode !== DG.Tweening.Core.Enums.SpecialStartupMode.None) {
                        if (!DG.Tweening.Tweener.DOStartupSpecials(T1, T2, TPlugOptions, t)) {
                            return false;
                        }
                    }

                    if (!t.hasManuallySetStartValue) {
                        // Take start value from current target value
                        if (DG.Tweening.DOTween.useSafeMode) {
                            try {
                                if (t.isFrom) {
                                    // From tween without forced From value and where setImmediately was FALSE
                                    // (contrary to other forms of From tweens its values will be set at startup)
                                    t.SetFrom(t.isRelative && !t.isBlendable);
                                    t.isRelative = false;
                                } else {
                                    t.startValue = Bridge.rValue(t.tweenPlugin.ConvertToStartValue(t, Bridge.rValue(t.getter())));
                                }
                            } catch (e) {
                                e = System.Exception.create(e);
                                if (DG.Tweening.Core.Debugger.ShouldLogSafeModeCapturedError()) {
                                    DG.Tweening.Core.Debugger.LogSafeModeCapturedError(System.String.format("Tween startup failed (NULL target/property - {0}): the tween will now be killed \u25ba {1}", e.TargetSite, e.Message), t);
                                }

                                DG.Tweening.DOTween.safeModeReport.Add(DG.Tweening.Core.SafeModeReport.SafeModeReportType.StartupFailure);
                                return false; // Target/field doesn't exist: kill tween
                            }
                        } else {
                            if (t.isFrom) {
                                // From tween without forced From value and where setImmediately was FALSE
                                // (contrary to other forms of From tweens its values will be set at startup)
                                t.SetFrom(t.isRelative && !t.isBlendable);
                                t.isRelative = false;
                            } else {
                                t.startValue = Bridge.rValue(t.tweenPlugin.ConvertToStartValue(t, Bridge.rValue(t.getter())));
                            }
                        }
                    }

                    if (t.isRelative) {
                        t.tweenPlugin.SetRelativeEndValue(t);
                    }

                    t.tweenPlugin.SetChangeValue(t);

                    // Duration based startup operations
                    DG.Tweening.Tweener.DOStartupDurationBased(T1, T2, TPlugOptions, t);

                    // Applied here so that the eventual duration derived from a speedBased tween has been set
                    if (t.duration <= 0) {
                        t.easeType = DG.Tweening.Ease.INTERNAL_Zero;
                    }

                    return true;
                },
                /*DG.Tweening.Tweener.DoStartup:static end.*/

                /*DG.Tweening.Tweener.DoChangeStartValue:static start.*/
                DoChangeStartValue: function (T1, T2, TPlugOptions, t, newStartValue, newDuration) {
if ( TRACE ) { TRACE( "DG.Tweening.Tweener#DoChangeStartValue", this ); }

                    t.hasManuallySetStartValue = true;
                    t.startValue = Bridge.rValue(newStartValue);

                    if (t.startupDone) {
                        if (t.specialStartupMode !== DG.Tweening.Core.Enums.SpecialStartupMode.None) {
                            if (!DG.Tweening.Tweener.DOStartupSpecials(T1, T2, TPlugOptions, t)) {
                                return null;
                            }
                        }

                        t.tweenPlugin.SetChangeValue(t);
                    }

                    if (newDuration > 0) {
                        t.duration = newDuration;
                        if (t.startupDone) {
                            DG.Tweening.Tweener.DOStartupDurationBased(T1, T2, TPlugOptions, t);
                        }
                    }

                    // Force rewind
                    DG.Tweening.Tween.DoGoto(t, 0, 0, DG.Tweening.Core.Enums.UpdateMode.IgnoreOnUpdate);

                    return t;
                },
                /*DG.Tweening.Tweener.DoChangeStartValue:static end.*/

                /*DG.Tweening.Tweener.DoChangeEndValue:static start.*/
                DoChangeEndValue: function (T1, T2, TPlugOptions, t, newEndValue, newDuration, snapStartValue) {
if ( TRACE ) { TRACE( "DG.Tweening.Tweener#DoChangeEndValue", this ); }

                    t.endValue = Bridge.rValue(newEndValue);
                    t.isRelative = false;

                    if (t.startupDone) {
                        if (t.specialStartupMode !== DG.Tweening.Core.Enums.SpecialStartupMode.None) {
                            if (!DG.Tweening.Tweener.DOStartupSpecials(T1, T2, TPlugOptions, t)) {
                                return null;
                            }
                        }

                        if (snapStartValue) {
                            // Reassign startValue with current target's value
                            if (DG.Tweening.DOTween.useSafeMode) {
                                try {
                                    t.startValue = Bridge.rValue(t.tweenPlugin.ConvertToStartValue(t, Bridge.rValue(t.getter())));
                                } catch (e) {
                                    e = System.Exception.create(e);
                                    // Target/field doesn't exist: kill tween
                                    if (DG.Tweening.Core.Debugger.ShouldLogSafeModeCapturedError()) {
                                        DG.Tweening.Core.Debugger.LogSafeModeCapturedError(System.String.format("Target or field is missing/null ({0}) \u25ba {1}\n\n{2}\n\n", e.TargetSite, e.Message, e.StackTrace), t);
                                    }

                                    DG.Tweening.Core.TweenManager.Despawn(t);
                                    DG.Tweening.DOTween.safeModeReport.Add(DG.Tweening.Core.SafeModeReport.SafeModeReportType.TargetOrFieldMissing);
                                    return null;
                                }
                            } else {
                                t.startValue = Bridge.rValue(t.tweenPlugin.ConvertToStartValue(t, Bridge.rValue(t.getter())));
                            }
                        }

                        t.tweenPlugin.SetChangeValue(t);
                    }

                    if (newDuration > 0) {
                        t.duration = newDuration;
                        if (t.startupDone) {
                            DG.Tweening.Tweener.DOStartupDurationBased(T1, T2, TPlugOptions, t);
                        }
                    }

                    // Force rewind
                    DG.Tweening.Tween.DoGoto(t, 0, 0, DG.Tweening.Core.Enums.UpdateMode.IgnoreOnUpdate);

                    return t;
                },
                /*DG.Tweening.Tweener.DoChangeEndValue:static end.*/

                /*DG.Tweening.Tweener.DoChangeValues:static start.*/
                DoChangeValues: function (T1, T2, TPlugOptions, t, newStartValue, newEndValue, newDuration) {
if ( TRACE ) { TRACE( "DG.Tweening.Tweener#DoChangeValues", this ); }

                    t.hasManuallySetStartValue = true;
                    t.isRelative = (t.isFrom = false);
                    t.startValue = Bridge.rValue(newStartValue);
                    t.endValue = Bridge.rValue(newEndValue);

                    if (t.startupDone) {
                        if (t.specialStartupMode !== DG.Tweening.Core.Enums.SpecialStartupMode.None) {
                            if (!DG.Tweening.Tweener.DOStartupSpecials(T1, T2, TPlugOptions, t)) {
                                return null;
                            }
                        }

                        t.tweenPlugin.SetChangeValue(t);
                    }

                    if (newDuration > 0) {
                        t.duration = newDuration;
                        if (t.startupDone) {
                            DG.Tweening.Tweener.DOStartupDurationBased(T1, T2, TPlugOptions, t);
                        }
                    }

                    // Force rewind
                    DG.Tweening.Tween.DoGoto(t, 0, 0, DG.Tweening.Core.Enums.UpdateMode.IgnoreOnUpdate);

                    return t;
                },
                /*DG.Tweening.Tweener.DoChangeValues:static end.*/

                /*DG.Tweening.Tweener.DOStartupSpecials:static start.*/
                DOStartupSpecials: function (T1, T2, TPlugOptions, t) {
if ( TRACE ) { TRACE( "DG.Tweening.Tweener#DOStartupSpecials", this ); }

                    try {
                        switch (t.specialStartupMode) {
                            case DG.Tweening.Core.Enums.SpecialStartupMode.SetLookAt: 
                                if (!DG.Tweening.Plugins.Core.SpecialPluginsUtils.SetLookAt(Bridge.as(t, DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions)))) {
                                    return false;
                                }
                                break;
                            case DG.Tweening.Core.Enums.SpecialStartupMode.SetPunch: 
                                if (!DG.Tweening.Plugins.Core.SpecialPluginsUtils.SetPunch(Bridge.as(t, DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions)))) {
                                    return false;
                                }
                                break;
                            case DG.Tweening.Core.Enums.SpecialStartupMode.SetShake: 
                                if (!DG.Tweening.Plugins.Core.SpecialPluginsUtils.SetShake(Bridge.as(t, DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions)))) {
                                    return false;
                                }
                                break;
                            case DG.Tweening.Core.Enums.SpecialStartupMode.SetCameraShakePosition: 
                                if (!DG.Tweening.Plugins.Core.SpecialPluginsUtils.SetCameraShakePosition(Bridge.as(t, DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions)))) {
                                    return false;
                                }
                                break;
                        }

                        return true;
                    } catch ($e1) {
                        $e1 = System.Exception.create($e1);
                        // Error in SpecialPluginUtils (usually due to target being destroyed)
                        return false;
                    }
                },
                /*DG.Tweening.Tweener.DOStartupSpecials:static end.*/

                /*DG.Tweening.Tweener.DOStartupDurationBased:static start.*/
                DOStartupDurationBased: function (T1, T2, TPlugOptions, t) {
if ( TRACE ) { TRACE( "DG.Tweening.Tweener#DOStartupDurationBased", this ); }

                    if (t.isSpeedBased) {
                        t.duration = t.tweenPlugin.GetSpeedBasedDuration(Bridge.rValue(t.plugOptions), t.duration, Bridge.rValue(t.changeValue));
                    }

                    t.fullDuration = t.loops > -1 ? t.duration * t.loops : window.Infinity;
                },
                /*DG.Tweening.Tweener.DOStartupDurationBased:static end.*/


            }
        },
        fields: {
            hasManuallySetStartValue: false,
            isFromAllowed: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Tweener#init", this ); }

                this.isFromAllowed = true;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Tweener#ctor", this ); }

                this.$initialize();
                DG.Tweening.Tween.ctor.call(this);
            }
        }
    });
    /*DG.Tweening.Tweener end.*/

    /*DG.Tweening.Plugins.Options.NoOptions start.*/
    Bridge.define("DG.Tweening.Plugins.Options.NoOptions", {
        inherits: [DG.Tweening.Plugins.Options.IPlugOptions],
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.NoOptions#getDefaultValue", this ); }
 return new DG.Tweening.Plugins.Options.NoOptions(); }
            }
        },
        alias: ["Reset", "DG$Tweening$Plugins$Options$IPlugOptions$Reset"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.NoOptions#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*DG.Tweening.Plugins.Options.NoOptions.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.NoOptions#Reset", this ); }
 },
            /*DG.Tweening.Plugins.Options.NoOptions.Reset end.*/

            $clone: function (to) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.NoOptions#$clone", this ); }
 return this; }
        }
    });
    /*DG.Tweening.Plugins.Options.NoOptions end.*/

    /*DG.Tweening.Plugins.CirclePlugin start.*/
    /** @namespace DG.Tweening.Plugins */

    /**
     * Tweens a Vector2 along a circle.
         EndValue represents the center of the circle, start and end value degrees are inside options
         ChangeValue x is changeValue, y is unused
     *
     * @public
     * @class DG.Tweening.Plugins.CirclePlugin
     * @augments DG.Tweening.Plugins.Core.ABSTweenPlugin$3
     */
    Bridge.define("DG.Tweening.Plugins.CirclePlugin", {
        inherits: [DG.Tweening.Plugins.Core.ABSTweenPlugin$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.CircleOptions)],
        statics: {
            methods: {
                /*DG.Tweening.Plugins.CirclePlugin.Get:static start.*/
                Get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.CirclePlugin#Get", this ); }

                    return DG.Tweening.Plugins.Core.PluginsManager.GetCustomPlugin(DG.Tweening.Plugins.CirclePlugin, UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.CircleOptions);
                },
                /*DG.Tweening.Plugins.CirclePlugin.Get:static end.*/


            }
        },
        methods: {
            /*DG.Tweening.Plugins.CirclePlugin.Reset start.*/
            Reset: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.CirclePlugin#Reset", this ); }
 },
            /*DG.Tweening.Plugins.CirclePlugin.Reset end.*/

            /*DG.Tweening.Plugins.CirclePlugin.SetFrom$1 start.*/
            SetFrom$1: function (t, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.CirclePlugin#SetFrom$1", this ); }

                if (!t.plugOptions.initialized) {
                    t.startValue = t.getter().$clone();
                    t.plugOptions.Initialize(t.startValue.$clone(), t.endValue.$clone());
                }

                var prevEndVal = t.plugOptions.endValueDegrees;
                t.plugOptions.endValueDegrees = t.plugOptions.startValueDegrees;
                t.plugOptions.startValueDegrees = isRelative ? t.plugOptions.endValueDegrees + prevEndVal : prevEndVal;
                t.startValue = this.GetPositionOnCircle(t.plugOptions.$clone(), t.plugOptions.startValueDegrees);
                t.setter(t.startValue.$clone());
            },
            /*DG.Tweening.Plugins.CirclePlugin.SetFrom$1 end.*/

            /*DG.Tweening.Plugins.CirclePlugin.SetFrom start.*/
            SetFrom: function (t, fromValue, setImmediately, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.CirclePlugin#SetFrom", this ); }

                if (!t.plugOptions.initialized) {
                    t.startValue = t.getter().$clone();
                    t.plugOptions.Initialize(t.startValue.$clone(), t.endValue.$clone());
                }

                var fromValueDegrees = fromValue.x;
                if (isRelative) {
                    var currVal = t.plugOptions.startValueDegrees;
                    t.plugOptions.endValueDegrees += currVal;
                    fromValueDegrees += currVal;
                }

                t.plugOptions.startValueDegrees = fromValueDegrees;
                t.startValue = this.GetPositionOnCircle(t.plugOptions.$clone(), fromValueDegrees);
                if (setImmediately) {
                    t.setter(t.startValue.$clone());
                }
            },
            /*DG.Tweening.Plugins.CirclePlugin.SetFrom end.*/

            /*DG.Tweening.Plugins.CirclePlugin.ConvertToStartValue start.*/
            ConvertToStartValue: function (t, value) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.CirclePlugin#ConvertToStartValue", this ); }

                return value.$clone();
            },
            /*DG.Tweening.Plugins.CirclePlugin.ConvertToStartValue end.*/

            /*DG.Tweening.Plugins.CirclePlugin.SetRelativeEndValue start.*/
            SetRelativeEndValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.CirclePlugin#SetRelativeEndValue", this ); }

                if (!t.plugOptions.initialized) {
                    t.plugOptions.Initialize(t.startValue.$clone(), t.endValue.$clone());
                }

                t.plugOptions.endValueDegrees += t.plugOptions.startValueDegrees;
            },
            /*DG.Tweening.Plugins.CirclePlugin.SetRelativeEndValue end.*/

            /*DG.Tweening.Plugins.CirclePlugin.SetChangeValue start.*/
            SetChangeValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.CirclePlugin#SetChangeValue", this ); }

                if (!t.plugOptions.initialized) {
                    t.plugOptions.Initialize(t.startValue.$clone(), t.endValue.$clone());
                }

                t.changeValue = new pc.Vec2( t.plugOptions.endValueDegrees - t.plugOptions.startValueDegrees, 0 );
            },
            /*DG.Tweening.Plugins.CirclePlugin.SetChangeValue end.*/

            /*DG.Tweening.Plugins.CirclePlugin.GetSpeedBasedDuration start.*/
            GetSpeedBasedDuration: function (options, unitsXSecond, changeValue) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.CirclePlugin#GetSpeedBasedDuration", this ); }

                return changeValue.x / unitsXSecond;
            },
            /*DG.Tweening.Plugins.CirclePlugin.GetSpeedBasedDuration end.*/

            /*DG.Tweening.Plugins.CirclePlugin.EvaluateAndApply start.*/
            EvaluateAndApply: function (options, t, isRelative, getter, setter, elapsed, startValue, changeValue, duration, usingInversePosition, updateNotice) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.CirclePlugin#EvaluateAndApply", this ); }

                var startValueDegrees = options.startValueDegrees;
                if (t.loopType === DG.Tweening.LoopType.Incremental) {
                    startValueDegrees += changeValue.x * (t.isComplete ? t.completedLoops - 1 : t.completedLoops);
                }

                if (t.isSequenced && t.sequenceParent.loopType === DG.Tweening.LoopType.Incremental) {
                    startValueDegrees += changeValue.x * (t.loopType === DG.Tweening.LoopType.Incremental ? t.loops : 1) * (t.sequenceParent.isComplete ? t.sequenceParent.completedLoops - 1 : t.sequenceParent.completedLoops);
                }

                var easeVal = DG.Tweening.Core.Easing.EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod);
                setter(this.GetPositionOnCircle(options.$clone(), startValueDegrees + changeValue.x * easeVal));
            },
            /*DG.Tweening.Plugins.CirclePlugin.EvaluateAndApply end.*/

            /*DG.Tweening.Plugins.CirclePlugin.GetPositionOnCircle start.*/
            GetPositionOnCircle: function (options, degrees) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.CirclePlugin#GetPositionOnCircle", this ); }

                var pos = DG.Tweening.Core.DOTweenUtils.GetPointOnCircle(options.center.$clone(), options.radius, degrees);
                if (options.snapping) {
                    pos.x = Math.round(pos.x);
                    pos.y = Math.round(pos.y);
                }

                return pos.$clone();
            },
            /*DG.Tweening.Plugins.CirclePlugin.GetPositionOnCircle end.*/


        },
        overloads: {
            "SetFrom(TweenerCore<Vector2, Vector2, CircleOptions>, bool)": "SetFrom$1"
        }
    });
    /*DG.Tweening.Plugins.CirclePlugin end.*/

    /*DG.Tweening.Plugins.Options.ColorOptions start.*/
    Bridge.define("DG.Tweening.Plugins.Options.ColorOptions", {
        inherits: [DG.Tweening.Plugins.Options.IPlugOptions],
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.ColorOptions#getDefaultValue", this ); }
 return new DG.Tweening.Plugins.Options.ColorOptions(); }
            }
        },
        fields: {
            alphaOnly: false
        },
        alias: ["Reset", "DG$Tweening$Plugins$Options$IPlugOptions$Reset"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.ColorOptions#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*DG.Tweening.Plugins.Options.ColorOptions.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.ColorOptions#Reset", this ); }

                this.alphaOnly = false;
            },
            /*DG.Tweening.Plugins.Options.ColorOptions.Reset end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.ColorOptions#getHashCode", this ); }

                var h = Bridge.addHash([5759512094, this.alphaOnly]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.ColorOptions#equals", this ); }

                if (!Bridge.is(o, DG.Tweening.Plugins.Options.ColorOptions)) {
                    return false;
                }
                return Bridge.equals(this.alphaOnly, o.alphaOnly);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.ColorOptions#$clone", this ); }

                var s = to || new DG.Tweening.Plugins.Options.ColorOptions();
                s.alphaOnly = this.alphaOnly;
                return s;
            }
        }
    });
    /*DG.Tweening.Plugins.Options.ColorOptions end.*/

    /*DG.Tweening.Plugins.Options.FloatOptions start.*/
    Bridge.define("DG.Tweening.Plugins.Options.FloatOptions", {
        inherits: [DG.Tweening.Plugins.Options.IPlugOptions],
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.FloatOptions#getDefaultValue", this ); }
 return new DG.Tweening.Plugins.Options.FloatOptions(); }
            }
        },
        fields: {
            snapping: false
        },
        alias: ["Reset", "DG$Tweening$Plugins$Options$IPlugOptions$Reset"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.FloatOptions#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*DG.Tweening.Plugins.Options.FloatOptions.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.FloatOptions#Reset", this ); }

                this.snapping = false;
            },
            /*DG.Tweening.Plugins.Options.FloatOptions.Reset end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.FloatOptions#getHashCode", this ); }

                var h = Bridge.addHash([5524826915, this.snapping]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.FloatOptions#equals", this ); }

                if (!Bridge.is(o, DG.Tweening.Plugins.Options.FloatOptions)) {
                    return false;
                }
                return Bridge.equals(this.snapping, o.snapping);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Options.FloatOptions#$clone", this ); }

                var s = to || new DG.Tweening.Plugins.Options.FloatOptions();
                s.snapping = this.snapping;
                return s;
            }
        }
    });
    /*DG.Tweening.Plugins.Options.FloatOptions end.*/

    /*DG.Tweening.Plugins.PathPlugin start.*/
    /**
     * Path plugin works exclusively with Transforms
     *
     * @public
     * @class DG.Tweening.Plugins.PathPlugin
     * @augments DG.Tweening.Plugins.Core.ABSTweenPlugin$3
     */
    Bridge.define("DG.Tweening.Plugins.PathPlugin", {
        inherits: [DG.Tweening.Plugins.Core.ABSTweenPlugin$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions)],
        statics: {
            fields: {
                MinLookAhead: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.PathPlugin#init", this ); }

                    this.MinLookAhead = 0.0001;
                }
            },
            methods: {
                /*DG.Tweening.Plugins.PathPlugin.Get:static start.*/
                Get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.PathPlugin#Get", this ); }

                    return DG.Tweening.Plugins.Core.PluginsManager.GetCustomPlugin(DG.Tweening.Plugins.PathPlugin, UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions);
                },
                /*DG.Tweening.Plugins.PathPlugin.Get:static end.*/


            }
        },
        methods: {
            /*DG.Tweening.Plugins.PathPlugin.Reset start.*/
            Reset: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.PathPlugin#Reset", this ); }

                t.endValue.Destroy(); // Clear path
                t.startValue = (t.endValue = (t.changeValue = null));
            },
            /*DG.Tweening.Plugins.PathPlugin.Reset end.*/

            /*DG.Tweening.Plugins.PathPlugin.SetFrom$1 start.*/
            SetFrom$1: function (t, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.PathPlugin#SetFrom$1", this ); }
 },
            /*DG.Tweening.Plugins.PathPlugin.SetFrom$1 end.*/

            /*DG.Tweening.Plugins.PathPlugin.SetFrom start.*/
            SetFrom: function (t, fromValue, setImmediately, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.PathPlugin#SetFrom", this ); }
 },
            /*DG.Tweening.Plugins.PathPlugin.SetFrom end.*/

            /*DG.Tweening.Plugins.PathPlugin.ConvertToStartValue start.*/
            ConvertToStartValue: function (t, value) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.PathPlugin#ConvertToStartValue", this ); }

                // Simply sets the same path as start and endValue
                return t.endValue;
            },
            /*DG.Tweening.Plugins.PathPlugin.ConvertToStartValue end.*/

            /*DG.Tweening.Plugins.PathPlugin.SetRelativeEndValue start.*/
            SetRelativeEndValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.PathPlugin#SetRelativeEndValue", this ); }

                var $t, $t1;
                if (t.endValue.isFinalized) {
                    return;
                }

                var startP = t.getter().$clone();
                var count = t.endValue.wps.length;
                for (var i = 0; i < count; ++i) {
                    ($t = t.endValue.wps)[i] = ($t1 = t.endValue.wps)[i].$clone().add( startP.$clone() );
                }
            },
            /*DG.Tweening.Plugins.PathPlugin.SetRelativeEndValue end.*/

            /*DG.Tweening.Plugins.PathPlugin.SetChangeValue start.*/
            SetChangeValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.PathPlugin#SetChangeValue", this ); }

                var go = Bridge.as(t.target, UnityEngine.GameObject);
                var trans = !(UnityEngine.GameObject.op_Equality(go, null)) ? go.transform : Bridge.cast(t.target, UnityEngine.Component).transform;
                // if (t.plugOptions.orientType == OrientType.ToPath && t.plugOptions.useLocalPosition) t.plugOptions.parent = trans.parent;
                if (t.plugOptions.orientType === DG.Tweening.Plugins.Options.OrientType.ToPath) {
                    t.plugOptions.parent = trans.parent;
                }

                if (t.endValue.isFinalized) {
                    t.changeValue = t.endValue;
                    return;
                }

                var currVal = t.getter().$clone();
                var path = t.endValue;
                path.plugOptions = t.plugOptions.$clone();
                var unmodifiedWpsLen = path.wps.length;
                var additionalWps = 0;
                var hasAdditionalStartingP = false, hasAdditionalEndingP = false;

                // Create final wps and add eventual starting/ending waypoints.
                if (unmodifiedWpsLen <= path.minInputWaypoints || !DG.Tweening.Core.DOTweenUtils.Vector3AreApproximatelyEqual(path.wps[0].$clone(), currVal.$clone())) {
                    hasAdditionalStartingP = true;
                    additionalWps += 1;
                }

                if (t.plugOptions.isClosedPath) {
                    var endWp = path.wps[unmodifiedWpsLen - 1].$clone();
                    if (path.type === DG.Tweening.PathType.CubicBezier) {
                        if (unmodifiedWpsLen < 3) {
                            UnityEngine.Debug.LogError$2("CubicBezier paths must contain waypoints in multiple of 3 excluding the starting point added automatically by DOTween (1: waypoint, 2: IN control point, 3: OUT control point \u2014 the minimum amount of waypoints for a single curve is 3)");
                        } else {
                            endWp = path.wps[unmodifiedWpsLen - 3].$clone();
                        }
                    }

                    if (!pc.Vec3.equals( endWp, currVal )) {
                        hasAdditionalEndingP = true;
                        additionalWps += 1;
                    }
                }

                var wpsLen = unmodifiedWpsLen + additionalWps;
                var wps = System.Array.init(wpsLen, function (){
                    return new UnityEngine.Vector3();
                }, UnityEngine.Vector3);
                var indMod = hasAdditionalStartingP ? 1 : 0;
                if (hasAdditionalStartingP) {
                    wps[0] = currVal.$clone();
                }

                for (var i = 0; i < unmodifiedWpsLen; ++i) {
                    wps[i + indMod] = path.wps[i].$clone();
                }

                if (hasAdditionalEndingP) {
                    wps[wps.length - 1] = wps[0].$clone();
                }

                path.wps = wps;

                // Finalize path
                path.addedExtraStartWp = hasAdditionalStartingP;
                path.addedExtraEndWp = hasAdditionalEndingP;
                path.FinalizePath(t.plugOptions.isClosedPath, t.plugOptions.lockPositionAxis, currVal.$clone());

                t.plugOptions.startupRot = trans.rotation.$clone();
                t.plugOptions.startupZRot = trans.eulerAngles.z;

                // Set changeValue as a reference to endValue
                t.changeValue = t.endValue;
            },
            /*DG.Tweening.Plugins.PathPlugin.SetChangeValue end.*/

            /*DG.Tweening.Plugins.PathPlugin.GetSpeedBasedDuration start.*/
            GetSpeedBasedDuration: function (options, unitsXSecond, changeValue) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.PathPlugin#GetSpeedBasedDuration", this ); }

                return changeValue.length / unitsXSecond;
            },
            /*DG.Tweening.Plugins.PathPlugin.GetSpeedBasedDuration end.*/

            /*DG.Tweening.Plugins.PathPlugin.EvaluateAndApply start.*/
            EvaluateAndApply: function (options, t, isRelative, getter, setter, elapsed, startValue, changeValue, duration, usingInversePosition, updateNotice) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.PathPlugin#EvaluateAndApply", this ); }

                if (t.loopType === DG.Tweening.LoopType.Incremental && !options.isClosedPath) {
                    var increment = t.isComplete ? t.completedLoops - 1 : t.completedLoops;
                    if (increment > 0) {
                        changeValue = changeValue.CloneIncremental(increment);
                    }
                }

                var pathPerc = DG.Tweening.Core.Easing.EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod);
                var constantPathPerc = changeValue.ConvertToConstantPathPerc(pathPerc);
                var newPos = changeValue.GetPoint(constantPathPerc);
                changeValue.targetPosition = newPos.$clone(); // Used to draw editor gizmos
                setter(newPos.$clone());

                if (options.mode !== DG.Tweening.PathMode.Ignore && options.orientType !== DG.Tweening.Plugins.Options.OrientType.None) {
                    this.SetOrientation(options.$clone(), t, changeValue, constantPathPerc, newPos.$clone(), updateNotice);
                }

                // Determine if current waypoint changed and eventually dispatch callback
                var isForward = !usingInversePosition;
                if (t.isBackwards) {
                    isForward = !isForward;
                }

                var newWaypointIndex = changeValue.GetWaypointIndexFromPerc(pathPerc, isForward);
                if (newWaypointIndex !== t.miscInt) {
                    var prevWPIndex = t.miscInt;
                    t.miscInt = newWaypointIndex;
                    if (!Bridge.staticEquals(t.onWaypointChange, null)) {
                        // If more than one waypoint changed, dispatch multiple callbacks
                        //                    bool isBackwards = newWaypointIndex < prevWPIndex;
                        var isBackwards = t.isBackwards;
                        if (t.hasLoops && t.loopType === DG.Tweening.LoopType.Yoyo) {
                            isBackwards = !t.isBackwards && t.completedLoops % 2 !== 0 || t.isBackwards && t.completedLoops % 2 === 0;
                        }

                        if (isBackwards) {
                            //                        for (int i = prevWPIndex - 1; i > newWaypointIndex - 1; --i) Tween.OnTweenCallback(t.onWaypointChange, i);
                            for (var i = prevWPIndex - 1; i > newWaypointIndex - 1; --i) {
                                DG.Tweening.Tween.OnTweenCallback$1(System.Int32, t.onWaypointChange, t, i);
                            }
                        } else {
                            //                        for (int i = prevWPIndex + 1; i < newWaypointIndex + 1; ++i) Tween.OnTweenCallback(t.onWaypointChange, i);
                            for (var i1 = prevWPIndex + 1; i1 < newWaypointIndex; ++i1) {
                                DG.Tweening.Tween.OnTweenCallback$1(System.Int32, t.onWaypointChange, t, i1);
                            }
                        }

                        DG.Tweening.Tween.OnTweenCallback$1(System.Int32, t.onWaypointChange, t, newWaypointIndex);
                    }
                }
            },
            /*DG.Tweening.Plugins.PathPlugin.EvaluateAndApply end.*/

            /*DG.Tweening.Plugins.PathPlugin.SetOrientation start.*/
            SetOrientation: function (options, t, path, pathPerc, tPos, updateNotice) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.PathPlugin#SetOrientation", this ); }

                var go = Bridge.as(t.target, UnityEngine.GameObject);
                var trans = !(UnityEngine.GameObject.op_Equality(go, null)) ? go.transform : Bridge.cast(t.target, UnityEngine.Component).transform;
                var newRot = pc.Quat.IDENTITY.clone();
                var transP = trans.position.$clone();

                if (updateNotice === DG.Tweening.Core.Enums.UpdateNotice.RewindStep) {
                    // Reset orientation before continuing
                    trans.rotation = options.startupRot.$clone();
                }

                switch (options.orientType) {
                    case DG.Tweening.Plugins.Options.OrientType.LookAtPosition: 
                        path.lookAtPosition = options.lookAtPosition.$clone(); // Used to draw editor gizmos
                        //                newRot = Quaternion.LookRotation(options.lookAtPosition - transP, trans.up);
                        newRot = new pc.Quat().setLookAt( options.lookAtPosition.$clone().sub( transP ), options.stableZRotation ? pc.Vec3.UP.clone() : trans.up.$clone() );
                        break;
                    case DG.Tweening.Plugins.Options.OrientType.LookAtTransform: 
                        if (UnityEngine.Component.op_Inequality(options.lookAtTransform, null)) {
                            path.lookAtPosition = options.lookAtTransform.position.$clone(); // Used to draw editor gizmos
                            //                    newRot = Quaternion.LookRotation(options.lookAtTransform.position - transP, trans.up);
                            newRot = new pc.Quat().setLookAt( options.lookAtTransform.position.$clone().sub( transP ), options.stableZRotation ? pc.Vec3.UP.clone() : trans.up.$clone() );
                        }
                        break;
                    case DG.Tweening.Plugins.Options.OrientType.ToPath: 
                        var lookAtP = new UnityEngine.Vector3();
                        if (path.type === DG.Tweening.PathType.Linear && options.lookAhead <= DG.Tweening.Plugins.PathPlugin.MinLookAhead) {
                            // Calculate lookAhead so that it doesn't turn until it starts moving on next waypoint
                            lookAtP = tPos.$clone().add( path.wps[path.linearWPIndex] ).sub( path.wps[path.linearWPIndex - 1] );
                        } else {
                            var lookAheadPerc = pathPerc + options.lookAhead;
                            if (lookAheadPerc > 1) {
                                lookAheadPerc = options.isClosedPath ? lookAheadPerc - 1 : path.type === DG.Tweening.PathType.Linear ? 1 : 1.00001;
                            }

                            lookAtP = path.GetPoint(lookAheadPerc);
                        }
                        if (path.type === DG.Tweening.PathType.Linear) {
                            // Check if it's the last waypoint, and keep correct direction
                            var lastWp = path.wps[path.wps.length - 1].$clone();
                            if (pc.Vec3.equals( lookAtP, lastWp )) {
                                lookAtP = pc.Vec3.equals( tPos, lastWp ) ? lastWp.$clone().add( (lastWp.$clone().sub( path.wps[path.wps.length - 2] )) ) : lastWp.$clone();
                            }
                        }
                        var transUp = trans.up.$clone();
                        // Apply basic modification for local position movement
                        var hasParent = UnityEngine.Component.op_Inequality(options.parent, null);
                        var hasLocalPositionAndParent = options.useLocalPosition && hasParent;
                        if (hasLocalPositionAndParent) {
                            lookAtP = options.parent.TransformPoint$1(lookAtP);
                        }
                        // LookAt axis constraint
                        if (options.lockRotationAxis !== DG.Tweening.AxisConstraint.None) {
                            if ((options.lockRotationAxis & DG.Tweening.AxisConstraint.X) === DG.Tweening.AxisConstraint.X) {
                                var v0 = trans.InverseTransformPoint(lookAtP);
                                v0.y = 0;
                                lookAtP = trans.TransformPoint$1(v0);
                                transUp = hasLocalPositionAndParent ? options.parent.up.$clone() : pc.Vec3.UP.clone();
                            }

                            if ((options.lockRotationAxis & DG.Tweening.AxisConstraint.Y) === DG.Tweening.AxisConstraint.Y) {
                                var v01 = trans.InverseTransformPoint(lookAtP);
                                if (v01.z < 0) {
                                    v01.z = -v01.z;
                                }

                                v01.x = 0;
                                lookAtP = trans.TransformPoint$1(v01);
                            }

                            if ((options.lockRotationAxis & DG.Tweening.AxisConstraint.Z) === DG.Tweening.AxisConstraint.Z) {
                                // Fix to allow racing loops to keep cars straight and not flip it
                                if (hasLocalPositionAndParent) {
                                    transUp = options.parent.TransformDirection$1(pc.Vec3.UP.clone());
                                } else {
                                    transUp = trans.TransformDirection$1(pc.Vec3.UP.clone());
                                }

                                transUp.z = options.startupZRot;
                            }
                        }
                        if (options.mode === DG.Tweening.PathMode.Full3D) {
                            // 3D path
                            var diff = lookAtP.$clone().sub( transP );
                            if (pc.Vec3.equals( diff, pc.Vec3.ZERO.clone() )) {
                                diff = trans.forward.$clone();
                            }

                            if (hasParent) {
                                // Adapt diff to parent scale, fixes problems with non-uniform parent scale
                                diff = this.DivideVectorByVector(diff.$clone(), options.parent.localScale.$clone());
                            }

                            newRot = new pc.Quat().setLookAt( diff, transUp );
                        } else {
                            // 2D path
                            if (hasParent) {
                                // Adapt diff to parent scale, fixes problems with non-uniform parent scale
                                var diffScaled = this.DivideVectorByVector(lookAtP.$clone().sub( transP ), options.parent.localScale.$clone());
                                lookAtP = transP.$clone().add( diffScaled );
                            }

                            var rotY = 0;
                            var rotZ = DG.Tweening.Core.DOTweenUtils.Angle2D(transP.$clone(), lookAtP.$clone());
                            if (rotZ < 0) {
                                rotZ = 360 + rotZ;
                            }

                            if (options.mode === DG.Tweening.PathMode.Sidescroller2D) {
                                // Manage Y and modified Z rotation
                                rotY = lookAtP.x < transP.x ? 180 : 0;
                                if (rotZ > 90 && rotZ < 270) {
                                    rotZ = 180 - rotZ;
                                }
                            }

                            newRot = new pc.Quat().setFromEulerAngles_Unity( 0, rotY, rotZ );
                        }
                        break;
                }

                if (options.hasCustomForwardDirection) {
                    newRot = newRot.$clone().clone().mul( options.forward.$clone() );
                }

                DG.Tweening.Core.DOTweenExternalCommand.Dispatch_SetOrientationOnPath(options.$clone(), t, newRot.$clone(), trans);
                //#if RIGIDBODY
                //            if (options.isRigidbody) ((Rigidbody)t.target).rotation = newRot;
                //            else trans.rotation = newRot;
                //#else
                //            trans.rotation = newRot;
                //#endif
            },
            /*DG.Tweening.Plugins.PathPlugin.SetOrientation end.*/

            /*DG.Tweening.Plugins.PathPlugin.DivideVectorByVector start.*/
            DivideVectorByVector: function (vector, byVector) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.PathPlugin#DivideVectorByVector", this ); }

                return new pc.Vec3( vector.x / byVector.x, vector.y / byVector.y, vector.z / byVector.z );
            },
            /*DG.Tweening.Plugins.PathPlugin.DivideVectorByVector end.*/

            /*DG.Tweening.Plugins.PathPlugin.MultiplyVectorByVector start.*/
            MultiplyVectorByVector: function (vector, byVector) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.PathPlugin#MultiplyVectorByVector", this ); }

                return new pc.Vec3( vector.x * byVector.x, vector.y * byVector.y, vector.z * byVector.z );
            },
            /*DG.Tweening.Plugins.PathPlugin.MultiplyVectorByVector end.*/


        },
        overloads: {
            "SetFrom(TweenerCore<Vector3, Path, PathOptions>, bool)": "SetFrom$1"
        }
    });
    /*DG.Tweening.Plugins.PathPlugin end.*/

    /*DG.Tweening.Plugins.QuaternionPlugin start.*/
    Bridge.define("DG.Tweening.Plugins.QuaternionPlugin", {
        inherits: [DG.Tweening.Plugins.Core.ABSTweenPlugin$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions)],
        methods: {
            /*DG.Tweening.Plugins.QuaternionPlugin.Reset start.*/
            Reset: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.QuaternionPlugin#Reset", this ); }
 },
            /*DG.Tweening.Plugins.QuaternionPlugin.Reset end.*/

            /*DG.Tweening.Plugins.QuaternionPlugin.SetFrom$1 start.*/
            SetFrom$1: function (t, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.QuaternionPlugin#SetFrom$1", this ); }

                var prevEndVal = t.endValue.$clone();
                t.endValue = t.getter().getPositiveEulerAngles().$clone();
                if (t.plugOptions.rotateMode === DG.Tweening.RotateMode.Fast && !t.isRelative) {
                    t.startValue = this.GetEulerValForCalculations(t, prevEndVal.$clone(), t.endValue.$clone());
                } else if (t.plugOptions.rotateMode === DG.Tweening.RotateMode.FastBeyond360) {
                    // t.startValue = t.endValue + prevEndVal;
                    t.startValue = this.GetEulerValForCalculations(t, t.endValue.$clone().add( prevEndVal ), t.endValue.$clone());
                } else {
                    var rot = t.getter().$clone();
                    if (t.plugOptions.rotateMode === DG.Tweening.RotateMode.WorldAxisAdd) {
                        t.startValue = (rot.clone().mul( rot.clone().invert() ).clone().mul( new pc.Quat().setFromEulerAngles_Unity( prevEndVal.x, prevEndVal.y, prevEndVal.z ) ).clone().mul( rot )).getPositiveEulerAngles().$clone();
                    } else {
                        t.startValue = (rot.clone().mul( new pc.Quat().setFromEulerAngles_Unity( prevEndVal.x, prevEndVal.y, prevEndVal.z ) )).getPositiveEulerAngles().$clone();
                    }

                    t.endValue = prevEndVal.$clone().scale( -1 );
                }

                t.setter(new pc.Quat().setFromEulerAngles_Unity( t.startValue.x, t.startValue.y, t.startValue.z ));
            },
            /*DG.Tweening.Plugins.QuaternionPlugin.SetFrom$1 end.*/

            /*DG.Tweening.Plugins.QuaternionPlugin.SetFrom start.*/
            SetFrom: function (t, fromValue, setImmediately, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.QuaternionPlugin#SetFrom", this ); }

                if (isRelative) {
                    var currVal = t.getter().getPositiveEulerAngles().$clone();
                    t.endValue = t.endValue.$clone().add( currVal.$clone() );
                    fromValue = fromValue.$clone().add( currVal.$clone() );
                }

                // t.startValue = fromValue;
                t.startValue = this.GetEulerValForCalculations(t, fromValue.$clone(), t.endValue.$clone());
                if (setImmediately) {
                    t.setter(new pc.Quat().setFromEulerAngles_Unity( fromValue.x, fromValue.y, fromValue.z ));
                }
            },
            /*DG.Tweening.Plugins.QuaternionPlugin.SetFrom end.*/

            /*DG.Tweening.Plugins.QuaternionPlugin.ConvertToStartValue start.*/
            ConvertToStartValue: function (t, value) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.QuaternionPlugin#ConvertToStartValue", this ); }

                return value.getPositiveEulerAngles().$clone();
            },
            /*DG.Tweening.Plugins.QuaternionPlugin.ConvertToStartValue end.*/

            /*DG.Tweening.Plugins.QuaternionPlugin.SetRelativeEndValue start.*/
            SetRelativeEndValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.QuaternionPlugin#SetRelativeEndValue", this ); }

                t.endValue = t.endValue.$clone().add( t.startValue.$clone() );
            },
            /*DG.Tweening.Plugins.QuaternionPlugin.SetRelativeEndValue end.*/

            /*DG.Tweening.Plugins.QuaternionPlugin.SetChangeValue start.*/
            SetChangeValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.QuaternionPlugin#SetChangeValue", this ); }

                // Vector3 endVal = GetEndValForCalculations(t);
                // If FROM don't use conversions method becuse it's already been used when assigning From values
                var endVal = t.isFrom ? t.endValue.$clone() : this.GetEulerValForCalculations(t, t.endValue.$clone(), t.startValue.$clone());
                var startVal = t.startValue.$clone();

                if (t.plugOptions.rotateMode === DG.Tweening.RotateMode.Fast && !t.isRelative) {
                    // Rotation will be adapted to 360 and will take the shortest route
                    // - Adapt to 360
                    // Vector3 ev = t.endValue;
                    if (endVal.x > 360 || endVal.x < 360) {
                        endVal.x = endVal.x % 360;
                    }

                    if (endVal.y > 360 || endVal.y < 360) {
                        endVal.y = endVal.y % 360;
                    }

                    if (endVal.z > 360 || endVal.z < 360) {
                        endVal.z = endVal.z % 360;
                    }

                    var changeVal = endVal.$clone().sub( startVal );
                    // - Find shortest rotation
                    var abs = changeVal.x > 0 ? changeVal.x : -changeVal.x;
                    if (abs > 180) {
                        changeVal.x = changeVal.x > 0 ? -(360 - abs) : 360 - abs;
                    }

                    abs = changeVal.y > 0 ? changeVal.y : -changeVal.y;
                    if (abs > 180) {
                        changeVal.y = changeVal.y > 0 ? -(360 - abs) : 360 - abs;
                    }

                    abs = changeVal.z > 0 ? changeVal.z : -changeVal.z;
                    if (abs > 180) {
                        changeVal.z = changeVal.z > 0 ? -(360 - abs) : 360 - abs;
                    }

                    // - Assign
                    t.changeValue = changeVal.$clone();
                } else if (t.plugOptions.rotateMode === DG.Tweening.RotateMode.FastBeyond360 || t.isRelative) {
                    t.changeValue = endVal.$clone().sub( startVal );
                } else {
                    t.changeValue = endVal.$clone();
                }

                // Debug.Log(" " + t.startValue + "  " + t.endValue);
                // Debug.Log(t.startValue + "/" + startVal + " - " + t.endValue + "/" + endVal + "  " + t.changeValue);
                // Debug.Log("    " + Quaternion.Euler(t.startValue).eulerAngles + " - " + Quaternion.Euler(t.endValue).eulerAngles + "  " + Quaternion.Euler(t.changeValue).eulerAngles);
            },
            /*DG.Tweening.Plugins.QuaternionPlugin.SetChangeValue end.*/

            /*DG.Tweening.Plugins.QuaternionPlugin.GetSpeedBasedDuration start.*/
            GetSpeedBasedDuration: function (options, unitsXSecond, changeValue) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.QuaternionPlugin#GetSpeedBasedDuration", this ); }

                return changeValue.length() / unitsXSecond;
            },
            /*DG.Tweening.Plugins.QuaternionPlugin.GetSpeedBasedDuration end.*/

            /*DG.Tweening.Plugins.QuaternionPlugin.EvaluateAndApply start.*/
            EvaluateAndApply: function (options, t, isRelative, getter, setter, elapsed, startValue, changeValue, duration, usingInversePosition, updateNotice) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.QuaternionPlugin#EvaluateAndApply", this ); }

                if (options.dynamicLookAt) {
                    var tweener = Bridge.cast(t, DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions));
                    tweener.endValue = options.dynamicLookAtWorldPosition.$clone();
                    DG.Tweening.Plugins.Core.SpecialPluginsUtils.SetLookAt(tweener);
                    this.SetChangeValue(tweener);
                    changeValue = tweener.changeValue.$clone();
                }

                var endValue = startValue.$clone();

                if (t.loopType === DG.Tweening.LoopType.Incremental) {
                    endValue = endValue.$clone().add( changeValue.$clone().clone().scale( (t.isComplete ? t.completedLoops - 1 : t.completedLoops) ) );
                }

                if (t.isSequenced && t.sequenceParent.loopType === DG.Tweening.LoopType.Incremental) {
                    endValue = endValue.$clone().add( changeValue.$clone().clone().scale( (t.loopType === DG.Tweening.LoopType.Incremental ? t.loops : 1) ).clone().scale( (t.sequenceParent.isComplete ? t.sequenceParent.completedLoops - 1 : t.sequenceParent.completedLoops) ) );
                }

                var easeVal = DG.Tweening.Core.Easing.EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod);
                switch (options.rotateMode) {
                    case DG.Tweening.RotateMode.WorldAxisAdd: 
                    case DG.Tweening.RotateMode.LocalAxisAdd: 
                        var startRot = new pc.Quat().setFromEulerAngles_Unity( startValue.x, startValue.y, startValue.z ); // Reset rotation
                        endValue.x = changeValue.x * easeVal;
                        endValue.y = changeValue.y * easeVal;
                        endValue.z = changeValue.z * easeVal;
                        if (options.rotateMode === DG.Tweening.RotateMode.WorldAxisAdd) {
                            setter(startRot.clone().mul( startRot.clone().invert() ).clone().mul( new pc.Quat().setFromEulerAngles_Unity( endValue.x, endValue.y, endValue.z ) ).clone().mul( startRot ));
                        } else {
                            setter(startRot.clone().mul( new pc.Quat().setFromEulerAngles_Unity( endValue.x, endValue.y, endValue.z ) ));
                        }
                        break;
                    default: 
                        endValue.x += changeValue.x * easeVal;
                        endValue.y += changeValue.y * easeVal;
                        endValue.z += changeValue.z * easeVal;
                        setter(new pc.Quat().setFromEulerAngles_Unity( endValue.x, endValue.y, endValue.z ));
                        break;
                }
            },
            /*DG.Tweening.Plugins.QuaternionPlugin.EvaluateAndApply end.*/

            /*DG.Tweening.Plugins.QuaternionPlugin.GetEulerValForCalculations start.*/
            GetEulerValForCalculations: function (t, val, counterVal) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.QuaternionPlugin#GetEulerValForCalculations", this ); }

                // return val;
                if (t.isRelative) {
                    return val.$clone();
                }
                // if (t.isFrom) return val; // Caller decides if this should be ignored or not
                // if (t.plugOptions.rotateMode != RotateMode.Fast) return val;

                var valFlipped = this.FlipEulerAngles(val.$clone());

                var xVsNormalSame = UnityEngine.Mathf.Approximately(counterVal.x, val.x);
                var xVsFlippedSame = UnityEngine.Mathf.Approximately(counterVal.x, valFlipped.x);
                var yVsNormalSame = UnityEngine.Mathf.Approximately(counterVal.y, val.y);
                var yVsFlippedSame = UnityEngine.Mathf.Approximately(counterVal.y, valFlipped.y);
                var zVsNormalSame = UnityEngine.Mathf.Approximately(counterVal.z, val.z);
                var zVsFlippedSame = UnityEngine.Mathf.Approximately(counterVal.z, valFlipped.z);

                var isSingleAxisRotationNormal = xVsNormalSame && (yVsNormalSame || zVsNormalSame) || yVsNormalSame && zVsNormalSame;
                var isSingleAxisRotationFlipped = !isSingleAxisRotationNormal && xVsFlippedSame && (yVsFlippedSame || zVsFlippedSame) || yVsFlippedSame && zVsFlippedSame;

                // Debug.Log(counterVal + " - " + val + " / " + valFlipped + "  isSingleAxisNormal: " + isSingleAxisRotationNormal + " / isSingleAxisFlipped: " + isSingleAxisRotationFlipped);
                if (!isSingleAxisRotationNormal && !isSingleAxisRotationFlipped) {
                    return val.$clone();
                }

                // Debug.Log(" Single Axis Rotation");
                var axisToRotate = 0;
                if (isSingleAxisRotationNormal) {
                    axisToRotate = xVsNormalSame ? yVsNormalSame ? 2 : 1 : 0;
                } else {
                    axisToRotate = xVsFlippedSame ? yVsFlippedSame ? 2 : 1 : 0;
                }

                var flip = false;
                switch (axisToRotate) {
                    case 0:  // X
                        flip = !UnityEngine.Mathf.Approximately(counterVal.y, val.y) || !UnityEngine.Mathf.Approximately(counterVal.z, val.z);
                        break;
                    case 1:  // Y
                        flip = !UnityEngine.Mathf.Approximately(counterVal.x, val.x) || !UnityEngine.Mathf.Approximately(counterVal.z, val.z);
                        break;
                    case 2:  // Z
                        flip = !UnityEngine.Mathf.Approximately(counterVal.x, val.x) || !UnityEngine.Mathf.Approximately(counterVal.y, val.y);
                        break;
                }

                // Debug.Log("   val: " + val + " / counterVal: " + counterVal + " / valFlipped: " + valFlipped);
                // Debug.Log("   axisToRotate: " + axisToRotate + " / yVsNormalSame: " + yVsNormalSame + "/ yVsFlippedSame: " + yVsFlippedSame + " / flip: " + flip);
                // if (flip) Debug.Log("     FLIPPED " + val + " to " + valFlipped);
                return flip ? valFlipped.$clone() : val.$clone();
            },
            /*DG.Tweening.Plugins.QuaternionPlugin.GetEulerValForCalculations end.*/

            /*DG.Tweening.Plugins.QuaternionPlugin.FlipEulerAngles start.*/
            FlipEulerAngles: function (euler) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.QuaternionPlugin#FlipEulerAngles", this ); }

                return new pc.Vec3( 180 - euler.x, euler.y + 180, euler.z + 180 );
            },
            /*DG.Tweening.Plugins.QuaternionPlugin.FlipEulerAngles end.*/


        },
        overloads: {
            "SetFrom(TweenerCore<Quaternion, Vector3, QuaternionOptions>, bool)": "SetFrom$1"
        }
    });
    /*DG.Tweening.Plugins.QuaternionPlugin end.*/

    /*DG.Tweening.Plugins.RectPlugin start.*/
    Bridge.define("DG.Tweening.Plugins.RectPlugin", {
        inherits: [DG.Tweening.Plugins.Core.ABSTweenPlugin$3(UnityEngine.Rect,UnityEngine.Rect,DG.Tweening.Plugins.Options.RectOptions)],
        methods: {
            /*DG.Tweening.Plugins.RectPlugin.Reset start.*/
            Reset: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.RectPlugin#Reset", this ); }
 },
            /*DG.Tweening.Plugins.RectPlugin.Reset end.*/

            /*DG.Tweening.Plugins.RectPlugin.SetFrom$1 start.*/
            SetFrom$1: function (t, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.RectPlugin#SetFrom$1", this ); }

                var prevEndVal = t.endValue.$clone();
                t.endValue = t.getter().$clone();
                t.startValue = prevEndVal.$clone();
                if (isRelative) {
                    t.startValue.x += t.endValue.x;
                    t.startValue.y += t.endValue.y;
                    t.startValue.width += t.endValue.width;
                    t.startValue.height += t.endValue.height;
                }

                var to = t.startValue.$clone();
                if (t.plugOptions.snapping) {
                    to.x = Bridge.Math.round(to.x, 0, 6);
                    to.y = Bridge.Math.round(to.y, 0, 6);
                    to.width = Bridge.Math.round(to.width, 0, 6);
                    to.height = Bridge.Math.round(to.height, 0, 6);
                }

                t.setter(to.$clone());
            },
            /*DG.Tweening.Plugins.RectPlugin.SetFrom$1 end.*/

            /*DG.Tweening.Plugins.RectPlugin.SetFrom start.*/
            SetFrom: function (t, fromValue, setImmediately, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.RectPlugin#SetFrom", this ); }

                if (isRelative) {
                    var currVal = t.getter().$clone();
                    t.endValue.x += currVal.x;
                    t.endValue.y += currVal.y;
                    t.endValue.width += currVal.width;
                    t.endValue.height += currVal.height;
                    fromValue.x += currVal.x;
                    fromValue.y += currVal.y;
                    fromValue.width += currVal.width;
                    fromValue.height += currVal.height;
                }

                t.startValue = fromValue.$clone();
                if (setImmediately) {
                    var to = fromValue.$clone();
                    if (t.plugOptions.snapping) {
                        to.x = Bridge.Math.round(to.x, 0, 6);
                        to.y = Bridge.Math.round(to.y, 0, 6);
                        to.width = Bridge.Math.round(to.width, 0, 6);
                        to.height = Bridge.Math.round(to.height, 0, 6);
                    }

                    t.setter(to.$clone());
                }
            },
            /*DG.Tweening.Plugins.RectPlugin.SetFrom end.*/

            /*DG.Tweening.Plugins.RectPlugin.ConvertToStartValue start.*/
            ConvertToStartValue: function (t, value) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.RectPlugin#ConvertToStartValue", this ); }

                return value.$clone();
            },
            /*DG.Tweening.Plugins.RectPlugin.ConvertToStartValue end.*/

            /*DG.Tweening.Plugins.RectPlugin.SetRelativeEndValue start.*/
            SetRelativeEndValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.RectPlugin#SetRelativeEndValue", this ); }

                t.endValue.x += t.startValue.x;
                t.endValue.y += t.startValue.y;
                t.endValue.width += t.startValue.width;
                t.endValue.height += t.startValue.height;
            },
            /*DG.Tweening.Plugins.RectPlugin.SetRelativeEndValue end.*/

            /*DG.Tweening.Plugins.RectPlugin.SetChangeValue start.*/
            SetChangeValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.RectPlugin#SetChangeValue", this ); }

                t.changeValue = new UnityEngine.Rect.$ctor1(t.endValue.x - t.startValue.x, t.endValue.y - t.startValue.y, t.endValue.width - t.startValue.width, t.endValue.height - t.startValue.height);
            },
            /*DG.Tweening.Plugins.RectPlugin.SetChangeValue end.*/

            /*DG.Tweening.Plugins.RectPlugin.GetSpeedBasedDuration start.*/
            GetSpeedBasedDuration: function (options, unitsXSecond, changeValue) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.RectPlugin#GetSpeedBasedDuration", this ); }

                // Uses length of diagonal to calculate units.
                var diffW = changeValue.width;
                var diffH = changeValue.height;
                var diag = Math.sqrt(diffW * diffW + diffH * diffH);
                return diag / unitsXSecond;
            },
            /*DG.Tweening.Plugins.RectPlugin.GetSpeedBasedDuration end.*/

            /*DG.Tweening.Plugins.RectPlugin.EvaluateAndApply start.*/
            EvaluateAndApply: function (options, t, isRelative, getter, setter, elapsed, startValue, changeValue, duration, usingInversePosition, updateNotice) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.RectPlugin#EvaluateAndApply", this ); }

                if (t.loopType === DG.Tweening.LoopType.Incremental) {
                    var iterations = t.isComplete ? t.completedLoops - 1 : t.completedLoops;
                    startValue.x += changeValue.x * iterations;
                    startValue.y += changeValue.y * iterations;
                    startValue.width += changeValue.width * iterations;
                    startValue.height += changeValue.height * iterations;
                }

                if (t.isSequenced && t.sequenceParent.loopType === DG.Tweening.LoopType.Incremental) {
                    var iterations1 = (t.loopType === DG.Tweening.LoopType.Incremental ? t.loops : 1) * (t.sequenceParent.isComplete ? t.sequenceParent.completedLoops - 1 : t.sequenceParent.completedLoops);
                    startValue.x += changeValue.x * iterations1;
                    startValue.y += changeValue.y * iterations1;
                    startValue.width += changeValue.width * iterations1;
                    startValue.height += changeValue.height * iterations1;
                }

                var easeVal = DG.Tweening.Core.Easing.EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod);
                startValue.x += changeValue.x * easeVal;
                startValue.y += changeValue.y * easeVal;
                startValue.width += changeValue.width * easeVal;
                startValue.height += changeValue.height * easeVal;
                if (options.snapping) {
                    startValue.x = Bridge.Math.round(startValue.x, 0, 6);
                    startValue.y = Bridge.Math.round(startValue.y, 0, 6);
                    startValue.width = Bridge.Math.round(startValue.width, 0, 6);
                    startValue.height = Bridge.Math.round(startValue.height, 0, 6);
                }

                setter(startValue.$clone());
            },
            /*DG.Tweening.Plugins.RectPlugin.EvaluateAndApply end.*/


        },
        overloads: {
            "SetFrom(TweenerCore<Rect, Rect, RectOptions>, bool)": "SetFrom$1"
        }
    });
    /*DG.Tweening.Plugins.RectPlugin end.*/

    /*DG.Tweening.Plugins.SpiralPlugin start.*/
    /**
     * Tweens a Vector3 along a spiral.
         EndValue represents the direction of the spiral
     *
     * @public
     * @class DG.Tweening.Plugins.SpiralPlugin
     * @augments DG.Tweening.Plugins.Core.ABSTweenPlugin$3
     */
    Bridge.define("DG.Tweening.Plugins.SpiralPlugin", {
        inherits: [DG.Tweening.Plugins.Core.ABSTweenPlugin$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.SpiralOptions)],
        statics: {
            fields: {
                DefaultDirection: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.SpiralPlugin#init", this ); }

                    this.DefaultDirection = new UnityEngine.Vector3();
                    this.DefaultDirection = new pc.Vec3( 0, 0, 1 );
                }
            },
            methods: {
                /*DG.Tweening.Plugins.SpiralPlugin.Get:static start.*/
                Get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.SpiralPlugin#Get", this ); }

                    return DG.Tweening.Plugins.Core.PluginsManager.GetCustomPlugin(DG.Tweening.Plugins.SpiralPlugin, UnityEngine.Vector3, UnityEngine.Vector3, DG.Tweening.Plugins.SpiralOptions);
                },
                /*DG.Tweening.Plugins.SpiralPlugin.Get:static end.*/


            }
        },
        methods: {
            /*DG.Tweening.Plugins.SpiralPlugin.Reset start.*/
            Reset: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.SpiralPlugin#Reset", this ); }
 },
            /*DG.Tweening.Plugins.SpiralPlugin.Reset end.*/

            /*DG.Tweening.Plugins.SpiralPlugin.SetFrom$1 start.*/
            SetFrom$1: function (t, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.SpiralPlugin#SetFrom$1", this ); }
 },
            /*DG.Tweening.Plugins.SpiralPlugin.SetFrom$1 end.*/

            /*DG.Tweening.Plugins.SpiralPlugin.SetFrom start.*/
            SetFrom: function (t, fromValue, setImmediately, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.SpiralPlugin#SetFrom", this ); }
 },
            /*DG.Tweening.Plugins.SpiralPlugin.SetFrom end.*/

            /*DG.Tweening.Plugins.SpiralPlugin.ConvertToStartValue start.*/
            ConvertToStartValue: function (t, value) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.SpiralPlugin#ConvertToStartValue", this ); }

                return value.$clone();
            },
            /*DG.Tweening.Plugins.SpiralPlugin.ConvertToStartValue end.*/

            /*DG.Tweening.Plugins.SpiralPlugin.SetRelativeEndValue start.*/
            SetRelativeEndValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.SpiralPlugin#SetRelativeEndValue", this ); }
 },
            /*DG.Tweening.Plugins.SpiralPlugin.SetRelativeEndValue end.*/

            /*DG.Tweening.Plugins.SpiralPlugin.SetChangeValue start.*/
            SetChangeValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.SpiralPlugin#SetChangeValue", this ); }

                t.plugOptions.speed *= 10.0 / t.plugOptions.frequency;
                t.plugOptions.axisQ = new pc.Quat().setLookAt( t.endValue, pc.Vec3.UP.clone() );
            },
            /*DG.Tweening.Plugins.SpiralPlugin.SetChangeValue end.*/

            /*DG.Tweening.Plugins.SpiralPlugin.GetSpeedBasedDuration start.*/
            GetSpeedBasedDuration: function (options, unitsXSecond, changeValue) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.SpiralPlugin#GetSpeedBasedDuration", this ); }

                return unitsXSecond;
            },
            /*DG.Tweening.Plugins.SpiralPlugin.GetSpeedBasedDuration end.*/

            /*DG.Tweening.Plugins.SpiralPlugin.EvaluateAndApply start.*/
            EvaluateAndApply: function (options, t, isRelative, getter, setter, elapsed, startValue, changeValue, duration, usingInversePosition, updateNotice) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.SpiralPlugin#EvaluateAndApply", this ); }

                var num1 = DG.Tweening.Core.Easing.EaseManager.Evaluate$1(t, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod);
                var num2 = options.mode !== DG.Tweening.SpiralMode.ExpandThenContract || num1 <= 0.5 ? num1 : 0.5 - (num1 - 0.5);
                if (t.loopType === DG.Tweening.LoopType.Incremental) {
                    num1 += t.isComplete ? t.completedLoops - 1 : t.completedLoops;
                }

                var num3 = duration * options.speed * num1;
                options.unit = duration * options.speed * num2;
                var pNewValue = new pc.Vec3( options.unit * Math.cos(num3 * options.frequency), options.unit * Math.sin(num3 * options.frequency), options.depth * num1 );
                pNewValue = options.axisQ.transformVector( pNewValue ).add( startValue );
                if (options.snapping) {
                    pNewValue.x = Bridge.Math.round(pNewValue.x, 0, 6);
                    pNewValue.y = Bridge.Math.round(pNewValue.y, 0, 6);
                    pNewValue.z = Bridge.Math.round(pNewValue.z, 0, 6);
                }

                setter(pNewValue.$clone());
            },
            /*DG.Tweening.Plugins.SpiralPlugin.EvaluateAndApply end.*/


        },
        overloads: {
            "SetFrom(TweenerCore<Vector3, Vector3, SpiralOptions>, bool)": "SetFrom$1"
        }
    });
    /*DG.Tweening.Plugins.SpiralPlugin end.*/

    /*DG.Tweening.Plugins.StringPlugin start.*/
    Bridge.define("DG.Tweening.Plugins.StringPlugin", {
        inherits: [DG.Tweening.Plugins.Core.ABSTweenPlugin$3(System.String,System.String,DG.Tweening.Plugins.Options.StringOptions)],
        statics: {
            fields: {
                _Buffer: null,
                _OpenedTags: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.StringPlugin#init", this ); }

                    this._Buffer = new System.Text.StringBuilder();
                    this._OpenedTags = new (System.Collections.Generic.List$1(System.Char)).ctor();
                }
            }
        },
        methods: {
            /*DG.Tweening.Plugins.StringPlugin.SetFrom$1 start.*/
            SetFrom$1: function (t, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.StringPlugin#SetFrom$1", this ); }

                var prevEndVal = t.endValue;
                t.endValue = t.getter();
                t.startValue = prevEndVal;
                t.setter(t.startValue);
            },
            /*DG.Tweening.Plugins.StringPlugin.SetFrom$1 end.*/

            /*DG.Tweening.Plugins.StringPlugin.SetFrom start.*/
            SetFrom: function (t, fromValue, setImmediately, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.StringPlugin#SetFrom", this ); }

                if (fromValue == null) {
                    fromValue = "";
                }

                if (isRelative) {
                    var currVal = t.getter();
                    fromValue = (fromValue || "") + (currVal || "");
                }

                t.startValue = fromValue;
                if (setImmediately) {
                    t.setter(fromValue);
                }
            },
            /*DG.Tweening.Plugins.StringPlugin.SetFrom end.*/

            /*DG.Tweening.Plugins.StringPlugin.Reset start.*/
            Reset: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.StringPlugin#Reset", this ); }

                t.startValue = (t.endValue = (t.changeValue = ""));
            },
            /*DG.Tweening.Plugins.StringPlugin.Reset end.*/

            /*DG.Tweening.Plugins.StringPlugin.ConvertToStartValue start.*/
            ConvertToStartValue: function (t, value) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.StringPlugin#ConvertToStartValue", this ); }

                return value;
            },
            /*DG.Tweening.Plugins.StringPlugin.ConvertToStartValue end.*/

            /*DG.Tweening.Plugins.StringPlugin.SetRelativeEndValue start.*/
            SetRelativeEndValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.StringPlugin#SetRelativeEndValue", this ); }

                // Do nothing (endValue stays the same)
            },
            /*DG.Tweening.Plugins.StringPlugin.SetRelativeEndValue end.*/

            /*DG.Tweening.Plugins.StringPlugin.SetChangeValue start.*/
            SetChangeValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.StringPlugin#SetChangeValue", this ); }

                t.changeValue = t.endValue;

                // Store no-tags versions of values
                var emptyStartValue = System.String.isNullOrEmpty(t.startValue);
                var emptyChangeValue = System.String.isNullOrEmpty(t.changeValue);
                t.plugOptions.startValueStrippedLength = emptyStartValue ? 0 : System.Text.RegularExpressions.Regex.replace(t.startValue, "<[^>]*>", "").length;
                t.plugOptions.changeValueStrippedLength = emptyChangeValue ? 0 : System.Text.RegularExpressions.Regex.replace(t.changeValue, "<[^>]*>", "").length;
                // Check if texts end with an open tag in which case consider it
                var startValueFullLen = emptyStartValue ? 0 : t.startValue.length;
                var changeValueFullLen = emptyChangeValue ? 0 : t.changeValue.length;
                if (startValueFullLen > 3 && t.startValue.charCodeAt(startValueFullLen - 1) === 62) {
                    for (var i = startValueFullLen - 3; i > -1; --i) {
                        if (t.startValue.charCodeAt(i) === 60) {
                            if (t.startValue.charCodeAt(i + 1) !== 47) {
                                // Start value ends with open tag
                                t.plugOptions.startValueStrippedLength++;
                            }

                            break;
                        }
                    }
                }

                if (changeValueFullLen > 3 && t.changeValue.charCodeAt(changeValueFullLen - 1) === 62) {
                    for (var i1 = changeValueFullLen - 3; i1 > -1; --i1) {
                        if (t.changeValue.charCodeAt(i1) === 60) {
                            if (t.changeValue.charCodeAt(i1 + 1) !== 47) {
                                // End value ends with open tag
                                t.plugOptions.changeValueStrippedLength++;
                            }

                            break;
                        }
                    }
                }
            },
            /*DG.Tweening.Plugins.StringPlugin.SetChangeValue end.*/

            /*DG.Tweening.Plugins.StringPlugin.GetSpeedBasedDuration start.*/
            GetSpeedBasedDuration: function (options, unitsXSecond, changeValue) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.StringPlugin#GetSpeedBasedDuration", this ); }

                //            float res = changeValue.Length / unitsXSecond;
                var res = (options.richTextEnabled ? options.changeValueStrippedLength : changeValue.length) / unitsXSecond;
                if (res < 0) {
                    res = -res;
                }

                return res;
            },
            /*DG.Tweening.Plugins.StringPlugin.GetSpeedBasedDuration end.*/

            /*DG.Tweening.Plugins.StringPlugin.EvaluateAndApply start.*/
            EvaluateAndApply: function (options, t, isRelative, getter, setter, elapsed, startValue, changeValue, duration, usingInversePosition, updateNotice) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.StringPlugin#EvaluateAndApply", this ); }

                DG.Tweening.Plugins.StringPlugin._Buffer.remove(0, DG.Tweening.Plugins.StringPlugin._Buffer.getLength());

                // Incremental works only with relative tweens (otherwise the tween makes no sense)
                // Sequence with Incremental loops have no effect here (why should they?)
                if (isRelative && t.loopType === DG.Tweening.LoopType.Incremental) {
                    var iterations = t.isComplete ? t.completedLoops - 1 : t.completedLoops;
                    if (iterations > 0) {
                        DG.Tweening.Plugins.StringPlugin._Buffer.append(startValue);
                        for (var i = 0; i < iterations; ++i) {
                            DG.Tweening.Plugins.StringPlugin._Buffer.append(changeValue);
                        }

                        startValue = DG.Tweening.Plugins.StringPlugin._Buffer.toString();
                        DG.Tweening.Plugins.StringPlugin._Buffer.remove(0, DG.Tweening.Plugins.StringPlugin._Buffer.getLength());
                    }
                }

                var startValueLen = options.richTextEnabled ? options.startValueStrippedLength : System.String.isNullOrEmpty(startValue) ? 0 : startValue.length;
                var changeValueLen = options.richTextEnabled ? options.changeValueStrippedLength : changeValue.length;
                var len = Bridge.Math.round(changeValueLen * DG.Tweening.Core.Easing.EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod), 0, 6);
                if (len > changeValueLen) {
                    len = changeValueLen;
                } else if (len < 0) {
                    len = 0;
                }

                if (isRelative) {
                    DG.Tweening.Plugins.StringPlugin._Buffer.append(startValue);
                    if (options.scrambleMode !== DG.Tweening.ScrambleMode.None) {
                        setter(DG.Tweening.Plugins.StringPluginExtensions.AppendScrambledChars(this.Append(changeValue, 0, len, options.richTextEnabled), changeValueLen - len, this.ScrambledCharsToUse(options.$clone())).toString());
                        return;
                    }

                    setter(this.Append(changeValue, 0, len, options.richTextEnabled).toString());
                    return;
                }

                if (options.scrambleMode !== DG.Tweening.ScrambleMode.None) {
                    setter(DG.Tweening.Plugins.StringPluginExtensions.AppendScrambledChars(this.Append(changeValue, 0, len, options.richTextEnabled), changeValueLen - len, this.ScrambledCharsToUse(options.$clone())).toString());
                    return;
                }

                var diff = startValueLen - changeValueLen;
                var startValueMaxLen = startValueLen;
                if (diff > 0) {
                    // String to be replaced is longer than endValue: remove parts of it while tweening
                    var perc = len / changeValueLen;
                    startValueMaxLen -= Math.floor(startValueMaxLen * perc);
                } else {
                    startValueMaxLen -= len;
                }

                this.Append(changeValue, 0, len, options.richTextEnabled);
                if (len < changeValueLen && len < startValueLen) {
                    this.Append(startValue, len, options.richTextEnabled ? len + startValueMaxLen : startValueMaxLen, options.richTextEnabled);
                }

                setter(DG.Tweening.Plugins.StringPlugin._Buffer.toString());
            },
            /*DG.Tweening.Plugins.StringPlugin.EvaluateAndApply end.*/

            /*DG.Tweening.Plugins.StringPlugin.Append start.*/
            Append: function (value, startIndex, length, richTextEnabled) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.StringPlugin#Append", this ); }

                if (!richTextEnabled) {
                    DG.Tweening.Plugins.StringPlugin._Buffer.append(value, startIndex, length);
                    return DG.Tweening.Plugins.StringPlugin._Buffer;
                }

                DG.Tweening.Plugins.StringPlugin._OpenedTags.clear();
                var tagMatch = "<.*?(>)";
                var closeTagMatch = "(</).*?>";
                var hasOpenTag = false;
                var fullLen = value.length;
                var i;
                for (i = 0; i < length; ++i) {
                    if (i > fullLen - 1) {
                        break; // Happens when string ends with an open tag
                    }

                    var c = value.charCodeAt(i);
                    if (c === 60) {
                        var hadOpenTag = hasOpenTag;
                        var nextChar = value.charCodeAt(i + 1);
                        hasOpenTag = !(i < fullLen - 1 && nextChar === 47);
                        if (hasOpenTag) {
                            DG.Tweening.Plugins.StringPlugin._OpenedTags.add(nextChar === 35 ? 99 : nextChar);
                        } else {
                            DG.Tweening.Plugins.StringPlugin._OpenedTags.removeAt(DG.Tweening.Plugins.StringPlugin._OpenedTags.Count - 1);
                        }

                        var s = value.substr(i);
                        var m = System.Text.RegularExpressions.Regex.match(s, tagMatch);
                        if (m.getSuccess()) {
                            if (!hasOpenTag && !hadOpenTag) {
                                // We have a closing tag without an opening tag, try to find previous correct opening tag and apply it
                                var closingTagFirstChar = value.charCodeAt(i + 1);
                                var openingTagLookouts;
                                if (closingTagFirstChar === 99) {
                                    openingTagLookouts = System.Array.init([35, 99], System.Char);
                                } else {
                                    openingTagLookouts = System.Array.init([closingTagFirstChar], System.Char);
                                }

                                var t = i - 1;
                                while (t > -1) {
                                    if (value.charCodeAt(t) === 60 && value.charCodeAt(t + 1) !== 47 && System.Array.indexOfT(openingTagLookouts, value.charCodeAt(t + 2)) !== -1) {
                                        DG.Tweening.Plugins.StringPlugin._Buffer.insert(0, value.substr(t, System.String.indexOf(value, String.fromCharCode(62), t) + 1 - t));
                                        break;
                                    }

                                    t--;
                                }
                            }

                            // Append tag and increase loop length to match
                            DG.Tweening.Plugins.StringPlugin._Buffer.append(m.getValue());
                            var add = m.getGroups().get(1).getIndex() + 1;
                            length += add;
                            startIndex += add;
                            i += add - 1;
                        }
                    } else if (i >= startIndex) {
                        DG.Tweening.Plugins.StringPlugin._Buffer.append(String.fromCharCode(c));
                    }
                }

                if (DG.Tweening.Plugins.StringPlugin._OpenedTags.Count > 0 && i < fullLen - 1) {
                    var next;
                    while (DG.Tweening.Plugins.StringPlugin._OpenedTags.Count > 0 && i < fullLen - 1) {
                        // Last open tag was not closed: find next close tag and apply it
                        next = value.substr(i);
                        var m1 = System.Text.RegularExpressions.Regex.match(next, closeTagMatch);
                        if (m1.getSuccess()) {
                            // Append only if it's the correct closing tag
                            if (m1.getValue().charCodeAt(2) === DG.Tweening.Plugins.StringPlugin._OpenedTags.getItem(DG.Tweening.Plugins.StringPlugin._OpenedTags.Count - 1)) {
                                DG.Tweening.Plugins.StringPlugin._Buffer.append(m1.getValue());
                                DG.Tweening.Plugins.StringPlugin._OpenedTags.removeAt(DG.Tweening.Plugins.StringPlugin._OpenedTags.Count - 1);
                            }

                            i += m1.getValue().length;
                        } else {
                            break;
                        }
                    }
                }

                return DG.Tweening.Plugins.StringPlugin._Buffer;
            },
            /*DG.Tweening.Plugins.StringPlugin.Append end.*/

            /*DG.Tweening.Plugins.StringPlugin.ScrambledCharsToUse start.*/
            ScrambledCharsToUse: function (options) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.StringPlugin#ScrambledCharsToUse", this ); }

                switch (options.scrambleMode) {
                    case DG.Tweening.ScrambleMode.Uppercase: 
                        return DG.Tweening.Plugins.StringPluginExtensions.ScrambledCharsUppercase;
                    case DG.Tweening.ScrambleMode.Lowercase: 
                        return DG.Tweening.Plugins.StringPluginExtensions.ScrambledCharsLowercase;
                    case DG.Tweening.ScrambleMode.Numerals: 
                        return DG.Tweening.Plugins.StringPluginExtensions.ScrambledCharsNumerals;
                    case DG.Tweening.ScrambleMode.Custom: 
                        return options.scrambledChars;
                    default: 
                        return DG.Tweening.Plugins.StringPluginExtensions.ScrambledCharsAll;
                }
            },
            /*DG.Tweening.Plugins.StringPlugin.ScrambledCharsToUse end.*/


        },
        overloads: {
            "SetFrom(TweenerCore<string, string, StringOptions>, bool)": "SetFrom$1"
        }
    });
    /*DG.Tweening.Plugins.StringPlugin end.*/

    /*DG.Tweening.Plugins.UintPlugin start.*/
    Bridge.define("DG.Tweening.Plugins.UintPlugin", {
        inherits: [DG.Tweening.Plugins.Core.ABSTweenPlugin$3(System.UInt32,System.UInt32,DG.Tweening.Plugins.Options.UintOptions)],
        methods: {
            /*DG.Tweening.Plugins.UintPlugin.Reset start.*/
            Reset: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.UintPlugin#Reset", this ); }
 },
            /*DG.Tweening.Plugins.UintPlugin.Reset end.*/

            /*DG.Tweening.Plugins.UintPlugin.SetFrom$1 start.*/
            SetFrom$1: function (t, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.UintPlugin#SetFrom$1", this ); }

                var prevEndVal = t.endValue;
                t.endValue = t.getter();
                t.startValue = isRelative ? t.endValue + prevEndVal : prevEndVal;
                t.setter(t.startValue);
            },
            /*DG.Tweening.Plugins.UintPlugin.SetFrom$1 end.*/

            /*DG.Tweening.Plugins.UintPlugin.SetFrom start.*/
            SetFrom: function (t, fromValue, setImmediately, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.UintPlugin#SetFrom", this ); }

                if (isRelative) {
                    var currVal = t.getter();
                    t.endValue += currVal;
                    fromValue += currVal;
                }

                t.startValue = fromValue;
                if (setImmediately) {
                    t.setter(fromValue);
                }
            },
            /*DG.Tweening.Plugins.UintPlugin.SetFrom end.*/

            /*DG.Tweening.Plugins.UintPlugin.ConvertToStartValue start.*/
            ConvertToStartValue: function (t, value) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.UintPlugin#ConvertToStartValue", this ); }

                return value;
            },
            /*DG.Tweening.Plugins.UintPlugin.ConvertToStartValue end.*/

            /*DG.Tweening.Plugins.UintPlugin.SetRelativeEndValue start.*/
            SetRelativeEndValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.UintPlugin#SetRelativeEndValue", this ); }

                t.endValue += t.startValue;
            },
            /*DG.Tweening.Plugins.UintPlugin.SetRelativeEndValue end.*/

            /*DG.Tweening.Plugins.UintPlugin.SetChangeValue start.*/
            SetChangeValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.UintPlugin#SetChangeValue", this ); }

                t.plugOptions.isNegativeChangeValue = t.endValue < t.startValue;
                t.changeValue = t.plugOptions.isNegativeChangeValue ? t.startValue - t.endValue : t.endValue - t.startValue;
                //            t.changeValue = t.endValue - t.startValue;
            },
            /*DG.Tweening.Plugins.UintPlugin.SetChangeValue end.*/

            /*DG.Tweening.Plugins.UintPlugin.GetSpeedBasedDuration start.*/
            GetSpeedBasedDuration: function (options, unitsXSecond, changeValue) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.UintPlugin#GetSpeedBasedDuration", this ); }

                var res = changeValue / unitsXSecond;
                if (res < 0) {
                    res = -res;
                }

                return res;
            },
            /*DG.Tweening.Plugins.UintPlugin.GetSpeedBasedDuration end.*/

            /*DG.Tweening.Plugins.UintPlugin.EvaluateAndApply start.*/
            EvaluateAndApply: function (options, t, isRelative, getter, setter, elapsed, startValue, changeValue, duration, usingInversePosition, updateNotice) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.UintPlugin#EvaluateAndApply", this ); }

                var v;
                if (t.loopType === DG.Tweening.LoopType.Incremental) {
                    v = System.Int64.clipu32(System.Int64(changeValue).mul(System.Int64((t.isComplete ? t.completedLoops - 1 : t.completedLoops))));
                    if (options.isNegativeChangeValue) {
                        startValue -= v;
                    } else {
                        startValue += v;
                    }
                }

                if (t.isSequenced && t.sequenceParent.loopType === DG.Tweening.LoopType.Incremental) {
                    v = System.Int64.clipu32(System.Int64(changeValue).mul(System.Int64((t.loopType === DG.Tweening.LoopType.Incremental ? t.loops : 1))).mul(System.Int64((t.sequenceParent.isComplete ? t.sequenceParent.completedLoops - 1 : t.sequenceParent.completedLoops))));
                    if (options.isNegativeChangeValue) {
                        startValue -= v;
                    } else {
                        startValue += v;
                    }
                }

                v = Bridge.Math.round(changeValue * DG.Tweening.Core.Easing.EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod), 0, 6);
                if (options.isNegativeChangeValue) {
                    setter(startValue - v);
                } else {
                    setter(startValue + v);
                }
            },
            /*DG.Tweening.Plugins.UintPlugin.EvaluateAndApply end.*/


        },
        overloads: {
            "SetFrom(TweenerCore<uint, uint, UintOptions>, bool)": "SetFrom$1"
        }
    });
    /*DG.Tweening.Plugins.UintPlugin end.*/

    /*DG.Tweening.Plugins.Vector2Plugin start.*/
    Bridge.define("DG.Tweening.Plugins.Vector2Plugin", {
        inherits: [DG.Tweening.Plugins.Core.ABSTweenPlugin$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions)],
        methods: {
            /*DG.Tweening.Plugins.Vector2Plugin.Reset start.*/
            Reset: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Vector2Plugin#Reset", this ); }
 },
            /*DG.Tweening.Plugins.Vector2Plugin.Reset end.*/

            /*DG.Tweening.Plugins.Vector2Plugin.SetFrom$1 start.*/
            SetFrom$1: function (t, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Vector2Plugin#SetFrom$1", this ); }

                var prevEndVal = t.endValue.$clone();
                t.endValue = t.getter().$clone();
                t.startValue = isRelative ? t.endValue.$clone().add( prevEndVal ) : prevEndVal.$clone();
                var to = t.endValue.$clone();
                switch (t.plugOptions.axisConstraint) {
                    case DG.Tweening.AxisConstraint.X: 
                        to.x = t.startValue.x;
                        break;
                    case DG.Tweening.AxisConstraint.Y: 
                        to.y = t.startValue.y;
                        break;
                    default: 
                        to = t.startValue.$clone();
                        break;
                }

                if (t.plugOptions.snapping) {
                    to.x = Bridge.Math.round(to.x, 0, 6);
                    to.y = Bridge.Math.round(to.y, 0, 6);
                }

                t.setter(to.$clone());
            },
            /*DG.Tweening.Plugins.Vector2Plugin.SetFrom$1 end.*/

            /*DG.Tweening.Plugins.Vector2Plugin.SetFrom start.*/
            SetFrom: function (t, fromValue, setImmediately, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Vector2Plugin#SetFrom", this ); }

                if (isRelative) {
                    var currVal = t.getter().$clone();
                    t.endValue = t.endValue.$clone().add( currVal.$clone() );
                    fromValue = fromValue.$clone().add( currVal.$clone() );
                }

                t.startValue = fromValue.$clone();
                if (setImmediately) {
                    var to = new UnityEngine.Vector2();
                    switch (t.plugOptions.axisConstraint) {
                        case DG.Tweening.AxisConstraint.X: 
                            to = t.getter().$clone();
                            to.x = fromValue.x;
                            break;
                        case DG.Tweening.AxisConstraint.Y: 
                            to = t.getter().$clone();
                            to.y = fromValue.y;
                            break;
                        default: 
                            to = fromValue.$clone();
                            break;
                    }

                    if (t.plugOptions.snapping) {
                        to.x = Bridge.Math.round(to.x, 0, 6);
                        to.y = Bridge.Math.round(to.y, 0, 6);
                    }

                    t.setter(to.$clone());
                }
            },
            /*DG.Tweening.Plugins.Vector2Plugin.SetFrom end.*/

            /*DG.Tweening.Plugins.Vector2Plugin.ConvertToStartValue start.*/
            ConvertToStartValue: function (t, value) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Vector2Plugin#ConvertToStartValue", this ); }

                return value.$clone();
            },
            /*DG.Tweening.Plugins.Vector2Plugin.ConvertToStartValue end.*/

            /*DG.Tweening.Plugins.Vector2Plugin.SetRelativeEndValue start.*/
            SetRelativeEndValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Vector2Plugin#SetRelativeEndValue", this ); }

                t.endValue = t.endValue.$clone().add( t.startValue.$clone() );
            },
            /*DG.Tweening.Plugins.Vector2Plugin.SetRelativeEndValue end.*/

            /*DG.Tweening.Plugins.Vector2Plugin.SetChangeValue start.*/
            SetChangeValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Vector2Plugin#SetChangeValue", this ); }

                switch (t.plugOptions.axisConstraint) {
                    case DG.Tweening.AxisConstraint.X: 
                        t.changeValue = new pc.Vec2( t.endValue.x - t.startValue.x, 0 );
                        break;
                    case DG.Tweening.AxisConstraint.Y: 
                        t.changeValue = new pc.Vec2( 0, t.endValue.y - t.startValue.y );
                        break;
                    default: 
                        t.changeValue = t.endValue.$clone().sub( t.startValue );
                        break;
                }
            },
            /*DG.Tweening.Plugins.Vector2Plugin.SetChangeValue end.*/

            /*DG.Tweening.Plugins.Vector2Plugin.GetSpeedBasedDuration start.*/
            GetSpeedBasedDuration: function (options, unitsXSecond, changeValue) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Vector2Plugin#GetSpeedBasedDuration", this ); }

                return changeValue.length() / unitsXSecond;
            },
            /*DG.Tweening.Plugins.Vector2Plugin.GetSpeedBasedDuration end.*/

            /*DG.Tweening.Plugins.Vector2Plugin.EvaluateAndApply start.*/
            EvaluateAndApply: function (options, t, isRelative, getter, setter, elapsed, startValue, changeValue, duration, usingInversePosition, updateNotice) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Vector2Plugin#EvaluateAndApply", this ); }

                if (t.loopType === DG.Tweening.LoopType.Incremental) {
                    startValue = startValue.$clone().add( changeValue.$clone().scale( (t.isComplete ? t.completedLoops - 1 : t.completedLoops) ) );
                }

                if (t.isSequenced && t.sequenceParent.loopType === DG.Tweening.LoopType.Incremental) {
                    startValue = startValue.$clone().add( changeValue.$clone().scale( (t.loopType === DG.Tweening.LoopType.Incremental ? t.loops : 1) ).scale( (t.sequenceParent.isComplete ? t.sequenceParent.completedLoops - 1 : t.sequenceParent.completedLoops) ) );
                }

                var easeVal = DG.Tweening.Core.Easing.EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod);
                switch (options.axisConstraint) {
                    case DG.Tweening.AxisConstraint.X: 
                        var resX = getter().$clone();
                        resX.x = startValue.x + changeValue.x * easeVal;
                        if (options.snapping) {
                            resX.x = Bridge.Math.round(resX.x, 0, 6);
                        }
                        setter(resX.$clone());
                        break;
                    case DG.Tweening.AxisConstraint.Y: 
                        var resY = getter().$clone();
                        resY.y = startValue.y + changeValue.y * easeVal;
                        if (options.snapping) {
                            resY.y = Bridge.Math.round(resY.y, 0, 6);
                        }
                        setter(resY.$clone());
                        break;
                    default: 
                        startValue.x += changeValue.x * easeVal;
                        startValue.y += changeValue.y * easeVal;
                        if (options.snapping) {
                            startValue.x = Bridge.Math.round(startValue.x, 0, 6);
                            startValue.y = Bridge.Math.round(startValue.y, 0, 6);
                        }
                        setter(startValue.$clone());
                        break;
                }
            },
            /*DG.Tweening.Plugins.Vector2Plugin.EvaluateAndApply end.*/


        },
        overloads: {
            "SetFrom(TweenerCore<Vector2, Vector2, VectorOptions>, bool)": "SetFrom$1"
        }
    });
    /*DG.Tweening.Plugins.Vector2Plugin end.*/

    /*DG.Tweening.Plugins.Vector3ArrayPlugin start.*/
    /**
     * This plugin generates some GC allocations at startup
     *
     * @public
     * @class DG.Tweening.Plugins.Vector3ArrayPlugin
     * @augments DG.Tweening.Plugins.Core.ABSTweenPlugin$3
     */
    Bridge.define("DG.Tweening.Plugins.Vector3ArrayPlugin", {
        inherits: [DG.Tweening.Plugins.Core.ABSTweenPlugin$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions)],
        methods: {
            /*DG.Tweening.Plugins.Vector3ArrayPlugin.Reset start.*/
            Reset: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Vector3ArrayPlugin#Reset", this ); }

                t.startValue = (t.endValue = (t.changeValue = null));
            },
            /*DG.Tweening.Plugins.Vector3ArrayPlugin.Reset end.*/

            /*DG.Tweening.Plugins.Vector3ArrayPlugin.SetFrom$1 start.*/
            SetFrom$1: function (t, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Vector3ArrayPlugin#SetFrom$1", this ); }
 },
            /*DG.Tweening.Plugins.Vector3ArrayPlugin.SetFrom$1 end.*/

            /*DG.Tweening.Plugins.Vector3ArrayPlugin.SetFrom start.*/
            SetFrom: function (t, fromValue, setImmediately, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Vector3ArrayPlugin#SetFrom", this ); }
 },
            /*DG.Tweening.Plugins.Vector3ArrayPlugin.SetFrom end.*/

            /*DG.Tweening.Plugins.Vector3ArrayPlugin.ConvertToStartValue start.*/
            ConvertToStartValue: function (t, value) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Vector3ArrayPlugin#ConvertToStartValue", this ); }

                var len = t.endValue.length;
                var res = System.Array.init(len, function (){
                    return new UnityEngine.Vector3();
                }, UnityEngine.Vector3);
                for (var i = 0; i < len; i++) {
                    if (i === 0) {
                        res[i] = value.$clone();
                    } else {
                        res[i] = t.endValue[i - 1].$clone();
                    }
                }

                return res;
            },
            /*DG.Tweening.Plugins.Vector3ArrayPlugin.ConvertToStartValue end.*/

            /*DG.Tweening.Plugins.Vector3ArrayPlugin.SetRelativeEndValue start.*/
            SetRelativeEndValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Vector3ArrayPlugin#SetRelativeEndValue", this ); }

                var len = t.endValue.length;
                for (var i = 0; i < len; ++i) {
                    if (i > 0) {
                        t.startValue[i] = t.endValue[i - 1].$clone();
                    }

                    t.endValue[i] = t.startValue[i].$clone().add( t.endValue[i] );
                }
            },
            /*DG.Tweening.Plugins.Vector3ArrayPlugin.SetRelativeEndValue end.*/

            /*DG.Tweening.Plugins.Vector3ArrayPlugin.SetChangeValue start.*/
            SetChangeValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Vector3ArrayPlugin#SetChangeValue", this ); }

                var len = t.endValue.length;
                t.changeValue = System.Array.init(len, function (){
                    return new UnityEngine.Vector3();
                }, UnityEngine.Vector3);
                for (var i = 0; i < len; ++i) {
                    t.changeValue[i] = t.endValue[i].$clone().sub( t.startValue[i] );
                }
            },
            /*DG.Tweening.Plugins.Vector3ArrayPlugin.SetChangeValue end.*/

            /*DG.Tweening.Plugins.Vector3ArrayPlugin.GetSpeedBasedDuration start.*/
            GetSpeedBasedDuration: function (options, unitsXSecond, changeValue) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Vector3ArrayPlugin#GetSpeedBasedDuration", this ); }

                var totDuration = 0;
                var len = changeValue.length;
                for (var i = 0; i < len; ++i) {
                    var duration = changeValue[i].length() / options.durations[i];
                    options.durations[i] = duration;
                    totDuration += duration;
                }

                return totDuration;
            },
            /*DG.Tweening.Plugins.Vector3ArrayPlugin.GetSpeedBasedDuration end.*/

            /*DG.Tweening.Plugins.Vector3ArrayPlugin.EvaluateAndApply start.*/
            EvaluateAndApply: function (options, t, isRelative, getter, setter, elapsed, startValue, changeValue, duration, usingInversePosition, updateNotice) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Vector3ArrayPlugin#EvaluateAndApply", this ); }

                var incrementValue = pc.Vec3.ZERO.clone();
                if (t.loopType === DG.Tweening.LoopType.Incremental) {
                    var iterations = t.isComplete ? t.completedLoops - 1 : t.completedLoops;
                    if (iterations > 0) {
                        var end = startValue.length - 1;
                        incrementValue = (startValue[end].$clone().add( changeValue[end] ).sub( startValue[0] )).clone().scale( iterations );
                    }
                }

                if (t.isSequenced && t.sequenceParent.loopType === DG.Tweening.LoopType.Incremental) {
                    var iterations1 = (t.loopType === DG.Tweening.LoopType.Incremental ? t.loops : 1) * (t.sequenceParent.isComplete ? t.sequenceParent.completedLoops - 1 : t.sequenceParent.completedLoops);
                    if (iterations1 > 0) {
                        var end1 = startValue.length - 1;
                        incrementValue = incrementValue.$clone().add( (startValue[end1].$clone().add( changeValue[end1] ).sub( startValue[0] )).clone().scale( iterations1 ) );
                    }
                }

                // Find correct index and segmentElapsed
                var index = 0;
                var segmentElapsed = 0;
                var segmentDuration = 0;
                var len = options.durations.length;
                var count = 0;
                for (var i = 0; i < len; i++) {
                    segmentDuration = options.durations[i];
                    count += segmentDuration;
                    if (elapsed > count) {
                        segmentElapsed += segmentDuration;
                        continue;
                    }

                    index = i;
                    segmentElapsed = elapsed - segmentElapsed;
                    break;
                }

                // Evaluate
                var easeVal = DG.Tweening.Core.Easing.EaseManager.Evaluate(t.easeType, t.customEase, segmentElapsed, segmentDuration, t.easeOvershootOrAmplitude, t.easePeriod);
                var res = pc.Vec3.ZERO.clone();
                switch (options.axisConstraint) {
                    case DG.Tweening.AxisConstraint.X: 
                        res = getter().$clone();
                        res.x = startValue[index].x + incrementValue.x + changeValue[index].x * easeVal;
                        if (options.snapping) {
                            res.x = Bridge.Math.round(res.x, 0, 6);
                        }
                        setter(res.$clone());
                        break;
                    case DG.Tweening.AxisConstraint.Y: 
                        res = getter().$clone();
                        res.y = startValue[index].y + incrementValue.y + changeValue[index].y * easeVal;
                        if (options.snapping) {
                            res.y = Bridge.Math.round(res.y, 0, 6);
                        }
                        setter(res.$clone());
                        return;
                    case DG.Tweening.AxisConstraint.Z: 
                        res = getter().$clone();
                        res.z = startValue[index].z + incrementValue.z + changeValue[index].z * easeVal;
                        if (options.snapping) {
                            res.z = Bridge.Math.round(res.z, 0, 6);
                        }
                        setter(res.$clone());
                        break;
                    default: 
                        res.x = startValue[index].x + incrementValue.x + changeValue[index].x * easeVal;
                        res.y = startValue[index].y + incrementValue.y + changeValue[index].y * easeVal;
                        res.z = startValue[index].z + incrementValue.z + changeValue[index].z * easeVal;
                        if (options.snapping) {
                            res.x = Bridge.Math.round(res.x, 0, 6);
                            res.y = Bridge.Math.round(res.y, 0, 6);
                            res.z = Bridge.Math.round(res.z, 0, 6);
                        }
                        setter(res.$clone());
                        break;
                }
            },
            /*DG.Tweening.Plugins.Vector3ArrayPlugin.EvaluateAndApply end.*/


        },
        overloads: {
            "SetFrom(TweenerCore<Vector3, Vector3[], Vector3ArrayOptions>, bool)": "SetFrom$1"
        }
    });
    /*DG.Tweening.Plugins.Vector3ArrayPlugin end.*/

    /*DG.Tweening.Plugins.Vector3Plugin start.*/
    Bridge.define("DG.Tweening.Plugins.Vector3Plugin", {
        inherits: [DG.Tweening.Plugins.Core.ABSTweenPlugin$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions)],
        methods: {
            /*DG.Tweening.Plugins.Vector3Plugin.Reset start.*/
            Reset: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Vector3Plugin#Reset", this ); }
 },
            /*DG.Tweening.Plugins.Vector3Plugin.Reset end.*/

            /*DG.Tweening.Plugins.Vector3Plugin.SetFrom$1 start.*/
            SetFrom$1: function (t, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Vector3Plugin#SetFrom$1", this ); }

                var prevEndVal = t.endValue.$clone();
                t.endValue = t.getter().$clone();
                t.startValue = isRelative ? t.endValue.$clone().add( prevEndVal ) : prevEndVal.$clone();
                var to = t.endValue.$clone();
                switch (t.plugOptions.axisConstraint) {
                    case DG.Tweening.AxisConstraint.X: 
                        to.x = t.startValue.x;
                        break;
                    case DG.Tweening.AxisConstraint.Y: 
                        to.y = t.startValue.y;
                        break;
                    case DG.Tweening.AxisConstraint.Z: 
                        to.z = t.startValue.z;
                        break;
                    default: 
                        to = t.startValue.$clone();
                        break;
                }

                if (t.plugOptions.snapping) {
                    to.x = Bridge.Math.round(to.x, 0, 6);
                    to.y = Bridge.Math.round(to.y, 0, 6);
                    to.z = Bridge.Math.round(to.z, 0, 6);
                }

                t.setter(to.$clone());
            },
            /*DG.Tweening.Plugins.Vector3Plugin.SetFrom$1 end.*/

            /*DG.Tweening.Plugins.Vector3Plugin.SetFrom start.*/
            SetFrom: function (t, fromValue, setImmediately, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Vector3Plugin#SetFrom", this ); }

                if (isRelative) {
                    var currVal = t.getter().$clone();
                    t.endValue = t.endValue.$clone().add( currVal.$clone() );
                    fromValue = fromValue.$clone().add( currVal.$clone() );
                }

                t.startValue = fromValue.$clone();
                if (setImmediately) {
                    var to = new UnityEngine.Vector3();
                    switch (t.plugOptions.axisConstraint) {
                        case DG.Tweening.AxisConstraint.X: 
                            to = t.getter().$clone();
                            to.x = fromValue.x;
                            break;
                        case DG.Tweening.AxisConstraint.Y: 
                            to = t.getter().$clone();
                            to.y = fromValue.y;
                            break;
                        case DG.Tweening.AxisConstraint.Z: 
                            to = t.getter().$clone();
                            to.z = fromValue.z;
                            break;
                        default: 
                            to = fromValue.$clone();
                            break;
                    }

                    if (t.plugOptions.snapping) {
                        to.x = Bridge.Math.round(to.x, 0, 6);
                        to.y = Bridge.Math.round(to.y, 0, 6);
                        to.z = Bridge.Math.round(to.z, 0, 6);
                    }

                    t.setter(to.$clone());
                }
            },
            /*DG.Tweening.Plugins.Vector3Plugin.SetFrom end.*/

            /*DG.Tweening.Plugins.Vector3Plugin.ConvertToStartValue start.*/
            ConvertToStartValue: function (t, value) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Vector3Plugin#ConvertToStartValue", this ); }

                return value.$clone();
            },
            /*DG.Tweening.Plugins.Vector3Plugin.ConvertToStartValue end.*/

            /*DG.Tweening.Plugins.Vector3Plugin.SetRelativeEndValue start.*/
            SetRelativeEndValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Vector3Plugin#SetRelativeEndValue", this ); }

                t.endValue = t.endValue.$clone().add( t.startValue.$clone() );
            },
            /*DG.Tweening.Plugins.Vector3Plugin.SetRelativeEndValue end.*/

            /*DG.Tweening.Plugins.Vector3Plugin.SetChangeValue start.*/
            SetChangeValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Vector3Plugin#SetChangeValue", this ); }

                switch (t.plugOptions.axisConstraint) {
                    case DG.Tweening.AxisConstraint.X: 
                        t.changeValue = new pc.Vec3( t.endValue.x - t.startValue.x, 0, 0 );
                        break;
                    case DG.Tweening.AxisConstraint.Y: 
                        t.changeValue = new pc.Vec3( 0, t.endValue.y - t.startValue.y, 0 );
                        break;
                    case DG.Tweening.AxisConstraint.Z: 
                        t.changeValue = new pc.Vec3( 0, 0, t.endValue.z - t.startValue.z );
                        break;
                    default: 
                        t.changeValue = t.endValue.$clone().sub( t.startValue );
                        break;
                }
            },
            /*DG.Tweening.Plugins.Vector3Plugin.SetChangeValue end.*/

            /*DG.Tweening.Plugins.Vector3Plugin.GetSpeedBasedDuration start.*/
            GetSpeedBasedDuration: function (options, unitsXSecond, changeValue) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Vector3Plugin#GetSpeedBasedDuration", this ); }

                return changeValue.length() / unitsXSecond;
            },
            /*DG.Tweening.Plugins.Vector3Plugin.GetSpeedBasedDuration end.*/

            /*DG.Tweening.Plugins.Vector3Plugin.EvaluateAndApply start.*/
            EvaluateAndApply: function (options, t, isRelative, getter, setter, elapsed, startValue, changeValue, duration, usingInversePosition, updateNotice) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Vector3Plugin#EvaluateAndApply", this ); }

                if (t.loopType === DG.Tweening.LoopType.Incremental) {
                    startValue = startValue.$clone().add( changeValue.$clone().clone().scale( (t.isComplete ? t.completedLoops - 1 : t.completedLoops) ) );
                }

                if (t.isSequenced && t.sequenceParent.loopType === DG.Tweening.LoopType.Incremental) {
                    startValue = startValue.$clone().add( changeValue.$clone().clone().scale( (t.loopType === DG.Tweening.LoopType.Incremental ? t.loops : 1) ).clone().scale( (t.sequenceParent.isComplete ? t.sequenceParent.completedLoops - 1 : t.sequenceParent.completedLoops) ) );
                }

                var easeVal = DG.Tweening.Core.Easing.EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod);
                switch (options.axisConstraint) {
                    case DG.Tweening.AxisConstraint.X: 
                        var resX = getter().$clone();
                        resX.x = startValue.x + changeValue.x * easeVal;
                        if (options.snapping) {
                            resX.x = Bridge.Math.round(resX.x, 0, 6);
                        }
                        setter(resX.$clone());
                        break;
                    case DG.Tweening.AxisConstraint.Y: 
                        var resY = getter().$clone();
                        resY.y = startValue.y + changeValue.y * easeVal;
                        if (options.snapping) {
                            resY.y = Bridge.Math.round(resY.y, 0, 6);
                        }
                        setter(resY.$clone());
                        break;
                    case DG.Tweening.AxisConstraint.Z: 
                        var resZ = getter().$clone();
                        resZ.z = startValue.z + changeValue.z * easeVal;
                        if (options.snapping) {
                            resZ.z = Bridge.Math.round(resZ.z, 0, 6);
                        }
                        setter(resZ.$clone());
                        break;
                    default: 
                        startValue.x += changeValue.x * easeVal;
                        startValue.y += changeValue.y * easeVal;
                        startValue.z += changeValue.z * easeVal;
                        if (options.snapping) {
                            startValue.x = Bridge.Math.round(startValue.x, 0, 6);
                            startValue.y = Bridge.Math.round(startValue.y, 0, 6);
                            startValue.z = Bridge.Math.round(startValue.z, 0, 6);
                        }
                        setter(startValue.$clone());
                        break;
                }
            },
            /*DG.Tweening.Plugins.Vector3Plugin.EvaluateAndApply end.*/


        },
        overloads: {
            "SetFrom(TweenerCore<Vector3, Vector3, VectorOptions>, bool)": "SetFrom$1"
        }
    });
    /*DG.Tweening.Plugins.Vector3Plugin end.*/

    /*DG.Tweening.Plugins.Vector4Plugin start.*/
    Bridge.define("DG.Tweening.Plugins.Vector4Plugin", {
        inherits: [DG.Tweening.Plugins.Core.ABSTweenPlugin$3(UnityEngine.Vector4,UnityEngine.Vector4,DG.Tweening.Plugins.Options.VectorOptions)],
        methods: {
            /*DG.Tweening.Plugins.Vector4Plugin.Reset start.*/
            Reset: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Vector4Plugin#Reset", this ); }
 },
            /*DG.Tweening.Plugins.Vector4Plugin.Reset end.*/

            /*DG.Tweening.Plugins.Vector4Plugin.SetFrom$1 start.*/
            SetFrom$1: function (t, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Vector4Plugin#SetFrom$1", this ); }

                var prevEndVal = t.endValue.$clone();
                t.endValue = t.getter().$clone();
                t.startValue = isRelative ? t.endValue.$clone().add( prevEndVal ) : prevEndVal.$clone();
                var to = t.endValue.$clone();
                switch (t.plugOptions.axisConstraint) {
                    case DG.Tweening.AxisConstraint.X: 
                        to.x = t.startValue.x;
                        break;
                    case DG.Tweening.AxisConstraint.Y: 
                        to.y = t.startValue.y;
                        break;
                    case DG.Tweening.AxisConstraint.Z: 
                        to.z = t.startValue.z;
                        break;
                    case DG.Tweening.AxisConstraint.W: 
                        to.w = t.startValue.w;
                        break;
                    default: 
                        to = t.startValue.$clone();
                        break;
                }

                if (t.plugOptions.snapping) {
                    to.x = Bridge.Math.round(to.x, 0, 6);
                    to.y = Bridge.Math.round(to.y, 0, 6);
                    to.z = Bridge.Math.round(to.z, 0, 6);
                    to.w = Bridge.Math.round(to.w, 0, 6);
                }

                t.setter(to.$clone());
            },
            /*DG.Tweening.Plugins.Vector4Plugin.SetFrom$1 end.*/

            /*DG.Tweening.Plugins.Vector4Plugin.SetFrom start.*/
            SetFrom: function (t, fromValue, setImmediately, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Vector4Plugin#SetFrom", this ); }

                if (isRelative) {
                    var currVal = t.getter().$clone();
                    t.endValue = t.endValue.$clone().add( currVal.$clone() );
                    fromValue = fromValue.$clone().add( currVal.$clone() );
                }

                t.startValue = fromValue.$clone();
                if (setImmediately) {
                    var to = new UnityEngine.Vector4();
                    switch (t.plugOptions.axisConstraint) {
                        case DG.Tweening.AxisConstraint.X: 
                            to = t.getter().$clone();
                            to.x = fromValue.x;
                            break;
                        case DG.Tweening.AxisConstraint.Y: 
                            to = t.getter().$clone();
                            to.y = fromValue.y;
                            break;
                        case DG.Tweening.AxisConstraint.Z: 
                            to = t.getter().$clone();
                            to.z = fromValue.z;
                            break;
                        case DG.Tweening.AxisConstraint.W: 
                            to = t.getter().$clone();
                            to.w = fromValue.w;
                            break;
                        default: 
                            to = fromValue.$clone();
                            break;
                    }

                    if (t.plugOptions.snapping) {
                        to.x = Bridge.Math.round(to.x, 0, 6);
                        to.y = Bridge.Math.round(to.y, 0, 6);
                        to.z = Bridge.Math.round(to.z, 0, 6);
                        to.w = Bridge.Math.round(to.w, 0, 6);
                    }

                    t.setter(to.$clone());
                }
            },
            /*DG.Tweening.Plugins.Vector4Plugin.SetFrom end.*/

            /*DG.Tweening.Plugins.Vector4Plugin.ConvertToStartValue start.*/
            ConvertToStartValue: function (t, value) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Vector4Plugin#ConvertToStartValue", this ); }

                return value.$clone();
            },
            /*DG.Tweening.Plugins.Vector4Plugin.ConvertToStartValue end.*/

            /*DG.Tweening.Plugins.Vector4Plugin.SetRelativeEndValue start.*/
            SetRelativeEndValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Vector4Plugin#SetRelativeEndValue", this ); }

                t.endValue = t.endValue.$clone().add( t.startValue.$clone() );
            },
            /*DG.Tweening.Plugins.Vector4Plugin.SetRelativeEndValue end.*/

            /*DG.Tweening.Plugins.Vector4Plugin.SetChangeValue start.*/
            SetChangeValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Vector4Plugin#SetChangeValue", this ); }

                switch (t.plugOptions.axisConstraint) {
                    case DG.Tweening.AxisConstraint.X: 
                        t.changeValue = new pc.Vec4( t.endValue.x - t.startValue.x, 0, 0, 0 );
                        break;
                    case DG.Tweening.AxisConstraint.Y: 
                        t.changeValue = new pc.Vec4( 0, t.endValue.y - t.startValue.y, 0, 0 );
                        break;
                    case DG.Tweening.AxisConstraint.Z: 
                        t.changeValue = new pc.Vec4( 0, 0, t.endValue.z - t.startValue.z, 0 );
                        break;
                    case DG.Tweening.AxisConstraint.W: 
                        t.changeValue = new pc.Vec4( 0, 0, 0, t.endValue.w - t.startValue.w );
                        break;
                    default: 
                        t.changeValue = t.endValue.$clone().sub( t.startValue );
                        break;
                }
            },
            /*DG.Tweening.Plugins.Vector4Plugin.SetChangeValue end.*/

            /*DG.Tweening.Plugins.Vector4Plugin.GetSpeedBasedDuration start.*/
            GetSpeedBasedDuration: function (options, unitsXSecond, changeValue) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Vector4Plugin#GetSpeedBasedDuration", this ); }

                return changeValue.length() / unitsXSecond;
            },
            /*DG.Tweening.Plugins.Vector4Plugin.GetSpeedBasedDuration end.*/

            /*DG.Tweening.Plugins.Vector4Plugin.EvaluateAndApply start.*/
            EvaluateAndApply: function (options, t, isRelative, getter, setter, elapsed, startValue, changeValue, duration, usingInversePosition, updateNotice) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Vector4Plugin#EvaluateAndApply", this ); }

                if (t.loopType === DG.Tweening.LoopType.Incremental) {
                    startValue = startValue.$clone().add( changeValue.$clone().scale( (t.isComplete ? t.completedLoops - 1 : t.completedLoops) ) );
                }

                if (t.isSequenced && t.sequenceParent.loopType === DG.Tweening.LoopType.Incremental) {
                    startValue = startValue.$clone().add( changeValue.$clone().scale( (t.loopType === DG.Tweening.LoopType.Incremental ? t.loops : 1) ).scale( (t.sequenceParent.isComplete ? t.sequenceParent.completedLoops - 1 : t.sequenceParent.completedLoops) ) );
                }

                var easeVal = DG.Tweening.Core.Easing.EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod);
                switch (options.axisConstraint) {
                    case DG.Tweening.AxisConstraint.X: 
                        var resX = getter().$clone();
                        resX.x = startValue.x + changeValue.x * easeVal;
                        if (options.snapping) {
                            resX.x = Bridge.Math.round(resX.x, 0, 6);
                        }
                        setter(resX.$clone());
                        break;
                    case DG.Tweening.AxisConstraint.Y: 
                        var resY = getter().$clone();
                        resY.y = startValue.y + changeValue.y * easeVal;
                        if (options.snapping) {
                            resY.y = Bridge.Math.round(resY.y, 0, 6);
                        }
                        setter(resY.$clone());
                        break;
                    case DG.Tweening.AxisConstraint.Z: 
                        var resZ = getter().$clone();
                        resZ.z = startValue.z + changeValue.z * easeVal;
                        if (options.snapping) {
                            resZ.z = Bridge.Math.round(resZ.z, 0, 6);
                        }
                        setter(resZ.$clone());
                        break;
                    case DG.Tweening.AxisConstraint.W: 
                        var resW = getter().$clone();
                        resW.w = startValue.w + changeValue.w * easeVal;
                        if (options.snapping) {
                            resW.w = Bridge.Math.round(resW.w, 0, 6);
                        }
                        setter(resW.$clone());
                        break;
                    default: 
                        startValue.x += changeValue.x * easeVal;
                        startValue.y += changeValue.y * easeVal;
                        startValue.z += changeValue.z * easeVal;
                        startValue.w += changeValue.w * easeVal;
                        if (options.snapping) {
                            startValue.x = Bridge.Math.round(startValue.x, 0, 6);
                            startValue.y = Bridge.Math.round(startValue.y, 0, 6);
                            startValue.z = Bridge.Math.round(startValue.z, 0, 6);
                            startValue.w = Bridge.Math.round(startValue.w, 0, 6);
                        }
                        setter(startValue.$clone());
                        break;
                }
            },
            /*DG.Tweening.Plugins.Vector4Plugin.EvaluateAndApply end.*/


        },
        overloads: {
            "SetFrom(TweenerCore<Vector4, Vector4, VectorOptions>, bool)": "SetFrom$1"
        }
    });
    /*DG.Tweening.Plugins.Vector4Plugin end.*/

    /*DG.Tweening.Sequence start.*/
    /**
     * Controls other tweens as a group
     *
     * @public
     * @class DG.Tweening.Sequence
     * @augments DG.Tweening.Tween
     */
    Bridge.define("DG.Tweening.Sequence", {
        inherits: [DG.Tweening.Tween],
        statics: {
            methods: {
                /*DG.Tweening.Sequence.Setup:static start.*/
                Setup: function (s) {
if ( TRACE ) { TRACE( "DG.Tweening.Sequence#Setup", this ); }

                    s.autoKill = DG.Tweening.DOTween.defaultAutoKill;
                    s.isRecyclable = DG.Tweening.DOTween.defaultRecyclable;
                    s.isPlaying = DG.Tweening.DOTween.defaultAutoPlay === DG.Tweening.AutoPlay.All || DG.Tweening.DOTween.defaultAutoPlay === DG.Tweening.AutoPlay.AutoPlaySequences;
                    s.loopType = DG.Tweening.DOTween.defaultLoopType;
                    s.easeType = DG.Tweening.Ease.Linear;
                    s.easeOvershootOrAmplitude = DG.Tweening.DOTween.defaultEaseOvershootOrAmplitude;
                    s.easePeriod = DG.Tweening.DOTween.defaultEasePeriod;
                },
                /*DG.Tweening.Sequence.Setup:static end.*/

                /*DG.Tweening.Sequence.DoStartup:static start.*/
                DoStartup: function (s) {
if ( TRACE ) { TRACE( "DG.Tweening.Sequence#DoStartup", this ); }

                    var sequencedObjsLen = s._sequencedObjs.Count;
                    if (s.sequencedTweens.Count === 0 && sequencedObjsLen === 0 && !DG.Tweening.Sequence.IsAnyCallbackSet(s)) {
                        return false; // Empty Sequence without any callback set
                    }

                    s.startupDone = true;
                    s.fullDuration = s.loops > -1 ? s.duration * s.loops : window.Infinity;
                    // Order sequencedObjs by start position
                    DG.Tweening.Sequence.StableSortSequencedObjs(s._sequencedObjs);
                    //            s._sequencedObjs.Sort(SortSequencedObjs); // Quicker old method that didn't implement stable sort
                    // Set relative nested tweens
                    if (s.isRelative) {
                        for (var len = s.sequencedTweens.Count, i = 0; i < len; ++i) {
                            var t = s.sequencedTweens.getItem(i);
                            if (!s.isBlendable) {
                                s.sequencedTweens.getItem(i).isRelative = true;
                            }
                        }
                    }

                    if (s.isInverted) {
                        // Complete all tweens on startup and invert them, so that we can start from the end
                        for (var i1 = 0; i1 < sequencedObjsLen; i1++) {
                            var sequentiable = s._sequencedObjs.getItem(i1);
                            if (sequentiable.tweenType === DG.Tweening.TweenType.Tweener) {
                                var t1 = Bridge.cast(sequentiable, DG.Tweening.Tween);
                                DG.Tweening.Core.TweenManager.Goto(t1, t1.duration * t1.loops, false, DG.Tweening.Core.Enums.UpdateMode.IgnoreOnComplete);
                                t1.isInverted = true;
                            }
                        }
                    }

                    return true;
                },
                /*DG.Tweening.Sequence.DoStartup:static end.*/

                /*DG.Tweening.Sequence.DoApplyTween:static start.*/
                DoApplyTween: function (s, prevPosition, prevCompletedLoops, newCompletedSteps, useInversePosition, updateMode) {
if ( TRACE ) { TRACE( "DG.Tweening.Sequence#DoApplyTween", this ); }

                    // Adapt to eventual ease position
                    var prevPos = prevPosition;
                    var newPos = s.position;
                    if (s.isInverted) {
                        useInversePosition = !useInversePosition;
                    }

                    if (s.easeType !== DG.Tweening.Ease.Linear) {
                        prevPos = s.duration * DG.Tweening.Core.Easing.EaseManager.Evaluate(s.easeType, s.customEase, prevPos, s.duration, s.easeOvershootOrAmplitude, s.easePeriod);
                        newPos = s.duration * DG.Tweening.Core.Easing.EaseManager.Evaluate(s.easeType, s.customEase, newPos, s.duration, s.easeOvershootOrAmplitude, s.easePeriod);
                    }

                    var from, to = 0;
                    // Determine if prevPos was inverse.
                    // Used to calculate correct "from" value when applying internal cycle
                    // and also in case of multiple loops within a single update
                    var prevPosIsInverse = (s.loops === -1 || s.loops > 1) && s.loopType === DG.Tweening.LoopType.Yoyo && (prevPos < s.duration ? prevCompletedLoops % 2 !== 0 : prevCompletedLoops % 2 === 0);
                    if (s.isBackwards) {
                        prevPosIsInverse = !prevPosIsInverse;
                    }

                    if (s.isInverted) {
                        prevPosIsInverse = !prevPosIsInverse;
                    }

                    // Update multiple loop cycles within the same update
                    if (newCompletedSteps > 0) {
                        //                Debug.Log(Time.frameCount + " <color=#FFEC03>newCompletedSteps = " + newCompletedSteps + "</color> - completedLoops: " + s.completedLoops + " - updateMode: " + updateMode);
                        // Store expected completedLoops and position, in order to check them after the update cycles.
                        var expectedCompletedLoops = s.completedLoops;
                        var expectedPosition = s.position;
                        //
                        var cycles = newCompletedSteps;
                        var cyclesDone = 0;
                        from = prevPos;
                        if (updateMode === DG.Tweening.Core.Enums.UpdateMode.Update) {
                            // Run all cycles elapsed since last update
                            while (cyclesDone < cycles) {
                                if (cyclesDone > 0) {
                                    from = to;
                                } else if (prevPosIsInverse && !s.isBackwards) {
                                    from = s.duration - from;
                                }

                                to = prevPosIsInverse ? 0 : s.duration;
                                if (DG.Tweening.Sequence.ApplyInternalCycle(s, from, to, updateMode, useInversePosition, prevPosIsInverse, true)) {
                                    return true;
                                }

                                cyclesDone++;
                                if (s.hasLoops && s.loopType === DG.Tweening.LoopType.Yoyo) {
                                    prevPosIsInverse = !prevPosIsInverse;
                                }
                            }

                            // If completedLoops or position were changed by some callback, exit here
                            //                    Debug.Log("     Internal Cycle Ended > expecteCompletedLoops/completedLoops: " + expectedCompletedLoops + "/" + s.completedLoops + " - expectedPosition/position: " + expectedPosition + "/" + s.position);
                            if (expectedCompletedLoops !== s.completedLoops || Math.abs(expectedPosition - s.position) > 1.401298E-45) {
                                return !s.active;
                            }
                        } else {
                            // Simply determine correct prevPosition after steps
                            if (s.hasLoops && s.loopType === DG.Tweening.LoopType.Yoyo && newCompletedSteps % 2 !== 0) {
                                prevPosIsInverse = !prevPosIsInverse;
                                prevPos = s.duration - prevPos;
                            }

                            newCompletedSteps = 0;
                        }
                    }

                    // Run current cycle
                    if (newCompletedSteps === 1 && s.isComplete) {
                        return false; // Skip update if complete because multicycle took care of it
                    }

                    if (newCompletedSteps > 0 && !s.isComplete) {
                        from = useInversePosition ? s.duration : 0;
                        // In case of Restart loop rewind all tweens (keep "to > 0" or remove it?)
                        if (s.loopType === DG.Tweening.LoopType.Restart && to > 0) {
                            DG.Tweening.Sequence.ApplyInternalCycle(s, s.duration, 0, DG.Tweening.Core.Enums.UpdateMode.Goto, false, false);
                        }
                    } else {
                        from = useInversePosition ? s.duration - prevPos : prevPos;
                    }

                    return DG.Tweening.Sequence.ApplyInternalCycle(s, from, useInversePosition ? s.duration - newPos : newPos, updateMode, useInversePosition, prevPosIsInverse);
                },
                /*DG.Tweening.Sequence.DoApplyTween:static end.*/

                /*DG.Tweening.Sequence.ApplyInternalCycle:static start.*/
                ApplyInternalCycle: function (s, fromPos, toPos, updateMode, useInverse, prevPosIsInverse, multiCycleStep) {
if ( TRACE ) { TRACE( "DG.Tweening.Sequence#ApplyInternalCycle", this ); }

                    if (multiCycleStep === void 0) { multiCycleStep = false; }
                    var wasPlaying = s.isPlaying; // Used to interrupt for loops in case a callback pauses a running Sequence
                    var isBackwardsUpdate = toPos < fromPos;
                    //            Debug.Log(Time.frameCount + " " + s.id + " " + (multiCycleStep ? "<color=#FFEC03>Multicycle</color> > " : "Cycle > ") + s.position + "/" + s.duration + " - s.isBackwards: " + s.isBackwards + ", useInverse/prevInverse: " + useInverse + "/" + prevPosIsInverse + " - " + fromPos + " > " + toPos + " - UpdateMode: " + updateMode + ", isPlaying: " + s.isPlaying + ", completedLoops: " + s.completedLoops);
                    if (isBackwardsUpdate) {
                        var len = s._sequencedObjs.Count - 1;
                        for (var i = len; i > -1; --i) {
                            if (!s.active) {
                                return true; // Killed by some internal callback
                            }

                            if (!s.isPlaying && wasPlaying) {
                                return false; // Paused by internal callback
                            }

                            var sequentiable = s._sequencedObjs.getItem(i);
                            if (sequentiable.sequencedEndPosition < toPos || sequentiable.sequencedPosition > fromPos) {
                                continue;
                            }

                            if (sequentiable.tweenType === DG.Tweening.TweenType.Callback) {
                                if (updateMode === DG.Tweening.Core.Enums.UpdateMode.Update && prevPosIsInverse) {
                                    //                            Debug.Log("<color=#FFEC03>BACKWARDS Callback > " + s.id + " - s.isBackwards: " + s.isBackwards + ", useInverse/prevInverse: " + useInverse + "/" + prevPosIsInverse + " - " + fromPos + " > " + toPos + "</color>");
                                    DG.Tweening.Tween.OnTweenCallback(sequentiable.onStart, s);
                                }
                            } else {
                                // Nested Tweener/Sequence
                                var gotoPos = toPos - sequentiable.sequencedPosition;
                                //                        float gotoPos = (float)((decimal)toPos - (decimal)sequentiable.sequencedPosition);
                                if (gotoPos < 0) {
                                    gotoPos = 0;
                                }

                                var t = Bridge.cast(sequentiable, DG.Tweening.Tween);
                                if (!t.startupDone) {
                                    continue; // since we're going backwards and this tween never started just ignore it
                                }

                                t.isBackwards = true;
                                if (s.isInverted) {
                                    gotoPos = t.fullDuration - gotoPos;
                                }

                                if (DG.Tweening.Core.TweenManager.Goto(t, gotoPos, false, updateMode)) {
                                    // Nested tween failed. If it's the only tween and there's no callbacks mark for killing the whole sequence
                                    // (default behaviour in any case prior to v1.2.060)...
                                    if (DG.Tweening.DOTween.nestedTweenFailureBehaviour === DG.Tweening.Core.Enums.NestedTweenFailureBehaviour.KillWholeSequence) {
                                        return true;
                                    }

                                    if (s.sequencedTweens.Count === 1 && s._sequencedObjs.Count === 1 && !DG.Tweening.Sequence.IsAnyCallbackSet(s)) {
                                        return true;
                                    }

                                    // ...otherwise remove failed tween from Sequence and continue
                                    DG.Tweening.Core.TweenManager.Despawn(t, false);
                                    s._sequencedObjs.removeAt(i);
                                    s.sequencedTweens.remove(t);
                                    --i;
                                    --len;
                                    continue;
                                }

                                // Fixes nested callbacks not being called correctly if main sequence has loops and nested ones don't
                                if (multiCycleStep && t.tweenType === DG.Tweening.TweenType.Sequence) {
                                    if (s.position <= 0 && s.completedLoops === 0) {
                                        t.position = 0;
                                    } else {
                                        var toZero = s.completedLoops === 0 || s.isBackwards && (s.completedLoops < s.loops || s.loops === -1);
                                        if (t.isBackwards) {
                                            toZero = !toZero;
                                        }

                                        if (useInverse) {
                                            toZero = !toZero;
                                        }

                                        if (s.isBackwards && !useInverse && !prevPosIsInverse) {
                                            toZero = !toZero;
                                        }

                                        t.position = toZero ? 0 : t.duration;
                                    }
                                }
                            }
                        }
                    } else {
                        var len1 = s._sequencedObjs.Count;
                        for (var i1 = 0; i1 < len1; ++i1) {
                            if (!s.active) {
                                return true; // Killed by some internal callback
                            }

                            if (!s.isPlaying && wasPlaying) {
                                return false; // Paused by internal callback
                            }

                            var sequentiable1 = s._sequencedObjs.getItem(i1);
                            //                    if (sequentiable.sequencedPosition > toPos || sequentiable.sequencedEndPosition < fromPos) continue;
                            // Fix rare case with high FPS when a tween/callback might happen in same exact time as it's set
                            // This fixes it but should check for backwards tweens and loops
                            if (sequentiable1.sequencedPosition > toPos || sequentiable1.sequencedPosition > 0 && sequentiable1.sequencedEndPosition <= fromPos || sequentiable1.sequencedPosition <= 0 && sequentiable1.sequencedEndPosition < fromPos) {
                                continue;
                            }

                            if (sequentiable1.tweenType === DG.Tweening.TweenType.Callback) {
                                if (updateMode === DG.Tweening.Core.Enums.UpdateMode.Update) {
                                    //                            Debug.Log("<color=#FFEC03>FORWARD Callback > " + s.id + " - s.isBackwards: " + s.isBackwards + ", useInverse/prevInverse: " + useInverse + "/" + prevPosIsInverse + " - " + fromPos + " > " + toPos + "</color>");
                                    var fire = !s.isBackwards && !useInverse && !prevPosIsInverse || s.isBackwards && useInverse && !prevPosIsInverse;
                                    if (fire) {
                                        DG.Tweening.Tween.OnTweenCallback(sequentiable1.onStart, s);
                                    }
                                }
                            } else {
                                // Nested Tweener/Sequence
                                var gotoPos1 = toPos - sequentiable1.sequencedPosition;
                                //                        float gotoPos = (float)((decimal)toPos - (decimal)sequentiable.sequencedPosition);
                                if (gotoPos1 < 0) {
                                    gotoPos1 = 0;
                                }

                                var t1 = Bridge.cast(sequentiable1, DG.Tweening.Tween);
                                // Fix for final nested tween not calling OnComplete in some cases
                                if (toPos >= sequentiable1.sequencedEndPosition) {
                                    if (!t1.startupDone) {
                                        DG.Tweening.Core.TweenManager.ForceInit(t1, true);
                                    }

                                    if (gotoPos1 < t1.fullDuration) {
                                        gotoPos1 = t1.fullDuration;
                                    }
                                }

                                //
                                t1.isBackwards = false;
                                if (s.isInverted) {
                                    gotoPos1 = t1.fullDuration - gotoPos1;
                                }

                                if (DG.Tweening.Core.TweenManager.Goto(t1, gotoPos1, false, updateMode)) {
                                    // Nested tween failed. If it's the only tween and there's no callbacks mark for killing the whole sequence
                                    // (default behaviour in any case prior to v1.2.060)...
                                    if (DG.Tweening.DOTween.nestedTweenFailureBehaviour === DG.Tweening.Core.Enums.NestedTweenFailureBehaviour.KillWholeSequence) {
                                        return true;
                                    }

                                    if (s.sequencedTweens.Count === 1 && s._sequencedObjs.Count === 1 && !DG.Tweening.Sequence.IsAnyCallbackSet(s)) {
                                        return true;
                                    }

                                    // ...otherwise remove failed tween from Sequence and continue
                                    DG.Tweening.Core.TweenManager.Despawn(t1, false);
                                    s._sequencedObjs.removeAt(i1);
                                    s.sequencedTweens.remove(t1);
                                    --i1;
                                    --len1;
                                    continue;
                                }

                                // Fixes nested callbacks not being called correctly if main sequence has loops and nested ones don't
                                if (multiCycleStep && t1.tweenType === DG.Tweening.TweenType.Sequence) {
                                    if (s.position <= 0 && s.completedLoops === 0) {
                                        t1.position = 0;
                                    } else {
                                        var toZero1 = s.completedLoops === 0 || !s.isBackwards && (s.completedLoops < s.loops || s.loops === -1);
                                        if (t1.isBackwards) {
                                            toZero1 = !toZero1;
                                        }

                                        if (useInverse) {
                                            toZero1 = !toZero1;
                                        }

                                        if (s.isBackwards && !useInverse && !prevPosIsInverse) {
                                            toZero1 = !toZero1;
                                        }

                                        t1.position = toZero1 ? 0 : t1.duration;
                                    }
                                }
                            }
                        }
                    }

                    return false;
                },
                /*DG.Tweening.Sequence.ApplyInternalCycle:static end.*/

                /*DG.Tweening.Sequence.StableSortSequencedObjs:static start.*/
                StableSortSequencedObjs: function (list) {
if ( TRACE ) { TRACE( "DG.Tweening.Sequence#StableSortSequencedObjs", this ); }

                    var len = list.Count;
                    for (var i = 1; i < len; i++) {
                        var j = i;
                        var temp = list.getItem(i);
                        while (j > 0 && list.getItem(j - 1).sequencedPosition > temp.sequencedPosition) {
                            list.setItem(j, list.getItem(j - 1));
                            j = j - 1;
                        }

                        list.setItem(j, temp);
                    }
                },
                /*DG.Tweening.Sequence.StableSortSequencedObjs:static end.*/

                /*DG.Tweening.Sequence.IsAnyCallbackSet:static start.*/
                IsAnyCallbackSet: function (s) {
if ( TRACE ) { TRACE( "DG.Tweening.Sequence#IsAnyCallbackSet", this ); }

                    return !Bridge.staticEquals(s.onComplete, null) || !Bridge.staticEquals(s.onKill, null) || !Bridge.staticEquals(s.onPause, null) || !Bridge.staticEquals(s.onPlay, null) || !Bridge.staticEquals(s.onRewind, null) || !Bridge.staticEquals(s.onStart, null) || !Bridge.staticEquals(s.onStepComplete, null) || !Bridge.staticEquals(s.onUpdate, null);
                },
                /*DG.Tweening.Sequence.IsAnyCallbackSet:static end.*/

                /*DG.Tweening.Sequence.DoPrepend:static start.*/
                DoPrepend: function (inSequence, t) {
if ( TRACE ) { TRACE( "DG.Tweening.Sequence#DoPrepend", this ); }

                    if (t.loops === -1) {
                        t.loops = 2147483647;
                        DG.Tweening.Core.Debugger.LogWarning("Infinite loops aren't allowed inside a Sequence (only on the Sequence itself) and will be changed to int.MaxValue", t);
                    }

                    var tFullTime = t.delay + t.duration * t.loops;
                    //            float tFullTime = t.duration * t.loops;
                    inSequence.duration += tFullTime;
                    var len = inSequence._sequencedObjs.Count;
                    for (var i = 0; i < len; ++i) {
                        var sequentiable = inSequence._sequencedObjs.getItem(i);
                        sequentiable.sequencedPosition += tFullTime;
                        sequentiable.sequencedEndPosition += tFullTime;
                    }

                    return DG.Tweening.Sequence.DoInsert(inSequence, t, 0);
                },
                /*DG.Tweening.Sequence.DoPrepend:static end.*/

                /*DG.Tweening.Sequence.DoInsert:static start.*/
                DoInsert: function (inSequence, t, atPosition) {
if ( TRACE ) { TRACE( "DG.Tweening.Sequence#DoInsert", this ); }

                    DG.Tweening.Core.TweenManager.AddActiveTweenToSequence(t);

                    // If t has a delay add it as an interval
                    atPosition += t.delay;
                    inSequence.lastTweenInsertTime = atPosition;

                    t.isSequenced = (t.creationLocked = true);
                    t.sequenceParent = inSequence;
                    if (t.loops === -1) {
                        t.loops = 2147483647;
                        DG.Tweening.Core.Debugger.LogWarning("Infinite loops aren't allowed inside a Sequence (only on the Sequence itself) and will be changed to int.MaxValue", t);
                    }

                    var tFullTime = t.duration * t.loops;
                    t.autoKill = false;
                    t.delay = (t.elapsedDelay = 0);
                    t.delayComplete = true;
                    if (t.isSpeedBased) {
                        t.isSpeedBased = false;
                        DG.Tweening.Core.Debugger.LogWarning("SpeedBased tweens are not allowed inside a Sequence: interpreting speed as duration", t);
                    }

                    t.sequencedPosition = atPosition;
                    t.sequencedEndPosition = atPosition + tFullTime;

                    if (t.sequencedEndPosition > inSequence.duration) {
                        inSequence.duration = t.sequencedEndPosition;
                    }

                    inSequence._sequencedObjs.add(t);
                    inSequence.sequencedTweens.add(t);

                    return inSequence;
                },
                /*DG.Tweening.Sequence.DoInsert:static end.*/

                /*DG.Tweening.Sequence.DoAppendInterval:static start.*/
                DoAppendInterval: function (inSequence, interval) {
if ( TRACE ) { TRACE( "DG.Tweening.Sequence#DoAppendInterval", this ); }

                    inSequence.lastTweenInsertTime = inSequence.duration;
                    inSequence.duration += interval;
                    return inSequence;
                },
                /*DG.Tweening.Sequence.DoAppendInterval:static end.*/

                /*DG.Tweening.Sequence.DoPrependInterval:static start.*/
                DoPrependInterval: function (inSequence, interval) {
if ( TRACE ) { TRACE( "DG.Tweening.Sequence#DoPrependInterval", this ); }

                    inSequence.lastTweenInsertTime = 0;
                    inSequence.duration += interval;
                    var len = inSequence._sequencedObjs.Count;
                    for (var i = 0; i < len; ++i) {
                        var sequentiable = inSequence._sequencedObjs.getItem(i);
                        sequentiable.sequencedPosition += interval;
                        sequentiable.sequencedEndPosition += interval;
                    }

                    return inSequence;
                },
                /*DG.Tweening.Sequence.DoPrependInterval:static end.*/

                /*DG.Tweening.Sequence.DoInsertCallback:static start.*/
                DoInsertCallback: function (inSequence, callback, atPosition) {
if ( TRACE ) { TRACE( "DG.Tweening.Sequence#DoInsertCallback", this ); }

                    inSequence.lastTweenInsertTime = atPosition;
                    var c = new DG.Tweening.Core.SequenceCallback(atPosition, callback);
                    c.sequencedPosition = (c.sequencedEndPosition = atPosition);
                    inSequence._sequencedObjs.add(c);
                    if (inSequence.duration < atPosition) {
                        inSequence.duration = atPosition;
                    }

                    return inSequence;
                },
                /*DG.Tweening.Sequence.DoInsertCallback:static end.*/


            }
        },
        fields: {
            _sequencedObjs: null,
            sequencedTweens: null,
            lastTweenInsertTime: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Sequence#init", this ); }

                this._sequencedObjs = new (System.Collections.Generic.List$1(DG.Tweening.Core.ABSSequentiable)).ctor();
                this.sequencedTweens = new (System.Collections.Generic.List$1(DG.Tweening.Tween)).ctor();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Sequence#ctor", this ); }

                this.$initialize();
                DG.Tweening.Tween.ctor.call(this);
                this.tweenType = DG.Tweening.TweenType.Sequence;
                this.Reset();
            }
        },
        methods: {
            /*DG.Tweening.Sequence.UpdateDelay start.*/
            UpdateDelay: function (elapsed) {
if ( TRACE ) { TRACE( "DG.Tweening.Sequence#UpdateDelay", this ); }

                var tweenDelay = this.delay;
                if (elapsed > tweenDelay) {
                    // Delay complete
                    this.elapsedDelay = tweenDelay;
                    this.delayComplete = true;
                    return elapsed - tweenDelay;
                }

                this.elapsedDelay = elapsed;
                return 0;
            },
            /*DG.Tweening.Sequence.UpdateDelay end.*/

            /*DG.Tweening.Sequence.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Sequence#Reset", this ); }

                DG.Tweening.Tween.prototype.Reset.call(this);

                this.sequencedTweens.clear();
                this._sequencedObjs.clear();
                this.lastTweenInsertTime = 0;
            },
            /*DG.Tweening.Sequence.Reset end.*/

            /*DG.Tweening.Sequence.Validate start.*/
            Validate: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Sequence#Validate", this ); }

                var len = this.sequencedTweens.Count;
                for (var i = 0; i < len; i++) {
                    if (!this.sequencedTweens.getItem(i).Validate()) {
                        return false;
                    }
                }

                return true;
            },
            /*DG.Tweening.Sequence.Validate end.*/

            /*DG.Tweening.Sequence.Startup start.*/
            Startup: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Sequence#Startup", this ); }

                return DG.Tweening.Sequence.DoStartup(this);
            },
            /*DG.Tweening.Sequence.Startup end.*/

            /*DG.Tweening.Sequence.ApplyTween start.*/
            ApplyTween: function (prevPosition, prevCompletedLoops, newCompletedSteps, useInversePosition, updateMode, updateNotice) {
if ( TRACE ) { TRACE( "DG.Tweening.Sequence#ApplyTween", this ); }

                return DG.Tweening.Sequence.DoApplyTween(this, prevPosition, prevCompletedLoops, newCompletedSteps, useInversePosition, updateMode);
            },
            /*DG.Tweening.Sequence.ApplyTween end.*/


        }
    });
    /*DG.Tweening.Sequence end.*/

    /*DG.Tweening.Core.TweenerCore$3 start.*/
    Bridge.define("DG.Tweening.Core.TweenerCore$3", function (T1, T2, TPlugOptions) { return {
        inherits: [DG.Tweening.Tweener],
        statics: {
            fields: {
                _TxtCantChangeSequencedValues: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenerCore$3#init", this ); }

                    this._TxtCantChangeSequencedValues = "You cannot change the values of a tween contained inside a Sequence";
                }
            }
        },
        fields: {
            startValue: Bridge.getDefaultValue(T2),
            endValue: Bridge.getDefaultValue(T2),
            changeValue: Bridge.getDefaultValue(T2),
            plugOptions: Bridge.getDefaultValue(TPlugOptions),
            getter: null,
            setter: null,
            tweenPlugin: null,
            _colorType: null,
            _color32Type: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenerCore$3#init", this ); }

                this.startValue = Bridge.getDefaultValue(T2);
                this.endValue = Bridge.getDefaultValue(T2);
                this.changeValue = Bridge.getDefaultValue(T2);
                this.plugOptions = Bridge.getDefaultValue(TPlugOptions);
                this._colorType = UnityEngine.Color;
                this._color32Type = UnityEngine.Color32;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenerCore$3#ctor", this ); }

                this.$initialize();
                DG.Tweening.Tweener.ctor.call(this);
                this.typeofT1 = T1;
                this.typeofT2 = T2;
                this.typeofTPlugOptions = TPlugOptions;
                this.tweenType = DG.Tweening.TweenType.Tweener;
                this.Reset();
            }
        },
        methods: {
            /*DG.Tweening.Core.TweenerCore$3.ChangeStartValue start.*/
            ChangeStartValue: function (newStartValue, newDuration) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenerCore$3#ChangeStartValue", this ); }

                if (newDuration === void 0) { newDuration = -1.0; }
                if (this.isSequenced) {
                    DG.Tweening.Core.Debugger.LogError(DG.Tweening.Core.TweenerCore$3(T1,T2,TPlugOptions)._TxtCantChangeSequencedValues, this);
                    return this;
                }
                var valT = Bridge.getType(newStartValue);
                var isColor32ToColor = { };
                if (!this.ValidateChangeValueType(valT, isColor32ToColor)) {
                    DG.Tweening.Core.Debugger.LogError(System.String.concat(System.String.concat("ChangeStartValue: incorrect newStartValue type (is ", Bridge.getTypeName(valT)) + ", should be ", Bridge.getTypeName(this.typeofT2)) + ")", this);
                    return this;
                }

                if (isColor32ToColor.v) {
                    return DG.Tweening.Tweener.DoChangeStartValue(T1, T2, TPlugOptions, this, Bridge.cast(UnityEngine.Color32.op_Implicit(newStartValue), T2), newDuration);
                }

                return DG.Tweening.Tweener.DoChangeStartValue(T1, T2, TPlugOptions, this, Bridge.cast(newStartValue, T2), newDuration);
            },
            /*DG.Tweening.Core.TweenerCore$3.ChangeStartValue end.*/

            /*DG.Tweening.Core.TweenerCore$3.ChangeStartValue$1 start.*/
            /**
             * NO-GC METHOD: changes the start value of a tween and rewinds it (without pausing it).
                 Has no effect with tweens that are inside Sequences
             *
             * @instance
             * @public
             * @this DG.Tweening.Core.TweenerCore$3
             * @memberof DG.Tweening.Core.TweenerCore$3
             * @param   {T2}                                newStartValue    The new start value
             * @param   {number}                            newDuration      If bigger than 0 applies it as the new tween duration
             * @return  {DG.Tweening.Core.TweenerCore$3}
             */
            ChangeStartValue$1: function (newStartValue, newDuration) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenerCore$3#ChangeStartValue$1", this ); }

                if (newDuration === void 0) { newDuration = -1.0; }
                if (this.isSequenced) {
                    DG.Tweening.Core.Debugger.LogError(DG.Tweening.Core.TweenerCore$3(T1,T2,TPlugOptions)._TxtCantChangeSequencedValues, this);
                    return this;
                }

                return DG.Tweening.Tweener.DoChangeStartValue(T1, T2, TPlugOptions, this, Bridge.rValue(newStartValue), newDuration);
            },
            /*DG.Tweening.Core.TweenerCore$3.ChangeStartValue$1 end.*/

            /*DG.Tweening.Core.TweenerCore$3.ChangeEndValue start.*/
            ChangeEndValue: function (newEndValue, snapStartValue) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenerCore$3#ChangeEndValue", this ); }

                return this.ChangeEndValue$1(newEndValue, -1, snapStartValue);
            },
            /*DG.Tweening.Core.TweenerCore$3.ChangeEndValue end.*/

            /*DG.Tweening.Core.TweenerCore$3.ChangeEndValue$1 start.*/
            ChangeEndValue$1: function (newEndValue, newDuration, snapStartValue) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenerCore$3#ChangeEndValue$1", this ); }

                if (newDuration === void 0) { newDuration = -1.0; }
                if (snapStartValue === void 0) { snapStartValue = false; }
                if (this.isSequenced) {
                    DG.Tweening.Core.Debugger.LogError(DG.Tweening.Core.TweenerCore$3(T1,T2,TPlugOptions)._TxtCantChangeSequencedValues, this);
                    return this;
                }
                var valT = Bridge.getType(newEndValue);
                var isColor32ToColor = { };
                if (!this.ValidateChangeValueType(valT, isColor32ToColor)) {
                    DG.Tweening.Core.Debugger.LogError(System.String.concat(System.String.concat("ChangeEndValue: incorrect newEndValue type (is ", Bridge.getTypeName(valT)) + ", should be ", Bridge.getTypeName(this.typeofT2)) + ")", this);
                    return this;
                }

                if (isColor32ToColor.v) {
                    return DG.Tweening.Tweener.DoChangeEndValue(T1, T2, TPlugOptions, this, Bridge.cast(UnityEngine.Color32.op_Implicit(newEndValue), T2), newDuration, snapStartValue);
                }

                return DG.Tweening.Tweener.DoChangeEndValue(T1, T2, TPlugOptions, this, Bridge.cast(newEndValue, T2), newDuration, snapStartValue);
            },
            /*DG.Tweening.Core.TweenerCore$3.ChangeEndValue$1 end.*/

            /*DG.Tweening.Core.TweenerCore$3.ChangeEndValue$2 start.*/
            /**
             * NO-GC METHOD: changes the end value of a tween and rewinds it (without pausing it).
                 Has no effect with tweens that are inside Sequences
             *
             * @instance
             * @public
             * @this DG.Tweening.Core.TweenerCore$3
             * @memberof DG.Tweening.Core.TweenerCore$3
             * @param   {T2}                                newEndValue       The new end value
             * @param   {boolean}                           snapStartValue    If TRUE the start value will become the current target's value, otherwise it will stay the
                 same
             * @return  {DG.Tweening.Core.TweenerCore$3}
             */
            ChangeEndValue$2: function (newEndValue, snapStartValue) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenerCore$3#ChangeEndValue$2", this ); }

                return this.ChangeEndValue$3(Bridge.rValue(newEndValue), -1, snapStartValue);
            },
            /*DG.Tweening.Core.TweenerCore$3.ChangeEndValue$2 end.*/

            /*DG.Tweening.Core.TweenerCore$3.ChangeEndValue$3 start.*/
            /**
             * NO-GC METHOD: changes the end value of a tween and rewinds it (without pausing it).
                 Has no effect with tweens that are inside Sequences
             *
             * @instance
             * @public
             * @this DG.Tweening.Core.TweenerCore$3
             * @memberof DG.Tweening.Core.TweenerCore$3
             * @param   {T2}                                newEndValue       The new end value
             * @param   {number}                            newDuration       If bigger than 0 applies it as the new tween duration
             * @param   {boolean}                           snapStartValue    If TRUE the start value will become the current target's value, otherwise it will stay the
                 same
             * @return  {DG.Tweening.Core.TweenerCore$3}
             */
            ChangeEndValue$3: function (newEndValue, newDuration, snapStartValue) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenerCore$3#ChangeEndValue$3", this ); }

                if (newDuration === void 0) { newDuration = -1.0; }
                if (snapStartValue === void 0) { snapStartValue = false; }
                if (this.isSequenced) {
                    DG.Tweening.Core.Debugger.LogError(DG.Tweening.Core.TweenerCore$3(T1,T2,TPlugOptions)._TxtCantChangeSequencedValues, this);
                    return this;
                }

                return DG.Tweening.Tweener.DoChangeEndValue(T1, T2, TPlugOptions, this, Bridge.rValue(newEndValue), newDuration, snapStartValue);
            },
            /*DG.Tweening.Core.TweenerCore$3.ChangeEndValue$3 end.*/

            /*DG.Tweening.Core.TweenerCore$3.ChangeValues start.*/
            ChangeValues: function (newStartValue, newEndValue, newDuration) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenerCore$3#ChangeValues", this ); }

                if (newDuration === void 0) { newDuration = -1.0; }
                if (this.isSequenced) {
                    DG.Tweening.Core.Debugger.LogError(DG.Tweening.Core.TweenerCore$3(T1,T2,TPlugOptions)._TxtCantChangeSequencedValues, this);
                    return this;
                }
                var valT0 = Bridge.getType(newStartValue);
                var valT1 = Bridge.getType(newEndValue);
                var isColor32ToColor = { };
                if (!this.ValidateChangeValueType(valT0, isColor32ToColor)) {
                    DG.Tweening.Core.Debugger.LogError(System.String.concat(System.String.concat("ChangeValues: incorrect value type (is ", Bridge.getTypeName(valT0)) + ", should be ", Bridge.getTypeName(this.typeofT2)) + ")", this);
                    return this;
                }

                if (!this.ValidateChangeValueType(valT1, isColor32ToColor)) {
                    DG.Tweening.Core.Debugger.LogError(System.String.concat(System.String.concat("ChangeValues: incorrect value type (is ", Bridge.getTypeName(valT1)) + ", should be ", Bridge.getTypeName(this.typeofT2)) + ")", this);
                    return this;
                }

                if (isColor32ToColor.v) {
                    return DG.Tweening.Tweener.DoChangeValues(T1, T2, TPlugOptions, this, Bridge.cast(UnityEngine.Color32.op_Implicit(newStartValue), T2), Bridge.cast(UnityEngine.Color32.op_Implicit(newEndValue), T2), newDuration);
                }

                return DG.Tweening.Tweener.DoChangeValues(T1, T2, TPlugOptions, this, Bridge.cast(newStartValue, T2), Bridge.cast(newEndValue, T2), newDuration);
            },
            /*DG.Tweening.Core.TweenerCore$3.ChangeValues end.*/

            /*DG.Tweening.Core.TweenerCore$3.ChangeValues$1 start.*/
            /**
             * NO-GC METHOD: changes the start and end value of a tween and rewinds it (without pausing it).
                 Has no effect with tweens that are inside Sequences
             *
             * @instance
             * @public
             * @this DG.Tweening.Core.TweenerCore$3
             * @memberof DG.Tweening.Core.TweenerCore$3
             * @param   {T2}                                newStartValue    The new start value
             * @param   {T2}                                newEndValue      The new end value
             * @param   {number}                            newDuration      If bigger than 0 applies it as the new tween duration
             * @return  {DG.Tweening.Core.TweenerCore$3}
             */
            ChangeValues$1: function (newStartValue, newEndValue, newDuration) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenerCore$3#ChangeValues$1", this ); }

                if (newDuration === void 0) { newDuration = -1.0; }
                if (this.isSequenced) {
                    DG.Tweening.Core.Debugger.LogError(DG.Tweening.Core.TweenerCore$3(T1,T2,TPlugOptions)._TxtCantChangeSequencedValues, this);
                    return this;
                }

                return DG.Tweening.Tweener.DoChangeValues(T1, T2, TPlugOptions, this, Bridge.rValue(newStartValue), Bridge.rValue(newEndValue), newDuration);
            },
            /*DG.Tweening.Core.TweenerCore$3.ChangeValues$1 end.*/

            /*DG.Tweening.Core.TweenerCore$3.SetFrom start.*/
            SetFrom: function (relative) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenerCore$3#SetFrom", this ); }

                this.tweenPlugin.SetFrom$1(this, relative);
                this.hasManuallySetStartValue = true;
                return this;
            },
            /*DG.Tweening.Core.TweenerCore$3.SetFrom end.*/

            /*DG.Tweening.Core.TweenerCore$3.SetFrom$1 start.*/
            SetFrom$1: function (fromValue, setImmediately, relative) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenerCore$3#SetFrom$1", this ); }

                this.tweenPlugin.SetFrom(this, Bridge.rValue(fromValue), setImmediately, relative);
                this.hasManuallySetStartValue = true;
                return this;
            },
            /*DG.Tweening.Core.TweenerCore$3.SetFrom$1 end.*/

            /*DG.Tweening.Core.TweenerCore$3.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenerCore$3#Reset", this ); }

                DG.Tweening.Tweener.prototype.Reset.call(this);

                if (this.tweenPlugin != null) {
                    this.tweenPlugin.Reset(this);
                }

                //            plugOptions = new TPlugOptions(); // Generates GC because converts to an Activator.CreateInstance
                //            plugOptions = DOTweenUtils.InstanceCreator<TPlugOptions>.Create(); // Fixes GC allocation using workaround (doesn't work with IL2CPP)
Bridge.rValue(                this.plugOptions).DG$Tweening$Plugins$Options$IPlugOptions$Reset(); // Alternate fix that uses IPlugOptions Reset
                this.getter = null;
                this.setter = null;
                this.hasManuallySetStartValue = false;
                this.isFromAllowed = true;
            },
            /*DG.Tweening.Core.TweenerCore$3.Reset end.*/

            /*DG.Tweening.Core.TweenerCore$3.Validate start.*/
            Validate: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenerCore$3#Validate", this ); }

                try {
                    this.getter();
                } catch ($e1) {
                    $e1 = System.Exception.create($e1);
                    return false;
                }

                return true;
            },
            /*DG.Tweening.Core.TweenerCore$3.Validate end.*/

            /*DG.Tweening.Core.TweenerCore$3.ValidateChangeValueType start.*/
            ValidateChangeValueType: function (newType, isColor32ToColor) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenerCore$3#ValidateChangeValueType", this ); }

                if (Bridge.referenceEquals(newType, this.typeofT2)) {
                    isColor32ToColor.v = false;
                    return true;
                }

                if (Bridge.referenceEquals(this.typeofT2, this._colorType) && Bridge.referenceEquals(newType, this._color32Type)) {
                    isColor32ToColor.v = true;
                    return true;
                }

                isColor32ToColor.v = false;
                return false;
            },
            /*DG.Tweening.Core.TweenerCore$3.ValidateChangeValueType end.*/

            /*DG.Tweening.Core.TweenerCore$3.UpdateDelay start.*/
            UpdateDelay: function (elapsed) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenerCore$3#UpdateDelay", this ); }

                return DG.Tweening.Tweener.DoUpdateDelay(T1, T2, TPlugOptions, this, elapsed);
            },
            /*DG.Tweening.Core.TweenerCore$3.UpdateDelay end.*/

            /*DG.Tweening.Core.TweenerCore$3.Startup start.*/
            Startup: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenerCore$3#Startup", this ); }

                return DG.Tweening.Tweener.DoStartup(T1, T2, TPlugOptions, this);
            },
            /*DG.Tweening.Core.TweenerCore$3.Startup end.*/

            /*DG.Tweening.Core.TweenerCore$3.ApplyTween start.*/
            ApplyTween: function (prevPosition, prevCompletedLoops, newCompletedSteps, useInversePosition, updateMode, updateNotice) {
if ( TRACE ) { TRACE( "DG.Tweening.Core.TweenerCore$3#ApplyTween", this ); }

                if (this.isInverted) {
                    useInversePosition = !useInversePosition;
                }

                var updatePosition = useInversePosition ? this.duration - this.position : this.position;
                if (DG.Tweening.DOTween.useSafeMode) {
                    try {
                        this.tweenPlugin.EvaluateAndApply(Bridge.rValue(this.plugOptions), this, this.isRelative, this.getter, this.setter, updatePosition, Bridge.rValue(this.startValue), Bridge.rValue(this.changeValue), this.duration, useInversePosition, updateNotice);
                    } catch (e) {
                        e = System.Exception.create(e);
                        // Target/field doesn't exist anymore: kill tween
                        if (DG.Tweening.Core.Debugger.ShouldLogSafeModeCapturedError()) {
                            DG.Tweening.Core.Debugger.LogSafeModeCapturedError(System.String.format("Target or field is missing/null ({0}) \u25ba {1}\n\n{2}\n\n", e.TargetSite, e.Message, e.StackTrace), this);
                        }

                        DG.Tweening.DOTween.safeModeReport.Add(DG.Tweening.Core.SafeModeReport.SafeModeReportType.TargetOrFieldMissing);
                        return true;
                    }
                } else {
                    this.tweenPlugin.EvaluateAndApply(Bridge.rValue(this.plugOptions), this, this.isRelative, this.getter, this.setter, updatePosition, Bridge.rValue(this.startValue), Bridge.rValue(this.changeValue), this.duration, useInversePosition, updateNotice);
                }

                return false;
            },
            /*DG.Tweening.Core.TweenerCore$3.ApplyTween end.*/


        },
        overloads: {
            "ChangeStartValue(T2, float)": "ChangeStartValue$1",
            "ChangeEndValue(object, float, bool)": "ChangeEndValue$1",
            "ChangeEndValue(T2, bool)": "ChangeEndValue$2",
            "ChangeEndValue(T2, float, bool)": "ChangeEndValue$3",
            "ChangeValues(T2, T2, float)": "ChangeValues$1",
            "SetFrom(T2, bool, bool)": "SetFrom$1"
        }
    }; });
    /*DG.Tweening.Core.TweenerCore$3 end.*/

    /*DG.Tweening.CustomPlugins.PureQuaternionPlugin start.*/
    /** @namespace DG.Tweening.CustomPlugins */

    /**
     * Straight Quaternion plugin. Instead of using Vector3 values accepts Quaternion values directly.
         <p>Beware: doesn't work with LoopType.Incremental (neither directly nor if inside a LoopType.Incremental
             Sequence).</p><p>To use it, call DOTween.To with the plugin parameter overload, passing it <pre><code>PureQuaternionPlugin.Plug()</code></pre> as
             first parameter
             (do not use any of the other public PureQuaternionPlugin methods):</p><pre><code>DOTween.To(PureQuaternionPlugin.Plug(), ()=&gt; myQuaternionProperty, x=&gt; myQuaternionProperty = x, myQuaternionEndValue, duration);</code></pre>
     *
     * @public
     * @class DG.Tweening.CustomPlugins.PureQuaternionPlugin
     * @augments DG.Tweening.Plugins.Core.ABSTweenPlugin$3
     */
    Bridge.define("DG.Tweening.CustomPlugins.PureQuaternionPlugin", {
        inherits: [DG.Tweening.Plugins.Core.ABSTweenPlugin$3(UnityEngine.Quaternion,UnityEngine.Quaternion,DG.Tweening.Plugins.Options.NoOptions)],
        statics: {
            fields: {
                _plug: null
            },
            methods: {
                /*DG.Tweening.CustomPlugins.PureQuaternionPlugin.Plug:static start.*/
                /**
                 * Plug this plugin inside a DOTween.To call.
                     <p>Example:</p><pre><code>DOTween.To(PureQuaternionPlugin.Plug(), ()=&gt; myQuaternionProperty, x=&gt; myQuaternionProperty = x, myQuaternionEndValue, duration);</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.CustomPlugins.PureQuaternionPlugin
                 * @memberof DG.Tweening.CustomPlugins.PureQuaternionPlugin
                 * @return  {DG.Tweening.CustomPlugins.PureQuaternionPlugin}
                 */
                Plug: function () {
if ( TRACE ) { TRACE( "DG.Tweening.CustomPlugins.PureQuaternionPlugin#Plug", this ); }

                    if (DG.Tweening.CustomPlugins.PureQuaternionPlugin._plug == null) {
                        DG.Tweening.CustomPlugins.PureQuaternionPlugin._plug = new DG.Tweening.CustomPlugins.PureQuaternionPlugin();
                    }

                    return DG.Tweening.CustomPlugins.PureQuaternionPlugin._plug;
                },
                /*DG.Tweening.CustomPlugins.PureQuaternionPlugin.Plug:static end.*/


            }
        },
        methods: {
            /*DG.Tweening.CustomPlugins.PureQuaternionPlugin.Reset start.*/
            /**
             * INTERNAL: do not use
             *
             * @instance
             * @public
             * @override
             * @this DG.Tweening.CustomPlugins.PureQuaternionPlugin
             * @memberof DG.Tweening.CustomPlugins.PureQuaternionPlugin
             * @param   {DG.Tweening.Core.TweenerCore$3}    t
             * @return  {void}
             */
            Reset: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.CustomPlugins.PureQuaternionPlugin#Reset", this ); }
 },
            /*DG.Tweening.CustomPlugins.PureQuaternionPlugin.Reset end.*/

            /*DG.Tweening.CustomPlugins.PureQuaternionPlugin.SetFrom$1 start.*/
            /**
             * INTERNAL: do not use
             *
             * @instance
             * @public
             * @override
             * @this DG.Tweening.CustomPlugins.PureQuaternionPlugin
             * @memberof DG.Tweening.CustomPlugins.PureQuaternionPlugin
             * @param   {DG.Tweening.Core.TweenerCore$3}    t             
             * @param   {boolean}                           isRelative
             * @return  {void}
             */
            SetFrom$1: function (t, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.CustomPlugins.PureQuaternionPlugin#SetFrom$1", this ); }

                var prevEndVal = t.endValue.$clone();
                t.endValue = t.getter().$clone();
                t.startValue = isRelative ? t.endValue.clone().mul( prevEndVal ) : prevEndVal.$clone();
                t.setter(t.startValue.$clone());
            },
            /*DG.Tweening.CustomPlugins.PureQuaternionPlugin.SetFrom$1 end.*/

            /*DG.Tweening.CustomPlugins.PureQuaternionPlugin.SetFrom start.*/
            /**
             * INTERNAL: do not use
             *
             * @instance
             * @public
             * @override
             * @this DG.Tweening.CustomPlugins.PureQuaternionPlugin
             * @memberof DG.Tweening.CustomPlugins.PureQuaternionPlugin
             * @param   {DG.Tweening.Core.TweenerCore$3}    t                 
             * @param   {UnityEngine.Quaternion}            fromValue         
             * @param   {boolean}                           setImmediately    
             * @param   {boolean}                           isRelative
             * @return  {void}
             */
            SetFrom: function (t, fromValue, setImmediately, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.CustomPlugins.PureQuaternionPlugin#SetFrom", this ); }

                if (isRelative) {
                    var currVal = t.getter().$clone();
                    t.endValue = currVal.clone().mul( t.endValue );
                    fromValue = currVal.clone().mul( fromValue );
                }

                t.startValue = fromValue.$clone();
                if (setImmediately) {
                    t.setter(fromValue.$clone());
                }
            },
            /*DG.Tweening.CustomPlugins.PureQuaternionPlugin.SetFrom end.*/

            /*DG.Tweening.CustomPlugins.PureQuaternionPlugin.ConvertToStartValue start.*/
            /**
             * INTERNAL: do not use
             *
             * @instance
             * @public
             * @override
             * @this DG.Tweening.CustomPlugins.PureQuaternionPlugin
             * @memberof DG.Tweening.CustomPlugins.PureQuaternionPlugin
             * @param   {DG.Tweening.Core.TweenerCore$3}    t        
             * @param   {UnityEngine.Quaternion}            value
             * @return  {UnityEngine.Quaternion}
             */
            ConvertToStartValue: function (t, value) {
if ( TRACE ) { TRACE( "DG.Tweening.CustomPlugins.PureQuaternionPlugin#ConvertToStartValue", this ); }

                return value.$clone();
            },
            /*DG.Tweening.CustomPlugins.PureQuaternionPlugin.ConvertToStartValue end.*/

            /*DG.Tweening.CustomPlugins.PureQuaternionPlugin.SetRelativeEndValue start.*/
            /**
             * INTERNAL: do not use
             *
             * @instance
             * @public
             * @override
             * @this DG.Tweening.CustomPlugins.PureQuaternionPlugin
             * @memberof DG.Tweening.CustomPlugins.PureQuaternionPlugin
             * @param   {DG.Tweening.Core.TweenerCore$3}    t
             * @return  {void}
             */
            SetRelativeEndValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.CustomPlugins.PureQuaternionPlugin#SetRelativeEndValue", this ); }

                t.endValue = t.endValue.$clone().clone().mul( t.startValue.$clone() );
            },
            /*DG.Tweening.CustomPlugins.PureQuaternionPlugin.SetRelativeEndValue end.*/

            /*DG.Tweening.CustomPlugins.PureQuaternionPlugin.SetChangeValue start.*/
            /**
             * INTERNAL: do not use
             *
             * @instance
             * @public
             * @override
             * @this DG.Tweening.CustomPlugins.PureQuaternionPlugin
             * @memberof DG.Tweening.CustomPlugins.PureQuaternionPlugin
             * @param   {DG.Tweening.Core.TweenerCore$3}    t
             * @return  {void}
             */
            SetChangeValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.CustomPlugins.PureQuaternionPlugin#SetChangeValue", this ); }

                //            t.changeValue.x = t.endValue.x - t.startValue.x;
                //            t.changeValue.y = t.endValue.y - t.startValue.y;
                //            t.changeValue.z = t.endValue.z - t.startValue.z;
                //            t.changeValue.w = t.endValue.w - t.startValue.w;
                t.changeValue = t.endValue.$clone(); // Special case where changeValue is equal to endValue so it can be applied better
            },
            /*DG.Tweening.CustomPlugins.PureQuaternionPlugin.SetChangeValue end.*/

            /*DG.Tweening.CustomPlugins.PureQuaternionPlugin.GetSpeedBasedDuration start.*/
            /**
             * INTERNAL: do not use
             *
             * @instance
             * @public
             * @override
             * @this DG.Tweening.CustomPlugins.PureQuaternionPlugin
             * @memberof DG.Tweening.CustomPlugins.PureQuaternionPlugin
             * @param   {DG.Tweening.Plugins.Options.NoOptions}    options         
             * @param   {number}                                   unitsXSecond    
             * @param   {UnityEngine.Quaternion}                   changeValue
             * @return  {number}
             */
            GetSpeedBasedDuration: function (options, unitsXSecond, changeValue) {
if ( TRACE ) { TRACE( "DG.Tweening.CustomPlugins.PureQuaternionPlugin#GetSpeedBasedDuration", this ); }

                return changeValue.getPositiveEulerAngles().length() / unitsXSecond;
            },
            /*DG.Tweening.CustomPlugins.PureQuaternionPlugin.GetSpeedBasedDuration end.*/

            /*DG.Tweening.CustomPlugins.PureQuaternionPlugin.EvaluateAndApply start.*/
            /**
             * INTERNAL: do not use
             *
             * @instance
             * @public
             * @override
             * @this DG.Tweening.CustomPlugins.PureQuaternionPlugin
             * @memberof DG.Tweening.CustomPlugins.PureQuaternionPlugin
             * @param   {DG.Tweening.Plugins.Options.NoOptions}    options                 
             * @param   {DG.Tweening.Tween}                        t                       
             * @param   {boolean}                                  isRelative              
             * @param   {DG.Tweening.Core.DOGetter}                getter                  
             * @param   {DG.Tweening.Core.DOSetter}                setter                  
             * @param   {number}                                   elapsed                 
             * @param   {UnityEngine.Quaternion}                   startValue              
             * @param   {UnityEngine.Quaternion}                   changeValue             
             * @param   {number}                                   duration                
             * @param   {boolean}                                  usingInversePosition    
             * @param   {DG.Tweening.Core.Enums.UpdateNotice}      updateNotice
             * @return  {void}
             */
            EvaluateAndApply: function (options, t, isRelative, getter, setter, elapsed, startValue, changeValue, duration, usingInversePosition, updateNotice) {
if ( TRACE ) { TRACE( "DG.Tweening.CustomPlugins.PureQuaternionPlugin#EvaluateAndApply", this ); }

                //            if (t.loopType == LoopType.Incremental) startValue *= changeValue * (t.isComplete ? t.completedLoops - 1 : t.completedLoops);
                //            if (t.isSequenced && t.sequenceParent.loopType == LoopType.Incremental) {
                //                startValue += changeValue * (t.loopType == LoopType.Incremental ? t.loops : 1)
                //                    * (t.sequenceParent.isComplete ? t.sequenceParent.completedLoops - 1 : t.sequenceParent.completedLoops);
                //            }
                var easeVal = DG.Tweening.Core.Easing.EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod);
                setter(new pc.Quat().slerp( startValue, changeValue, easeVal ));
                //            startValue.x += changeValue.x * easeVal;
                //            startValue.y += changeValue.y * easeVal;
                //            startValue.z += changeValue.z * easeVal;
                //            startValue.w += changeValue.w * easeVal;
                //            setter(startValue);
            },
            /*DG.Tweening.CustomPlugins.PureQuaternionPlugin.EvaluateAndApply end.*/


        },
        overloads: {
            "SetFrom(TweenerCore<Quaternion, Quaternion, NoOptions>, bool)": "SetFrom$1"
        }
    });
    /*DG.Tweening.CustomPlugins.PureQuaternionPlugin end.*/

    /*DG.Tweening.Plugins.Color2Plugin start.*/
    Bridge.define("DG.Tweening.Plugins.Color2Plugin", {
        inherits: [DG.Tweening.Plugins.Core.ABSTweenPlugin$3(DG.Tweening.Color2,DG.Tweening.Color2,DG.Tweening.Plugins.Options.ColorOptions)],
        methods: {
            /*DG.Tweening.Plugins.Color2Plugin.Reset start.*/
            Reset: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Color2Plugin#Reset", this ); }
 },
            /*DG.Tweening.Plugins.Color2Plugin.Reset end.*/

            /*DG.Tweening.Plugins.Color2Plugin.SetFrom$1 start.*/
            SetFrom$1: function (t, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Color2Plugin#SetFrom$1", this ); }

                var $t, $t1;
                var prevEndVal = t.endValue.$clone();
                t.endValue = t.getter().$clone();
                if (isRelative) {
                    t.startValue = new DG.Tweening.Color2.$ctor1(($t = t.endValue.ca, new pc.Color( $t.r + prevEndVal.ca.r, $t.g + prevEndVal.ca.g, $t.b + prevEndVal.ca.b, $t.a + prevEndVal.ca.a )), ($t1 = t.endValue.cb, new pc.Color( $t1.r + prevEndVal.cb.r, $t1.g + prevEndVal.cb.g, $t1.b + prevEndVal.cb.b, $t1.a + prevEndVal.cb.a )));
                } else {
                    t.startValue = new DG.Tweening.Color2.$ctor1(prevEndVal.ca.$clone(), prevEndVal.cb.$clone());
                }

                var to = t.endValue.$clone();
                if (!t.plugOptions.alphaOnly) {
                    to = t.startValue.$clone();
                } else {
                    to.ca.a = t.startValue.ca.a;
                    to.cb.a = t.startValue.cb.a;
                }

                t.setter(to.$clone());
            },
            /*DG.Tweening.Plugins.Color2Plugin.SetFrom$1 end.*/

            /*DG.Tweening.Plugins.Color2Plugin.SetFrom start.*/
            SetFrom: function (t, fromValue, setImmediately, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Color2Plugin#SetFrom", this ); }

                if (isRelative) {
                    var currVal = t.getter().$clone();
                    t.endValue = DG.Tweening.Color2.op_Addition(t.endValue.$clone(), currVal.$clone());
                    fromValue = DG.Tweening.Color2.op_Addition(fromValue.$clone(), currVal.$clone());
                }

                t.startValue = fromValue.$clone();
                if (setImmediately) {
                    var to = fromValue.$clone();
                    if (t.plugOptions.alphaOnly) {
                        to = t.getter().$clone();
                        to.ca.a = fromValue.ca.a;
                        to.cb.a = fromValue.cb.a;
                    }

                    t.setter(to.$clone());
                }
            },
            /*DG.Tweening.Plugins.Color2Plugin.SetFrom end.*/

            /*DG.Tweening.Plugins.Color2Plugin.ConvertToStartValue start.*/
            ConvertToStartValue: function (t, value) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Color2Plugin#ConvertToStartValue", this ); }

                return value.$clone();
            },
            /*DG.Tweening.Plugins.Color2Plugin.ConvertToStartValue end.*/

            /*DG.Tweening.Plugins.Color2Plugin.SetRelativeEndValue start.*/
            SetRelativeEndValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Color2Plugin#SetRelativeEndValue", this ); }

                t.endValue = DG.Tweening.Color2.op_Addition(t.endValue.$clone(), t.startValue.$clone());
            },
            /*DG.Tweening.Plugins.Color2Plugin.SetRelativeEndValue end.*/

            /*DG.Tweening.Plugins.Color2Plugin.SetChangeValue start.*/
            SetChangeValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Color2Plugin#SetChangeValue", this ); }

                t.changeValue = DG.Tweening.Color2.op_Subtraction(t.endValue.$clone(), t.startValue.$clone());
            },
            /*DG.Tweening.Plugins.Color2Plugin.SetChangeValue end.*/

            /*DG.Tweening.Plugins.Color2Plugin.GetSpeedBasedDuration start.*/
            GetSpeedBasedDuration: function (options, unitsXSecond, changeValue) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Color2Plugin#GetSpeedBasedDuration", this ); }

                return 1.0 / unitsXSecond;
            },
            /*DG.Tweening.Plugins.Color2Plugin.GetSpeedBasedDuration end.*/

            /*DG.Tweening.Plugins.Color2Plugin.EvaluateAndApply start.*/
            EvaluateAndApply: function (options, t, isRelative, getter, setter, elapsed, startValue, changeValue, duration, usingInversePosition, updateNotice) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.Color2Plugin#EvaluateAndApply", this ); }

                if (t.loopType === DG.Tweening.LoopType.Incremental) {
                    startValue = DG.Tweening.Color2.op_Addition(startValue.$clone(), DG.Tweening.Color2.op_Multiply(changeValue.$clone(), (t.isComplete ? t.completedLoops - 1 : t.completedLoops)));
                }

                if (t.isSequenced && t.sequenceParent.loopType === DG.Tweening.LoopType.Incremental) {
                    startValue = DG.Tweening.Color2.op_Addition(startValue.$clone(), DG.Tweening.Color2.op_Multiply(DG.Tweening.Color2.op_Multiply(changeValue.$clone(), (t.loopType === DG.Tweening.LoopType.Incremental ? t.loops : 1)), (t.sequenceParent.isComplete ? t.sequenceParent.completedLoops - 1 : t.sequenceParent.completedLoops)));
                }

                var easeVal = DG.Tweening.Core.Easing.EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod);
                if (!options.alphaOnly) {
                    startValue.ca.r += changeValue.ca.r * easeVal;
                    startValue.ca.g += changeValue.ca.g * easeVal;
                    startValue.ca.b += changeValue.ca.b * easeVal;
                    startValue.ca.a += changeValue.ca.a * easeVal;
                    startValue.cb.r += changeValue.cb.r * easeVal;
                    startValue.cb.g += changeValue.cb.g * easeVal;
                    startValue.cb.b += changeValue.cb.b * easeVal;
                    startValue.cb.a += changeValue.cb.a * easeVal;
                    setter(startValue.$clone());
                    return;
                }

                // Alpha only
                var res = getter().$clone();
                res.ca.a = startValue.ca.a + changeValue.ca.a * easeVal;
                res.cb.a = startValue.cb.a + changeValue.cb.a * easeVal;
                setter(res.$clone());
            },
            /*DG.Tweening.Plugins.Color2Plugin.EvaluateAndApply end.*/


        },
        overloads: {
            "SetFrom(TweenerCore<Color2, Color2, ColorOptions>, bool)": "SetFrom$1"
        }
    });
    /*DG.Tweening.Plugins.Color2Plugin end.*/

    /*DG.Tweening.Plugins.ColorPlugin start.*/
    Bridge.define("DG.Tweening.Plugins.ColorPlugin", {
        inherits: [DG.Tweening.Plugins.Core.ABSTweenPlugin$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions)],
        methods: {
            /*DG.Tweening.Plugins.ColorPlugin.Reset start.*/
            Reset: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.ColorPlugin#Reset", this ); }
 },
            /*DG.Tweening.Plugins.ColorPlugin.Reset end.*/

            /*DG.Tweening.Plugins.ColorPlugin.SetFrom$1 start.*/
            SetFrom$1: function (t, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.ColorPlugin#SetFrom$1", this ); }

                var prevEndVal = t.endValue.$clone();
                t.endValue = t.getter().$clone();
                t.startValue = isRelative ? new pc.Color( t.endValue.r + prevEndVal.r, t.endValue.g + prevEndVal.g, t.endValue.b + prevEndVal.b, t.endValue.a + prevEndVal.a ) : prevEndVal.$clone();
                var to = t.endValue.$clone();
                if (!t.plugOptions.alphaOnly) {
                    to = t.startValue.$clone();
                } else {
                    to.a = t.startValue.a;
                }

                t.setter(to.$clone());
            },
            /*DG.Tweening.Plugins.ColorPlugin.SetFrom$1 end.*/

            /*DG.Tweening.Plugins.ColorPlugin.SetFrom start.*/
            SetFrom: function (t, fromValue, setImmediately, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.ColorPlugin#SetFrom", this ); }

                if (isRelative) {
                    var currVal = t.getter().$clone();
                    t.endValue = new pc.Color( t.endValue.$clone().r + currVal.$clone().r, t.endValue.$clone().g + currVal.$clone().g, t.endValue.$clone().b + currVal.$clone().b, t.endValue.$clone().a + currVal.$clone().a );
                    fromValue = new pc.Color( fromValue.$clone().r + currVal.$clone().r, fromValue.$clone().g + currVal.$clone().g, fromValue.$clone().b + currVal.$clone().b, fromValue.$clone().a + currVal.$clone().a );
                }

                t.startValue = fromValue.$clone();
                if (setImmediately) {
                    var to = fromValue.$clone();
                    if (t.plugOptions.alphaOnly) {
                        to = t.getter().$clone();
                        to.a = fromValue.a;
                    }

                    t.setter(to.$clone());
                }
            },
            /*DG.Tweening.Plugins.ColorPlugin.SetFrom end.*/

            /*DG.Tweening.Plugins.ColorPlugin.ConvertToStartValue start.*/
            ConvertToStartValue: function (t, value) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.ColorPlugin#ConvertToStartValue", this ); }

                return value.$clone();
            },
            /*DG.Tweening.Plugins.ColorPlugin.ConvertToStartValue end.*/

            /*DG.Tweening.Plugins.ColorPlugin.SetRelativeEndValue start.*/
            SetRelativeEndValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.ColorPlugin#SetRelativeEndValue", this ); }

                t.endValue = new pc.Color( t.endValue.$clone().r + t.startValue.$clone().r, t.endValue.$clone().g + t.startValue.$clone().g, t.endValue.$clone().b + t.startValue.$clone().b, t.endValue.$clone().a + t.startValue.$clone().a );
            },
            /*DG.Tweening.Plugins.ColorPlugin.SetRelativeEndValue end.*/

            /*DG.Tweening.Plugins.ColorPlugin.SetChangeValue start.*/
            SetChangeValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.ColorPlugin#SetChangeValue", this ); }

                t.changeValue = new pc.Color( t.endValue.r - t.startValue.r, t.endValue.g - t.startValue.g, t.endValue.b - t.startValue.b, t.endValue.a - t.startValue.a );
            },
            /*DG.Tweening.Plugins.ColorPlugin.SetChangeValue end.*/

            /*DG.Tweening.Plugins.ColorPlugin.GetSpeedBasedDuration start.*/
            GetSpeedBasedDuration: function (options, unitsXSecond, changeValue) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.ColorPlugin#GetSpeedBasedDuration", this ); }

                return 1.0 / unitsXSecond;
            },
            /*DG.Tweening.Plugins.ColorPlugin.GetSpeedBasedDuration end.*/

            /*DG.Tweening.Plugins.ColorPlugin.EvaluateAndApply start.*/
            EvaluateAndApply: function (options, t, isRelative, getter, setter, elapsed, startValue, changeValue, duration, usingInversePosition, updateNotice) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.ColorPlugin#EvaluateAndApply", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5;
                if (t.loopType === DG.Tweening.LoopType.Incremental) {
                    startValue = ($t1 = ($t = (t.isComplete ? t.completedLoops - 1 : t.completedLoops), new pc.Color( changeValue.r * $t, changeValue.g * $t, changeValue.b * $t, changeValue.a * $t )), new pc.Color( startValue.$clone().r + $t1.r, startValue.$clone().g + $t1.g, startValue.$clone().b + $t1.b, startValue.$clone().a + $t1.a ));
                }

                if (t.isSequenced && t.sequenceParent.loopType === DG.Tweening.LoopType.Incremental) {
                    startValue = ($t5 = ($t3 = ($t2 = (t.loopType === DG.Tweening.LoopType.Incremental ? t.loops : 1), new pc.Color( changeValue.r * $t2, changeValue.g * $t2, changeValue.b * $t2, changeValue.a * $t2 )), $t4 = (t.sequenceParent.isComplete ? t.sequenceParent.completedLoops - 1 : t.sequenceParent.completedLoops), new pc.Color( $t3.r * $t4, $t3.g * $t4, $t3.b * $t4, $t3.a * $t4 )), new pc.Color( startValue.$clone().r + $t5.r, startValue.$clone().g + $t5.g, startValue.$clone().b + $t5.b, startValue.$clone().a + $t5.a ));
                }

                var easeVal = DG.Tweening.Core.Easing.EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod);
                if (!options.alphaOnly) {
                    startValue.r += changeValue.r * easeVal;
                    startValue.g += changeValue.g * easeVal;
                    startValue.b += changeValue.b * easeVal;
                    startValue.a += changeValue.a * easeVal;
                    setter(startValue.$clone());
                    return;
                }

                // Alpha only
                var res = getter().$clone();
                res.a = startValue.a + changeValue.a * easeVal;
                setter(res.$clone());
            },
            /*DG.Tweening.Plugins.ColorPlugin.EvaluateAndApply end.*/


        },
        overloads: {
            "SetFrom(TweenerCore<Color, Color, ColorOptions>, bool)": "SetFrom$1"
        }
    });
    /*DG.Tweening.Plugins.ColorPlugin end.*/

    /*DG.Tweening.Plugins.DoublePlugin start.*/
    Bridge.define("DG.Tweening.Plugins.DoublePlugin", {
        inherits: [DG.Tweening.Plugins.Core.ABSTweenPlugin$3(System.Double,System.Double,DG.Tweening.Plugins.Options.NoOptions)],
        methods: {
            /*DG.Tweening.Plugins.DoublePlugin.Reset start.*/
            Reset: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.DoublePlugin#Reset", this ); }
 },
            /*DG.Tweening.Plugins.DoublePlugin.Reset end.*/

            /*DG.Tweening.Plugins.DoublePlugin.SetFrom$1 start.*/
            SetFrom$1: function (t, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.DoublePlugin#SetFrom$1", this ); }

                var prevEndVal = t.endValue;
                t.endValue = t.getter();
                t.startValue = isRelative ? t.endValue + prevEndVal : prevEndVal;
                t.setter(t.startValue);
            },
            /*DG.Tweening.Plugins.DoublePlugin.SetFrom$1 end.*/

            /*DG.Tweening.Plugins.DoublePlugin.SetFrom start.*/
            SetFrom: function (t, fromValue, setImmediately, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.DoublePlugin#SetFrom", this ); }

                if (isRelative) {
                    var currVal = t.getter();
                    t.endValue += currVal;
                    fromValue += currVal;
                }

                t.startValue = fromValue;
                if (setImmediately) {
                    t.setter(fromValue);
                }
            },
            /*DG.Tweening.Plugins.DoublePlugin.SetFrom end.*/

            /*DG.Tweening.Plugins.DoublePlugin.ConvertToStartValue start.*/
            ConvertToStartValue: function (t, value) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.DoublePlugin#ConvertToStartValue", this ); }

                return value;
            },
            /*DG.Tweening.Plugins.DoublePlugin.ConvertToStartValue end.*/

            /*DG.Tweening.Plugins.DoublePlugin.SetRelativeEndValue start.*/
            SetRelativeEndValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.DoublePlugin#SetRelativeEndValue", this ); }

                t.endValue += t.startValue;
            },
            /*DG.Tweening.Plugins.DoublePlugin.SetRelativeEndValue end.*/

            /*DG.Tweening.Plugins.DoublePlugin.SetChangeValue start.*/
            SetChangeValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.DoublePlugin#SetChangeValue", this ); }

                t.changeValue = t.endValue - t.startValue;
            },
            /*DG.Tweening.Plugins.DoublePlugin.SetChangeValue end.*/

            /*DG.Tweening.Plugins.DoublePlugin.GetSpeedBasedDuration start.*/
            GetSpeedBasedDuration: function (options, unitsXSecond, changeValue) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.DoublePlugin#GetSpeedBasedDuration", this ); }

                var res = changeValue / unitsXSecond;
                if (res < 0) {
                    res = -res;
                }

                return res;
            },
            /*DG.Tweening.Plugins.DoublePlugin.GetSpeedBasedDuration end.*/

            /*DG.Tweening.Plugins.DoublePlugin.EvaluateAndApply start.*/
            EvaluateAndApply: function (options, t, isRelative, getter, setter, elapsed, startValue, changeValue, duration, usingInversePosition, updateNotice) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.DoublePlugin#EvaluateAndApply", this ); }

                if (t.loopType === DG.Tweening.LoopType.Incremental) {
                    startValue += changeValue * (t.isComplete ? t.completedLoops - 1 : t.completedLoops);
                }

                if (t.isSequenced && t.sequenceParent.loopType === DG.Tweening.LoopType.Incremental) {
                    startValue += changeValue * (t.loopType === DG.Tweening.LoopType.Incremental ? t.loops : 1) * (t.sequenceParent.isComplete ? t.sequenceParent.completedLoops - 1 : t.sequenceParent.completedLoops);
                }

                setter(startValue + changeValue * DG.Tweening.Core.Easing.EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod));
            },
            /*DG.Tweening.Plugins.DoublePlugin.EvaluateAndApply end.*/


        },
        overloads: {
            "SetFrom(TweenerCore<double, double, NoOptions>, bool)": "SetFrom$1"
        }
    });
    /*DG.Tweening.Plugins.DoublePlugin end.*/

    /*DG.Tweening.Plugins.FloatPlugin start.*/
    Bridge.define("DG.Tweening.Plugins.FloatPlugin", {
        inherits: [DG.Tweening.Plugins.Core.ABSTweenPlugin$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions)],
        methods: {
            /*DG.Tweening.Plugins.FloatPlugin.Reset start.*/
            Reset: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.FloatPlugin#Reset", this ); }
 },
            /*DG.Tweening.Plugins.FloatPlugin.Reset end.*/

            /*DG.Tweening.Plugins.FloatPlugin.SetFrom$1 start.*/
            SetFrom$1: function (t, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.FloatPlugin#SetFrom$1", this ); }

                var prevEndVal = t.endValue;
                t.endValue = t.getter();
                t.startValue = isRelative ? t.endValue + prevEndVal : prevEndVal;
                t.setter(!t.plugOptions.snapping ? t.startValue : Bridge.Math.round(t.startValue, 0, 6));
            },
            /*DG.Tweening.Plugins.FloatPlugin.SetFrom$1 end.*/

            /*DG.Tweening.Plugins.FloatPlugin.SetFrom start.*/
            SetFrom: function (t, fromValue, setImmediately, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.FloatPlugin#SetFrom", this ); }

                if (isRelative) {
                    var currVal = t.getter();
                    t.endValue += currVal;
                    fromValue += currVal;
                }

                t.startValue = fromValue;
                if (setImmediately) {
                    t.setter(!t.plugOptions.snapping ? fromValue : Bridge.Math.round(fromValue, 0, 6));
                }
            },
            /*DG.Tweening.Plugins.FloatPlugin.SetFrom end.*/

            /*DG.Tweening.Plugins.FloatPlugin.ConvertToStartValue start.*/
            ConvertToStartValue: function (t, value) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.FloatPlugin#ConvertToStartValue", this ); }

                return value;
            },
            /*DG.Tweening.Plugins.FloatPlugin.ConvertToStartValue end.*/

            /*DG.Tweening.Plugins.FloatPlugin.SetRelativeEndValue start.*/
            SetRelativeEndValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.FloatPlugin#SetRelativeEndValue", this ); }

                t.endValue += t.startValue;
            },
            /*DG.Tweening.Plugins.FloatPlugin.SetRelativeEndValue end.*/

            /*DG.Tweening.Plugins.FloatPlugin.SetChangeValue start.*/
            SetChangeValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.FloatPlugin#SetChangeValue", this ); }

                t.changeValue = t.endValue - t.startValue;
            },
            /*DG.Tweening.Plugins.FloatPlugin.SetChangeValue end.*/

            /*DG.Tweening.Plugins.FloatPlugin.GetSpeedBasedDuration start.*/
            GetSpeedBasedDuration: function (options, unitsXSecond, changeValue) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.FloatPlugin#GetSpeedBasedDuration", this ); }

                var res = changeValue / unitsXSecond;
                if (res < 0) {
                    res = -res;
                }

                return res;
            },
            /*DG.Tweening.Plugins.FloatPlugin.GetSpeedBasedDuration end.*/

            /*DG.Tweening.Plugins.FloatPlugin.EvaluateAndApply start.*/
            EvaluateAndApply: function (options, t, isRelative, getter, setter, elapsed, startValue, changeValue, duration, usingInversePosition, updateNotice) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.FloatPlugin#EvaluateAndApply", this ); }

                if (t.loopType === DG.Tweening.LoopType.Incremental) {
                    startValue += changeValue * (t.isComplete ? t.completedLoops - 1 : t.completedLoops);
                }

                if (t.isSequenced && t.sequenceParent.loopType === DG.Tweening.LoopType.Incremental) {
                    startValue += changeValue * (t.loopType === DG.Tweening.LoopType.Incremental ? t.loops : 1) * (t.sequenceParent.isComplete ? t.sequenceParent.completedLoops - 1 : t.sequenceParent.completedLoops);
                }

                setter(!options.snapping ? startValue + changeValue * DG.Tweening.Core.Easing.EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod) : Bridge.Math.round(startValue + changeValue * DG.Tweening.Core.Easing.EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod), 0, 6));
            },
            /*DG.Tweening.Plugins.FloatPlugin.EvaluateAndApply end.*/


        },
        overloads: {
            "SetFrom(TweenerCore<float, float, FloatOptions>, bool)": "SetFrom$1"
        }
    });
    /*DG.Tweening.Plugins.FloatPlugin end.*/

    /*DG.Tweening.Plugins.IntPlugin start.*/
    Bridge.define("DG.Tweening.Plugins.IntPlugin", {
        inherits: [DG.Tweening.Plugins.Core.ABSTweenPlugin$3(System.Int32,System.Int32,DG.Tweening.Plugins.Options.NoOptions)],
        methods: {
            /*DG.Tweening.Plugins.IntPlugin.Reset start.*/
            Reset: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.IntPlugin#Reset", this ); }
 },
            /*DG.Tweening.Plugins.IntPlugin.Reset end.*/

            /*DG.Tweening.Plugins.IntPlugin.SetFrom$1 start.*/
            SetFrom$1: function (t, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.IntPlugin#SetFrom$1", this ); }

                var prevEndVal = t.endValue;
                t.endValue = t.getter();
                t.startValue = isRelative ? t.endValue + prevEndVal : prevEndVal;
                t.setter(t.startValue);
            },
            /*DG.Tweening.Plugins.IntPlugin.SetFrom$1 end.*/

            /*DG.Tweening.Plugins.IntPlugin.SetFrom start.*/
            SetFrom: function (t, fromValue, setImmediately, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.IntPlugin#SetFrom", this ); }

                if (isRelative) {
                    var currVal = t.getter();
                    t.endValue += currVal;
                    fromValue += currVal;
                }

                t.startValue = fromValue;
                if (setImmediately) {
                    t.setter(fromValue);
                }
            },
            /*DG.Tweening.Plugins.IntPlugin.SetFrom end.*/

            /*DG.Tweening.Plugins.IntPlugin.ConvertToStartValue start.*/
            ConvertToStartValue: function (t, value) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.IntPlugin#ConvertToStartValue", this ); }

                return value;
            },
            /*DG.Tweening.Plugins.IntPlugin.ConvertToStartValue end.*/

            /*DG.Tweening.Plugins.IntPlugin.SetRelativeEndValue start.*/
            SetRelativeEndValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.IntPlugin#SetRelativeEndValue", this ); }

                t.endValue += t.startValue;
            },
            /*DG.Tweening.Plugins.IntPlugin.SetRelativeEndValue end.*/

            /*DG.Tweening.Plugins.IntPlugin.SetChangeValue start.*/
            SetChangeValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.IntPlugin#SetChangeValue", this ); }

                t.changeValue = t.endValue - t.startValue;
            },
            /*DG.Tweening.Plugins.IntPlugin.SetChangeValue end.*/

            /*DG.Tweening.Plugins.IntPlugin.GetSpeedBasedDuration start.*/
            GetSpeedBasedDuration: function (options, unitsXSecond, changeValue) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.IntPlugin#GetSpeedBasedDuration", this ); }

                var res = changeValue / unitsXSecond;
                if (res < 0) {
                    res = -res;
                }

                return res;
            },
            /*DG.Tweening.Plugins.IntPlugin.GetSpeedBasedDuration end.*/

            /*DG.Tweening.Plugins.IntPlugin.EvaluateAndApply start.*/
            EvaluateAndApply: function (options, t, isRelative, getter, setter, elapsed, startValue, changeValue, duration, usingInversePosition, updateNotice) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.IntPlugin#EvaluateAndApply", this ); }

                if (t.loopType === DG.Tweening.LoopType.Incremental) {
                    startValue += changeValue * (t.isComplete ? t.completedLoops - 1 : t.completedLoops);
                }

                if (t.isSequenced && t.sequenceParent.loopType === DG.Tweening.LoopType.Incremental) {
                    startValue += changeValue * (t.loopType === DG.Tweening.LoopType.Incremental ? t.loops : 1) * (t.sequenceParent.isComplete ? t.sequenceParent.completedLoops - 1 : t.sequenceParent.completedLoops);
                }

                setter(Bridge.Math.round(startValue + changeValue * DG.Tweening.Core.Easing.EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod), 0, 6));
            },
            /*DG.Tweening.Plugins.IntPlugin.EvaluateAndApply end.*/


        },
        overloads: {
            "SetFrom(TweenerCore<int, int, NoOptions>, bool)": "SetFrom$1"
        }
    });
    /*DG.Tweening.Plugins.IntPlugin end.*/

    /*DG.Tweening.Plugins.LongPlugin start.*/
    Bridge.define("DG.Tweening.Plugins.LongPlugin", {
        inherits: [DG.Tweening.Plugins.Core.ABSTweenPlugin$3(System.Int64,System.Int64,DG.Tweening.Plugins.Options.NoOptions)],
        methods: {
            /*DG.Tweening.Plugins.LongPlugin.Reset start.*/
            Reset: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.LongPlugin#Reset", this ); }
 },
            /*DG.Tweening.Plugins.LongPlugin.Reset end.*/

            /*DG.Tweening.Plugins.LongPlugin.SetFrom$1 start.*/
            SetFrom$1: function (t, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.LongPlugin#SetFrom$1", this ); }

                var prevEndVal = t.endValue;
                t.endValue = t.getter();
                t.startValue = isRelative ? t.endValue.add(prevEndVal) : prevEndVal;
                t.setter(t.startValue);
            },
            /*DG.Tweening.Plugins.LongPlugin.SetFrom$1 end.*/

            /*DG.Tweening.Plugins.LongPlugin.SetFrom start.*/
            SetFrom: function (t, fromValue, setImmediately, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.LongPlugin#SetFrom", this ); }

                if (isRelative) {
                    var currVal = t.getter();
                    t.endValue = t.endValue.add(currVal);
                    fromValue = fromValue.add(currVal);
                }

                t.startValue = fromValue;
                if (setImmediately) {
                    t.setter(fromValue);
                }
            },
            /*DG.Tweening.Plugins.LongPlugin.SetFrom end.*/

            /*DG.Tweening.Plugins.LongPlugin.ConvertToStartValue start.*/
            ConvertToStartValue: function (t, value) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.LongPlugin#ConvertToStartValue", this ); }

                return value;
            },
            /*DG.Tweening.Plugins.LongPlugin.ConvertToStartValue end.*/

            /*DG.Tweening.Plugins.LongPlugin.SetRelativeEndValue start.*/
            SetRelativeEndValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.LongPlugin#SetRelativeEndValue", this ); }

                t.endValue = t.endValue.add(t.startValue);
            },
            /*DG.Tweening.Plugins.LongPlugin.SetRelativeEndValue end.*/

            /*DG.Tweening.Plugins.LongPlugin.SetChangeValue start.*/
            SetChangeValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.LongPlugin#SetChangeValue", this ); }

                t.changeValue = t.endValue.sub(t.startValue);
            },
            /*DG.Tweening.Plugins.LongPlugin.SetChangeValue end.*/

            /*DG.Tweening.Plugins.LongPlugin.GetSpeedBasedDuration start.*/
            GetSpeedBasedDuration: function (options, unitsXSecond, changeValue) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.LongPlugin#GetSpeedBasedDuration", this ); }

                var res = changeValue / unitsXSecond;
                if (res < 0) {
                    res = -res;
                }

                return res;
            },
            /*DG.Tweening.Plugins.LongPlugin.GetSpeedBasedDuration end.*/

            /*DG.Tweening.Plugins.LongPlugin.EvaluateAndApply start.*/
            EvaluateAndApply: function (options, t, isRelative, getter, setter, elapsed, startValue, changeValue, duration, usingInversePosition, updateNotice) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.LongPlugin#EvaluateAndApply", this ); }

                if (t.loopType === DG.Tweening.LoopType.Incremental) {
                    startValue = startValue.add(changeValue.mul(System.Int64((t.isComplete ? t.completedLoops - 1 : t.completedLoops))));
                }

                if (t.isSequenced && t.sequenceParent.loopType === DG.Tweening.LoopType.Incremental) {
                    startValue = startValue.add(changeValue.mul(System.Int64((t.loopType === DG.Tweening.LoopType.Incremental ? t.loops : 1))).mul(System.Int64((t.sequenceParent.isComplete ? t.sequenceParent.completedLoops - 1 : t.sequenceParent.completedLoops))));
                }

                setter(Bridge.Math.round(System.Int64.toNumber(startValue) + System.Int64.toNumber(changeValue) * DG.Tweening.Core.Easing.EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod), 0, 6));
            },
            /*DG.Tweening.Plugins.LongPlugin.EvaluateAndApply end.*/


        },
        overloads: {
            "SetFrom(TweenerCore<long, long, NoOptions>, bool)": "SetFrom$1"
        }
    });
    /*DG.Tweening.Plugins.LongPlugin end.*/

    /*DG.Tweening.Plugins.RectOffsetPlugin start.*/
    Bridge.define("DG.Tweening.Plugins.RectOffsetPlugin", {
        inherits: [DG.Tweening.Plugins.Core.ABSTweenPlugin$3(UnityEngine.RectOffset,UnityEngine.RectOffset,DG.Tweening.Plugins.Options.NoOptions)],
        statics: {
            fields: {
                _r: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.RectOffsetPlugin#init", this ); }

                    this._r = new UnityEngine.RectOffset.ctor();
                }
            }
        },
        methods: {
            /*DG.Tweening.Plugins.RectOffsetPlugin.Reset start.*/
            Reset: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.RectOffsetPlugin#Reset", this ); }

                t.startValue = (t.endValue = (t.changeValue = null));
            },
            /*DG.Tweening.Plugins.RectOffsetPlugin.Reset end.*/

            /*DG.Tweening.Plugins.RectOffsetPlugin.SetFrom$1 start.*/
            SetFrom$1: function (t, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.RectOffsetPlugin#SetFrom$1", this ); }

                var prevEndVal = t.endValue;
                t.endValue = t.getter();
                t.startValue = prevEndVal;
                if (isRelative) {
                    t.startValue.left += t.endValue.left;
                    t.startValue.right += t.endValue.right;
                    t.startValue.top += t.endValue.top;
                    t.startValue.bottom += t.endValue.bottom;
                }

                t.setter(t.startValue);
            },
            /*DG.Tweening.Plugins.RectOffsetPlugin.SetFrom$1 end.*/

            /*DG.Tweening.Plugins.RectOffsetPlugin.SetFrom start.*/
            SetFrom: function (t, fromValue, setImmediately, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.RectOffsetPlugin#SetFrom", this ); }

                if (isRelative) {
                    var currVal = t.getter();
                    t.endValue.left += currVal.left;
                    t.endValue.right += currVal.right;
                    t.endValue.top += currVal.top;
                    t.endValue.bottom += currVal.bottom;
                    fromValue.left += currVal.left;
                    fromValue.right += currVal.right;
                    fromValue.top += currVal.top;
                    fromValue.bottom += currVal.bottom;
                }

                t.startValue = fromValue;
                if (setImmediately) {
                    t.setter(fromValue);
                }
            },
            /*DG.Tweening.Plugins.RectOffsetPlugin.SetFrom end.*/

            /*DG.Tweening.Plugins.RectOffsetPlugin.ConvertToStartValue start.*/
            ConvertToStartValue: function (t, value) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.RectOffsetPlugin#ConvertToStartValue", this ); }

                return new UnityEngine.RectOffset.$ctor1(value.left, value.right, value.top, value.bottom);
            },
            /*DG.Tweening.Plugins.RectOffsetPlugin.ConvertToStartValue end.*/

            /*DG.Tweening.Plugins.RectOffsetPlugin.SetRelativeEndValue start.*/
            SetRelativeEndValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.RectOffsetPlugin#SetRelativeEndValue", this ); }

                t.endValue.left += t.startValue.left;
                t.endValue.right += t.startValue.right;
                t.endValue.top += t.startValue.top;
                t.endValue.bottom += t.startValue.bottom;
            },
            /*DG.Tweening.Plugins.RectOffsetPlugin.SetRelativeEndValue end.*/

            /*DG.Tweening.Plugins.RectOffsetPlugin.SetChangeValue start.*/
            SetChangeValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.RectOffsetPlugin#SetChangeValue", this ); }

                t.changeValue = new UnityEngine.RectOffset.$ctor1(t.endValue.left - t.startValue.left, t.endValue.right - t.startValue.right, t.endValue.top - t.startValue.top, t.endValue.bottom - t.startValue.bottom);
            },
            /*DG.Tweening.Plugins.RectOffsetPlugin.SetChangeValue end.*/

            /*DG.Tweening.Plugins.RectOffsetPlugin.GetSpeedBasedDuration start.*/
            GetSpeedBasedDuration: function (options, unitsXSecond, changeValue) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.RectOffsetPlugin#GetSpeedBasedDuration", this ); }

                // Uses length of diagonal to calculate units.
                var diffW = changeValue.right;
                if (diffW < 0) {
                    diffW = -diffW;
                }

                var diffH = changeValue.bottom;
                if (diffH < 0) {
                    diffH = -diffH;
                }

                var diag = Math.sqrt(diffW * diffW + diffH * diffH);
                return diag / unitsXSecond;
            },
            /*DG.Tweening.Plugins.RectOffsetPlugin.GetSpeedBasedDuration end.*/

            /*DG.Tweening.Plugins.RectOffsetPlugin.EvaluateAndApply start.*/
            EvaluateAndApply: function (options, t, isRelative, getter, setter, elapsed, startValue, changeValue, duration, usingInversePosition, updateNotice) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.RectOffsetPlugin#EvaluateAndApply", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7;
                DG.Tweening.Plugins.RectOffsetPlugin._r.left = startValue.left;
                DG.Tweening.Plugins.RectOffsetPlugin._r.right = startValue.right;
                DG.Tweening.Plugins.RectOffsetPlugin._r.top = startValue.top;
                DG.Tweening.Plugins.RectOffsetPlugin._r.bottom = startValue.bottom;

                if (t.loopType === DG.Tweening.LoopType.Incremental) {
                    var iterations = t.isComplete ? t.completedLoops - 1 : t.completedLoops;
                    $t = DG.Tweening.Plugins.RectOffsetPlugin._r;
                    $t.left += changeValue.left * iterations;
                    $t1 = DG.Tweening.Plugins.RectOffsetPlugin._r;
                    $t1.right += changeValue.right * iterations;
                    $t2 = DG.Tweening.Plugins.RectOffsetPlugin._r;
                    $t2.top += changeValue.top * iterations;
                    $t3 = DG.Tweening.Plugins.RectOffsetPlugin._r;
                    $t3.bottom += changeValue.bottom * iterations;
                }

                if (t.isSequenced && t.sequenceParent.loopType === DG.Tweening.LoopType.Incremental) {
                    var iterations1 = (t.loopType === DG.Tweening.LoopType.Incremental ? t.loops : 1) * (t.sequenceParent.isComplete ? t.sequenceParent.completedLoops - 1 : t.sequenceParent.completedLoops);
                    $t4 = DG.Tweening.Plugins.RectOffsetPlugin._r;
                    $t4.left += changeValue.left * iterations1;
                    $t5 = DG.Tweening.Plugins.RectOffsetPlugin._r;
                    $t5.right += changeValue.right * iterations1;
                    $t6 = DG.Tweening.Plugins.RectOffsetPlugin._r;
                    $t6.top += changeValue.top * iterations1;
                    $t7 = DG.Tweening.Plugins.RectOffsetPlugin._r;
                    $t7.bottom += changeValue.bottom * iterations1;
                }

                var easeVal = DG.Tweening.Core.Easing.EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod);
                setter(new UnityEngine.RectOffset.$ctor1(Bridge.Math.round(DG.Tweening.Plugins.RectOffsetPlugin._r.left + changeValue.left * easeVal, 0, 6), Bridge.Math.round(DG.Tweening.Plugins.RectOffsetPlugin._r.right + changeValue.right * easeVal, 0, 6), Bridge.Math.round(DG.Tweening.Plugins.RectOffsetPlugin._r.top + changeValue.top * easeVal, 0, 6), Bridge.Math.round(DG.Tweening.Plugins.RectOffsetPlugin._r.bottom + changeValue.bottom * easeVal, 0, 6)));
            },
            /*DG.Tweening.Plugins.RectOffsetPlugin.EvaluateAndApply end.*/


        },
        overloads: {
            "SetFrom(TweenerCore<RectOffset, RectOffset, NoOptions>, bool)": "SetFrom$1"
        }
    });
    /*DG.Tweening.Plugins.RectOffsetPlugin end.*/

    /*DG.Tweening.Plugins.UlongPlugin start.*/
    Bridge.define("DG.Tweening.Plugins.UlongPlugin", {
        inherits: [DG.Tweening.Plugins.Core.ABSTweenPlugin$3(System.UInt64,System.UInt64,DG.Tweening.Plugins.Options.NoOptions)],
        methods: {
            /*DG.Tweening.Plugins.UlongPlugin.Reset start.*/
            Reset: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.UlongPlugin#Reset", this ); }
 },
            /*DG.Tweening.Plugins.UlongPlugin.Reset end.*/

            /*DG.Tweening.Plugins.UlongPlugin.SetFrom$1 start.*/
            SetFrom$1: function (t, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.UlongPlugin#SetFrom$1", this ); }

                var prevEndVal = t.endValue;
                t.endValue = t.getter();
                t.startValue = isRelative ? t.endValue.add(prevEndVal) : prevEndVal;
                t.setter(t.startValue);
            },
            /*DG.Tweening.Plugins.UlongPlugin.SetFrom$1 end.*/

            /*DG.Tweening.Plugins.UlongPlugin.SetFrom start.*/
            SetFrom: function (t, fromValue, setImmediately, isRelative) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.UlongPlugin#SetFrom", this ); }

                if (isRelative) {
                    var currVal = t.getter();
                    t.endValue = t.endValue.add(currVal);
                    fromValue = fromValue.add(currVal);
                }

                t.startValue = fromValue;
                if (setImmediately) {
                    t.setter(fromValue);
                }
            },
            /*DG.Tweening.Plugins.UlongPlugin.SetFrom end.*/

            /*DG.Tweening.Plugins.UlongPlugin.ConvertToStartValue start.*/
            ConvertToStartValue: function (t, value) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.UlongPlugin#ConvertToStartValue", this ); }

                return value;
            },
            /*DG.Tweening.Plugins.UlongPlugin.ConvertToStartValue end.*/

            /*DG.Tweening.Plugins.UlongPlugin.SetRelativeEndValue start.*/
            SetRelativeEndValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.UlongPlugin#SetRelativeEndValue", this ); }

                t.endValue = t.endValue.add(t.startValue);
            },
            /*DG.Tweening.Plugins.UlongPlugin.SetRelativeEndValue end.*/

            /*DG.Tweening.Plugins.UlongPlugin.SetChangeValue start.*/
            SetChangeValue: function (t) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.UlongPlugin#SetChangeValue", this ); }

                t.changeValue = t.endValue.sub(t.startValue);
            },
            /*DG.Tweening.Plugins.UlongPlugin.SetChangeValue end.*/

            /*DG.Tweening.Plugins.UlongPlugin.GetSpeedBasedDuration start.*/
            GetSpeedBasedDuration: function (options, unitsXSecond, changeValue) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.UlongPlugin#GetSpeedBasedDuration", this ); }

                var res = changeValue / unitsXSecond;
                if (res < 0) {
                    res = -res;
                }

                return res;
            },
            /*DG.Tweening.Plugins.UlongPlugin.GetSpeedBasedDuration end.*/

            /*DG.Tweening.Plugins.UlongPlugin.EvaluateAndApply start.*/
            EvaluateAndApply: function (options, t, isRelative, getter, setter, elapsed, startValue, changeValue, duration, usingInversePosition, updateNotice) {
if ( TRACE ) { TRACE( "DG.Tweening.Plugins.UlongPlugin#EvaluateAndApply", this ); }

                if (t.loopType === DG.Tweening.LoopType.Incremental) {
                    startValue = startValue.add(changeValue.mul(System.UInt64((t.isComplete ? t.completedLoops - 1 : t.completedLoops))));
                }

                if (t.isSequenced && t.sequenceParent.loopType === DG.Tweening.LoopType.Incremental) {
                    startValue = startValue.add(changeValue.mul(System.UInt64((t.loopType === DG.Tweening.LoopType.Incremental ? t.loops : 1))).mul(System.UInt64((t.sequenceParent.isComplete ? t.sequenceParent.completedLoops - 1 : t.sequenceParent.completedLoops))));
                }

                // Converts ease value to decimal, otherwise final ulong conversion will not be correct
                setter(System.Decimal.toInt(System.Decimal(startValue).add(System.Decimal(changeValue).mul(System.Decimal(DG.Tweening.Core.Easing.EaseManager.Evaluate(t.easeType, t.customEase, elapsed, duration, t.easeOvershootOrAmplitude, t.easePeriod), null, System.Single))), System.UInt64));
            },
            /*DG.Tweening.Plugins.UlongPlugin.EvaluateAndApply end.*/


        },
        overloads: {
            "SetFrom(TweenerCore<ulong, ulong, NoOptions>, bool)": "SetFrom$1"
        }
    });
    /*DG.Tweening.Plugins.UlongPlugin end.*/

    if ( MODULE_reflection ) {
    var $m = Bridge.setMetadata,
        $n = ["System","DG.Tweening"];

    /*DG.Tweening.Core.DOTweenSettings+ModulesSetup start.*/
    $m("DG.Tweening.Core.DOTweenSettings.ModulesSetup", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*DG.Tweening.Core.DOTweenSettings+ModulesSetup end.*/

    /*DG.Tweening.Core.DOTweenSettings+SafeModeOptions start.*/
    $m("DG.Tweening.Core.DOTweenSettings.SafeModeOptions", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*DG.Tweening.Core.DOTweenSettings+SafeModeOptions end.*/

    /*DG.Tweening.Plugins.Core.PathCore.ControlPoint start.*/
    $m("DG.Tweening.Plugins.Core.PathCore.ControlPoint", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*DG.Tweening.Plugins.Core.PathCore.ControlPoint end.*/

    /*DG.Tweening.Plugins.Core.PathCore.Path start.*/
    $m("DG.Tweening.Plugins.Core.PathCore.Path", function () { return {"at":[new System.SerializableAttribute()],"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"controlPoints","t":4,"rt":System.Array.type(DG.Tweening.Plugins.Core.PathCore.ControlPoint),"sn":"controlPoints"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"isFinalized","t":4,"rt":$n[0].Boolean,"sn":"isFinalized","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"length","t":4,"rt":$n[0].Single,"sn":"length","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"lengthsTable","t":4,"rt":$n[0].Array.type(System.Single),"sn":"lengthsTable"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"subdivisions","t":4,"rt":$n[0].Int32,"sn":"subdivisions","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"subdivisionsXSegment","t":4,"rt":$n[0].Int32,"sn":"subdivisionsXSegment","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"timesTable","t":4,"rt":$n[0].Array.type(System.Single),"sn":"timesTable"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"type","t":4,"rt":$n[1].PathType,"sn":"type","box":function ($v) { return Bridge.box($v, DG.Tweening.PathType, System.Enum.toStringFn(DG.Tweening.PathType));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":2,"n":"wps","t":4,"rt":System.Array.type(UnityEngine.Vector3),"sn":"wps"}]}; }, $n);
    /*DG.Tweening.Plugins.Core.PathCore.Path end.*/

    /*DG.Tweening.Core.DOTweenComponent start.*/
    $m("DG.Tweening.Core.DOTweenComponent", function () { return {"at":[new UnityEngine.AddComponentMenu.ctor("")]}; }, $n);
    /*DG.Tweening.Core.DOTweenComponent end.*/

    }});
