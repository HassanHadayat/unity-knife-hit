if ( TRACE ) { TRACE( JSON.parse( '["TMPro.CaretInfo#getDefaultValue","TMPro.CaretInfo#$ctor1","TMPro.CaretInfo#ctor","TMPro.CaretInfo#getHashCode","TMPro.CaretInfo#equals","TMPro.CaretInfo#$clone","TMPro.CodePoint#init","TMPro.Compute_DT_EventArgs#ctor","TMPro.Compute_DT_EventArgs#$ctor1","TMPro.Extents#init","TMPro.Extents#OverrideClone","TMPro.Extents#getDefaultValue","TMPro.Extents#init","TMPro.Extents#$ctor1","TMPro.Extents#ctor","TMPro.Extents#toString","TMPro.Extents#getHashCode","TMPro.Extents#equals","TMPro.Extents#$clone","TMPro.FastAction#init","TMPro.FastAction#Add","TMPro.FastAction#Remove","TMPro.FastAction#Call","TMPro.FastAction$1#init","TMPro.FastAction$1#Add","TMPro.FastAction$1#Remove","TMPro.FastAction$1#Call","TMPro.FastAction$2#init","TMPro.FastAction$2#Add","TMPro.FastAction$2#Remove","TMPro.FastAction$2#Call","TMPro.FastAction$3#init","TMPro.FastAction$3#Add","TMPro.FastAction$3#Remove","TMPro.FastAction$3#Call","TMPro.FontAssetCreationSettings#getDefaultValue","TMPro.FontAssetCreationSettings#$ctor1","TMPro.FontAssetCreationSettings#ctor","TMPro.FontAssetCreationSettings#getHashCode","TMPro.FontAssetCreationSettings#equals","TMPro.FontAssetCreationSettings#$clone","TMPro.GlyphPairKey#getDefaultValue","TMPro.GlyphPairKey#$ctor1","TMPro.GlyphPairKey#$ctor2","TMPro.GlyphPairKey#ctor","TMPro.GlyphPairKey#getHashCode","TMPro.GlyphPairKey#equals","TMPro.GlyphPairKey#$clone","TMPro.GlyphValueRecord_Legacy#op_Addition","TMPro.GlyphValueRecord_Legacy#getDefaultValue","TMPro.GlyphValueRecord_Legacy#$ctor1","TMPro.GlyphValueRecord_Legacy#ctor","TMPro.GlyphValueRecord_Legacy#getHashCode","TMPro.GlyphValueRecord_Legacy#equals","TMPro.GlyphValueRecord_Legacy#$clone","TMPro.HighlightState#op_Equality","TMPro.HighlightState#op_Inequality","TMPro.HighlightState#getDefaultValue","TMPro.HighlightState#init","TMPro.HighlightState#$ctor1","TMPro.HighlightState#ctor","TMPro.HighlightState#Copy","TMPro.HighlightState#getHashCode","TMPro.HighlightState#equals","TMPro.HighlightState#Equals","TMPro.HighlightState#$clone","TMPro.KerningPair#init","TMPro.KerningPair#firstGlyph#get","TMPro.KerningPair#firstGlyph#set","TMPro.KerningPair#firstGlyphAdjustments#get","TMPro.KerningPair#secondGlyph#get","TMPro.KerningPair#secondGlyph#set","TMPro.KerningPair#secondGlyphAdjustments#get","TMPro.KerningPair#ignoreSpacingAdjustments#get","TMPro.KerningPair#init","TMPro.KerningPair#ctor","TMPro.KerningPair#$ctor1","TMPro.KerningPair#$ctor2","TMPro.KerningPair#ConvertLegacyKerningData","TMPro.KerningPairKey#getDefaultValue","TMPro.KerningPairKey#$ctor1","TMPro.KerningPairKey#ctor","TMPro.KerningPairKey#getHashCode","TMPro.KerningPairKey#equals","TMPro.KerningPairKey#$clone","TMPro.KerningTable#ctor","TMPro.KerningTable#AddKerningPair$1","TMPro.KerningTable#AddKerningPair","TMPro.KerningTable#AddGlyphPairAdjustmentRecord","TMPro.KerningTable#RemoveKerningPair$1","TMPro.KerningTable#RemoveKerningPair","TMPro.KerningTable#SortKerningPairs","TMPro.MaterialReference#Contains","TMPro.MaterialReference#AddMaterialReference","TMPro.MaterialReference#AddMaterialReference$1","TMPro.MaterialReference#getDefaultValue","TMPro.MaterialReference#$ctor1","TMPro.MaterialReference#ctor","TMPro.MaterialReference#Copy","TMPro.MaterialReference#getHashCode","TMPro.MaterialReference#equals","TMPro.MaterialReference#$clone","TMPro.MaterialReferenceManager#instance#get","TMPro.MaterialReferenceManager#AddFontAsset","TMPro.MaterialReferenceManager#AddSpriteAsset$1","TMPro.MaterialReferenceManager#AddSpriteAsset","TMPro.MaterialReferenceManager#AddFontMaterial","TMPro.MaterialReferenceManager#AddColorGradientPreset","TMPro.MaterialReferenceManager#TryGetFontAsset","TMPro.MaterialReferenceManager#TryGetSpriteAsset","TMPro.MaterialReferenceManager#TryGetColorGradientPreset","TMPro.MaterialReferenceManager#TryGetMaterial","TMPro.MaterialReferenceManager#init","TMPro.MaterialReferenceManager#AddFontAssetInternal","TMPro.MaterialReferenceManager#AddSpriteAssetInternal$1","TMPro.MaterialReferenceManager#AddSpriteAssetInternal","TMPro.MaterialReferenceManager#AddFontMaterialInternal","TMPro.MaterialReferenceManager#AddColorGradientPreset_Internal","TMPro.MaterialReferenceManager#Contains","TMPro.MaterialReferenceManager#Contains$1","TMPro.MaterialReferenceManager#TryGetFontAssetInternal","TMPro.MaterialReferenceManager#TryGetSpriteAssetInternal","TMPro.MaterialReferenceManager#TryGetColorGradientPresetInternal","TMPro.MaterialReferenceManager#TryGetMaterialInternal","TMPro.Mesh_Extents#getDefaultValue","TMPro.Mesh_Extents#init","TMPro.Mesh_Extents#$ctor1","TMPro.Mesh_Extents#ctor","TMPro.Mesh_Extents#toString","TMPro.Mesh_Extents#getHashCode","TMPro.Mesh_Extents#equals","TMPro.Mesh_Extents#$clone","TMPro.RichTextTagAttribute#getDefaultValue","TMPro.RichTextTagAttribute#ctor","TMPro.RichTextTagAttribute#getHashCode","TMPro.RichTextTagAttribute#equals","TMPro.RichTextTagAttribute#$clone","TMPro.SetPropertyUtility#SetColor","TMPro.SetPropertyUtility#SetEquatableStruct","TMPro.SetPropertyUtility#SetStruct","TMPro.SetPropertyUtility#SetClass","TMPro.ShaderUtilities#ShaderRef_MobileSDF#get","TMPro.ShaderUtilities#ShaderRef_MobileBitmap#get","TMPro.ShaderUtilities#init","TMPro.ShaderUtilities#ctor","TMPro.ShaderUtilities#GetShaderPropertyIDs","TMPro.ShaderUtilities#UpdateShaderRatios","TMPro.ShaderUtilities#GetFontExtent","TMPro.ShaderUtilities#IsMaskingEnabled","TMPro.ShaderUtilities#GetPadding","TMPro.ShaderUtilities#GetPadding$1","TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Frame#getDefaultValue","TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Frame#init","TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Frame#ctor","TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Frame#getHashCode","TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Frame#equals","TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Frame#$clone","TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Meta#getDefaultValue","TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Meta#init","TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Meta#ctor","TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Meta#getHashCode","TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Meta#equals","TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Meta#$clone","TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteDataObject#init","TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteFrame#getDefaultValue","TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteFrame#ctor","TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteFrame#toString","TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteFrame#getHashCode","TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteFrame#equals","TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteFrame#$clone","TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteSize#getDefaultValue","TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteSize#ctor","TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteSize#toString","TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteSize#getHashCode","TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteSize#equals","TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteSize#$clone","TMPro.TagAttribute#getDefaultValue","TMPro.TagAttribute#ctor","TMPro.TagAttribute#getHashCode","TMPro.TagAttribute#equals","TMPro.TagAttribute#$clone","TMPro.TextContainer#init","TMPro.TextContainer#hasChanged#get","TMPro.TextContainer#hasChanged#set","TMPro.TextContainer#pivot#get","TMPro.TextContainer#pivot#set","TMPro.TextContainer#anchorPosition#get","TMPro.TextContainer#anchorPosition#set","TMPro.TextContainer#rect#get","TMPro.TextContainer#rect#set","TMPro.TextContainer#size#get","TMPro.TextContainer#size#set","TMPro.TextContainer#width#get","TMPro.TextContainer#width#set","TMPro.TextContainer#height#get","TMPro.TextContainer#height#set","TMPro.TextContainer#isDefaultWidth#get","TMPro.TextContainer#isDefaultHeight#get","TMPro.TextContainer#isAutoFitting#get","TMPro.TextContainer#isAutoFitting#set","TMPro.TextContainer#corners#get","TMPro.TextContainer#worldCorners#get","TMPro.TextContainer#margins#get","TMPro.TextContainer#margins#set","TMPro.TextContainer#rectTransform#get","TMPro.TextContainer#textMeshPro#get","TMPro.TextContainer#init","TMPro.TextContainer#Awake","TMPro.TextContainer#OnEnable","TMPro.TextContainer#OnDisable","TMPro.TextContainer#OnContainerChanged","TMPro.TextContainer#OnRectTransformDimensionsChange","TMPro.TextContainer#SetRect","TMPro.TextContainer#UpdateCorners","TMPro.TextContainer#GetPivot","TMPro.TextContainer#GetAnchorPosition","TMPro.TMP_Text#init","TMPro.TMP_Text#text#get","TMPro.TMP_Text#text#set","TMPro.TMP_Text#textPreprocessor#get","TMPro.TMP_Text#textPreprocessor#set","TMPro.TMP_Text#isRightToLeftText#get","TMPro.TMP_Text#isRightToLeftText#set","TMPro.TMP_Text#font#get","TMPro.TMP_Text#font#set","TMPro.TMP_Text#fontSharedMaterial#get","TMPro.TMP_Text#fontSharedMaterial#set","TMPro.TMP_Text#fontSharedMaterials#get","TMPro.TMP_Text#fontSharedMaterials#set","TMPro.TMP_Text#fontMaterial#get","TMPro.TMP_Text#fontMaterial#set","TMPro.TMP_Text#fontMaterials#get","TMPro.TMP_Text#fontMaterials#set","TMPro.TMP_Text#color#get","TMPro.TMP_Text#color#set","TMPro.TMP_Text#alpha#get","TMPro.TMP_Text#alpha#set","TMPro.TMP_Text#enableVertexGradient#get","TMPro.TMP_Text#enableVertexGradient#set","TMPro.TMP_Text#colorGradient#get","TMPro.TMP_Text#colorGradient#set","TMPro.TMP_Text#colorGradientPreset#get","TMPro.TMP_Text#colorGradientPreset#set","TMPro.TMP_Text#spriteAsset#get","TMPro.TMP_Text#spriteAsset#set","TMPro.TMP_Text#tintAllSprites#get","TMPro.TMP_Text#tintAllSprites#set","TMPro.TMP_Text#styleSheet#get","TMPro.TMP_Text#styleSheet#set","TMPro.TMP_Text#textStyle#get","TMPro.TMP_Text#textStyle#set","TMPro.TMP_Text#overrideColorTags#get","TMPro.TMP_Text#overrideColorTags#set","TMPro.TMP_Text#faceColor#get","TMPro.TMP_Text#faceColor#set","TMPro.TMP_Text#outlineColor#get","TMPro.TMP_Text#outlineColor#set","TMPro.TMP_Text#outlineWidth#get","TMPro.TMP_Text#outlineWidth#set","TMPro.TMP_Text#fontSize#get","TMPro.TMP_Text#fontSize#set","TMPro.TMP_Text#fontWeight#get","TMPro.TMP_Text#fontWeight#set","TMPro.TMP_Text#pixelsPerUnit#get","TMPro.TMP_Text#enableAutoSizing#get","TMPro.TMP_Text#enableAutoSizing#set","TMPro.TMP_Text#fontSizeMin#get","TMPro.TMP_Text#fontSizeMin#set","TMPro.TMP_Text#fontSizeMax#get","TMPro.TMP_Text#fontSizeMax#set","TMPro.TMP_Text#fontStyle#get","TMPro.TMP_Text#fontStyle#set","TMPro.TMP_Text#isUsingBold#get","TMPro.TMP_Text#horizontalAlignment#get","TMPro.TMP_Text#horizontalAlignment#set","TMPro.TMP_Text#verticalAlignment#get","TMPro.TMP_Text#verticalAlignment#set","TMPro.TMP_Text#alignment#get","TMPro.TMP_Text#alignment#set","TMPro.TMP_Text#characterSpacing#get","TMPro.TMP_Text#characterSpacing#set","TMPro.TMP_Text#wordSpacing#get","TMPro.TMP_Text#wordSpacing#set","TMPro.TMP_Text#lineSpacing#get","TMPro.TMP_Text#lineSpacing#set","TMPro.TMP_Text#lineSpacingAdjustment#get","TMPro.TMP_Text#lineSpacingAdjustment#set","TMPro.TMP_Text#paragraphSpacing#get","TMPro.TMP_Text#paragraphSpacing#set","TMPro.TMP_Text#characterWidthAdjustment#get","TMPro.TMP_Text#characterWidthAdjustment#set","TMPro.TMP_Text#enableWordWrapping#get","TMPro.TMP_Text#enableWordWrapping#set","TMPro.TMP_Text#wordWrappingRatios#get","TMPro.TMP_Text#wordWrappingRatios#set","TMPro.TMP_Text#overflowMode#get","TMPro.TMP_Text#overflowMode#set","TMPro.TMP_Text#isTextOverflowing#get","TMPro.TMP_Text#firstOverflowCharacterIndex#get","TMPro.TMP_Text#linkedTextComponent#get","TMPro.TMP_Text#linkedTextComponent#set","TMPro.TMP_Text#isTextTruncated#get","TMPro.TMP_Text#enableKerning#get","TMPro.TMP_Text#enableKerning#set","TMPro.TMP_Text#extraPadding#get","TMPro.TMP_Text#extraPadding#set","TMPro.TMP_Text#richText#get","TMPro.TMP_Text#richText#set","TMPro.TMP_Text#parseCtrlCharacters#get","TMPro.TMP_Text#parseCtrlCharacters#set","TMPro.TMP_Text#isOverlay#get","TMPro.TMP_Text#isOverlay#set","TMPro.TMP_Text#isOrthographic#get","TMPro.TMP_Text#isOrthographic#set","TMPro.TMP_Text#enableCulling#get","TMPro.TMP_Text#enableCulling#set","TMPro.TMP_Text#ignoreVisibility#get","TMPro.TMP_Text#ignoreVisibility#set","TMPro.TMP_Text#horizontalMapping#get","TMPro.TMP_Text#horizontalMapping#set","TMPro.TMP_Text#verticalMapping#get","TMPro.TMP_Text#verticalMapping#set","TMPro.TMP_Text#mappingUvLineOffset#get","TMPro.TMP_Text#mappingUvLineOffset#set","TMPro.TMP_Text#renderMode#get","TMPro.TMP_Text#renderMode#set","TMPro.TMP_Text#geometrySortingOrder#get","TMPro.TMP_Text#geometrySortingOrder#set","TMPro.TMP_Text#isTextObjectScaleStatic#get","TMPro.TMP_Text#isTextObjectScaleStatic#set","TMPro.TMP_Text#vertexBufferAutoSizeReduction#get","TMPro.TMP_Text#vertexBufferAutoSizeReduction#set","TMPro.TMP_Text#firstVisibleCharacter#get","TMPro.TMP_Text#firstVisibleCharacter#set","TMPro.TMP_Text#maxVisibleCharacters#get","TMPro.TMP_Text#maxVisibleCharacters#set","TMPro.TMP_Text#maxVisibleWords#get","TMPro.TMP_Text#maxVisibleWords#set","TMPro.TMP_Text#maxVisibleLines#get","TMPro.TMP_Text#maxVisibleLines#set","TMPro.TMP_Text#useMaxVisibleDescender#get","TMPro.TMP_Text#useMaxVisibleDescender#set","TMPro.TMP_Text#pageToDisplay#get","TMPro.TMP_Text#pageToDisplay#set","TMPro.TMP_Text#margin#get","TMPro.TMP_Text#margin#set","TMPro.TMP_Text#textInfo#get","TMPro.TMP_Text#havePropertiesChanged#get","TMPro.TMP_Text#havePropertiesChanged#set","TMPro.TMP_Text#isUsingLegacyAnimationComponent#get","TMPro.TMP_Text#isUsingLegacyAnimationComponent#set","TMPro.TMP_Text#transform$1#get","TMPro.TMP_Text#rectTransform$1#get","TMPro.TMP_Text#mesh#get","TMPro.TMP_Text#isVolumetricText#get","TMPro.TMP_Text#isVolumetricText#set","TMPro.TMP_Text#bounds#get","TMPro.TMP_Text#textBounds#get","TMPro.TMP_Text#spriteAnimator#get","TMPro.TMP_Text#flexibleHeight#get","TMPro.TMP_Text#flexibleWidth#get","TMPro.TMP_Text#minWidth#get","TMPro.TMP_Text#minHeight#get","TMPro.TMP_Text#maxWidth#get","TMPro.TMP_Text#maxHeight#get","TMPro.TMP_Text#layoutElement#get","TMPro.TMP_Text#preferredWidth#get","TMPro.TMP_Text#preferredHeight#get","TMPro.TMP_Text#renderedWidth#get","TMPro.TMP_Text#renderedHeight#get","TMPro.TMP_Text#layoutPriority#get","TMPro.TMP_Text#init","TMPro.TMP_Text#LoadFontAsset","TMPro.TMP_Text#SetSharedMaterial","TMPro.TMP_Text#GetMaterial","TMPro.TMP_Text#SetFontBaseMaterial","TMPro.TMP_Text#GetSharedMaterials","TMPro.TMP_Text#SetSharedMaterials","TMPro.TMP_Text#GetMaterials","TMPro.TMP_Text#CreateMaterialInstance","TMPro.TMP_Text#SetVertexColorGradient","TMPro.TMP_Text#SetTextSortingOrder$1","TMPro.TMP_Text#SetTextSortingOrder","TMPro.TMP_Text#SetFaceColor","TMPro.TMP_Text#SetOutlineColor","TMPro.TMP_Text#SetOutlineThickness","TMPro.TMP_Text#SetShaderDepth","TMPro.TMP_Text#SetCulling","TMPro.TMP_Text#UpdateCulling","TMPro.TMP_Text#GetPaddingForMaterial","TMPro.TMP_Text#GetPaddingForMaterial$1","TMPro.TMP_Text#GetTextContainerLocalCorners","TMPro.TMP_Text#ForceMeshUpdate","TMPro.TMP_Text#UpdateGeometry$1","TMPro.TMP_Text#UpdateVertexData$1","TMPro.TMP_Text#UpdateVertexData","TMPro.TMP_Text#SetVertices","TMPro.TMP_Text#UpdateMeshPadding","TMPro.TMP_Text#CrossFadeColor","TMPro.TMP_Text#CrossFadeAlpha","TMPro.TMP_Text#InternalCrossFadeColor","TMPro.TMP_Text#InternalCrossFadeAlpha","TMPro.TMP_Text#ParseInputText","TMPro.TMP_Text#PopulateTextBackingArray$1","TMPro.TMP_Text#PopulateTextBackingArray$2","TMPro.TMP_Text#PopulateTextBackingArray$3","TMPro.TMP_Text#PopulateTextBackingArray","TMPro.TMP_Text#PopulateTextProcessingArray","TMPro.TMP_Text#SetTextInternal","TMPro.TMP_Text#SetText$2","TMPro.TMP_Text#SetText$3","TMPro.TMP_Text#SetText$4","TMPro.TMP_Text#SetText$5","TMPro.TMP_Text#SetText$6","TMPro.TMP_Text#SetText$7","TMPro.TMP_Text#SetText$8","TMPro.TMP_Text#SetText$9","TMPro.TMP_Text#SetText$10","TMPro.TMP_Text#SetText$11","TMPro.TMP_Text#SetText$12","TMPro.TMP_Text#SetText","TMPro.TMP_Text#SetText$1","TMPro.TMP_Text#SetCharArray","TMPro.TMP_Text#SetCharArray$1","TMPro.TMP_Text#GetStyle","TMPro.TMP_Text#ReplaceOpeningStyleTag$1","TMPro.TMP_Text#ReplaceOpeningStyleTag","TMPro.TMP_Text#ReplaceClosingStyleTag$1","TMPro.TMP_Text#ReplaceClosingStyleTag","TMPro.TMP_Text#InsertOpeningStyleTag","TMPro.TMP_Text#InsertClosingStyleTag","TMPro.TMP_Text#GetMarkupTagHashCode","TMPro.TMP_Text#GetMarkupTagHashCode$1","TMPro.TMP_Text#GetStyleHashCode","TMPro.TMP_Text#GetStyleHashCode$1","TMPro.TMP_Text#ResizeInternalArray","TMPro.TMP_Text#ResizeInternalArray$1","TMPro.TMP_Text#AddFloatToInternalTextBackingArray","TMPro.TMP_Text#AddIntegerToInternalTextBackingArray","TMPro.TMP_Text#InternalTextBackingArrayToString","TMPro.TMP_Text#SetArraySizes","TMPro.TMP_Text#GetPreferredValues","TMPro.TMP_Text#GetPreferredValues$1","TMPro.TMP_Text#GetPreferredValues$2","TMPro.TMP_Text#GetPreferredValues$3","TMPro.TMP_Text#GetPreferredWidth","TMPro.TMP_Text#GetPreferredWidth$1","TMPro.TMP_Text#GetPreferredHeight","TMPro.TMP_Text#GetPreferredHeight$1","TMPro.TMP_Text#GetRenderedValues","TMPro.TMP_Text#GetRenderedValues$1","TMPro.TMP_Text#GetRenderedWidth$1","TMPro.TMP_Text#GetRenderedWidth","TMPro.TMP_Text#GetRenderedHeight$1","TMPro.TMP_Text#GetRenderedHeight","TMPro.TMP_Text#CalculatePreferredValues","TMPro.TMP_Text#GetCompoundBounds","TMPro.TMP_Text#GetCanvasSpaceClippingRect","TMPro.TMP_Text#GetTextBounds","TMPro.TMP_Text#GetTextBounds$1","TMPro.TMP_Text#AdjustLineOffset","TMPro.TMP_Text#ResizeLineExtents","TMPro.TMP_Text#GetTextInfo","TMPro.TMP_Text#ComputeMarginSize","TMPro.TMP_Text#InsertNewLine","TMPro.TMP_Text#SaveWordWrappingState","TMPro.TMP_Text#RestoreWordWrappingState","TMPro.TMP_Text#SaveGlyphVertexInfo","TMPro.TMP_Text#SaveSpriteVertexInfo","TMPro.TMP_Text#FillCharacterVertexBuffers","TMPro.TMP_Text#FillCharacterVertexBuffers$1","TMPro.TMP_Text#FillSpriteVertexBuffers","TMPro.TMP_Text#DrawUnderlineMesh","TMPro.TMP_Text#DrawTextHighlight","TMPro.TMP_Text#LoadDefaultSettings","TMPro.TMP_Text#GetSpecialCharacters","TMPro.TMP_Text#GetEllipsisSpecialCharacter","TMPro.TMP_Text#GetUnderlineSpecialCharacter","TMPro.TMP_Text#ReplaceTagWithCharacter","TMPro.TMP_Text#GetFontAssetForWeight","TMPro.TMP_Text#GetTextElement","TMPro.TMP_Text#SetActiveSubMeshes","TMPro.TMP_Text#DestroySubMeshObjects","TMPro.TMP_Text#ClearMesh","TMPro.TMP_Text#ClearMesh$1","TMPro.TMP_Text#GetParsedText","TMPro.TMP_Text#IsSelfOrLinkedAncestor","TMPro.TMP_Text#ReleaseLinkedTextComponent","TMPro.TMP_Text#PackUV$1","TMPro.TMP_Text#PackUV","TMPro.TMP_Text#InternalUpdate","TMPro.TMP_Text#HexToInt","TMPro.TMP_Text#GetUTF16$2","TMPro.TMP_Text#GetUTF16$1","TMPro.TMP_Text#GetUTF16","TMPro.TMP_Text#GetUTF16$3","TMPro.TMP_Text#GetUTF16$4","TMPro.TMP_Text#GetUTF32$2","TMPro.TMP_Text#GetUTF32$1","TMPro.TMP_Text#GetUTF32","TMPro.TMP_Text#GetUTF32$3","TMPro.TMP_Text#GetUTF32$4","TMPro.TMP_Text#HexCharsToColor","TMPro.TMP_Text#HexCharsToColor$1","TMPro.TMP_Text#GetAttributeParameters","TMPro.TMP_Text#ConvertToFloat","TMPro.TMP_Text#ConvertToFloat$1","TMPro.TMP_Text#ValidateHtmlTag","TMPro.TMP_Asset#instanceID#get","TMPro.TMP_TextElement#elementType#get","TMPro.TMP_TextElement#unicode#get","TMPro.TMP_TextElement#unicode#set","TMPro.TMP_TextElement#textAsset#get","TMPro.TMP_TextElement#textAsset#set","TMPro.TMP_TextElement#glyph#get","TMPro.TMP_TextElement#glyph#set","TMPro.TMP_TextElement#glyphIndex#get","TMPro.TMP_TextElement#glyphIndex#set","TMPro.TMP_TextElement#scale#get","TMPro.TMP_TextElement#scale#set","TMPro.TMP_CharacterInfo#getDefaultValue","TMPro.TMP_CharacterInfo#init","TMPro.TMP_CharacterInfo#ctor","TMPro.TMP_CharacterInfo#getHashCode","TMPro.TMP_CharacterInfo#equals","TMPro.TMP_CharacterInfo#$clone","TMPro.TMP_ColorGradient#init","TMPro.TMP_ColorGradient#init","TMPro.TMP_ColorGradient#ctor","TMPro.TMP_ColorGradient#$ctor1","TMPro.TMP_ColorGradient#$ctor2","TMPro.TMP_Compatibility#ConvertTextAlignmentEnumValues","TMPro.TMP_DefaultControls#init","TMPro.TMP_DefaultControls#CreateUIElementRoot","TMPro.TMP_DefaultControls#CreateUIObject","TMPro.TMP_DefaultControls#SetDefaultTextValues","TMPro.TMP_DefaultControls#SetDefaultColorTransitionValues","TMPro.TMP_DefaultControls#SetParentAndAlign","TMPro.TMP_DefaultControls#SetLayerRecursively","TMPro.TMP_DefaultControls#CreateScrollbar","TMPro.TMP_DefaultControls#CreateButton","TMPro.TMP_DefaultControls#CreateText","TMPro.TMP_DefaultControls#CreateInputField","TMPro.TMP_DefaultControls#CreateDropdown","TMPro.TMP_DefaultControls.Resources#getDefaultValue","TMPro.TMP_DefaultControls.Resources#ctor","TMPro.TMP_DefaultControls.Resources#getHashCode","TMPro.TMP_DefaultControls.Resources#equals","TMPro.TMP_DefaultControls.Resources#$clone","TMPro.TMP_Dropdown#init","TMPro.TMP_Dropdown#GetOrAddComponent","TMPro.TMP_Dropdown#template#get","TMPro.TMP_Dropdown#template#set","TMPro.TMP_Dropdown#captionText#get","TMPro.TMP_Dropdown#captionText#set","TMPro.TMP_Dropdown#captionImage#get","TMPro.TMP_Dropdown#captionImage#set","TMPro.TMP_Dropdown#placeholder#get","TMPro.TMP_Dropdown#placeholder#set","TMPro.TMP_Dropdown#itemText#get","TMPro.TMP_Dropdown#itemText#set","TMPro.TMP_Dropdown#itemImage#get","TMPro.TMP_Dropdown#itemImage#set","TMPro.TMP_Dropdown#options#get","TMPro.TMP_Dropdown#options#set","TMPro.TMP_Dropdown#onValueChanged#get","TMPro.TMP_Dropdown#onValueChanged#set","TMPro.TMP_Dropdown#alphaFadeSpeed#get","TMPro.TMP_Dropdown#alphaFadeSpeed#set","TMPro.TMP_Dropdown#value#get","TMPro.TMP_Dropdown#value#set","TMPro.TMP_Dropdown#IsExpanded#get","TMPro.TMP_Dropdown#init","TMPro.TMP_Dropdown#ctor","TMPro.TMP_Dropdown#SetValueWithoutNotify","TMPro.TMP_Dropdown#SetValue","TMPro.TMP_Dropdown#Awake","TMPro.TMP_Dropdown#Start","TMPro.TMP_Dropdown#OnDisable","TMPro.TMP_Dropdown#RefreshShownValue","TMPro.TMP_Dropdown#AddOptions$1","TMPro.TMP_Dropdown#AddOptions","TMPro.TMP_Dropdown#AddOptions$2","TMPro.TMP_Dropdown#ClearOptions","TMPro.TMP_Dropdown#SetupTemplate","TMPro.TMP_Dropdown#OnPointerClick","TMPro.TMP_Dropdown#OnSubmit","TMPro.TMP_Dropdown#OnCancel","TMPro.TMP_Dropdown#Show","TMPro.TMP_Dropdown#CreateBlocker","TMPro.TMP_Dropdown#DestroyBlocker","TMPro.TMP_Dropdown#CreateDropdownList","TMPro.TMP_Dropdown#DestroyDropdownList","TMPro.TMP_Dropdown#CreateItem","TMPro.TMP_Dropdown#DestroyItem","TMPro.TMP_Dropdown#AddItem","TMPro.TMP_Dropdown#AlphaFadeList","TMPro.TMP_Dropdown#AlphaFadeList$1","TMPro.TMP_Dropdown#SetAlpha","TMPro.TMP_Dropdown#Hide","TMPro.TMP_Dropdown#DelayedDestroyDropdownList","TMPro.TMP_Dropdown#ImmediateDestroyDropdownList","TMPro.TMP_Dropdown#OnSelectItem","TMPro.TMP_Dropdown.DropdownItem#text#get","TMPro.TMP_Dropdown.DropdownItem#text#set","TMPro.TMP_Dropdown.DropdownItem#image#get","TMPro.TMP_Dropdown.DropdownItem#image#set","TMPro.TMP_Dropdown.DropdownItem#rectTransform#get","TMPro.TMP_Dropdown.DropdownItem#rectTransform#set","TMPro.TMP_Dropdown.DropdownItem#toggle#get","TMPro.TMP_Dropdown.DropdownItem#toggle#set","TMPro.TMP_Dropdown.DropdownItem#OnPointerEnter","TMPro.TMP_Dropdown.DropdownItem#OnCancel","TMPro.TMP_Dropdown.OptionData#text#get","TMPro.TMP_Dropdown.OptionData#text#set","TMPro.TMP_Dropdown.OptionData#image#get","TMPro.TMP_Dropdown.OptionData#image#set","TMPro.TMP_Dropdown.OptionData#ctor","TMPro.TMP_Dropdown.OptionData#$ctor1","TMPro.TMP_Dropdown.OptionData#$ctor3","TMPro.TMP_Dropdown.OptionData#$ctor2","TMPro.TMP_Dropdown.OptionDataList#options#get","TMPro.TMP_Dropdown.OptionDataList#options#set","TMPro.TMP_Dropdown.OptionDataList#ctor","TMPro.TMP_FontAssetUtilities#instance#get","TMPro.TMP_FontAssetUtilities#init","TMPro.TMP_FontAssetUtilities#ctor","TMPro.TMP_FontAssetUtilities#GetCharacterFromFontAsset","TMPro.TMP_FontAssetUtilities#GetCharacterFromFontAsset_Internal","TMPro.TMP_FontAssetUtilities#GetCharacterFromFontAssets","TMPro.TMP_FontAssetUtilities#GetSpriteCharacterFromSpriteAsset","TMPro.TMP_FontAssetUtilities#GetSpriteCharacterFromSpriteAsset_Internal","TMPro.TMP_FontFeatureTable#glyphPairAdjustmentRecords#get","TMPro.TMP_FontFeatureTable#glyphPairAdjustmentRecords#set","TMPro.TMP_FontFeatureTable#ctor","TMPro.TMP_FontFeatureTable#SortGlyphPairAdjustmentRecords","TMPro.TMP_FontStyleStack#getDefaultValue","TMPro.TMP_FontStyleStack#ctor","TMPro.TMP_FontStyleStack#Copy","TMPro.TMP_FontStyleStack#Clear","TMPro.TMP_FontStyleStack#Add","TMPro.TMP_FontStyleStack#Remove","TMPro.TMP_FontStyleStack#getHashCode","TMPro.TMP_FontStyleStack#equals","TMPro.TMP_FontStyleStack#$clone","TMPro.TMP_FontUtilities#SearchForCharacter$1","TMPro.TMP_FontUtilities#SearchForCharacter","TMPro.TMP_FontUtilities#SearchForCharacterInternal$1","TMPro.TMP_FontUtilities#SearchForCharacterInternal","TMPro.TMP_FontWeightPair#getDefaultValue","TMPro.TMP_FontWeightPair#ctor","TMPro.TMP_FontWeightPair#getHashCode","TMPro.TMP_FontWeightPair#equals","TMPro.TMP_FontWeightPair#$clone","TMPro.TMP_GlyphAdjustmentRecord#getDefaultValue","TMPro.TMP_GlyphAdjustmentRecord#glyphIndex#get","TMPro.TMP_GlyphAdjustmentRecord#glyphIndex#set","TMPro.TMP_GlyphAdjustmentRecord#glyphValueRecord#get","TMPro.TMP_GlyphAdjustmentRecord#glyphValueRecord#set","TMPro.TMP_GlyphAdjustmentRecord#init","TMPro.TMP_GlyphAdjustmentRecord#$ctor1","TMPro.TMP_GlyphAdjustmentRecord#$ctor2","TMPro.TMP_GlyphAdjustmentRecord#ctor","TMPro.TMP_GlyphAdjustmentRecord#getHashCode","TMPro.TMP_GlyphAdjustmentRecord#equals","TMPro.TMP_GlyphAdjustmentRecord#$clone","TMPro.TMP_GlyphPairAdjustmentRecord#firstAdjustmentRecord#get","TMPro.TMP_GlyphPairAdjustmentRecord#firstAdjustmentRecord#set","TMPro.TMP_GlyphPairAdjustmentRecord#secondAdjustmentRecord#get","TMPro.TMP_GlyphPairAdjustmentRecord#secondAdjustmentRecord#set","TMPro.TMP_GlyphPairAdjustmentRecord#featureLookupFlags#get","TMPro.TMP_GlyphPairAdjustmentRecord#featureLookupFlags#set","TMPro.TMP_GlyphPairAdjustmentRecord#init","TMPro.TMP_GlyphPairAdjustmentRecord#ctor","TMPro.TMP_GlyphPairAdjustmentRecord#$ctor1","TMPro.TMP_GlyphValueRecord#op_Addition","TMPro.TMP_GlyphValueRecord#getDefaultValue","TMPro.TMP_GlyphValueRecord#xPlacement#get","TMPro.TMP_GlyphValueRecord#xPlacement#set","TMPro.TMP_GlyphValueRecord#yPlacement#get","TMPro.TMP_GlyphValueRecord#yPlacement#set","TMPro.TMP_GlyphValueRecord#xAdvance#get","TMPro.TMP_GlyphValueRecord#xAdvance#set","TMPro.TMP_GlyphValueRecord#yAdvance#get","TMPro.TMP_GlyphValueRecord#yAdvance#set","TMPro.TMP_GlyphValueRecord#$ctor1","TMPro.TMP_GlyphValueRecord#$ctor2","TMPro.TMP_GlyphValueRecord#$ctor3","TMPro.TMP_GlyphValueRecord#ctor","TMPro.TMP_GlyphValueRecord#getHashCode","TMPro.TMP_GlyphValueRecord#equals","TMPro.TMP_GlyphValueRecord#$clone","TMPro.TMP_InputField#clipboard#get","TMPro.TMP_InputField#clipboard#set","TMPro.TMP_InputField#init","TMPro.TMP_InputField#inputSystem#get","TMPro.TMP_InputField#compositionString#get","TMPro.TMP_InputField#compositionLength#get","TMPro.TMP_InputField#mesh#get","TMPro.TMP_InputField#shouldHideMobileInput#get","TMPro.TMP_InputField#shouldHideMobileInput#set","TMPro.TMP_InputField#shouldHideSoftKeyboard#get","TMPro.TMP_InputField#shouldHideSoftKeyboard#set","TMPro.TMP_InputField#text#get","TMPro.TMP_InputField#text#set","TMPro.TMP_InputField#isFocused#get","TMPro.TMP_InputField#caretBlinkRate#get","TMPro.TMP_InputField#caretBlinkRate#set","TMPro.TMP_InputField#caretWidth#get","TMPro.TMP_InputField#caretWidth#set","TMPro.TMP_InputField#textViewport#get","TMPro.TMP_InputField#textViewport#set","TMPro.TMP_InputField#textComponent#get","TMPro.TMP_InputField#textComponent#set","TMPro.TMP_InputField#placeholder#get","TMPro.TMP_InputField#placeholder#set","TMPro.TMP_InputField#verticalScrollbar#get","TMPro.TMP_InputField#verticalScrollbar#set","TMPro.TMP_InputField#scrollSensitivity#get","TMPro.TMP_InputField#scrollSensitivity#set","TMPro.TMP_InputField#caretColor#get","TMPro.TMP_InputField#caretColor#set","TMPro.TMP_InputField#customCaretColor#get","TMPro.TMP_InputField#customCaretColor#set","TMPro.TMP_InputField#selectionColor#get","TMPro.TMP_InputField#selectionColor#set","TMPro.TMP_InputField#onEndEdit#get","TMPro.TMP_InputField#onEndEdit#set","TMPro.TMP_InputField#onSubmit#get","TMPro.TMP_InputField#onSubmit#set","TMPro.TMP_InputField#onSelect#get","TMPro.TMP_InputField#onSelect#set","TMPro.TMP_InputField#onDeselect#get","TMPro.TMP_InputField#onDeselect#set","TMPro.TMP_InputField#onTextSelection#get","TMPro.TMP_InputField#onTextSelection#set","TMPro.TMP_InputField#onEndTextSelection#get","TMPro.TMP_InputField#onEndTextSelection#set","TMPro.TMP_InputField#onValueChanged#get","TMPro.TMP_InputField#onValueChanged#set","TMPro.TMP_InputField#onTouchScreenKeyboardStatusChanged#get","TMPro.TMP_InputField#onTouchScreenKeyboardStatusChanged#set","TMPro.TMP_InputField#onValidateInput#get","TMPro.TMP_InputField#onValidateInput#set","TMPro.TMP_InputField#characterLimit#get","TMPro.TMP_InputField#characterLimit#set","TMPro.TMP_InputField#pointSize#get","TMPro.TMP_InputField#pointSize#set","TMPro.TMP_InputField#fontAsset#get","TMPro.TMP_InputField#fontAsset#set","TMPro.TMP_InputField#onFocusSelectAll#get","TMPro.TMP_InputField#onFocusSelectAll#set","TMPro.TMP_InputField#resetOnDeActivation#get","TMPro.TMP_InputField#resetOnDeActivation#set","TMPro.TMP_InputField#restoreOriginalTextOnEscape#get","TMPro.TMP_InputField#restoreOriginalTextOnEscape#set","TMPro.TMP_InputField#isRichTextEditingAllowed#get","TMPro.TMP_InputField#isRichTextEditingAllowed#set","TMPro.TMP_InputField#contentType#get","TMPro.TMP_InputField#contentType#set","TMPro.TMP_InputField#lineType#get","TMPro.TMP_InputField#lineType#set","TMPro.TMP_InputField#lineLimit#get","TMPro.TMP_InputField#lineLimit#set","TMPro.TMP_InputField#inputType#get","TMPro.TMP_InputField#inputType#set","TMPro.TMP_InputField#keyboardType#get","TMPro.TMP_InputField#keyboardType#set","TMPro.TMP_InputField#characterValidation#get","TMPro.TMP_InputField#characterValidation#set","TMPro.TMP_InputField#inputValidator#get","TMPro.TMP_InputField#inputValidator#set","TMPro.TMP_InputField#readOnly#get","TMPro.TMP_InputField#readOnly#set","TMPro.TMP_InputField#richText#get","TMPro.TMP_InputField#richText#set","TMPro.TMP_InputField#multiLine#get","TMPro.TMP_InputField#asteriskChar#get","TMPro.TMP_InputField#asteriskChar#set","TMPro.TMP_InputField#wasCanceled#get","TMPro.TMP_InputField#caretPositionInternal#get","TMPro.TMP_InputField#caretPositionInternal#set","TMPro.TMP_InputField#stringPositionInternal#get","TMPro.TMP_InputField#stringPositionInternal#set","TMPro.TMP_InputField#caretSelectPositionInternal#get","TMPro.TMP_InputField#caretSelectPositionInternal#set","TMPro.TMP_InputField#stringSelectPositionInternal#get","TMPro.TMP_InputField#stringSelectPositionInternal#set","TMPro.TMP_InputField#hasSelection$1#get","TMPro.TMP_InputField#caretPosition#get","TMPro.TMP_InputField#caretPosition#set","TMPro.TMP_InputField#selectionAnchorPosition#get","TMPro.TMP_InputField#selectionAnchorPosition#set","TMPro.TMP_InputField#selectionFocusPosition#get","TMPro.TMP_InputField#selectionFocusPosition#set","TMPro.TMP_InputField#stringPosition#get","TMPro.TMP_InputField#stringPosition#set","TMPro.TMP_InputField#selectionStringAnchorPosition#get","TMPro.TMP_InputField#selectionStringAnchorPosition#set","TMPro.TMP_InputField#selectionStringFocusPosition#get","TMPro.TMP_InputField#selectionStringFocusPosition#set","TMPro.TMP_InputField#minWidth#get","TMPro.TMP_InputField#preferredWidth#get","TMPro.TMP_InputField#flexibleWidth#get","TMPro.TMP_InputField#minHeight#get","TMPro.TMP_InputField#preferredHeight#get","TMPro.TMP_InputField#flexibleHeight#get","TMPro.TMP_InputField#layoutPriority#get","TMPro.TMP_InputField#init","TMPro.TMP_InputField#ctor","TMPro.TMP_InputField#isKeyboardUsingEvents","TMPro.TMP_InputField#SetTextWithoutNotify","TMPro.TMP_InputField#SetText","TMPro.TMP_InputField#ClampStringPos","TMPro.TMP_InputField#ClampCaretPos","TMPro.TMP_InputField#OnEnable","TMPro.TMP_InputField#OnDisable","TMPro.TMP_InputField#ON_TEXT_CHANGED","TMPro.TMP_InputField#CaretBlink","TMPro.TMP_InputField#SetCaretVisible","TMPro.TMP_InputField#SetCaretActive","TMPro.TMP_InputField#OnFocus","TMPro.TMP_InputField#SelectAll","TMPro.TMP_InputField#MoveTextEnd","TMPro.TMP_InputField#MoveTextStart","TMPro.TMP_InputField#MoveToEndOfLine","TMPro.TMP_InputField#MoveToStartOfLine","TMPro.TMP_InputField#InPlaceEditing","TMPro.TMP_InputField#UpdateStringPositionFromKeyboard","TMPro.TMP_InputField#LateUpdate","TMPro.TMP_InputField#MayDrag","TMPro.TMP_InputField#OnBeginDrag","TMPro.TMP_InputField#OnDrag","TMPro.TMP_InputField#MouseDragOutsideRect","TMPro.TMP_InputField#OnEndDrag","TMPro.TMP_InputField#OnPointerDown","TMPro.TMP_InputField#KeyPressed","TMPro.TMP_InputField#IsValidChar","TMPro.TMP_InputField#ProcessEvent","TMPro.TMP_InputField#OnUpdateSelected","TMPro.TMP_InputField#OnScroll","TMPro.TMP_InputField#GetScrollPositionRelativeToViewport","TMPro.TMP_InputField#GetSelectedString","TMPro.TMP_InputField#FindNextWordBegin","TMPro.TMP_InputField#MoveRight","TMPro.TMP_InputField#FindPrevWordBegin","TMPro.TMP_InputField#MoveLeft","TMPro.TMP_InputField#LineUpCharacterPosition","TMPro.TMP_InputField#LineDownCharacterPosition","TMPro.TMP_InputField#PageUpCharacterPosition","TMPro.TMP_InputField#PageDownCharacterPosition","TMPro.TMP_InputField#MoveDown","TMPro.TMP_InputField#MoveDown$1","TMPro.TMP_InputField#MoveUp","TMPro.TMP_InputField#MoveUp$1","TMPro.TMP_InputField#MovePageUp","TMPro.TMP_InputField#MovePageUp$1","TMPro.TMP_InputField#MovePageDown","TMPro.TMP_InputField#MovePageDown$1","TMPro.TMP_InputField#Delete","TMPro.TMP_InputField#DeleteKey","TMPro.TMP_InputField#Backspace","TMPro.TMP_InputField#Append$1","TMPro.TMP_InputField#Append","TMPro.TMP_InputField#Insert","TMPro.TMP_InputField#UpdateTouchKeyboardFromEditChanges","TMPro.TMP_InputField#SendOnValueChangedAndUpdateLabel","TMPro.TMP_InputField#SendOnValueChanged","TMPro.TMP_InputField#SendOnEndEdit","TMPro.TMP_InputField#SendOnSubmit","TMPro.TMP_InputField#SendOnFocus","TMPro.TMP_InputField#SendOnFocusLost","TMPro.TMP_InputField#SendOnTextSelection","TMPro.TMP_InputField#SendOnEndTextSelection","TMPro.TMP_InputField#SendTouchScreenKeyboardStatusChanged","TMPro.TMP_InputField#UpdateLabel","TMPro.TMP_InputField#UpdateScrollbar","TMPro.TMP_InputField#OnScrollbarValueChange","TMPro.TMP_InputField#UpdateMaskRegions","TMPro.TMP_InputField#AdjustTextPositionRelativeToViewport","TMPro.TMP_InputField#GetCaretPositionFromStringIndex","TMPro.TMP_InputField#GetMinCaretPositionFromStringIndex","TMPro.TMP_InputField#GetMaxCaretPositionFromStringIndex","TMPro.TMP_InputField#GetStringIndexFromCaretPosition","TMPro.TMP_InputField#ForceLabelUpdate","TMPro.TMP_InputField#MarkGeometryAsDirty","TMPro.TMP_InputField#Rebuild","TMPro.TMP_InputField#LayoutComplete","TMPro.TMP_InputField#GraphicUpdateComplete","TMPro.TMP_InputField#UpdateGeometry","TMPro.TMP_InputField#AssignPositioningIfNeeded","TMPro.TMP_InputField#OnFillVBO","TMPro.TMP_InputField#GenerateCaret","TMPro.TMP_InputField#CreateCursorVerts","TMPro.TMP_InputField#GenerateHightlight","TMPro.TMP_InputField#AdjustRectTransformRelativeToViewport","TMPro.TMP_InputField#Validate","TMPro.TMP_InputField#ActivateInputField","TMPro.TMP_InputField#ActivateInputFieldInternal","TMPro.TMP_InputField#OnSelect","TMPro.TMP_InputField#OnPointerClick","TMPro.TMP_InputField#OnControlClick","TMPro.TMP_InputField#ReleaseSelection","TMPro.TMP_InputField#DeactivateInputField","TMPro.TMP_InputField#OnDeselect","TMPro.TMP_InputField#OnSubmit","TMPro.TMP_InputField#EnforceContentType","TMPro.TMP_InputField#SetTextComponentWrapMode","TMPro.TMP_InputField#SetTextComponentRichTextMode","TMPro.TMP_InputField#SetToCustomIfContentTypeIsNot","TMPro.TMP_InputField#SetToCustom","TMPro.TMP_InputField#SetToCustom$1","TMPro.TMP_InputField#DoStateTransition","TMPro.TMP_InputField#CalculateLayoutInputHorizontal","TMPro.TMP_InputField#CalculateLayoutInputVertical","TMPro.TMP_InputField#SetGlobalPointSize","TMPro.TMP_InputField#SetGlobalFontAsset","TMPro.TMP_LineInfo#getDefaultValue","TMPro.TMP_LineInfo#init","TMPro.TMP_LineInfo#ctor","TMPro.TMP_LineInfo#getHashCode","TMPro.TMP_LineInfo#equals","TMPro.TMP_LineInfo#$clone","TMPro.TMP_LinkInfo#getDefaultValue","TMPro.TMP_LinkInfo#ctor","TMPro.TMP_LinkInfo#SetLinkID","TMPro.TMP_LinkInfo#GetLinkText","TMPro.TMP_LinkInfo#GetLinkID","TMPro.TMP_LinkInfo#getHashCode","TMPro.TMP_LinkInfo#equals","TMPro.TMP_LinkInfo#$clone","TMPro.TMP_ListPool$1#init","TMPro.TMP_ListPool$1#Get","TMPro.TMP_ListPool$1#Release","TMPro.TMP_MaterialManager#init","TMPro.TMP_MaterialManager#ctor","TMPro.TMP_MaterialManager#OnPreRender","TMPro.TMP_MaterialManager#GetStencilMaterial","TMPro.TMP_MaterialManager#ReleaseStencilMaterial","TMPro.TMP_MaterialManager#GetBaseMaterial","TMPro.TMP_MaterialManager#SetStencil","TMPro.TMP_MaterialManager#AddMaskingMaterial","TMPro.TMP_MaterialManager#RemoveStencilMaterial","TMPro.TMP_MaterialManager#ReleaseBaseMaterial","TMPro.TMP_MaterialManager#ClearMaterials","TMPro.TMP_MaterialManager#GetStencilID","TMPro.TMP_MaterialManager#GetMaterialForRendering","TMPro.TMP_MaterialManager#FindRootSortOverrideCanvas","TMPro.TMP_MaterialManager#GetFallbackMaterial$1","TMPro.TMP_MaterialManager#GetFallbackMaterial","TMPro.TMP_MaterialManager#AddFallbackMaterialReference","TMPro.TMP_MaterialManager#RemoveFallbackMaterialReference","TMPro.TMP_MaterialManager#CleanupFallbackMaterials","TMPro.TMP_MaterialManager#ReleaseFallbackMaterial","TMPro.TMP_MaterialManager#CopyMaterialPresetProperties","TMPro.TMP_MaterialReference#getDefaultValue","TMPro.TMP_MaterialReference#ctor","TMPro.TMP_MaterialReference#getHashCode","TMPro.TMP_MaterialReference#equals","TMPro.TMP_MaterialReference#$clone","TMPro.TMP_Math#init","TMPro.TMP_Math#Approximately","TMPro.TMP_Math#Mod","TMPro.TMP_MeshInfo#init","TMPro.TMP_MeshInfo#getDefaultValue","TMPro.TMP_MeshInfo#$ctor1","TMPro.TMP_MeshInfo#$ctor2","TMPro.TMP_MeshInfo#ctor","TMPro.TMP_MeshInfo#ResizeMeshInfo","TMPro.TMP_MeshInfo#ResizeMeshInfo$1","TMPro.TMP_MeshInfo#Clear","TMPro.TMP_MeshInfo#Clear$1","TMPro.TMP_MeshInfo#ClearUnusedVertices","TMPro.TMP_MeshInfo#ClearUnusedVertices$1","TMPro.TMP_MeshInfo#ClearUnusedVertices$2","TMPro.TMP_MeshInfo#SortGeometry$1","TMPro.TMP_MeshInfo#SortGeometry","TMPro.TMP_MeshInfo#SwapVertexData","TMPro.TMP_MeshInfo#getHashCode","TMPro.TMP_MeshInfo#equals","TMPro.TMP_MeshInfo#$clone","TMPro.TMP_ObjectPool$1#countActive#get","TMPro.TMP_ObjectPool$1#countInactive#get","TMPro.TMP_ObjectPool$1#init","TMPro.TMP_ObjectPool$1#ctor","TMPro.TMP_ObjectPool$1#Get","TMPro.TMP_ObjectPool$1#Release","TMPro.TMP_Offset#zero#get","TMPro.TMP_Offset#init","TMPro.TMP_Offset#op_Equality","TMPro.TMP_Offset#op_Inequality","TMPro.TMP_Offset#op_Multiply","TMPro.TMP_Offset#getDefaultValue","TMPro.TMP_Offset#left#get","TMPro.TMP_Offset#left#set","TMPro.TMP_Offset#right#get","TMPro.TMP_Offset#right#set","TMPro.TMP_Offset#top#get","TMPro.TMP_Offset#top#set","TMPro.TMP_Offset#bottom#get","TMPro.TMP_Offset#bottom#set","TMPro.TMP_Offset#horizontal#get","TMPro.TMP_Offset#horizontal#set","TMPro.TMP_Offset#vertical#get","TMPro.TMP_Offset#vertical#set","TMPro.TMP_Offset#$ctor2","TMPro.TMP_Offset#$ctor1","TMPro.TMP_Offset#ctor","TMPro.TMP_Offset#Copy","TMPro.TMP_Offset#getHashCode","TMPro.TMP_Offset#equals","TMPro.TMP_Offset#Equals","TMPro.TMP_Offset#$clone","TMPro.TMP_PageInfo#getDefaultValue","TMPro.TMP_PageInfo#ctor","TMPro.TMP_PageInfo#getHashCode","TMPro.TMP_PageInfo#equals","TMPro.TMP_PageInfo#$clone","TMPro.TMP_ResourceManager#init","TMPro.TMP_ResourceManager#ctor","TMPro.TMP_ResourceManager#GetTextSettings","TMPro.TMP_ResourceManager#AddFontAsset","TMPro.TMP_ResourceManager#TryGetFontAsset","TMPro.TMP_ResourceManager#RebuildFontAssetCache","TMPro.TMP_ScrollbarEventHandler#OnPointerClick","TMPro.TMP_ScrollbarEventHandler#OnSelect","TMPro.TMP_ScrollbarEventHandler#OnDeselect","TMPro.TMP_SelectionCaret#Cull","TMPro.TMP_SelectionCaret#UpdateGeometry","TMPro.TMP_Settings#version#get","TMPro.TMP_Settings#enableWordWrapping#get","TMPro.TMP_Settings#enableKerning#get","TMPro.TMP_Settings#enableExtraPadding#get","TMPro.TMP_Settings#enableTintAllSprites#get","TMPro.TMP_Settings#enableParseEscapeCharacters#get","TMPro.TMP_Settings#enableRaycastTarget#get","TMPro.TMP_Settings#getFontFeaturesAtRuntime#get","TMPro.TMP_Settings#missingGlyphCharacter#get","TMPro.TMP_Settings#missingGlyphCharacter#set","TMPro.TMP_Settings#warningsDisabled#get","TMPro.TMP_Settings#defaultFontAsset#get","TMPro.TMP_Settings#defaultFontAssetPath#get","TMPro.TMP_Settings#defaultFontSize#get","TMPro.TMP_Settings#defaultTextAutoSizingMinRatio#get","TMPro.TMP_Settings#defaultTextAutoSizingMaxRatio#get","TMPro.TMP_Settings#defaultTextMeshProTextContainerSize#get","TMPro.TMP_Settings#defaultTextMeshProUITextContainerSize#get","TMPro.TMP_Settings#autoSizeTextContainer#get","TMPro.TMP_Settings#isTextObjectScaleStatic#get","TMPro.TMP_Settings#isTextObjectScaleStatic#set","TMPro.TMP_Settings#fallbackFontAssets#get","TMPro.TMP_Settings#matchMaterialPreset#get","TMPro.TMP_Settings#defaultSpriteAsset#get","TMPro.TMP_Settings#defaultSpriteAssetPath#get","TMPro.TMP_Settings#enableEmojiSupport#get","TMPro.TMP_Settings#enableEmojiSupport#set","TMPro.TMP_Settings#missingCharacterSpriteUnicode#get","TMPro.TMP_Settings#missingCharacterSpriteUnicode#set","TMPro.TMP_Settings#defaultColorGradientPresetsPath#get","TMPro.TMP_Settings#defaultStyleSheet#get","TMPro.TMP_Settings#styleSheetsResourcePath#get","TMPro.TMP_Settings#leadingCharacters#get","TMPro.TMP_Settings#followingCharacters#get","TMPro.TMP_Settings#linebreakingRules#get","TMPro.TMP_Settings#useModernHangulLineBreakingRules#get","TMPro.TMP_Settings#useModernHangulLineBreakingRules#set","TMPro.TMP_Settings#instance#get","TMPro.TMP_Settings#LoadDefaultSettings","TMPro.TMP_Settings#GetSettings","TMPro.TMP_Settings#GetFontAsset","TMPro.TMP_Settings#GetSpriteAsset","TMPro.TMP_Settings#GetStyleSheet","TMPro.TMP_Settings#LoadLinebreakingRules","TMPro.TMP_Settings#GetCharacters","TMPro.TMP_Settings#init","TMPro.TMP_SpriteAnimator#init","TMPro.TMP_SpriteAnimator#Awake","TMPro.TMP_SpriteAnimator#OnEnable","TMPro.TMP_SpriteAnimator#OnDisable","TMPro.TMP_SpriteAnimator#StopAllAnimations","TMPro.TMP_SpriteAnimator#DoSpriteAnimation","TMPro.TMP_SpriteAnimator#DoSpriteAnimationInternal","TMPro.TMP_SpriteGlyph#ctor","TMPro.TMP_SpriteGlyph#$ctor1","TMPro.TMP_SpriteGlyph#$ctor2","TMPro.TMP_SpriteInfo#getDefaultValue","TMPro.TMP_SpriteInfo#ctor","TMPro.TMP_SpriteInfo#getHashCode","TMPro.TMP_SpriteInfo#equals","TMPro.TMP_SpriteInfo#$clone","TMPro.TMP_Style#NormalStyle#get","TMPro.TMP_Style#name#get","TMPro.TMP_Style#name#set","TMPro.TMP_Style#hashCode#get","TMPro.TMP_Style#hashCode#set","TMPro.TMP_Style#styleOpeningDefinition#get","TMPro.TMP_Style#styleClosingDefinition#get","TMPro.TMP_Style#styleOpeningTagArray#get","TMPro.TMP_Style#styleClosingTagArray#get","TMPro.TMP_Style#ctor","TMPro.TMP_Style#RefreshStyle","TMPro.TMP_StyleSheet#styles#get","TMPro.TMP_StyleSheet#init","TMPro.TMP_StyleSheet#Reset","TMPro.TMP_StyleSheet#GetStyle","TMPro.TMP_StyleSheet#GetStyle$1","TMPro.TMP_StyleSheet#RefreshStyles","TMPro.TMP_StyleSheet#LoadStyleDictionaryInternal","TMPro.TMP_SubMesh#AddSubTextObject","TMPro.TMP_SubMesh#fontAsset#get","TMPro.TMP_SubMesh#fontAsset#set","TMPro.TMP_SubMesh#spriteAsset#get","TMPro.TMP_SubMesh#spriteAsset#set","TMPro.TMP_SubMesh#material#get","TMPro.TMP_SubMesh#material#set","TMPro.TMP_SubMesh#sharedMaterial#get","TMPro.TMP_SubMesh#sharedMaterial#set","TMPro.TMP_SubMesh#fallbackMaterial#get","TMPro.TMP_SubMesh#fallbackMaterial#set","TMPro.TMP_SubMesh#fallbackSourceMaterial#get","TMPro.TMP_SubMesh#fallbackSourceMaterial#set","TMPro.TMP_SubMesh#isDefaultMaterial#get","TMPro.TMP_SubMesh#isDefaultMaterial#set","TMPro.TMP_SubMesh#padding#get","TMPro.TMP_SubMesh#padding#set","TMPro.TMP_SubMesh#renderer#get","TMPro.TMP_SubMesh#meshFilter#get","TMPro.TMP_SubMesh#mesh#get","TMPro.TMP_SubMesh#mesh#set","TMPro.TMP_SubMesh#textComponent#get","TMPro.TMP_SubMesh#OnEnable","TMPro.TMP_SubMesh#OnDisable","TMPro.TMP_SubMesh#OnDestroy","TMPro.TMP_SubMesh#DestroySelf","TMPro.TMP_SubMesh#GetMaterial","TMPro.TMP_SubMesh#CreateMaterialInstance","TMPro.TMP_SubMesh#GetSharedMaterial","TMPro.TMP_SubMesh#SetSharedMaterial","TMPro.TMP_SubMesh#GetPaddingForMaterial","TMPro.TMP_SubMesh#UpdateMeshPadding","TMPro.TMP_SubMesh#SetVerticesDirty","TMPro.TMP_SubMesh#SetMaterialDirty","TMPro.TMP_SubMesh#UpdateMaterial","TMPro.TMP_SubMeshUI#AddSubTextObject","TMPro.TMP_SubMeshUI#fontAsset#get","TMPro.TMP_SubMeshUI#fontAsset#set","TMPro.TMP_SubMeshUI#spriteAsset#get","TMPro.TMP_SubMeshUI#spriteAsset#set","TMPro.TMP_SubMeshUI#mainTexture#get","TMPro.TMP_SubMeshUI#material#get","TMPro.TMP_SubMeshUI#material#set","TMPro.TMP_SubMeshUI#sharedMaterial#get","TMPro.TMP_SubMeshUI#sharedMaterial#set","TMPro.TMP_SubMeshUI#fallbackMaterial#get","TMPro.TMP_SubMeshUI#fallbackMaterial#set","TMPro.TMP_SubMeshUI#fallbackSourceMaterial#get","TMPro.TMP_SubMeshUI#fallbackSourceMaterial#set","TMPro.TMP_SubMeshUI#materialForRendering#get","TMPro.TMP_SubMeshUI#isDefaultMaterial#get","TMPro.TMP_SubMeshUI#isDefaultMaterial#set","TMPro.TMP_SubMeshUI#padding#get","TMPro.TMP_SubMeshUI#padding#set","TMPro.TMP_SubMeshUI#mesh#get","TMPro.TMP_SubMeshUI#mesh#set","TMPro.TMP_SubMeshUI#textComponent#get","TMPro.TMP_SubMeshUI#OnEnable","TMPro.TMP_SubMeshUI#OnDisable","TMPro.TMP_SubMeshUI#OnDestroy","TMPro.TMP_SubMeshUI#OnTransformParentChanged","TMPro.TMP_SubMeshUI#GetModifiedMaterial","TMPro.TMP_SubMeshUI#GetPaddingForMaterial","TMPro.TMP_SubMeshUI#GetPaddingForMaterial$1","TMPro.TMP_SubMeshUI#UpdateMeshPadding","TMPro.TMP_SubMeshUI#SetAllDirty","TMPro.TMP_SubMeshUI#SetVerticesDirty","TMPro.TMP_SubMeshUI#SetLayoutDirty","TMPro.TMP_SubMeshUI#SetMaterialDirty","TMPro.TMP_SubMeshUI#SetPivotDirty","TMPro.TMP_SubMeshUI#GetRootCanvasTransform","TMPro.TMP_SubMeshUI#Cull","TMPro.TMP_SubMeshUI#UpdateGeometry","TMPro.TMP_SubMeshUI#Rebuild","TMPro.TMP_SubMeshUI#RefreshMaterial","TMPro.TMP_SubMeshUI#UpdateMaterial","TMPro.TMP_SubMeshUI#RecalculateClipping","TMPro.TMP_SubMeshUI#GetMaterial","TMPro.TMP_SubMeshUI#GetMaterial$1","TMPro.TMP_SubMeshUI#CreateMaterialInstance","TMPro.TMP_SubMeshUI#GetSharedMaterial","TMPro.TMP_SubMeshUI#SetSharedMaterial","TMPro.TMP_Text.CharacterSubstitution#getDefaultValue","TMPro.TMP_Text.CharacterSubstitution#$ctor1","TMPro.TMP_Text.CharacterSubstitution#ctor","TMPro.TMP_Text.CharacterSubstitution#getHashCode","TMPro.TMP_Text.CharacterSubstitution#equals","TMPro.TMP_Text.CharacterSubstitution#$clone","TMPro.TMP_Text.SpecialCharacter#getDefaultValue","TMPro.TMP_Text.SpecialCharacter#$ctor1","TMPro.TMP_Text.SpecialCharacter#ctor","TMPro.TMP_Text.SpecialCharacter#getHashCode","TMPro.TMP_Text.SpecialCharacter#equals","TMPro.TMP_Text.SpecialCharacter#$clone","TMPro.TMP_Text.TextBackingContainer#getDefaultValue","TMPro.TMP_Text.TextBackingContainer#Capacity#get","TMPro.TMP_Text.TextBackingContainer#Count#get","TMPro.TMP_Text.TextBackingContainer#Count#set","TMPro.TMP_Text.TextBackingContainer#$ctor1","TMPro.TMP_Text.TextBackingContainer#ctor","TMPro.TMP_Text.TextBackingContainer#getItem","TMPro.TMP_Text.TextBackingContainer#setItem","TMPro.TMP_Text.TextBackingContainer#Resize","TMPro.TMP_Text.TextBackingContainer#getHashCode","TMPro.TMP_Text.TextBackingContainer#equals","TMPro.TMP_Text.TextBackingContainer#$clone","TMPro.TMP_Text.UnicodeChar#getDefaultValue","TMPro.TMP_Text.UnicodeChar#ctor","TMPro.TMP_Text.UnicodeChar#getHashCode","TMPro.TMP_Text.UnicodeChar#equals","TMPro.TMP_Text.UnicodeChar#$clone","TMPro.TMP_TextInfo#init","TMPro.TMP_TextInfo#Resize","TMPro.TMP_TextInfo#Resize$1","TMPro.TMP_TextInfo#ctor","TMPro.TMP_TextInfo#$ctor1","TMPro.TMP_TextInfo#$ctor2","TMPro.TMP_TextInfo#Clear","TMPro.TMP_TextInfo#ClearAllData","TMPro.TMP_TextInfo#ClearMeshInfo","TMPro.TMP_TextInfo#ClearAllMeshInfo","TMPro.TMP_TextInfo#ResetVertexLayout","TMPro.TMP_TextInfo#ClearUnusedVertices","TMPro.TMP_TextInfo#ClearLineInfo","TMPro.TMP_TextInfo#ClearPageInfo","TMPro.TMP_TextInfo#CopyMeshInfoVertexData","TMPro.TMP_TextParsingUtilities#instance#get","TMPro.TMP_TextParsingUtilities#init","TMPro.TMP_TextParsingUtilities#ctor","TMPro.TMP_TextParsingUtilities#GetHashCode","TMPro.TMP_TextParsingUtilities#GetHashCodeCaseSensitive","TMPro.TMP_TextParsingUtilities#ToLowerASCIIFast","TMPro.TMP_TextParsingUtilities#ToLowerASCIIFast$1","TMPro.TMP_TextParsingUtilities#ToUpperASCIIFast","TMPro.TMP_TextParsingUtilities#ToUpperASCIIFast$1","TMPro.TMP_TextParsingUtilities#IsHighSurrogate","TMPro.TMP_TextParsingUtilities#IsLowSurrogate","TMPro.TMP_TextParsingUtilities#ConvertToUTF32","TMPro.TMP_TextProcessingStack$1#init","TMPro.TMP_TextProcessingStack$1#SetDefault","TMPro.TMP_TextProcessingStack$1#getDefaultValue","TMPro.TMP_TextProcessingStack$1#Count#get","TMPro.TMP_TextProcessingStack$1#current#get","TMPro.TMP_TextProcessingStack$1#rolloverSize#get","TMPro.TMP_TextProcessingStack$1#rolloverSize#set","TMPro.TMP_TextProcessingStack$1#init","TMPro.TMP_TextProcessingStack$1#$ctor1","TMPro.TMP_TextProcessingStack$1#$ctor2","TMPro.TMP_TextProcessingStack$1#$ctor3","TMPro.TMP_TextProcessingStack$1#ctor","TMPro.TMP_TextProcessingStack$1#CopyBase","TMPro.TMP_TextProcessingStack$1#Copy","TMPro.TMP_TextProcessingStack$1#CopyStruct","TMPro.TMP_TextProcessingStack$1#Clear","TMPro.TMP_TextProcessingStack$1#SetDefault","TMPro.TMP_TextProcessingStack$1#Add","TMPro.TMP_TextProcessingStack$1#Remove","TMPro.TMP_TextProcessingStack$1#Push","TMPro.TMP_TextProcessingStack$1#Pop","TMPro.TMP_TextProcessingStack$1#Peek","TMPro.TMP_TextProcessingStack$1#CurrentItem","TMPro.TMP_TextProcessingStack$1#PreviousItem","TMPro.TMP_TextProcessingStack$1#getHashCode","TMPro.TMP_TextProcessingStack$1#equals","TMPro.TMP_TextProcessingStack$1#$clone","TMPro.TMP_TextUtilities#init","TMPro.TMP_TextUtilities#GetCursorIndexFromPosition","TMPro.TMP_TextUtilities#GetCursorIndexFromPosition$1","TMPro.TMP_TextUtilities#FindNearestLine","TMPro.TMP_TextUtilities#FindNearestCharacterOnLine","TMPro.TMP_TextUtilities#IsIntersectingRectTransform","TMPro.TMP_TextUtilities#FindIntersectingCharacter","TMPro.TMP_TextUtilities#FindNearestCharacter","TMPro.TMP_TextUtilities#FindIntersectingWord","TMPro.TMP_TextUtilities#FindNearestWord","TMPro.TMP_TextUtilities#FindIntersectingLine","TMPro.TMP_TextUtilities#FindIntersectingLink","TMPro.TMP_TextUtilities#FindNearestLink","TMPro.TMP_TextUtilities#PointIntersectRectangle","TMPro.TMP_TextUtilities#ScreenPointToWorldPointInRectangle","TMPro.TMP_TextUtilities#IntersectLinePlane","TMPro.TMP_TextUtilities#DistanceToLine","TMPro.TMP_TextUtilities#ToLowerFast","TMPro.TMP_TextUtilities#ToUpperFast","TMPro.TMP_TextUtilities#ToUpperASCIIFast","TMPro.TMP_TextUtilities#GetHashCode","TMPro.TMP_TextUtilities#GetSimpleHashCode","TMPro.TMP_TextUtilities#GetSimpleHashCodeLowercase","TMPro.TMP_TextUtilities#HexToInt","TMPro.TMP_TextUtilities#StringHexToInt","TMPro.TMP_TextUtilities.LineSegment#getDefaultValue","TMPro.TMP_TextUtilities.LineSegment#init","TMPro.TMP_TextUtilities.LineSegment#$ctor1","TMPro.TMP_TextUtilities.LineSegment#ctor","TMPro.TMP_TextUtilities.LineSegment#getHashCode","TMPro.TMP_TextUtilities.LineSegment#equals","TMPro.TMP_TextUtilities.LineSegment#$clone","TMPro.TMP_UpdateManager#instance#get","TMPro.TMP_UpdateManager#RegisterTextObjectForUpdate","TMPro.TMP_UpdateManager#RegisterTextElementForLayoutRebuild","TMPro.TMP_UpdateManager#RegisterTextElementForGraphicRebuild","TMPro.TMP_UpdateManager#RegisterTextElementForCullingUpdate","TMPro.TMP_UpdateManager#UnRegisterTextObjectForUpdate","TMPro.TMP_UpdateManager#UnRegisterTextElementForRebuild","TMPro.TMP_UpdateManager#init","TMPro.TMP_UpdateManager#ctor","TMPro.TMP_UpdateManager#InternalRegisterTextObjectForUpdate","TMPro.TMP_UpdateManager#InternalRegisterTextElementForLayoutRebuild","TMPro.TMP_UpdateManager#InternalRegisterTextElementForGraphicRebuild","TMPro.TMP_UpdateManager#InternalRegisterTextElementForCullingUpdate","TMPro.TMP_UpdateManager#OnCameraPreCull","TMPro.TMP_UpdateManager#DoRebuilds","TMPro.TMP_UpdateManager#InternalUnRegisterTextElementForGraphicRebuild","TMPro.TMP_UpdateManager#InternalUnRegisterTextElementForLayoutRebuild","TMPro.TMP_UpdateManager#InternalUnRegisterTextObjectForUpdate","TMPro.TMP_UpdateRegistry#instance#get","TMPro.TMP_UpdateRegistry#RegisterCanvasElementForLayoutRebuild","TMPro.TMP_UpdateRegistry#RegisterCanvasElementForGraphicRebuild","TMPro.TMP_UpdateRegistry#UnRegisterCanvasElementForRebuild","TMPro.TMP_UpdateRegistry#init","TMPro.TMP_UpdateRegistry#ctor","TMPro.TMP_UpdateRegistry#InternalRegisterCanvasElementForLayoutRebuild","TMPro.TMP_UpdateRegistry#InternalRegisterCanvasElementForGraphicRebuild","TMPro.TMP_UpdateRegistry#PerformUpdateForCanvasRendererObjects","TMPro.TMP_UpdateRegistry#PerformUpdateForMeshRendererObjects","TMPro.TMP_UpdateRegistry#InternalUnRegisterCanvasElementForLayoutRebuild","TMPro.TMP_UpdateRegistry#InternalUnRegisterCanvasElementForGraphicRebuild","TMPro.TMP_Vertex#zero#get","TMPro.TMP_Vertex#init","TMPro.TMP_Vertex#getDefaultValue","TMPro.TMP_Vertex#init","TMPro.TMP_Vertex#ctor","TMPro.TMP_Vertex#getHashCode","TMPro.TMP_Vertex#equals","TMPro.TMP_Vertex#$clone","TMPro.TMP_WordInfo#getDefaultValue","TMPro.TMP_WordInfo#ctor","TMPro.TMP_WordInfo#GetWord","TMPro.TMP_WordInfo#getHashCode","TMPro.TMP_WordInfo#equals","TMPro.TMP_WordInfo#$clone","TMPro.TMPro_EventManager#init","TMPro.TMPro_EventManager#ON_MATERIAL_PROPERTY_CHANGED","TMPro.TMPro_EventManager#ON_FONT_PROPERTY_CHANGED","TMPro.TMPro_EventManager#ON_SPRITE_ASSET_PROPERTY_CHANGED","TMPro.TMPro_EventManager#ON_TEXTMESHPRO_PROPERTY_CHANGED","TMPro.TMPro_EventManager#ON_DRAG_AND_DROP_MATERIAL_CHANGED","TMPro.TMPro_EventManager#ON_TEXT_STYLE_PROPERTY_CHANGED","TMPro.TMPro_EventManager#ON_COLOR_GRADIENT_PROPERTY_CHANGED","TMPro.TMPro_EventManager#ON_TEXT_CHANGED","TMPro.TMPro_EventManager#ON_TMP_SETTINGS_CHANGED","TMPro.TMPro_EventManager#ON_RESOURCES_LOADED","TMPro.TMPro_EventManager#ON_TEXTMESHPRO_UGUI_PROPERTY_CHANGED","TMPro.TMPro_EventManager#ON_COMPUTE_DT_EVENT","TMPro.TMPro_ExtensionMethods#ToIntArray","TMPro.TMPro_ExtensionMethods#ArrayToString","TMPro.TMPro_ExtensionMethods#IntToString","TMPro.TMPro_ExtensionMethods#IntToString$1","TMPro.TMPro_ExtensionMethods#UintToString","TMPro.TMPro_ExtensionMethods#FindInstanceID","TMPro.TMPro_ExtensionMethods#Compare$1","TMPro.TMPro_ExtensionMethods#Compare","TMPro.TMPro_ExtensionMethods#Compare$3","TMPro.TMPro_ExtensionMethods#Compare$2","TMPro.TMPro_ExtensionMethods#CompareRGB$1","TMPro.TMPro_ExtensionMethods#CompareRGB","TMPro.TMPro_ExtensionMethods#Multiply","TMPro.TMPro_ExtensionMethods#Tint$1","TMPro.TMPro_ExtensionMethods#Tint","TMPro.TMPro_ExtensionMethods#MinAlpha","TMPro.VertexGradient#getDefaultValue","TMPro.VertexGradient#init","TMPro.VertexGradient#$ctor1","TMPro.VertexGradient#$ctor2","TMPro.VertexGradient#ctor","TMPro.VertexGradient#getHashCode","TMPro.VertexGradient#equals","TMPro.VertexGradient#$clone","TMPro.WordWrapState#getDefaultValue","TMPro.WordWrapState#init","TMPro.WordWrapState#ctor","TMPro.WordWrapState#getHashCode","TMPro.WordWrapState#equals","TMPro.WordWrapState#$clone","TMPro.ColorTween#getDefaultValue","TMPro.ColorTween#startColor#get","TMPro.ColorTween#startColor#set","TMPro.ColorTween#targetColor#get","TMPro.ColorTween#targetColor#set","TMPro.ColorTween#tweenMode#get","TMPro.ColorTween#tweenMode#set","TMPro.ColorTween#duration#get","TMPro.ColorTween#duration#set","TMPro.ColorTween#ignoreTimeScale#get","TMPro.ColorTween#ignoreTimeScale#set","TMPro.ColorTween#init","TMPro.ColorTween#ctor","TMPro.ColorTween#TweenValue","TMPro.ColorTween#AddOnChangedCallback","TMPro.ColorTween#GetIgnoreTimescale","TMPro.ColorTween#GetDuration","TMPro.ColorTween#ValidTarget","TMPro.ColorTween#getHashCode","TMPro.ColorTween#equals","TMPro.ColorTween#$clone","TMPro.FloatTween#getDefaultValue","TMPro.FloatTween#startValue#get","TMPro.FloatTween#startValue#set","TMPro.FloatTween#targetValue#get","TMPro.FloatTween#targetValue#set","TMPro.FloatTween#duration#get","TMPro.FloatTween#duration#set","TMPro.FloatTween#ignoreTimeScale#get","TMPro.FloatTween#ignoreTimeScale#set","TMPro.FloatTween#ctor","TMPro.FloatTween#TweenValue","TMPro.FloatTween#AddOnChangedCallback","TMPro.FloatTween#GetIgnoreTimescale","TMPro.FloatTween#GetDuration","TMPro.FloatTween#ValidTarget","TMPro.FloatTween#getHashCode","TMPro.FloatTween#equals","TMPro.FloatTween#$clone","TMPro.TextMeshPro#sortingLayerID#get","TMPro.TextMeshPro#sortingLayerID#set","TMPro.TextMeshPro#sortingOrder#get","TMPro.TextMeshPro#sortingOrder#set","TMPro.TextMeshPro#autoSizeTextContainer#get","TMPro.TextMeshPro#autoSizeTextContainer#set","TMPro.TextMeshPro#textContainer#get","TMPro.TextMeshPro#transform$2#get","TMPro.TextMeshPro#renderer#get","TMPro.TextMeshPro#mesh#get","TMPro.TextMeshPro#meshFilter#get","TMPro.TextMeshPro#maskType#get","TMPro.TextMeshPro#maskType#set","TMPro.TextMeshPro#init","TMPro.TextMeshPro#SetMask","TMPro.TextMeshPro#SetMask$1","TMPro.TextMeshPro#SetMask$2","TMPro.TextMeshPro#SetVerticesDirty","TMPro.TextMeshPro#SetLayoutDirty","TMPro.TextMeshPro#SetMaterialDirty","TMPro.TextMeshPro#SetAllDirty","TMPro.TextMeshPro#Rebuild","TMPro.TextMeshPro#UpdateMaterial","TMPro.TextMeshPro#UpdateMeshPadding","TMPro.TextMeshPro#ForceMeshUpdate","TMPro.TextMeshPro#GetTextInfo","TMPro.TextMeshPro#ClearMesh$1","TMPro.TextMeshPro#UpdateGeometry$1","TMPro.TextMeshPro#UpdateVertexData$1","TMPro.TextMeshPro#UpdateVertexData","TMPro.TextMeshPro#UpdateFontAsset","TMPro.TextMeshPro#CalculateLayoutInputHorizontal","TMPro.TextMeshPro#CalculateLayoutInputVertical","TMPro.TextMeshPro#Awake","TMPro.TextMeshPro#OnEnable","TMPro.TextMeshPro#OnDisable","TMPro.TextMeshPro#OnDestroy","TMPro.TextMeshPro#LoadFontAsset","TMPro.TextMeshPro#UpdateEnvMapMatrix","TMPro.TextMeshPro#SetMaskCoordinates","TMPro.TextMeshPro#SetMaskCoordinates$1","TMPro.TextMeshPro#EnableMasking","TMPro.TextMeshPro#DisableMasking","TMPro.TextMeshPro#UpdateMask","TMPro.TextMeshPro#GetMaterial","TMPro.TextMeshPro#GetMaterials","TMPro.TextMeshPro#SetSharedMaterial","TMPro.TextMeshPro#GetSharedMaterials","TMPro.TextMeshPro#SetSharedMaterials","TMPro.TextMeshPro#SetOutlineThickness","TMPro.TextMeshPro#SetFaceColor","TMPro.TextMeshPro#SetOutlineColor","TMPro.TextMeshPro#CreateMaterialInstance$1","TMPro.TextMeshPro#SetShaderDepth","TMPro.TextMeshPro#SetCulling","TMPro.TextMeshPro#SetPerspectiveCorrection","TMPro.TextMeshPro#SetArraySizes","TMPro.TextMeshPro#ComputeMarginSize","TMPro.TextMeshPro#OnDidApplyAnimationProperties","TMPro.TextMeshPro#OnTransformParentChanged","TMPro.TextMeshPro#OnRectTransformDimensionsChange","TMPro.TextMeshPro#InternalUpdate","TMPro.TextMeshPro#OnPreRenderObject","TMPro.TextMeshPro#GenerateTextMesh","TMPro.TextMeshPro#GetTextContainerLocalCorners","TMPro.TextMeshPro#SetMeshFilters","TMPro.TextMeshPro#SetActiveSubMeshes","TMPro.TextMeshPro#SetActiveSubTextObjectRenderers","TMPro.TextMeshPro#DestroySubMeshObjects","TMPro.TextMeshPro#UpdateSubMeshSortingLayerID","TMPro.TextMeshPro#UpdateSubMeshSortingOrder","TMPro.TextMeshPro#GetCompoundBounds","TMPro.TextMeshPro#UpdateSDFScale","TMPro.TextMeshProUGUI#materialForRendering#get","TMPro.TextMeshProUGUI#autoSizeTextContainer#get","TMPro.TextMeshProUGUI#autoSizeTextContainer#set","TMPro.TextMeshProUGUI#mesh#get","TMPro.TextMeshProUGUI#canvasRenderer$1#get","TMPro.TextMeshProUGUI#maskOffset#get","TMPro.TextMeshProUGUI#maskOffset#set","TMPro.TextMeshProUGUI#init","TMPro.TextMeshProUGUI#CalculateLayoutInputHorizontal","TMPro.TextMeshProUGUI#CalculateLayoutInputVertical","TMPro.TextMeshProUGUI#SetVerticesDirty","TMPro.TextMeshProUGUI#SetLayoutDirty","TMPro.TextMeshProUGUI#SetMaterialDirty","TMPro.TextMeshProUGUI#SetAllDirty","TMPro.TextMeshProUGUI#DelayedGraphicRebuild","TMPro.TextMeshProUGUI#DelayedMaterialRebuild","TMPro.TextMeshProUGUI#Rebuild","TMPro.TextMeshProUGUI#UpdateSubObjectPivot","TMPro.TextMeshProUGUI#GetModifiedMaterial","TMPro.TextMeshProUGUI#UpdateMaterial","TMPro.TextMeshProUGUI#RecalculateClipping","TMPro.TextMeshProUGUI#Cull","TMPro.TextMeshProUGUI#UpdateCulling","TMPro.TextMeshProUGUI#UpdateMeshPadding","TMPro.TextMeshProUGUI#InternalCrossFadeColor","TMPro.TextMeshProUGUI#InternalCrossFadeAlpha","TMPro.TextMeshProUGUI#ForceMeshUpdate","TMPro.TextMeshProUGUI#GetTextInfo","TMPro.TextMeshProUGUI#ClearMesh","TMPro.TextMeshProUGUI#UpdateGeometry$1","TMPro.TextMeshProUGUI#UpdateVertexData$1","TMPro.TextMeshProUGUI#UpdateVertexData","TMPro.TextMeshProUGUI#UpdateFontAsset","TMPro.TextMeshProUGUI#Awake","TMPro.TextMeshProUGUI#OnEnable","TMPro.TextMeshProUGUI#OnDisable","TMPro.TextMeshProUGUI#OnDestroy","TMPro.TextMeshProUGUI#LoadFontAsset","TMPro.TextMeshProUGUI#GetCanvas","TMPro.TextMeshProUGUI#UpdateEnvMapMatrix","TMPro.TextMeshProUGUI#EnableMasking","TMPro.TextMeshProUGUI#DisableMasking","TMPro.TextMeshProUGUI#UpdateMask","TMPro.TextMeshProUGUI#GetMaterial","TMPro.TextMeshProUGUI#GetMaterials","TMPro.TextMeshProUGUI#SetSharedMaterial","TMPro.TextMeshProUGUI#GetSharedMaterials","TMPro.TextMeshProUGUI#SetSharedMaterials","TMPro.TextMeshProUGUI#SetOutlineThickness","TMPro.TextMeshProUGUI#SetFaceColor","TMPro.TextMeshProUGUI#SetOutlineColor","TMPro.TextMeshProUGUI#SetShaderDepth","TMPro.TextMeshProUGUI#SetCulling","TMPro.TextMeshProUGUI#SetPerspectiveCorrection","TMPro.TextMeshProUGUI#SetMeshArrays","TMPro.TextMeshProUGUI#SetArraySizes","TMPro.TextMeshProUGUI#ComputeMarginSize","TMPro.TextMeshProUGUI#OnDidApplyAnimationProperties","TMPro.TextMeshProUGUI#OnCanvasHierarchyChanged","TMPro.TextMeshProUGUI#OnTransformParentChanged","TMPro.TextMeshProUGUI#OnRectTransformDimensionsChange","TMPro.TextMeshProUGUI#InternalUpdate","TMPro.TextMeshProUGUI#OnPreRenderCanvas","TMPro.TextMeshProUGUI#GenerateTextMesh","TMPro.TextMeshProUGUI#GetTextContainerLocalCorners","TMPro.TextMeshProUGUI#SetActiveSubMeshes","TMPro.TextMeshProUGUI#DestroySubMeshObjects","TMPro.TextMeshProUGUI#GetCompoundBounds","TMPro.TextMeshProUGUI#GetCanvasSpaceClippingRect","TMPro.TextMeshProUGUI#UpdateSDFScale","TMPro.TMP_Character#ctor","TMPro.TMP_Character#$ctor3","TMPro.TMP_Character#$ctor2","TMPro.TMP_Character#$ctor1","TMPro.TMP_FontAsset#init","TMPro.TMP_FontAsset#CreateFontAsset","TMPro.TMP_FontAsset#CreateFontAsset$1","TMPro.TMP_FontAsset#GetCharacters","TMPro.TMP_FontAsset#GetCharactersArray","TMPro.TMP_FontAsset#RegisterFontAssetForFontFeatureUpdate","TMPro.TMP_FontAsset#UpdateFontFeaturesForFontAssetsInQueue","TMPro.TMP_FontAsset#RegisterFontAssetForAtlasTextureUpdate","TMPro.TMP_FontAsset#UpdateAtlasTexturesForFontAssetsInQueue","TMPro.TMP_FontAsset#version#get","TMPro.TMP_FontAsset#version#set","TMPro.TMP_FontAsset#sourceFontFile#get","TMPro.TMP_FontAsset#sourceFontFile#set","TMPro.TMP_FontAsset#atlasPopulationMode#get","TMPro.TMP_FontAsset#atlasPopulationMode#set","TMPro.TMP_FontAsset#faceInfo#get","TMPro.TMP_FontAsset#faceInfo#set","TMPro.TMP_FontAsset#glyphTable#get","TMPro.TMP_FontAsset#glyphTable#set","TMPro.TMP_FontAsset#glyphLookupTable#get","TMPro.TMP_FontAsset#characterTable#get","TMPro.TMP_FontAsset#characterTable#set","TMPro.TMP_FontAsset#characterLookupTable#get","TMPro.TMP_FontAsset#atlasTexture#get","TMPro.TMP_FontAsset#atlasTextures#get","TMPro.TMP_FontAsset#atlasTextures#set","TMPro.TMP_FontAsset#atlasTextureCount#get","TMPro.TMP_FontAsset#isMultiAtlasTexturesEnabled#get","TMPro.TMP_FontAsset#isMultiAtlasTexturesEnabled#set","TMPro.TMP_FontAsset#clearDynamicDataOnBuild#get","TMPro.TMP_FontAsset#clearDynamicDataOnBuild#set","TMPro.TMP_FontAsset#usedGlyphRects#get","TMPro.TMP_FontAsset#usedGlyphRects#set","TMPro.TMP_FontAsset#freeGlyphRects#get","TMPro.TMP_FontAsset#freeGlyphRects#set","TMPro.TMP_FontAsset#fontInfo#get","TMPro.TMP_FontAsset#atlasWidth#get","TMPro.TMP_FontAsset#atlasWidth#set","TMPro.TMP_FontAsset#atlasHeight#get","TMPro.TMP_FontAsset#atlasHeight#set","TMPro.TMP_FontAsset#atlasPadding#get","TMPro.TMP_FontAsset#atlasPadding#set","TMPro.TMP_FontAsset#atlasRenderMode#get","TMPro.TMP_FontAsset#atlasRenderMode#set","TMPro.TMP_FontAsset#fontFeatureTable#get","TMPro.TMP_FontAsset#fontFeatureTable#set","TMPro.TMP_FontAsset#fallbackFontAssetTable#get","TMPro.TMP_FontAsset#fallbackFontAssetTable#set","TMPro.TMP_FontAsset#creationSettings#get","TMPro.TMP_FontAsset#creationSettings#set","TMPro.TMP_FontAsset#fontWeightTable#get","TMPro.TMP_FontAsset#fontWeightTable#set","TMPro.TMP_FontAsset#init","TMPro.TMP_FontAsset#Awake","TMPro.TMP_FontAsset#ReadFontAssetDefinition","TMPro.TMP_FontAsset#InitializeDictionaryLookupTables","TMPro.TMP_FontAsset#InitializeGlyphLookupDictionary","TMPro.TMP_FontAsset#InitializeCharacterLookupDictionary","TMPro.TMP_FontAsset#InitializeGlyphPaidAdjustmentRecordsLookupDictionary","TMPro.TMP_FontAsset#AddSynthesizedCharactersAndFaceMetrics","TMPro.TMP_FontAsset#AddSynthesizedCharacter","TMPro.TMP_FontAsset#AddCharacterToLookupCache","TMPro.TMP_FontAsset#SortCharacterTable","TMPro.TMP_FontAsset#SortGlyphTable","TMPro.TMP_FontAsset#SortFontFeatureTable","TMPro.TMP_FontAsset#SortAllTables","TMPro.TMP_FontAsset#HasCharacter$1","TMPro.TMP_FontAsset#HasCharacter","TMPro.TMP_FontAsset#HasCharacter_Internal","TMPro.TMP_FontAsset#HasCharacters$1","TMPro.TMP_FontAsset#HasCharacters$2","TMPro.TMP_FontAsset#HasCharacters","TMPro.TMP_FontAsset#GetGlyphIndex","TMPro.TMP_FontAsset#TryAddCharacters$2","TMPro.TMP_FontAsset#TryAddCharacters$3","TMPro.TMP_FontAsset#TryAddCharacters","TMPro.TMP_FontAsset#TryAddCharacters$1","TMPro.TMP_FontAsset#TryAddCharacterInternal","TMPro.TMP_FontAsset#TryGetCharacter_and_QueueRenderToTexture","TMPro.TMP_FontAsset#TryAddGlyphsToAtlasTextures","TMPro.TMP_FontAsset#TryAddGlyphsToNewAtlasTexture","TMPro.TMP_FontAsset#SetupNewAtlasTexture","TMPro.TMP_FontAsset#UpdateAtlasTexture","TMPro.TMP_FontAsset#UpdateGlyphAdjustmentRecords","TMPro.TMP_FontAsset#UpdateGlyphAdjustmentRecords$3","TMPro.TMP_FontAsset#UpdateGlyphAdjustmentRecords$1","TMPro.TMP_FontAsset#UpdateGlyphAdjustmentRecords$2","TMPro.TMP_FontAsset#CopyListDataToArray","TMPro.TMP_FontAsset#ClearFontAssetData","TMPro.TMP_FontAsset#ClearFontAssetDataInternal","TMPro.TMP_FontAsset#UpdateFontAssetData","TMPro.TMP_FontAsset#ClearFontAssetTables","TMPro.TMP_FontAsset#ClearAtlasTextures","TMPro.TMP_FontAsset#UpgradeFontAsset","TMPro.TMP_FontAsset#UpgradeGlyphAdjustmentTableToFontFeatureTable","TMPro.TMP_Glyph#Clone","TMPro.TMP_Sprite#init","TMPro.TMP_SpriteAsset#SearchForSpriteByUnicode","TMPro.TMP_SpriteAsset#SearchForSpriteByUnicodeInternal","TMPro.TMP_SpriteAsset#SearchForSpriteByUnicodeInternal$1","TMPro.TMP_SpriteAsset#SearchForSpriteByHashCode","TMPro.TMP_SpriteAsset#SearchForSpriteByHashCodeInternal","TMPro.TMP_SpriteAsset#SearchForSpriteByHashCodeInternal$1","TMPro.TMP_SpriteAsset#version#get","TMPro.TMP_SpriteAsset#version#set","TMPro.TMP_SpriteAsset#faceInfo#get","TMPro.TMP_SpriteAsset#faceInfo#set","TMPro.TMP_SpriteAsset#spriteCharacterTable#get","TMPro.TMP_SpriteAsset#spriteCharacterTable#set","TMPro.TMP_SpriteAsset#spriteCharacterLookupTable#get","TMPro.TMP_SpriteAsset#spriteCharacterLookupTable#set","TMPro.TMP_SpriteAsset#spriteGlyphTable#get","TMPro.TMP_SpriteAsset#spriteGlyphTable#set","TMPro.TMP_SpriteAsset#init","TMPro.TMP_SpriteAsset#Awake","TMPro.TMP_SpriteAsset#GetDefaultSpriteMaterial","TMPro.TMP_SpriteAsset#UpdateLookupTables","TMPro.TMP_SpriteAsset#GetSpriteIndexFromHashcode","TMPro.TMP_SpriteAsset#GetSpriteIndexFromUnicode","TMPro.TMP_SpriteAsset#GetSpriteIndexFromName","TMPro.TMP_SpriteAsset#SortGlyphTable","TMPro.TMP_SpriteAsset#SortCharacterTable","TMPro.TMP_SpriteAsset#SortGlyphAndCharacterTables","TMPro.TMP_SpriteAsset#UpgradeSpriteAsset","TMPro.TMP_SpriteCharacter#name#get","TMPro.TMP_SpriteCharacter#name#set","TMPro.TMP_SpriteCharacter#hashCode#get","TMPro.TMP_SpriteCharacter#ctor","TMPro.TMP_SpriteCharacter#$ctor3","TMPro.TMP_SpriteCharacter#$ctor2","TMPro.TMP_SpriteCharacter#$ctor1","TMPro.TweenRunner$1#Start","TMPro.TweenRunner$1#Init","TMPro.TweenRunner$1#StartTween","TMPro.TweenRunner$1#StopTween"]' ) ); }
/**
 * @compiler Bridge.NET 17.9.33-luna
 */
Bridge.assembly("TextMeshPro", function ($asm, globals) {
    "use strict";

    /*TMPro.AtlasPopulationMode start.*/
    Bridge.define("TMPro.AtlasPopulationMode", {
        $kind: 6,
        statics: {
            fields: {
                Static: 0,
                Dynamic: 1
            }
        }
    });
    /*TMPro.AtlasPopulationMode end.*/

    /*TMPro.CaretInfo start.*/
    /** @namespace TMPro */

    /**
     * Structure which contains the character index and position of caret relative to the character.
     *
     * @public
     * @class TMPro.CaretInfo
     */
    Bridge.define("TMPro.CaretInfo", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.CaretInfo#getDefaultValue", this ); }
 return new TMPro.CaretInfo(); }
            }
        },
        fields: {
            index: 0,
            position: 0
        },
        ctors: {
            $ctor1: function (index, position) {
if ( TRACE ) { TRACE( "TMPro.CaretInfo#$ctor1", this ); }

                this.$initialize();
                this.index = index;
                this.position = position;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.CaretInfo#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.CaretInfo#getHashCode", this ); }

                var h = Bridge.addHash([3420498726, this.index, this.position]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.CaretInfo#equals", this ); }

                if (!Bridge.is(o, TMPro.CaretInfo)) {
                    return false;
                }
                return Bridge.equals(this.index, o.index) && Bridge.equals(this.position, o.position);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.CaretInfo#$clone", this ); }

                var s = to || new TMPro.CaretInfo();
                s.index = this.index;
                s.position = this.position;
                return s;
            }
        }
    });
    /*TMPro.CaretInfo end.*/

    /*TMPro.CaretPosition start.*/
    Bridge.define("TMPro.CaretPosition", {
        $kind: 6,
        statics: {
            fields: {
                None: 0,
                Left: 1,
                Right: 2
            }
        }
    });
    /*TMPro.CaretPosition end.*/

    /*TMPro.CodePoint start.*/
    /**
     * Commonly referenced Unicode characters in the text generation process.
     *
     * @static
     * @abstract
     * @class TMPro.CodePoint
     */
    Bridge.define("TMPro.CodePoint", {
        statics: {
            fields: {
                SPACE: 0,
                DOUBLE_QUOTE: 0,
                NUMBER_SIGN: 0,
                PERCENTAGE: 0,
                PLUS: 0,
                MINUS: 0,
                PERIOD: 0,
                HYPHEN_MINUS: 0,
                SOFT_HYPHEN: 0,
                HYPHEN: 0,
                NON_BREAKING_HYPHEN: 0,
                ZERO_WIDTH_SPACE: 0,
                RIGHT_SINGLE_QUOTATION: 0,
                APOSTROPHE: 0,
                WORD_JOINER: 0,
                HIGH_SURROGATE_START: 0,
                HIGH_SURROGATE_END: 0,
                LOW_SURROGATE_START: 0,
                LOW_SURROGATE_END: 0,
                UNICODE_PLANE01_START: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "TMPro.CodePoint#init", this ); }

                    this.SPACE = 32;
                    this.DOUBLE_QUOTE = 34;
                    this.NUMBER_SIGN = 35;
                    this.PERCENTAGE = 37;
                    this.PLUS = 43;
                    this.MINUS = 45;
                    this.PERIOD = 46;
                    this.HYPHEN_MINUS = 45;
                    this.SOFT_HYPHEN = 173;
                    this.HYPHEN = 8208;
                    this.NON_BREAKING_HYPHEN = 8209;
                    this.ZERO_WIDTH_SPACE = 8203;
                    this.RIGHT_SINGLE_QUOTATION = 8217;
                    this.APOSTROPHE = 39;
                    this.WORD_JOINER = 8288;
                    this.HIGH_SURROGATE_START = 55296;
                    this.HIGH_SURROGATE_END = 56319;
                    this.LOW_SURROGATE_START = 56320;
                    this.LOW_SURROGATE_END = 57343;
                    this.UNICODE_PLANE01_START = 65536;
                }
            }
        }
    });
    /*TMPro.CodePoint end.*/

    /*TMPro.ColorMode start.*/
    Bridge.define("TMPro.ColorMode", {
        $kind: 6,
        statics: {
            fields: {
                Single: 0,
                HorizontalGradient: 1,
                VerticalGradient: 2,
                FourCornersGradient: 3
            }
        }
    });
    /*TMPro.ColorMode end.*/

    /*TMPro.ITweenValue start.*/
    Bridge.define("TMPro.ITweenValue", {
        $kind: 3
    });
    /*TMPro.ITweenValue end.*/

    /*TMPro.ColorTween+ColorTweenCallback start.*/
    Bridge.define("TMPro.ColorTween.ColorTweenCallback", {
        inherits: [UnityEngine.Events.UnityEvent$1(UnityEngine.Color)],
        $kind: 1002
    });
    /*TMPro.ColorTween+ColorTweenCallback end.*/

    /*TMPro.ColorTween+ColorTweenMode start.*/
    Bridge.define("TMPro.ColorTween.ColorTweenMode", {
        $kind: 1006,
        statics: {
            fields: {
                All: 0,
                RGB: 1,
                Alpha: 2
            }
        }
    });
    /*TMPro.ColorTween+ColorTweenMode end.*/

    /*TMPro.Compute_DistanceTransform_EventTypes start.*/
    Bridge.define("TMPro.Compute_DistanceTransform_EventTypes", {
        $kind: 6,
        statics: {
            fields: {
                Processing: 0,
                Completed: 1
            }
        }
    });
    /*TMPro.Compute_DistanceTransform_EventTypes end.*/

    /*TMPro.Compute_DT_EventArgs start.*/
    Bridge.define("TMPro.Compute_DT_EventArgs", {
        fields: {
            EventType: 0,
            ProgressPercentage: 0,
            Colors: null
        },
        ctors: {
            ctor: function (type, progress) {
if ( TRACE ) { TRACE( "TMPro.Compute_DT_EventArgs#ctor", this ); }

                this.$initialize();
                this.EventType = type;
                this.ProgressPercentage = progress;
            },
            $ctor1: function (type, colors) {
if ( TRACE ) { TRACE( "TMPro.Compute_DT_EventArgs#$ctor1", this ); }

                this.$initialize();
                this.EventType = type;
                this.Colors = colors;
            }
        }
    });
    /*TMPro.Compute_DT_EventArgs end.*/

    /*TMPro.Extents start.*/
    Bridge.define("TMPro.Extents", {
        $kind: 4,
        statics: {
            fields: {
                zero: null,
                uninitialized: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "TMPro.Extents#init", this ); }

                    this.zero = new TMPro.Extents();
                    this.uninitialized = new TMPro.Extents();
                    this.zero = new TMPro.Extents.$ctor1(pc.Vec2.ZERO.clone(), pc.Vec2.ZERO.clone());
                    this.uninitialized = new TMPro.Extents.$ctor1(new pc.Vec2( 32767, 32767 ), new pc.Vec2( -32767, -32767 ));
                }
            },
            methods: {
                /*TMPro.Extents.OverrideClone:static start.*/
                OverrideClone: function () {
if ( TRACE ) { TRACE( "TMPro.Extents#OverrideClone", this ); }

                    
            TMPro.Extents.prototype.$clone = function ( to ) {
                var s = to || new TMPro.Extents();
                s.min.copy( this.min );
                s.max.copy( this.max );
                return s;
            }
            ;
                },
                /*TMPro.Extents.OverrideClone:static end.*/

                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.Extents#getDefaultValue", this ); }
 return new TMPro.Extents(); }
            }
        },
        fields: {
            min: null,
            max: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.Extents#init", this ); }

                this.min = new UnityEngine.Vector2();
                this.max = new UnityEngine.Vector2();
            },
            $ctor1: function (min, max) {
if ( TRACE ) { TRACE( "TMPro.Extents#$ctor1", this ); }

                this.$initialize();
                this.min = min.$clone();
                this.max = max.$clone();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.Extents#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*TMPro.Extents.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "TMPro.Extents#toString", this ); }

                var s = "Min (" + (System.Single.format(this.min.x, "f2") || "") + ", " + (System.Single.format(this.min.y, "f2") || "") + ")   Max (" + (System.Single.format(this.max.x, "f2") || "") + ", " + (System.Single.format(this.max.y, "f2") || "") + ")";
                return s;
            },
            /*TMPro.Extents.toString end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.Extents#getHashCode", this ); }

                var h = Bridge.addHash([1709698227, this.min, this.max]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.Extents#equals", this ); }

                if (!Bridge.is(o, TMPro.Extents)) {
                    return false;
                }
                return Bridge.equals(this.min, o.min) && Bridge.equals(this.max, o.max);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.Extents#$clone", this ); }

                var s = to || new TMPro.Extents();
                s.min = this.min.$clone();
                s.max = this.max.$clone();
                return s;
            }
        },
        overloads: {
            "ToString()": "toString"
        }
    });

    Bridge.init(function () { TMPro.Extents.OverrideClone(); });
    /*TMPro.Extents end.*/

    /*TMPro.FaceInfo_Legacy start.*/
    /**
     * Class that contains the basic information about the font.
     *
     * @public
     * @class TMPro.FaceInfo_Legacy
     */
    Bridge.define("TMPro.FaceInfo_Legacy", {
        fields: {
            Name: null,
            PointSize: 0,
            Scale: 0,
            CharacterCount: 0,
            LineHeight: 0,
            Baseline: 0,
            Ascender: 0,
            CapHeight: 0,
            Descender: 0,
            CenterLine: 0,
            SuperscriptOffset: 0,
            SubscriptOffset: 0,
            SubSize: 0,
            Underline: 0,
            UnderlineThickness: 0,
            strikethrough: 0,
            strikethroughThickness: 0,
            TabWidth: 0,
            Padding: 0,
            AtlasWidth: 0,
            AtlasHeight: 0
        }
    });
    /*TMPro.FaceInfo_Legacy end.*/

    /*TMPro.FastAction start.*/
    Bridge.define("TMPro.FastAction", {
        fields: {
            delegates: null,
            lookup: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.FastAction#init", this ); }

                this.delegates = new (System.Collections.Generic.LinkedList$1(Function)).ctor();
                this.lookup = new (System.Collections.Generic.Dictionary$2(Function,System.Collections.Generic.LinkedListNode$1(Function))).ctor();
            }
        },
        methods: {
            /*TMPro.FastAction.Add start.*/
            Add: function (rhs) {
if ( TRACE ) { TRACE( "TMPro.FastAction#Add", this ); }

                if (this.lookup.containsKey(rhs)) {
                    return;
                }

                this.lookup.setItem(rhs, this.delegates.AddLast(rhs));
            },
            /*TMPro.FastAction.Add end.*/

            /*TMPro.FastAction.Remove start.*/
            Remove: function (rhs) {
if ( TRACE ) { TRACE( "TMPro.FastAction#Remove", this ); }

                var node = { };
                if (this.lookup.tryGetValue(rhs, node)) {
                    this.lookup.remove(rhs);
                    this.delegates.Remove(node.v);
                }
            },
            /*TMPro.FastAction.Remove end.*/

            /*TMPro.FastAction.Call start.*/
            Call: function () {
if ( TRACE ) { TRACE( "TMPro.FastAction#Call", this ); }

                var node = this.delegates.First;
                while (node != null) {
                    node.Value();
                    node = node.Next;
                }
            },
            /*TMPro.FastAction.Call end.*/


        }
    });
    /*TMPro.FastAction end.*/

    /*TMPro.FastAction$1 start.*/
    Bridge.define("TMPro.FastAction$1", function (A) { return {
        fields: {
            delegates: null,
            lookup: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.FastAction$1#init", this ); }

                this.delegates = new (System.Collections.Generic.LinkedList$1(Function)).ctor();
                this.lookup = new (System.Collections.Generic.Dictionary$2(Function,System.Collections.Generic.LinkedListNode$1(Function))).ctor();
            }
        },
        methods: {
            /*TMPro.FastAction$1.Add start.*/
            Add: function (rhs) {
if ( TRACE ) { TRACE( "TMPro.FastAction$1#Add", this ); }

                if (this.lookup.containsKey(rhs)) {
                    return;
                }

                this.lookup.setItem(rhs, this.delegates.AddLast(rhs));
            },
            /*TMPro.FastAction$1.Add end.*/

            /*TMPro.FastAction$1.Remove start.*/
            Remove: function (rhs) {
if ( TRACE ) { TRACE( "TMPro.FastAction$1#Remove", this ); }

                var node = { };
                if (this.lookup.tryGetValue(rhs, node)) {
                    this.lookup.remove(rhs);
                    this.delegates.Remove(node.v);
                }
            },
            /*TMPro.FastAction$1.Remove end.*/

            /*TMPro.FastAction$1.Call start.*/
            Call: function (a) {
if ( TRACE ) { TRACE( "TMPro.FastAction$1#Call", this ); }

                var node = this.delegates.First;
                while (node != null) {
                    node.Value(a);
                    node = node.Next;
                }
            },
            /*TMPro.FastAction$1.Call end.*/


        }
    }; });
    /*TMPro.FastAction$1 end.*/

    /*TMPro.FastAction$2 start.*/
    Bridge.define("TMPro.FastAction$2", function (A, B) { return {
        fields: {
            delegates: null,
            lookup: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.FastAction$2#init", this ); }

                this.delegates = new (System.Collections.Generic.LinkedList$1(Function)).ctor();
                this.lookup = new (System.Collections.Generic.Dictionary$2(Function,System.Collections.Generic.LinkedListNode$1(Function))).ctor();
            }
        },
        methods: {
            /*TMPro.FastAction$2.Add start.*/
            Add: function (rhs) {
if ( TRACE ) { TRACE( "TMPro.FastAction$2#Add", this ); }

                if (this.lookup.containsKey(rhs)) {
                    return;
                }

                this.lookup.setItem(rhs, this.delegates.AddLast(rhs));
            },
            /*TMPro.FastAction$2.Add end.*/

            /*TMPro.FastAction$2.Remove start.*/
            Remove: function (rhs) {
if ( TRACE ) { TRACE( "TMPro.FastAction$2#Remove", this ); }

                var node = { };
                if (this.lookup.tryGetValue(rhs, node)) {
                    this.lookup.remove(rhs);
                    this.delegates.Remove(node.v);
                }
            },
            /*TMPro.FastAction$2.Remove end.*/

            /*TMPro.FastAction$2.Call start.*/
            Call: function (a, b) {
if ( TRACE ) { TRACE( "TMPro.FastAction$2#Call", this ); }

                var node = this.delegates.First;
                while (node != null) {
                    node.Value(a, b);
                    node = node.Next;
                }
            },
            /*TMPro.FastAction$2.Call end.*/


        }
    }; });
    /*TMPro.FastAction$2 end.*/

    /*TMPro.FastAction$3 start.*/
    Bridge.define("TMPro.FastAction$3", function (A, B, C) { return {
        fields: {
            delegates: null,
            lookup: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.FastAction$3#init", this ); }

                this.delegates = new (System.Collections.Generic.LinkedList$1(Function)).ctor();
                this.lookup = new (System.Collections.Generic.Dictionary$2(Function,System.Collections.Generic.LinkedListNode$1(Function))).ctor();
            }
        },
        methods: {
            /*TMPro.FastAction$3.Add start.*/
            Add: function (rhs) {
if ( TRACE ) { TRACE( "TMPro.FastAction$3#Add", this ); }

                if (this.lookup.containsKey(rhs)) {
                    return;
                }

                this.lookup.setItem(rhs, this.delegates.AddLast(rhs));
            },
            /*TMPro.FastAction$3.Add end.*/

            /*TMPro.FastAction$3.Remove start.*/
            Remove: function (rhs) {
if ( TRACE ) { TRACE( "TMPro.FastAction$3#Remove", this ); }

                var node = { };
                if (this.lookup.tryGetValue(rhs, node)) {
                    this.lookup.remove(rhs);
                    this.delegates.Remove(node.v);
                }
            },
            /*TMPro.FastAction$3.Remove end.*/

            /*TMPro.FastAction$3.Call start.*/
            Call: function (a, b, c) {
if ( TRACE ) { TRACE( "TMPro.FastAction$3#Call", this ); }

                var node = this.delegates.First;
                while (node != null) {
                    node.Value(a, b, c);
                    node = node.Next;
                }
            },
            /*TMPro.FastAction$3.Call end.*/


        }
    }; });
    /*TMPro.FastAction$3 end.*/

    /*TMPro.FloatTween+FloatTweenCallback start.*/
    Bridge.define("TMPro.FloatTween.FloatTweenCallback", {
        inherits: [UnityEngine.Events.UnityEvent$1(System.Single)],
        $kind: 1002
    });
    /*TMPro.FloatTween+FloatTweenCallback end.*/

    /*TMPro.FontAssetCreationSettings start.*/
    Bridge.define("TMPro.FontAssetCreationSettings", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.FontAssetCreationSettings#getDefaultValue", this ); }
 return new TMPro.FontAssetCreationSettings(); }
            }
        },
        fields: {
            sourceFontFileName: null,
            sourceFontFileGUID: null,
            pointSizeSamplingMode: 0,
            pointSize: 0,
            padding: 0,
            packingMode: 0,
            atlasWidth: 0,
            atlasHeight: 0,
            characterSetSelectionMode: 0,
            characterSequence: null,
            referencedFontAssetGUID: null,
            referencedTextAssetGUID: null,
            fontStyle: 0,
            fontStyleModifier: 0,
            renderMode: 0,
            includeFontFeatures: false
        },
        ctors: {
            $ctor1: function (sourceFontFileGUID, pointSize, pointSizeSamplingMode, padding, packingMode, atlasWidth, atlasHeight, characterSelectionMode, characterSet, renderMode) {
if ( TRACE ) { TRACE( "TMPro.FontAssetCreationSettings#$ctor1", this ); }

                this.$initialize();
                this.sourceFontFileName = "";
                this.sourceFontFileGUID = sourceFontFileGUID;
                this.pointSize = pointSize;
                this.pointSizeSamplingMode = pointSizeSamplingMode;
                this.padding = padding;
                this.packingMode = packingMode;
                this.atlasWidth = atlasWidth;
                this.atlasHeight = atlasHeight;
                this.characterSequence = characterSet;
                this.characterSetSelectionMode = characterSelectionMode;
                this.renderMode = renderMode;

                this.referencedFontAssetGUID = "";
                this.referencedTextAssetGUID = "";
                this.fontStyle = 0;
                this.fontStyleModifier = 0;
                this.includeFontFeatures = false;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.FontAssetCreationSettings#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.FontAssetCreationSettings#getHashCode", this ); }

                var h = Bridge.addHash([10914715569, this.sourceFontFileName, this.sourceFontFileGUID, this.pointSizeSamplingMode, this.pointSize, this.padding, this.packingMode, this.atlasWidth, this.atlasHeight, this.characterSetSelectionMode, this.characterSequence, this.referencedFontAssetGUID, this.referencedTextAssetGUID, this.fontStyle, this.fontStyleModifier, this.renderMode, this.includeFontFeatures]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.FontAssetCreationSettings#equals", this ); }

                if (!Bridge.is(o, TMPro.FontAssetCreationSettings)) {
                    return false;
                }
                return Bridge.equals(this.sourceFontFileName, o.sourceFontFileName) && Bridge.equals(this.sourceFontFileGUID, o.sourceFontFileGUID) && Bridge.equals(this.pointSizeSamplingMode, o.pointSizeSamplingMode) && Bridge.equals(this.pointSize, o.pointSize) && Bridge.equals(this.padding, o.padding) && Bridge.equals(this.packingMode, o.packingMode) && Bridge.equals(this.atlasWidth, o.atlasWidth) && Bridge.equals(this.atlasHeight, o.atlasHeight) && Bridge.equals(this.characterSetSelectionMode, o.characterSetSelectionMode) && Bridge.equals(this.characterSequence, o.characterSequence) && Bridge.equals(this.referencedFontAssetGUID, o.referencedFontAssetGUID) && Bridge.equals(this.referencedTextAssetGUID, o.referencedTextAssetGUID) && Bridge.equals(this.fontStyle, o.fontStyle) && Bridge.equals(this.fontStyleModifier, o.fontStyleModifier) && Bridge.equals(this.renderMode, o.renderMode) && Bridge.equals(this.includeFontFeatures, o.includeFontFeatures);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.FontAssetCreationSettings#$clone", this ); }

                var s = to || new TMPro.FontAssetCreationSettings();
                s.sourceFontFileName = this.sourceFontFileName;
                s.sourceFontFileGUID = this.sourceFontFileGUID;
                s.pointSizeSamplingMode = this.pointSizeSamplingMode;
                s.pointSize = this.pointSize;
                s.padding = this.padding;
                s.packingMode = this.packingMode;
                s.atlasWidth = this.atlasWidth;
                s.atlasHeight = this.atlasHeight;
                s.characterSetSelectionMode = this.characterSetSelectionMode;
                s.characterSequence = this.characterSequence;
                s.referencedFontAssetGUID = this.referencedFontAssetGUID;
                s.referencedTextAssetGUID = this.referencedTextAssetGUID;
                s.fontStyle = this.fontStyle;
                s.fontStyleModifier = this.fontStyleModifier;
                s.renderMode = this.renderMode;
                s.includeFontFeatures = this.includeFontFeatures;
                return s;
            }
        }
    });
    /*TMPro.FontAssetCreationSettings end.*/

    /*TMPro.FontFeatureLookupFlags start.*/
    Bridge.define("TMPro.FontFeatureLookupFlags", {
        $kind: 6,
        statics: {
            fields: {
                None: 0,
                IgnoreLigatures: 4,
                IgnoreSpacingAdjustments: 256
            }
        },
        $flags: true
    });
    /*TMPro.FontFeatureLookupFlags end.*/

    /*TMPro.FontStyles start.*/
    Bridge.define("TMPro.FontStyles", {
        $kind: 6,
        statics: {
            fields: {
                Normal: 0,
                Bold: 1,
                Italic: 2,
                Underline: 4,
                LowerCase: 8,
                UpperCase: 16,
                SmallCaps: 32,
                Strikethrough: 64,
                Superscript: 128,
                Subscript: 256,
                Highlight: 512
            }
        },
        $flags: true
    });
    /*TMPro.FontStyles end.*/

    /*TMPro.FontWeight start.*/
    Bridge.define("TMPro.FontWeight", {
        $kind: 6,
        statics: {
            fields: {
                Thin: 100,
                ExtraLight: 200,
                Light: 300,
                Regular: 400,
                Medium: 500,
                SemiBold: 600,
                Bold: 700,
                Heavy: 800,
                Black: 900
            }
        }
    });
    /*TMPro.FontWeight end.*/

    /*TMPro.GlyphPairKey start.*/
    Bridge.define("TMPro.GlyphPairKey", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.GlyphPairKey#getDefaultValue", this ); }
 return new TMPro.GlyphPairKey(); }
            }
        },
        fields: {
            firstGlyphIndex: 0,
            secondGlyphIndex: 0,
            key: 0
        },
        ctors: {
            $ctor1: function (firstGlyphIndex, secondGlyphIndex) {
if ( TRACE ) { TRACE( "TMPro.GlyphPairKey#$ctor1", this ); }

                this.$initialize();
                this.firstGlyphIndex = firstGlyphIndex;
                this.secondGlyphIndex = secondGlyphIndex;
                this.key = (secondGlyphIndex << 16) | firstGlyphIndex;
            },
            $ctor2: function (record) {
if ( TRACE ) { TRACE( "TMPro.GlyphPairKey#$ctor2", this ); }

                this.$initialize();
                this.firstGlyphIndex = record.firstAdjustmentRecord.glyphIndex;
                this.secondGlyphIndex = record.secondAdjustmentRecord.glyphIndex;
                this.key = (this.secondGlyphIndex << 16) | this.firstGlyphIndex;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.GlyphPairKey#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.GlyphPairKey#getHashCode", this ); }

                var h = Bridge.addHash([5691672609, this.firstGlyphIndex, this.secondGlyphIndex, this.key]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.GlyphPairKey#equals", this ); }

                if (!Bridge.is(o, TMPro.GlyphPairKey)) {
                    return false;
                }
                return Bridge.equals(this.firstGlyphIndex, o.firstGlyphIndex) && Bridge.equals(this.secondGlyphIndex, o.secondGlyphIndex) && Bridge.equals(this.key, o.key);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.GlyphPairKey#$clone", this ); }

                var s = to || new TMPro.GlyphPairKey();
                s.firstGlyphIndex = this.firstGlyphIndex;
                s.secondGlyphIndex = this.secondGlyphIndex;
                s.key = this.key;
                return s;
            }
        }
    });
    /*TMPro.GlyphPairKey end.*/

    /*TMPro.GlyphValueRecord_Legacy start.*/
    /**
     * Positional adjustments of a glyph
     *
     * @public
     * @class TMPro.GlyphValueRecord_Legacy
     */
    Bridge.define("TMPro.GlyphValueRecord_Legacy", {
        $kind: 4,
        statics: {
            methods: {
                op_Addition: function (a, b) {
if ( TRACE ) { TRACE( "TMPro.GlyphValueRecord_Legacy#op_Addition", this ); }

                    var c = new TMPro.GlyphValueRecord_Legacy();
                    c.xPlacement = a.xPlacement + b.xPlacement;
                    c.yPlacement = a.yPlacement + b.yPlacement;
                    c.xAdvance = a.xAdvance + b.xAdvance;
                    c.yAdvance = a.yAdvance + b.yAdvance;

                    return c.$clone();
                },
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.GlyphValueRecord_Legacy#getDefaultValue", this ); }
 return new TMPro.GlyphValueRecord_Legacy(); }
            }
        },
        fields: {
            xPlacement: 0,
            yPlacement: 0,
            xAdvance: 0,
            yAdvance: 0
        },
        ctors: {
            $ctor1: function (valueRecord) {
if ( TRACE ) { TRACE( "TMPro.GlyphValueRecord_Legacy#$ctor1", this ); }

                this.$initialize();
                this.xPlacement = valueRecord.xPlacement;
                this.yPlacement = valueRecord.yPlacement;
                this.xAdvance = valueRecord.xAdvance;
                this.yAdvance = valueRecord.yAdvance;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.GlyphValueRecord_Legacy#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.GlyphValueRecord_Legacy#getHashCode", this ); }

                var h = Bridge.addHash([8833091399, this.xPlacement, this.yPlacement, this.xAdvance, this.yAdvance]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.GlyphValueRecord_Legacy#equals", this ); }

                if (!Bridge.is(o, TMPro.GlyphValueRecord_Legacy)) {
                    return false;
                }
                return Bridge.equals(this.xPlacement, o.xPlacement) && Bridge.equals(this.yPlacement, o.yPlacement) && Bridge.equals(this.xAdvance, o.xAdvance) && Bridge.equals(this.yAdvance, o.yAdvance);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.GlyphValueRecord_Legacy#$clone", this ); }

                var s = to || new TMPro.GlyphValueRecord_Legacy();
                s.xPlacement = this.xPlacement;
                s.yPlacement = this.yPlacement;
                s.xAdvance = this.xAdvance;
                s.yAdvance = this.yAdvance;
                return s;
            }
        }
    });
    /*TMPro.GlyphValueRecord_Legacy end.*/

    /*TMPro.HighlightState start.*/
    /**
     * @public
     * @class TMPro.HighlightState
     */
    Bridge.define("TMPro.HighlightState", {
        $kind: 4,
        statics: {
            methods: {
                op_Equality: function (lhs, rhs) {
if ( TRACE ) { TRACE( "TMPro.HighlightState#op_Equality", this ); }

                    return TMPro.TMPro_ExtensionMethods.Compare$1(lhs.color, rhs.color.$clone()) && TMPro.TMP_Offset.op_Equality(lhs.padding.$clone(), rhs.padding.$clone());
                },
                op_Inequality: function (lhs, rhs) {
if ( TRACE ) { TRACE( "TMPro.HighlightState#op_Inequality", this ); }

                    return !(TMPro.HighlightState.op_Equality(lhs.$clone(), rhs.$clone()));
                },
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.HighlightState#getDefaultValue", this ); }
 return new TMPro.HighlightState(); }
            }
        },
        fields: {
            color: null,
            padding: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.HighlightState#init", this ); }

                this.color = new UnityEngine.Color32();
                this.padding = new TMPro.TMP_Offset();
            },
            $ctor1: function (color, padding) {
if ( TRACE ) { TRACE( "TMPro.HighlightState#$ctor1", this ); }

                this.$initialize();
                this.color = color.$clone();
                this.padding = padding.$clone();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.HighlightState#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*TMPro.HighlightState.Copy start.*/
            Copy: function (other) {
if ( TRACE ) { TRACE( "TMPro.HighlightState#Copy", this ); }

                this.color.Copy(other.color);
                this.padding.Copy(other.padding);
            },
            /*TMPro.HighlightState.Copy end.*/

            /*TMPro.HighlightState.getHashCode start.*/
            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.HighlightState#getHashCode", this ); }

                return Bridge.getHashCode(this);
            },
            /*TMPro.HighlightState.getHashCode end.*/

            /*TMPro.HighlightState.equals start.*/
            equals: function (obj) {
if ( TRACE ) { TRACE( "TMPro.HighlightState#equals", this ); }

                return Bridge.equals(this, obj);
            },
            /*TMPro.HighlightState.equals end.*/

            /*TMPro.HighlightState.Equals start.*/
            Equals: function (other) {
if ( TRACE ) { TRACE( "TMPro.HighlightState#Equals", this ); }

                return Bridge.equals(this, other.$clone());
            },
            /*TMPro.HighlightState.Equals end.*/

            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.HighlightState#$clone", this ); }

                var s = to || new TMPro.HighlightState();
                s.color = this.color.$clone();
                s.padding = this.padding.$clone();
                return s;
            }
        },
        overloads: {
            "GetHashCode()": "getHashCode",
            "Equals(object)": "equals"
        }
    });
    /*TMPro.HighlightState end.*/

    /*TMPro.HorizontalAlignmentOptions start.*/
    /**
     * Horizontal text alignment options.
     *
     * @public
     * @class TMPro.HorizontalAlignmentOptions
     */
    Bridge.define("TMPro.HorizontalAlignmentOptions", {
        $kind: 6,
        statics: {
            fields: {
                Left: 1,
                Center: 2,
                Right: 4,
                Justified: 8,
                Flush: 16,
                Geometry: 32
            }
        }
    });
    /*TMPro.HorizontalAlignmentOptions end.*/

    /*TMPro.ITextElement start.*/
    Bridge.define("TMPro.ITextElement", {
        $kind: 3
    });
    /*TMPro.ITextElement end.*/

    /*TMPro.ITextPreprocessor start.*/
    /**
     * Interface used for preprocessing and shaping of text.
     *
     * @abstract
     * @public
     * @class TMPro.ITextPreprocessor
     */
    Bridge.define("TMPro.ITextPreprocessor", {
        $kind: 3
    });
    /*TMPro.ITextPreprocessor end.*/

    /*TMPro.KerningPair start.*/
    Bridge.define("TMPro.KerningPair", {
        statics: {
            fields: {
                empty: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "TMPro.KerningPair#init", this ); }

                    this.empty = new TMPro.KerningPair.$ctor2(0, new TMPro.GlyphValueRecord_Legacy.ctor(), 0, new TMPro.GlyphValueRecord_Legacy.ctor());
                }
            }
        },
        fields: {
            m_FirstGlyph: 0,
            m_FirstGlyphAdjustments: null,
            m_SecondGlyph: 0,
            m_SecondGlyphAdjustments: null,
            xOffset: 0,
            m_IgnoreSpacingAdjustments: false
        },
        props: {
            /**
             * The first glyph part of a kerning pair.
             *
             * @instance
             * @public
             * @memberof TMPro.KerningPair
             * @function firstGlyph
             * @type number
             */
            firstGlyph: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.KerningPair#firstGlyph#get", this ); }

                    return this.m_FirstGlyph;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.KerningPair#firstGlyph#set", this ); }

                    this.m_FirstGlyph = value;
                }
            },
            /**
             * The positional adjustment of the first glyph.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.KerningPair
             * @function firstGlyphAdjustments
             * @type TMPro.GlyphValueRecord_Legacy
             */
            firstGlyphAdjustments: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.KerningPair#firstGlyphAdjustments#get", this ); }

                    return this.m_FirstGlyphAdjustments.$clone();
                }
            },
            /**
             * The second glyph part of a kerning pair.
             *
             * @instance
             * @public
             * @memberof TMPro.KerningPair
             * @function secondGlyph
             * @type number
             */
            secondGlyph: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.KerningPair#secondGlyph#get", this ); }

                    return this.m_SecondGlyph;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.KerningPair#secondGlyph#set", this ); }

                    this.m_SecondGlyph = value;
                }
            },
            /**
             * The positional adjustment of the second glyph.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.KerningPair
             * @function secondGlyphAdjustments
             * @type TMPro.GlyphValueRecord_Legacy
             */
            secondGlyphAdjustments: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.KerningPair#secondGlyphAdjustments#get", this ); }

                    return this.m_SecondGlyphAdjustments.$clone();
                }
            },
            /**
             * Determines if the Character Spacing property of the text object will affect the kerning pair.
             This is mostly relevant when using Diacritical marks to prevent Character Spacing from altering the
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.KerningPair
             * @function ignoreSpacingAdjustments
             * @type boolean
             */
            ignoreSpacingAdjustments: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.KerningPair#ignoreSpacingAdjustments#get", this ); }

                    return this.m_IgnoreSpacingAdjustments;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.KerningPair#init", this ); }

                this.m_FirstGlyphAdjustments = new TMPro.GlyphValueRecord_Legacy();
                this.m_SecondGlyphAdjustments = new TMPro.GlyphValueRecord_Legacy();
                this.m_IgnoreSpacingAdjustments = false;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.KerningPair#ctor", this ); }

                this.$initialize();
                this.m_FirstGlyph = 0;
                this.m_FirstGlyphAdjustments = new TMPro.GlyphValueRecord_Legacy.ctor();

                this.m_SecondGlyph = 0;
                this.m_SecondGlyphAdjustments = new TMPro.GlyphValueRecord_Legacy.ctor();
            },
            $ctor1: function (left, right, offset) {
if ( TRACE ) { TRACE( "TMPro.KerningPair#$ctor1", this ); }

                this.$initialize();
                this.firstGlyph = left;
                this.m_SecondGlyph = right;
                this.xOffset = offset;
            },
            $ctor2: function (firstGlyph, firstGlyphAdjustments, secondGlyph, secondGlyphAdjustments) {
if ( TRACE ) { TRACE( "TMPro.KerningPair#$ctor2", this ); }

                this.$initialize();
                this.m_FirstGlyph = firstGlyph;
                this.m_FirstGlyphAdjustments = firstGlyphAdjustments.$clone();
                this.m_SecondGlyph = secondGlyph;
                this.m_SecondGlyphAdjustments = secondGlyphAdjustments.$clone();
            }
        },
        methods: {
            /*TMPro.KerningPair.ConvertLegacyKerningData start.*/
            ConvertLegacyKerningData: function () {
if ( TRACE ) { TRACE( "TMPro.KerningPair#ConvertLegacyKerningData", this ); }

                this.m_FirstGlyphAdjustments.xAdvance = this.xOffset;
                //xOffset = 0;
            },
            /*TMPro.KerningPair.ConvertLegacyKerningData end.*/


        }
    });
    /*TMPro.KerningPair end.*/

    /*TMPro.KerningPairKey start.*/
    Bridge.define("TMPro.KerningPairKey", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.KerningPairKey#getDefaultValue", this ); }
 return new TMPro.KerningPairKey(); }
            }
        },
        fields: {
            ascii_Left: 0,
            ascii_Right: 0,
            key: 0
        },
        ctors: {
            $ctor1: function (ascii_left, ascii_right) {
if ( TRACE ) { TRACE( "TMPro.KerningPairKey#$ctor1", this ); }

                this.$initialize();
                this.ascii_Left = ascii_left;
                this.ascii_Right = ascii_right;
                this.key = (ascii_right << 16) + ascii_left;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.KerningPairKey#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.KerningPairKey#getHashCode", this ); }

                var h = Bridge.addHash([4467766906, this.ascii_Left, this.ascii_Right, this.key]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.KerningPairKey#equals", this ); }

                if (!Bridge.is(o, TMPro.KerningPairKey)) {
                    return false;
                }
                return Bridge.equals(this.ascii_Left, o.ascii_Left) && Bridge.equals(this.ascii_Right, o.ascii_Right) && Bridge.equals(this.key, o.key);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.KerningPairKey#$clone", this ); }

                var s = to || new TMPro.KerningPairKey();
                s.ascii_Left = this.ascii_Left;
                s.ascii_Right = this.ascii_Right;
                s.key = this.key;
                return s;
            }
        }
    });
    /*TMPro.KerningPairKey end.*/

    /*TMPro.KerningTable start.*/
    Bridge.define("TMPro.KerningTable", {
        fields: {
            kerningPairs: null
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.KerningTable#ctor", this ); }

                this.$initialize();
                this.kerningPairs = new (System.Collections.Generic.List$1(TMPro.KerningPair)).ctor();
            }
        },
        methods: {
            /*TMPro.KerningTable.AddKerningPair$1 start.*/
            AddKerningPair$1: function () {
if ( TRACE ) { TRACE( "TMPro.KerningTable#AddKerningPair$1", this ); }

                if (this.kerningPairs.Count === 0) {
                    this.kerningPairs.add(new TMPro.KerningPair.$ctor1(0, 0, 0));
                } else {
                    var left = System.Linq.Enumerable.from(this.kerningPairs, TMPro.KerningPair).last().firstGlyph;
                    var right = System.Linq.Enumerable.from(this.kerningPairs, TMPro.KerningPair).last().secondGlyph;
                    var xoffset = System.Linq.Enumerable.from(this.kerningPairs, TMPro.KerningPair).last().xOffset;

                    this.kerningPairs.add(new TMPro.KerningPair.$ctor1(left, right, xoffset));
                }
            },
            /*TMPro.KerningTable.AddKerningPair$1 end.*/

            /*TMPro.KerningTable.AddKerningPair start.*/
            /**
             * Add Kerning Pair
             *
             * @instance
             * @public
             * @this TMPro.KerningTable
             * @memberof TMPro.KerningTable
             * @param   {number}    first     First glyph
             * @param   {number}    second    Second glyph
             * @param   {number}    offset    xAdvance value
             * @return  {number}
             */
            AddKerningPair: function (first, second, offset) {
if ( TRACE ) { TRACE( "TMPro.KerningTable#AddKerningPair", this ); }

                var index = this.kerningPairs.FindIndex$2(function (item) {
                    return item.firstGlyph === first && item.secondGlyph === second;
                });

                if (index === -1) {
                    this.kerningPairs.add(new TMPro.KerningPair.$ctor1(first, second, offset));
                    return 0;
                }

                // Return -1 if Kerning Pair already exists.
                return -1;
            },
            /*TMPro.KerningTable.AddKerningPair end.*/

            /*TMPro.KerningTable.AddGlyphPairAdjustmentRecord start.*/
            /**
             * Add Glyph pair adjustment record
             *
             * @instance
             * @public
             * @this TMPro.KerningTable
             * @memberof TMPro.KerningTable
             * @param   {number}                           first                
             * @param   {TMPro.GlyphValueRecord_Legacy}    firstAdjustments     
             * @param   {number}                           second               
             * @param   {TMPro.GlyphValueRecord_Legacy}    secondAdjustments
             * @return  {number}
             */
            AddGlyphPairAdjustmentRecord: function (first, firstAdjustments, second, secondAdjustments) {
if ( TRACE ) { TRACE( "TMPro.KerningTable#AddGlyphPairAdjustmentRecord", this ); }

                var index = this.kerningPairs.FindIndex$2(function (item) {
                    return item.firstGlyph === first && item.secondGlyph === second;
                });

                if (index === -1) {
                    this.kerningPairs.add(new TMPro.KerningPair.$ctor2(first, firstAdjustments.$clone(), second, secondAdjustments.$clone()));
                    return 0;
                }

                // Return -1 if Kerning Pair already exists.
                return -1;
            },
            /*TMPro.KerningTable.AddGlyphPairAdjustmentRecord end.*/

            /*TMPro.KerningTable.RemoveKerningPair$1 start.*/
            RemoveKerningPair$1: function (left, right) {
if ( TRACE ) { TRACE( "TMPro.KerningTable#RemoveKerningPair$1", this ); }

                var index = this.kerningPairs.FindIndex$2(function (item) {
                    return System.Int64(item.firstGlyph).equals(System.Int64(left)) && System.Int64(item.secondGlyph).equals(System.Int64(right));
                });

                if (index !== -1) {
                    this.kerningPairs.removeAt(index);
                }
            },
            /*TMPro.KerningTable.RemoveKerningPair$1 end.*/

            /*TMPro.KerningTable.RemoveKerningPair start.*/
            RemoveKerningPair: function (index) {
if ( TRACE ) { TRACE( "TMPro.KerningTable#RemoveKerningPair", this ); }

                this.kerningPairs.removeAt(index);
            },
            /*TMPro.KerningTable.RemoveKerningPair end.*/

            /*TMPro.KerningTable.SortKerningPairs start.*/
            SortKerningPairs: function () {
if ( TRACE ) { TRACE( "TMPro.KerningTable#SortKerningPairs", this ); }

                // Sort List of Kerning Info
                if (this.kerningPairs.Count > 0) {
                    this.kerningPairs = System.Linq.Enumerable.from(this.kerningPairs, TMPro.KerningPair).orderBy(function (s) {
                            return s.firstGlyph;
                        }).thenBy(function (s) {
                        return s.secondGlyph;
                    }).toList(TMPro.KerningPair);
                }
            },
            /*TMPro.KerningTable.SortKerningPairs end.*/


        },
        overloads: {
            "AddKerningPair()": "AddKerningPair$1",
            "RemoveKerningPair(int, int)": "RemoveKerningPair$1"
        }
    });
    /*TMPro.KerningTable end.*/

    /*TMPro.MarkupTag start.*/
    /**
     * Rich Text Tags and Attribute definitions and their respective HashCode values.
     *
     * @class TMPro.MarkupTag
     * @augments number
     */
    Bridge.define("TMPro.MarkupTag", {
        $kind: 6,
        statics: {
            fields: {
                BOLD: 66,
                SLASH_BOLD: 1613,
                ITALIC: 73,
                SLASH_ITALIC: 1606,
                UNDERLINE: 85,
                SLASH_UNDERLINE: 1626,
                STRIKETHROUGH: 83,
                SLASH_STRIKETHROUGH: 1628,
                MARK: 2699125,
                SLASH_MARK: 57644506,
                SUBSCRIPT: 92132,
                SLASH_SUBSCRIPT: 1770219,
                SUPERSCRIPT: 92150,
                SLASH_SUPERSCRIPT: 1770233,
                COLOR: 81999901,
                SLASH_COLOR: 1909026194,
                ALPHA: 75165780,
                A: 65,
                SLASH_A: 1614,
                SIZE: 3061285,
                SLASH_SIZE: 58429962,
                SPRITE: -991527447,
                NO_BREAK: 2856657,
                SLASH_NO_BREAK: 57477502,
                STYLE: 100252951,
                SLASH_STYLE: 1927738392,
                FONT: 2586451,
                SLASH_FONT: 57747708,
                SLASH_MATERIAL: -1100708252,
                LINK: 2656128,
                SLASH_LINK: 57686191,
                FONT_WEIGHT: -1889896162,
                SLASH_FONT_WEIGHT: -757976431,
                NO_PARSE: -408011596,
                SLASH_NO_PARSE: -294095813,
                POSITION: 85420,
                SLASH_POSITION: 1777699,
                VERTICAL_OFFSET: 1952379995,
                SLASH_VERTICAL_OFFSET: -11107948,
                SPACE: 100083556,
                SLASH_SPACE: 1927873067,
                PAGE: 2808691,
                SLASH_PAGE: 58683868,
                ALIGN: 75138797,
                SLASH_ALIGN: 1916026786,
                WIDTH: 105793766,
                SLASH_WIDTH: 1923459625,
                GRADIENT: -1999759898,
                SLASH_GRADIENT: -1854491959,
                CHARACTER_SPACE: -1584382009,
                SLASH_CHARACTER_SPACE: -1394426712,
                MONOSPACE: -1340221943,
                SLASH_MONOSPACE: -1638865562,
                CLASS: 82115566,
                INDENT: -1514123076,
                SLASH_INDENT: -1496889389,
                LINE_INDENT: -844305121,
                SLASH_LINE_INDENT: 93886352,
                MARGIN: -1355614050,
                SLASH_MARGIN: -1649644303,
                MARGIN_LEFT: -272933656,
                MARGIN_RIGHT: -447416589,
                LINE_HEIGHT: -799081892,
                SLASH_LINE_HEIGHT: 200452819,
                ACTION: -1827519330,
                SLASH_ACTION: -1187217679,
                SCALE: 100553336,
                SLASH_SCALE: 1928413879,
                ROTATE: -1000007783,
                SLASH_ROTATE: -764695562,
                LOWERCASE: -1506899689,
                SLASH_LOWERCASE: -1451284584,
                ALLCAPS: 218273952,
                SLASH_ALLCAPS: -797437649,
                UPPERCASE: -305409418,
                SLASH_UPPERCASE: -582368199,
                SMALLCAPS: -766062114,
                SLASH_SMALLCAPS: 199921873,
                LIGA: 2655971,
                SLASH_LIGA: 57686604,
                FRAC: 2598518,
                SLASH_FRAC: 57774681,
                NAME: 2875623,
                INDEX: 84268030,
                TINT: 2960519,
                ANIM: 2283339,
                MATERIAL: 825491659,
                HREF: 2535353,
                ANGLE: 75347905,
                RED: 91635,
                GREEN: 87065851,
                BLUE: 2457214,
                YELLOW: -882444668,
                ORANGE: -1108587920,
                BLACK: 81074727,
                WHITE: 105680263,
                PURPLE: -1250222130,
                BR: 2256,
                ZWSP: 3288238,
                NBSP: 2869039,
                SHY: 92674,
                LEFT: 2660507,
                RIGHT: 99937376,
                CENTER: -1591113269,
                JUSTIFIED: 817091359,
                FLUSH: 85552164,
                NONE: 2857034,
                PLUS: 43,
                MINUS: 45,
                PX: 2568,
                PLUS_PX: 49507,
                MINUS_PX: 47461,
                EM: 2216,
                PLUS_EM: 49091,
                MINUS_EM: 46789,
                PCT: 85031,
                PLUS_PCT: 1634348,
                MINUS_PCT: 1567082,
                PERCENTAGE: 37,
                PLUS_PERCENTAGE: 1454,
                MINUS_PERCENTAGE: 1512,
                TRUE: 2932022,
                FALSE: 85422813,
                INVALID: 1585415185,
                NORMAL: -1183493901,
                DEFAULT: -620974005
            }
        }
    });
    /*TMPro.MarkupTag end.*/

    /*TMPro.MaskingOffsetMode start.*/
    Bridge.define("TMPro.MaskingOffsetMode", {
        $kind: 6,
        statics: {
            fields: {
                Percentage: 0,
                Pixel: 1
            }
        }
    });
    /*TMPro.MaskingOffsetMode end.*/

    /*TMPro.MaskingTypes start.*/
    Bridge.define("TMPro.MaskingTypes", {
        $kind: 6,
        statics: {
            fields: {
                MaskOff: 0,
                MaskHard: 1,
                MaskSoft: 2
            }
        }
    });
    /*TMPro.MaskingTypes end.*/

    /*TMPro.MaterialReference start.*/
    Bridge.define("TMPro.MaterialReference", {
        $kind: 4,
        statics: {
            methods: {
                /*TMPro.MaterialReference.Contains:static start.*/
                /**
                 * Function to check if a certain font asset is contained in the material reference array.
                 *
                 * @static
                 * @public
                 * @this TMPro.MaterialReference
                 * @memberof TMPro.MaterialReference
                 * @param   {Array.<TMPro.MaterialReference>}    materialReferences    
                 * @param   {TMPro.TMP_FontAsset}                fontAsset
                 * @return  {boolean}
                 */
                Contains: function (materialReferences, fontAsset) {
if ( TRACE ) { TRACE( "TMPro.MaterialReference#Contains", this ); }

                    var id = fontAsset.GetInstanceID();

                    for (var i = 0; i < materialReferences.length && materialReferences[i].fontAsset != null; i++) {
                        if (materialReferences[i].fontAsset.GetInstanceID() === id) {
                            return true;
                        }
                    }

                    return false;
                },
                /*TMPro.MaterialReference.Contains:static end.*/

                /*TMPro.MaterialReference.AddMaterialReference:static start.*/
                /**
                 * Function to add a new material reference and returning its index in the material reference array.
                 *
                 * @static
                 * @public
                 * @this TMPro.MaterialReference
                 * @memberof TMPro.MaterialReference
                 * @param   {UnityEngine.Material}                       material                        
                 * @param   {TMPro.TMP_FontAsset}                        fontAsset                       
                 * @param   {TMPro.MaterialReference}                    materialReferences              
                 * @param   {System.Collections.Generic.Dictionary$2}    materialReferenceIndexLookup
                 * @return  {number}
                 */
                AddMaterialReference: function (material, fontAsset, materialReferences, materialReferenceIndexLookup) {
if ( TRACE ) { TRACE( "TMPro.MaterialReference#AddMaterialReference", this ); }

                    var materialID = material.GetInstanceID();
                    var index = { };

                    if (materialReferenceIndexLookup.tryGetValue(materialID, index)) {
                        return index.v;
                    }

                    index.v = materialReferenceIndexLookup.Count;

                    // Add new reference index
                    materialReferenceIndexLookup.setItem(materialID, index.v);

                    if (index.v >= materialReferences.v.length) {
                        System.Array.resize(materialReferences, UnityEngine.Mathf.NextPowerOfTwo(index.v + 1), function () {
                            return Bridge.getDefaultValue(TMPro.MaterialReference);
                        }, TMPro.MaterialReference);
                    }

                    materialReferences.v[index.v].index = index.v;
                    materialReferences.v[index.v].fontAsset = fontAsset;
                    materialReferences.v[index.v].spriteAsset = null;
                    materialReferences.v[index.v].material = material;
                    materialReferences.v[index.v].isDefaultMaterial = materialID === fontAsset.material.GetInstanceID() ? true : false;
                    //materialReferences[index].padding = 0;
                    materialReferences.v[index.v].referenceCount = 0;

                    return index.v;
                },
                /*TMPro.MaterialReference.AddMaterialReference:static end.*/

                /*TMPro.MaterialReference.AddMaterialReference$1:static start.*/
                /**
                 * @static
                 * @public
                 * @this TMPro.MaterialReference
                 * @memberof TMPro.MaterialReference
                 * @param   {UnityEngine.Material}                       material                        
                 * @param   {TMPro.TMP_SpriteAsset}                      spriteAsset                     
                 * @param   {TMPro.MaterialReference}                    materialReferences              
                 * @param   {System.Collections.Generic.Dictionary$2}    materialReferenceIndexLookup
                 * @return  {number}
                 */
                AddMaterialReference$1: function (material, spriteAsset, materialReferences, materialReferenceIndexLookup) {
if ( TRACE ) { TRACE( "TMPro.MaterialReference#AddMaterialReference$1", this ); }

                    var materialID = material.GetInstanceID();
                    var index = { };

                    if (materialReferenceIndexLookup.tryGetValue(materialID, index)) {
                        return index.v;
                    }

                    index.v = materialReferenceIndexLookup.Count;

                    // Add new reference index
                    materialReferenceIndexLookup.setItem(materialID, index.v);

                    if (index.v >= materialReferences.v.length) {
                        System.Array.resize(materialReferences, UnityEngine.Mathf.NextPowerOfTwo(index.v + 1), function () {
                            return Bridge.getDefaultValue(TMPro.MaterialReference);
                        }, TMPro.MaterialReference);
                    }

                    materialReferences.v[index.v].index = index.v;
                    materialReferences.v[index.v].fontAsset = materialReferences.v[0].fontAsset;
                    materialReferences.v[index.v].spriteAsset = spriteAsset;
                    materialReferences.v[index.v].material = material;
                    materialReferences.v[index.v].isDefaultMaterial = true;
                    //materialReferences[index].padding = 0;
                    materialReferences.v[index.v].referenceCount = 0;

                    return index.v;
                },
                /*TMPro.MaterialReference.AddMaterialReference$1:static end.*/

                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.MaterialReference#getDefaultValue", this ); }
 return new TMPro.MaterialReference(); }
            }
        },
        fields: {
            index: 0,
            fontAsset: null,
            spriteAsset: null,
            material: null,
            isDefaultMaterial: false,
            isFallbackMaterial: false,
            fallbackMaterial: null,
            padding: 0,
            referenceCount: 0
        },
        ctors: {
            /**
             * Constructor for new Material Reference.
             *
             * @instance
             * @public
             * @this TMPro.MaterialReference
             * @memberof TMPro.MaterialReference
             * @param   {number}                   index          
             * @param   {TMPro.TMP_FontAsset}      fontAsset      
             * @param   {TMPro.TMP_SpriteAsset}    spriteAsset    
             * @param   {UnityEngine.Material}     material       
             * @param   {number}                   padding
             * @return  {void}
             */
            $ctor1: function (index, fontAsset, spriteAsset, material, padding) {
if ( TRACE ) { TRACE( "TMPro.MaterialReference#$ctor1", this ); }

                this.$initialize();
                this.index = index;
                this.fontAsset = fontAsset;
                this.spriteAsset = spriteAsset;
                this.material = material;
                this.isDefaultMaterial = material.GetInstanceID() === fontAsset.material.GetInstanceID() ? true : false;
                this.isFallbackMaterial = false;
                this.fallbackMaterial = null;
                this.padding = padding;
                this.referenceCount = 0;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.MaterialReference#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*TMPro.MaterialReference.Copy start.*/
            Copy: function (other) {
if ( TRACE ) { TRACE( "TMPro.MaterialReference#Copy", this ); }

                this.index = other.index;
                this.fontAsset = other.fontAsset;
                this.spriteAsset = other.spriteAsset;
                this.material = other.material;
                this.isDefaultMaterial = other.isDefaultMaterial;
                this.isFallbackMaterial = other.isFallbackMaterial;
                this.fallbackMaterial = other.fallbackMaterial;
                this.padding = other.padding;
                this.referenceCount = other.referenceCount;
            },
            /*TMPro.MaterialReference.Copy end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.MaterialReference#getHashCode", this ); }

                var h = Bridge.addHash([6889838056, this.index, this.fontAsset, this.spriteAsset, this.material, this.isDefaultMaterial, this.isFallbackMaterial, this.fallbackMaterial, this.padding, this.referenceCount]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.MaterialReference#equals", this ); }

                if (!Bridge.is(o, TMPro.MaterialReference)) {
                    return false;
                }
                return Bridge.equals(this.index, o.index) && Bridge.equals(this.fontAsset, o.fontAsset) && Bridge.equals(this.spriteAsset, o.spriteAsset) && Bridge.equals(this.material, o.material) && Bridge.equals(this.isDefaultMaterial, o.isDefaultMaterial) && Bridge.equals(this.isFallbackMaterial, o.isFallbackMaterial) && Bridge.equals(this.fallbackMaterial, o.fallbackMaterial) && Bridge.equals(this.padding, o.padding) && Bridge.equals(this.referenceCount, o.referenceCount);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.MaterialReference#$clone", this ); }

                var s = to || new TMPro.MaterialReference();
                s.index = this.index;
                s.fontAsset = this.fontAsset;
                s.spriteAsset = this.spriteAsset;
                s.material = this.material;
                s.isDefaultMaterial = this.isDefaultMaterial;
                s.isFallbackMaterial = this.isFallbackMaterial;
                s.fallbackMaterial = this.fallbackMaterial;
                s.padding = this.padding;
                s.referenceCount = this.referenceCount;
                return s;
            }
        }
    });
    /*TMPro.MaterialReference end.*/

    /*TMPro.MaterialReferenceManager start.*/
    /**
     * Function to lookup a material based on hash code and returning the MaterialReference containing this material.
     * 
     * 
     * 
     * 
     * Function to clear the reference count for each of the material references.
     *
     * @public
     * @class TMPro.MaterialReferenceManager
     * @return  {[type]}
     */
    Bridge.define("TMPro.MaterialReferenceManager", {
        statics: {
            fields: {
                s_Instance: null
            },
            props: {
                /**
                 * Get a singleton instance of the registry
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof TMPro.MaterialReferenceManager
                 * @function instance
                 * @type TMPro.MaterialReferenceManager
                 */
                instance: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.MaterialReferenceManager#instance#get", this ); }

                        if (TMPro.MaterialReferenceManager.s_Instance == null) {
                            TMPro.MaterialReferenceManager.s_Instance = new TMPro.MaterialReferenceManager();
                        }

                        return TMPro.MaterialReferenceManager.s_Instance;
                    }
                }
            },
            methods: {
                /*TMPro.MaterialReferenceManager.AddFontAsset:static start.*/
                /**
                 * Add new font asset reference to dictionary.
                 *
                 * @static
                 * @public
                 * @this TMPro.MaterialReferenceManager
                 * @memberof TMPro.MaterialReferenceManager
                 * @param   {TMPro.TMP_FontAsset}    fontAsset
                 * @return  {void}
                 */
                AddFontAsset: function (fontAsset) {
if ( TRACE ) { TRACE( "TMPro.MaterialReferenceManager#AddFontAsset", this ); }

                    TMPro.MaterialReferenceManager.instance.AddFontAssetInternal(fontAsset);
                },
                /*TMPro.MaterialReferenceManager.AddFontAsset:static end.*/

                /*TMPro.MaterialReferenceManager.AddSpriteAsset$1:static start.*/
                /**
                 * Add new Sprite Asset to dictionary.
                 *
                 * @static
                 * @public
                 * @this TMPro.MaterialReferenceManager
                 * @memberof TMPro.MaterialReferenceManager
                 * @param   {TMPro.TMP_SpriteAsset}    spriteAsset
                 * @return  {void}
                 */
                AddSpriteAsset$1: function (spriteAsset) {
if ( TRACE ) { TRACE( "TMPro.MaterialReferenceManager#AddSpriteAsset$1", this ); }

                    TMPro.MaterialReferenceManager.instance.AddSpriteAssetInternal$1(spriteAsset);
                },
                /*TMPro.MaterialReferenceManager.AddSpriteAsset$1:static end.*/

                /*TMPro.MaterialReferenceManager.AddSpriteAsset:static start.*/
                /**
                 * Add new Sprite Asset to dictionary.
                 *
                 * @static
                 * @public
                 * @this TMPro.MaterialReferenceManager
                 * @memberof TMPro.MaterialReferenceManager
                 * @param   {number}                   hashCode       
                 * @param   {TMPro.TMP_SpriteAsset}    spriteAsset
                 * @return  {void}
                 */
                AddSpriteAsset: function (hashCode, spriteAsset) {
if ( TRACE ) { TRACE( "TMPro.MaterialReferenceManager#AddSpriteAsset", this ); }

                    TMPro.MaterialReferenceManager.instance.AddSpriteAssetInternal(hashCode, spriteAsset);
                },
                /*TMPro.MaterialReferenceManager.AddSpriteAsset:static end.*/

                /*TMPro.MaterialReferenceManager.AddFontMaterial:static start.*/
                /**
                 * Add new Material reference to dictionary.
                 *
                 * @static
                 * @public
                 * @this TMPro.MaterialReferenceManager
                 * @memberof TMPro.MaterialReferenceManager
                 * @param   {number}                  hashCode    
                 * @param   {UnityEngine.Material}    material
                 * @return  {void}
                 */
                AddFontMaterial: function (hashCode, material) {
if ( TRACE ) { TRACE( "TMPro.MaterialReferenceManager#AddFontMaterial", this ); }

                    TMPro.MaterialReferenceManager.instance.AddFontMaterialInternal(hashCode, material);
                },
                /*TMPro.MaterialReferenceManager.AddFontMaterial:static end.*/

                /*TMPro.MaterialReferenceManager.AddColorGradientPreset:static start.*/
                /**
                 * Add new Color Gradient Preset to dictionary.
                 *
                 * @static
                 * @public
                 * @this TMPro.MaterialReferenceManager
                 * @memberof TMPro.MaterialReferenceManager
                 * @param   {number}                     hashCode       
                 * @param   {TMPro.TMP_ColorGradient}    spriteAsset
                 * @return  {void}
                 */
                AddColorGradientPreset: function (hashCode, spriteAsset) {
if ( TRACE ) { TRACE( "TMPro.MaterialReferenceManager#AddColorGradientPreset", this ); }

                    TMPro.MaterialReferenceManager.instance.AddColorGradientPreset_Internal(hashCode, spriteAsset);
                },
                /*TMPro.MaterialReferenceManager.AddColorGradientPreset:static end.*/

                /*TMPro.MaterialReferenceManager.TryGetFontAsset:static start.*/
                /**
                 * Function returning the Font Asset corresponding to the provided hash code.
                 *
                 * @static
                 * @public
                 * @this TMPro.MaterialReferenceManager
                 * @memberof TMPro.MaterialReferenceManager
                 * @param   {number}                 hashCode     
                 * @param   {TMPro.TMP_FontAsset}    fontAsset
                 * @return  {boolean}
                 */
                TryGetFontAsset: function (hashCode, fontAsset) {
if ( TRACE ) { TRACE( "TMPro.MaterialReferenceManager#TryGetFontAsset", this ); }

                    return TMPro.MaterialReferenceManager.instance.TryGetFontAssetInternal(hashCode, fontAsset);
                },
                /*TMPro.MaterialReferenceManager.TryGetFontAsset:static end.*/

                /*TMPro.MaterialReferenceManager.TryGetSpriteAsset:static start.*/
                /**
                 * Function returning the Sprite Asset corresponding to the provided hash code.
                 *
                 * @static
                 * @public
                 * @this TMPro.MaterialReferenceManager
                 * @memberof TMPro.MaterialReferenceManager
                 * @param   {number}                   hashCode       
                 * @param   {TMPro.TMP_SpriteAsset}    spriteAsset
                 * @return  {boolean}
                 */
                TryGetSpriteAsset: function (hashCode, spriteAsset) {
if ( TRACE ) { TRACE( "TMPro.MaterialReferenceManager#TryGetSpriteAsset", this ); }

                    return TMPro.MaterialReferenceManager.instance.TryGetSpriteAssetInternal(hashCode, spriteAsset);
                },
                /*TMPro.MaterialReferenceManager.TryGetSpriteAsset:static end.*/

                /*TMPro.MaterialReferenceManager.TryGetColorGradientPreset:static start.*/
                /**
                 * Function returning the Color Gradient Preset corresponding to the provided hash code.
                 *
                 * @static
                 * @public
                 * @this TMPro.MaterialReferenceManager
                 * @memberof TMPro.MaterialReferenceManager
                 * @param   {number}                     hashCode          
                 * @param   {TMPro.TMP_ColorGradient}    gradientPreset
                 * @return  {boolean}
                 */
                TryGetColorGradientPreset: function (hashCode, gradientPreset) {
if ( TRACE ) { TRACE( "TMPro.MaterialReferenceManager#TryGetColorGradientPreset", this ); }

                    return TMPro.MaterialReferenceManager.instance.TryGetColorGradientPresetInternal(hashCode, gradientPreset);
                },
                /*TMPro.MaterialReferenceManager.TryGetColorGradientPreset:static end.*/

                /*TMPro.MaterialReferenceManager.TryGetMaterial:static start.*/
                /**
                 * Function returning the Font Material corresponding to the provided hash code.
                 *
                 * @static
                 * @public
                 * @this TMPro.MaterialReferenceManager
                 * @memberof TMPro.MaterialReferenceManager
                 * @param   {number}                  hashCode    
                 * @param   {UnityEngine.Material}    material
                 * @return  {boolean}
                 */
                TryGetMaterial: function (hashCode, material) {
if ( TRACE ) { TRACE( "TMPro.MaterialReferenceManager#TryGetMaterial", this ); }

                    return TMPro.MaterialReferenceManager.instance.TryGetMaterialInternal(hashCode, material);
                },
                /*TMPro.MaterialReferenceManager.TryGetMaterial:static end.*/


            }
        },
        fields: {
            m_FontMaterialReferenceLookup: null,
            m_FontAssetReferenceLookup: null,
            m_SpriteAssetReferenceLookup: null,
            m_ColorGradientReferenceLookup: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.MaterialReferenceManager#init", this ); }

                this.m_FontMaterialReferenceLookup = new (System.Collections.Generic.Dictionary$2(System.Int32,UnityEngine.Material)).ctor();
                this.m_FontAssetReferenceLookup = new (System.Collections.Generic.Dictionary$2(System.Int32,TMPro.TMP_FontAsset)).ctor();
                this.m_SpriteAssetReferenceLookup = new (System.Collections.Generic.Dictionary$2(System.Int32,TMPro.TMP_SpriteAsset)).ctor();
                this.m_ColorGradientReferenceLookup = new (System.Collections.Generic.Dictionary$2(System.Int32,TMPro.TMP_ColorGradient)).ctor();
            }
        },
        methods: {
            /*TMPro.MaterialReferenceManager.AddFontAssetInternal start.*/
            /**
             * Add new Font Asset reference to dictionary.
             *
             * @instance
             * @private
             * @this TMPro.MaterialReferenceManager
             * @memberof TMPro.MaterialReferenceManager
             * @param   {TMPro.TMP_FontAsset}    fontAsset
             * @return  {void}
             */
            AddFontAssetInternal: function (fontAsset) {
if ( TRACE ) { TRACE( "TMPro.MaterialReferenceManager#AddFontAssetInternal", this ); }

                if (this.m_FontAssetReferenceLookup.containsKey(fontAsset.hashCode)) {
                    return;
                }

                // Add reference to the font asset.
                this.m_FontAssetReferenceLookup.add(fontAsset.hashCode, fontAsset);

                // Add reference to the font material.
                this.m_FontMaterialReferenceLookup.add(fontAsset.materialHashCode, fontAsset.material);
            },
            /*TMPro.MaterialReferenceManager.AddFontAssetInternal end.*/

            /*TMPro.MaterialReferenceManager.AddSpriteAssetInternal$1 start.*/
            /**
             * Internal method to add a new sprite asset to the dictionary.
             *
             * @instance
             * @private
             * @this TMPro.MaterialReferenceManager
             * @memberof TMPro.MaterialReferenceManager
             * @param   {TMPro.TMP_SpriteAsset}    spriteAsset
             * @return  {void}
             */
            AddSpriteAssetInternal$1: function (spriteAsset) {
if ( TRACE ) { TRACE( "TMPro.MaterialReferenceManager#AddSpriteAssetInternal$1", this ); }

                if (this.m_SpriteAssetReferenceLookup.containsKey(spriteAsset.hashCode)) {
                    return;
                }

                // Add reference to sprite asset.
                this.m_SpriteAssetReferenceLookup.add(spriteAsset.hashCode, spriteAsset);

                // Adding reference to the sprite asset material as well
                this.m_FontMaterialReferenceLookup.add(spriteAsset.hashCode, spriteAsset.material);
            },
            /*TMPro.MaterialReferenceManager.AddSpriteAssetInternal$1 end.*/

            /*TMPro.MaterialReferenceManager.AddSpriteAssetInternal start.*/
            /**
             * Internal method to add a new sprite asset to the dictionary.
             *
             * @instance
             * @private
             * @this TMPro.MaterialReferenceManager
             * @memberof TMPro.MaterialReferenceManager
             * @param   {number}                   hashCode       
             * @param   {TMPro.TMP_SpriteAsset}    spriteAsset
             * @return  {void}
             */
            AddSpriteAssetInternal: function (hashCode, spriteAsset) {
if ( TRACE ) { TRACE( "TMPro.MaterialReferenceManager#AddSpriteAssetInternal", this ); }

                if (this.m_SpriteAssetReferenceLookup.containsKey(hashCode)) {
                    return;
                }

                // Add reference to Sprite Asset.
                this.m_SpriteAssetReferenceLookup.add(hashCode, spriteAsset);

                // Add reference to Sprite Asset using the asset hashcode.
                this.m_FontMaterialReferenceLookup.add(hashCode, spriteAsset.material);

                // Compatibility check
                if (spriteAsset.hashCode === 0) {
                    spriteAsset.hashCode = hashCode;
                }
            },
            /*TMPro.MaterialReferenceManager.AddSpriteAssetInternal end.*/

            /*TMPro.MaterialReferenceManager.AddFontMaterialInternal start.*/
            /**
             * Add new material reference to dictionary.
             *
             * @instance
             * @private
             * @this TMPro.MaterialReferenceManager
             * @memberof TMPro.MaterialReferenceManager
             * @param   {number}                  hashCode    
             * @param   {UnityEngine.Material}    material
             * @return  {void}
             */
            AddFontMaterialInternal: function (hashCode, material) {
if ( TRACE ) { TRACE( "TMPro.MaterialReferenceManager#AddFontMaterialInternal", this ); }

                // Since this function is called after checking if the material is
                // contained in the dictionary, there is no need to check again.
                this.m_FontMaterialReferenceLookup.add(hashCode, material);
            },
            /*TMPro.MaterialReferenceManager.AddFontMaterialInternal end.*/

            /*TMPro.MaterialReferenceManager.AddColorGradientPreset_Internal start.*/
            /**
             * Internal method to add a new Color Gradient Preset to the dictionary.
             *
             * @instance
             * @private
             * @this TMPro.MaterialReferenceManager
             * @memberof TMPro.MaterialReferenceManager
             * @param   {number}                     hashCode       
             * @param   {TMPro.TMP_ColorGradient}    spriteAsset
             * @return  {void}
             */
            AddColorGradientPreset_Internal: function (hashCode, spriteAsset) {
if ( TRACE ) { TRACE( "TMPro.MaterialReferenceManager#AddColorGradientPreset_Internal", this ); }

                if (this.m_ColorGradientReferenceLookup.containsKey(hashCode)) {
                    return;
                }

                // Add reference to Color Gradient Preset Asset.
                this.m_ColorGradientReferenceLookup.add(hashCode, spriteAsset);
            },
            /*TMPro.MaterialReferenceManager.AddColorGradientPreset_Internal end.*/

            /*TMPro.MaterialReferenceManager.Contains start.*/
            /**
             * Add new material reference and return the index of this new reference in the materialReferences array.
             * Add new material reference and return the index of this new reference in the materialReferences array.
             * Function to check if the font asset is already referenced.
             *
             * @instance
             * @public
             * @this TMPro.MaterialReferenceManager
             * @memberof TMPro.MaterialReferenceManager
             * @param   {TMPro.TMP_FontAsset}    font
             * @return  {boolean}
             */
            Contains: function (font) {
if ( TRACE ) { TRACE( "TMPro.MaterialReferenceManager#Contains", this ); }

                return this.m_FontAssetReferenceLookup.containsKey(font.hashCode);
            },
            /*TMPro.MaterialReferenceManager.Contains end.*/

            /*TMPro.MaterialReferenceManager.Contains$1 start.*/
            /**
             * Function to check if the sprite asset is already referenced.
             *
             * @instance
             * @public
             * @this TMPro.MaterialReferenceManager
             * @memberof TMPro.MaterialReferenceManager
             * @param   {TMPro.TMP_SpriteAsset}    sprite
             * @return  {boolean}
             */
            Contains$1: function (sprite) {
if ( TRACE ) { TRACE( "TMPro.MaterialReferenceManager#Contains$1", this ); }

                return this.m_FontAssetReferenceLookup.containsKey(sprite.hashCode);
            },
            /*TMPro.MaterialReferenceManager.Contains$1 end.*/

            /*TMPro.MaterialReferenceManager.TryGetFontAssetInternal start.*/
            /**
             * Internal Function returning the Font Asset corresponding to the provided hash code.
             *
             * @instance
             * @private
             * @this TMPro.MaterialReferenceManager
             * @memberof TMPro.MaterialReferenceManager
             * @param   {number}                 hashCode     
             * @param   {TMPro.TMP_FontAsset}    fontAsset
             * @return  {boolean}
             */
            TryGetFontAssetInternal: function (hashCode, fontAsset) {
if ( TRACE ) { TRACE( "TMPro.MaterialReferenceManager#TryGetFontAssetInternal", this ); }

                fontAsset.v = null;

                return this.m_FontAssetReferenceLookup.tryGetValue(hashCode, fontAsset);
            },
            /*TMPro.MaterialReferenceManager.TryGetFontAssetInternal end.*/

            /*TMPro.MaterialReferenceManager.TryGetSpriteAssetInternal start.*/
            /**
             * Internal function returning the Sprite Asset corresponding to the provided hash code.
             *
             * @instance
             * @private
             * @this TMPro.MaterialReferenceManager
             * @memberof TMPro.MaterialReferenceManager
             * @param   {number}                   hashCode       
             * @param   {TMPro.TMP_SpriteAsset}    spriteAsset
             * @return  {boolean}
             */
            TryGetSpriteAssetInternal: function (hashCode, spriteAsset) {
if ( TRACE ) { TRACE( "TMPro.MaterialReferenceManager#TryGetSpriteAssetInternal", this ); }

                spriteAsset.v = null;

                return this.m_SpriteAssetReferenceLookup.tryGetValue(hashCode, spriteAsset);
            },
            /*TMPro.MaterialReferenceManager.TryGetSpriteAssetInternal end.*/

            /*TMPro.MaterialReferenceManager.TryGetColorGradientPresetInternal start.*/
            /**
             * Internal function returning the Color Gradient Preset corresponding to the provided hash code.
             *
             * @instance
             * @private
             * @this TMPro.MaterialReferenceManager
             * @memberof TMPro.MaterialReferenceManager
             * @param   {number}                     hashCode          
             * @param   {TMPro.TMP_ColorGradient}    gradientPreset
             * @return  {boolean}
             */
            TryGetColorGradientPresetInternal: function (hashCode, gradientPreset) {
if ( TRACE ) { TRACE( "TMPro.MaterialReferenceManager#TryGetColorGradientPresetInternal", this ); }

                gradientPreset.v = null;

                return this.m_ColorGradientReferenceLookup.tryGetValue(hashCode, gradientPreset);
            },
            /*TMPro.MaterialReferenceManager.TryGetColorGradientPresetInternal end.*/

            /*TMPro.MaterialReferenceManager.TryGetMaterialInternal start.*/
            /**
             * Internal function returning the Font Material corresponding to the provided hash code.
             *
             * @instance
             * @private
             * @this TMPro.MaterialReferenceManager
             * @memberof TMPro.MaterialReferenceManager
             * @param   {number}                  hashCode    
             * @param   {UnityEngine.Material}    material
             * @return  {boolean}
             */
            TryGetMaterialInternal: function (hashCode, material) {
if ( TRACE ) { TRACE( "TMPro.MaterialReferenceManager#TryGetMaterialInternal", this ); }

                material.v = null;

                return this.m_FontMaterialReferenceLookup.tryGetValue(hashCode, material);
            },
            /*TMPro.MaterialReferenceManager.TryGetMaterialInternal end.*/


        },
        overloads: {
            "AddSpriteAssetInternal(TMP_SpriteAsset)": "AddSpriteAssetInternal$1",
            "Contains(TMP_SpriteAsset)": "Contains$1"
        }
    });
    /*TMPro.MaterialReferenceManager end.*/

    /*TMPro.Mesh_Extents start.*/
    Bridge.define("TMPro.Mesh_Extents", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.Mesh_Extents#getDefaultValue", this ); }
 return new TMPro.Mesh_Extents(); }
            }
        },
        fields: {
            min: null,
            max: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.Mesh_Extents#init", this ); }

                this.min = new UnityEngine.Vector2();
                this.max = new UnityEngine.Vector2();
            },
            $ctor1: function (min, max) {
if ( TRACE ) { TRACE( "TMPro.Mesh_Extents#$ctor1", this ); }

                this.$initialize();
                this.min = min.$clone();
                this.max = max.$clone();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.Mesh_Extents#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*TMPro.Mesh_Extents.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "TMPro.Mesh_Extents#toString", this ); }

                var s = "Min (" + (System.Single.format(this.min.x, "f2") || "") + ", " + (System.Single.format(this.min.y, "f2") || "") + ")   Max (" + (System.Single.format(this.max.x, "f2") || "") + ", " + (System.Single.format(this.max.y, "f2") || "") + ")";
                //string s = "Center: (" + ")" + "  Extents: (" + ((max.x - min.x) / 2).ToString("f2") + "," + ((max.y - min.y) / 2).ToString("f2") + ").";
                return s;
            },
            /*TMPro.Mesh_Extents.toString end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.Mesh_Extents#getHashCode", this ); }

                var h = Bridge.addHash([5643442449, this.min, this.max]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.Mesh_Extents#equals", this ); }

                if (!Bridge.is(o, TMPro.Mesh_Extents)) {
                    return false;
                }
                return Bridge.equals(this.min, o.min) && Bridge.equals(this.max, o.max);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.Mesh_Extents#$clone", this ); }

                var s = to || new TMPro.Mesh_Extents();
                s.min = this.min.$clone();
                s.max = this.max.$clone();
                return s;
            }
        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*TMPro.Mesh_Extents end.*/

    /*TMPro.RichTextTagAttribute start.*/
    Bridge.define("TMPro.RichTextTagAttribute", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.RichTextTagAttribute#getDefaultValue", this ); }
 return new TMPro.RichTextTagAttribute(); }
            }
        },
        fields: {
            nameHashCode: 0,
            valueHashCode: 0,
            valueType: 0,
            valueStartIndex: 0,
            valueLength: 0,
            unitType: 0
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.RichTextTagAttribute#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.RichTextTagAttribute#getHashCode", this ); }

                var h = Bridge.addHash([8273926608, this.nameHashCode, this.valueHashCode, this.valueType, this.valueStartIndex, this.valueLength, this.unitType]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.RichTextTagAttribute#equals", this ); }

                if (!Bridge.is(o, TMPro.RichTextTagAttribute)) {
                    return false;
                }
                return Bridge.equals(this.nameHashCode, o.nameHashCode) && Bridge.equals(this.valueHashCode, o.valueHashCode) && Bridge.equals(this.valueType, o.valueType) && Bridge.equals(this.valueStartIndex, o.valueStartIndex) && Bridge.equals(this.valueLength, o.valueLength) && Bridge.equals(this.unitType, o.unitType);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.RichTextTagAttribute#$clone", this ); }

                var s = to || new TMPro.RichTextTagAttribute();
                s.nameHashCode = this.nameHashCode;
                s.valueHashCode = this.valueHashCode;
                s.valueType = this.valueType;
                s.valueStartIndex = this.valueStartIndex;
                s.valueLength = this.valueLength;
                s.unitType = this.unitType;
                return s;
            }
        }
    });
    /*TMPro.RichTextTagAttribute end.*/

    /*TMPro.SetPropertyUtility start.*/
    Bridge.define("TMPro.SetPropertyUtility", {
        statics: {
            methods: {
                /*TMPro.SetPropertyUtility.SetColor:static start.*/
                SetColor: function (currentValue, newValue) {
if ( TRACE ) { TRACE( "TMPro.SetPropertyUtility#SetColor", this ); }

                    if (currentValue.v.r === newValue.r && currentValue.v.g === newValue.g && currentValue.v.b === newValue.b && currentValue.v.a === newValue.a) {
                        return false;
                    }

                    currentValue.v = newValue.$clone();
                    return true;
                },
                /*TMPro.SetPropertyUtility.SetColor:static end.*/

                /*TMPro.SetPropertyUtility.SetEquatableStruct:static start.*/
                SetEquatableStruct: function (T, currentValue, newValue) {
if ( TRACE ) { TRACE( "TMPro.SetPropertyUtility#SetEquatableStruct", this ); }

                    if (Bridge.equalsT(currentValue.v, newValue, T)) {
                        return false;
                    }

                    currentValue.v = newValue;
                    return true;
                },
                /*TMPro.SetPropertyUtility.SetEquatableStruct:static end.*/

                /*TMPro.SetPropertyUtility.SetStruct:static start.*/
                SetStruct: function (T, currentValue, newValue) {
if ( TRACE ) { TRACE( "TMPro.SetPropertyUtility#SetStruct", this ); }

                    if (Bridge.equals(currentValue.v, newValue)) {
                        return false;
                    }

                    currentValue.v = newValue;
                    return true;
                },
                /*TMPro.SetPropertyUtility.SetStruct:static end.*/

                /*TMPro.SetPropertyUtility.SetClass:static start.*/
                SetClass: function (T, currentValue, newValue) {
if ( TRACE ) { TRACE( "TMPro.SetPropertyUtility#SetClass", this ); }

                    if (currentValue.v == null && newValue == null || currentValue.v != null && Bridge.equals(currentValue.v, newValue)) {
                        return false;
                    }

                    currentValue.v = newValue;
                    return true;
                },
                /*TMPro.SetPropertyUtility.SetClass:static end.*/


            }
        }
    });
    /*TMPro.SetPropertyUtility end.*/

    /*TMPro.ShaderUtilities start.*/
    Bridge.define("TMPro.ShaderUtilities", {
        statics: {
            fields: {
                ID_MainTex: 0,
                ID_FaceTex: 0,
                ID_FaceColor: 0,
                ID_FaceDilate: 0,
                ID_Shininess: 0,
                ID_UnderlayColor: 0,
                ID_UnderlayOffsetX: 0,
                ID_UnderlayOffsetY: 0,
                ID_UnderlayDilate: 0,
                ID_UnderlaySoftness: 0,
                /**
                 * Property ID for the _UnderlayOffset shader property used by URP and HDRP shaders
                 *
                 * @static
                 * @public
                 * @memberof TMPro.ShaderUtilities
                 * @type number
                 */
                ID_UnderlayOffset: 0,
                /**
                 * Property ID for the _UnderlayIsoPerimeter shader property used by URP and HDRP shaders
                 *
                 * @static
                 * @public
                 * @memberof TMPro.ShaderUtilities
                 * @type number
                 */
                ID_UnderlayIsoPerimeter: 0,
                ID_WeightNormal: 0,
                ID_WeightBold: 0,
                ID_OutlineTex: 0,
                ID_OutlineWidth: 0,
                ID_OutlineSoftness: 0,
                ID_OutlineColor: 0,
                ID_Outline2Color: 0,
                ID_Outline2Width: 0,
                ID_Padding: 0,
                ID_GradientScale: 0,
                ID_ScaleX: 0,
                ID_ScaleY: 0,
                ID_PerspectiveFilter: 0,
                ID_Sharpness: 0,
                ID_TextureWidth: 0,
                ID_TextureHeight: 0,
                ID_BevelAmount: 0,
                ID_GlowColor: 0,
                ID_GlowOffset: 0,
                ID_GlowPower: 0,
                ID_GlowOuter: 0,
                ID_GlowInner: 0,
                ID_LightAngle: 0,
                ID_EnvMap: 0,
                ID_EnvMatrix: 0,
                ID_EnvMatrixRotation: 0,
                ID_MaskCoord: 0,
                ID_ClipRect: 0,
                ID_MaskSoftnessX: 0,
                ID_MaskSoftnessY: 0,
                ID_VertexOffsetX: 0,
                ID_VertexOffsetY: 0,
                ID_UseClipRect: 0,
                ID_StencilID: 0,
                ID_StencilOp: 0,
                ID_StencilComp: 0,
                ID_StencilReadMask: 0,
                ID_StencilWriteMask: 0,
                ID_ShaderFlags: 0,
                ID_ScaleRatio_A: 0,
                ID_ScaleRatio_B: 0,
                ID_ScaleRatio_C: 0,
                Keyword_Bevel: null,
                Keyword_Glow: null,
                Keyword_Underlay: null,
                Keyword_Ratios: null,
                Keyword_MASK_SOFT: null,
                Keyword_MASK_HARD: null,
                Keyword_MASK_TEX: null,
                Keyword_Outline: null,
                ShaderTag_ZTestMode: null,
                ShaderTag_CullMode: null,
                m_clamp: 0,
                isInitialized: false,
                k_ShaderRef_MobileSDF: null,
                k_ShaderRef_MobileBitmap: null
            },
            props: {
                /**
                 * Returns a reference to the mobile distance field shader.
                 *
                 * @static
                 * @readonly
                 * @memberof TMPro.ShaderUtilities
                 * @function ShaderRef_MobileSDF
                 * @type UnityEngine.Shader
                 */
                ShaderRef_MobileSDF: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.ShaderUtilities#ShaderRef_MobileSDF#get", this ); }

                        if (TMPro.ShaderUtilities.k_ShaderRef_MobileSDF == null) {
                            TMPro.ShaderUtilities.k_ShaderRef_MobileSDF = UnityEngine.Shader.Find("TextMeshPro/Mobile/Distance Field");
                        }

                        return TMPro.ShaderUtilities.k_ShaderRef_MobileSDF;
                    }
                },
                /**
                 * Returns a reference to the mobile bitmap shader.
                 *
                 * @static
                 * @readonly
                 * @memberof TMPro.ShaderUtilities
                 * @function ShaderRef_MobileBitmap
                 * @type UnityEngine.Shader
                 */
                ShaderRef_MobileBitmap: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.ShaderUtilities#ShaderRef_MobileBitmap#get", this ); }

                        if (TMPro.ShaderUtilities.k_ShaderRef_MobileBitmap == null) {
                            TMPro.ShaderUtilities.k_ShaderRef_MobileBitmap = UnityEngine.Shader.Find("TextMeshPro/Mobile/Bitmap");
                        }

                        return TMPro.ShaderUtilities.k_ShaderRef_MobileBitmap;
                    }
                }
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "TMPro.ShaderUtilities#init", this ); }

                    this.Keyword_Bevel = "BEVEL_ON";
                    this.Keyword_Glow = "GLOW_ON";
                    this.Keyword_Underlay = "UNDERLAY_ON";
                    this.Keyword_Ratios = "RATIOS_OFF";
                    this.Keyword_MASK_SOFT = "MASK_SOFT";
                    this.Keyword_MASK_HARD = "MASK_HARD";
                    this.Keyword_MASK_TEX = "MASK_TEX";
                    this.Keyword_Outline = "OUTLINE_ON";
                    this.ShaderTag_ZTestMode = "unity_GUIZTestMode";
                    this.ShaderTag_CullMode = "_CullMode";
                    this.m_clamp = 1.0;
                    this.isInitialized = false;
                },
                ctor: function () {
if ( TRACE ) { TRACE( "TMPro.ShaderUtilities#ctor", this ); }

                    TMPro.ShaderUtilities.GetShaderPropertyIDs();
                }
            },
            methods: {
                /*TMPro.ShaderUtilities.GetShaderPropertyIDs:static start.*/
                /**
                 * @static
                 * @public
                 * @this TMPro.ShaderUtilities
                 * @memberof TMPro.ShaderUtilities
                 * @return  {void}
                 */
                GetShaderPropertyIDs: function () {
if ( TRACE ) { TRACE( "TMPro.ShaderUtilities#GetShaderPropertyIDs", this ); }

                    if (TMPro.ShaderUtilities.isInitialized === false) {
                        //Debug.Log("Getting Shader property IDs");
                        TMPro.ShaderUtilities.isInitialized = true;

                        TMPro.ShaderUtilities.ID_MainTex = UnityEngine.Shader.PropertyToID("_MainTex");

                        TMPro.ShaderUtilities.ID_FaceTex = UnityEngine.Shader.PropertyToID("_FaceTex");
                        TMPro.ShaderUtilities.ID_FaceColor = UnityEngine.Shader.PropertyToID("_FaceColor");
                        TMPro.ShaderUtilities.ID_FaceDilate = UnityEngine.Shader.PropertyToID("_FaceDilate");
                        TMPro.ShaderUtilities.ID_Shininess = UnityEngine.Shader.PropertyToID("_FaceShininess");

                        TMPro.ShaderUtilities.ID_UnderlayColor = UnityEngine.Shader.PropertyToID("_UnderlayColor");
                        TMPro.ShaderUtilities.ID_UnderlayOffsetX = UnityEngine.Shader.PropertyToID("_UnderlayOffsetX");
                        TMPro.ShaderUtilities.ID_UnderlayOffsetY = UnityEngine.Shader.PropertyToID("_UnderlayOffsetY");
                        TMPro.ShaderUtilities.ID_UnderlayDilate = UnityEngine.Shader.PropertyToID("_UnderlayDilate");
                        TMPro.ShaderUtilities.ID_UnderlaySoftness = UnityEngine.Shader.PropertyToID("_UnderlaySoftness");

                        TMPro.ShaderUtilities.ID_UnderlayOffset = UnityEngine.Shader.PropertyToID("_UnderlayOffset");
                        TMPro.ShaderUtilities.ID_UnderlayIsoPerimeter = UnityEngine.Shader.PropertyToID("_UnderlayIsoPerimeter");

                        TMPro.ShaderUtilities.ID_WeightNormal = UnityEngine.Shader.PropertyToID("_WeightNormal");
                        TMPro.ShaderUtilities.ID_WeightBold = UnityEngine.Shader.PropertyToID("_WeightBold");

                        TMPro.ShaderUtilities.ID_OutlineTex = UnityEngine.Shader.PropertyToID("_OutlineTex");
                        TMPro.ShaderUtilities.ID_OutlineWidth = UnityEngine.Shader.PropertyToID("_OutlineWidth");
                        TMPro.ShaderUtilities.ID_OutlineSoftness = UnityEngine.Shader.PropertyToID("_OutlineSoftness");
                        TMPro.ShaderUtilities.ID_OutlineColor = UnityEngine.Shader.PropertyToID("_OutlineColor");

                        TMPro.ShaderUtilities.ID_Outline2Color = UnityEngine.Shader.PropertyToID("_Outline2Color");
                        TMPro.ShaderUtilities.ID_Outline2Width = UnityEngine.Shader.PropertyToID("_Outline2Width");

                        TMPro.ShaderUtilities.ID_Padding = UnityEngine.Shader.PropertyToID("_Padding");
                        TMPro.ShaderUtilities.ID_GradientScale = UnityEngine.Shader.PropertyToID("_GradientScale");
                        TMPro.ShaderUtilities.ID_ScaleX = UnityEngine.Shader.PropertyToID("_ScaleX");
                        TMPro.ShaderUtilities.ID_ScaleY = UnityEngine.Shader.PropertyToID("_ScaleY");
                        TMPro.ShaderUtilities.ID_PerspectiveFilter = UnityEngine.Shader.PropertyToID("_PerspectiveFilter");
                        TMPro.ShaderUtilities.ID_Sharpness = UnityEngine.Shader.PropertyToID("_Sharpness");

                        TMPro.ShaderUtilities.ID_TextureWidth = UnityEngine.Shader.PropertyToID("_TextureWidth");
                        TMPro.ShaderUtilities.ID_TextureHeight = UnityEngine.Shader.PropertyToID("_TextureHeight");

                        TMPro.ShaderUtilities.ID_BevelAmount = UnityEngine.Shader.PropertyToID("_Bevel");

                        TMPro.ShaderUtilities.ID_LightAngle = UnityEngine.Shader.PropertyToID("_LightAngle");

                        TMPro.ShaderUtilities.ID_EnvMap = UnityEngine.Shader.PropertyToID("_Cube");
                        TMPro.ShaderUtilities.ID_EnvMatrix = UnityEngine.Shader.PropertyToID("_EnvMatrix");
                        TMPro.ShaderUtilities.ID_EnvMatrixRotation = UnityEngine.Shader.PropertyToID("_EnvMatrixRotation");


                        TMPro.ShaderUtilities.ID_GlowColor = UnityEngine.Shader.PropertyToID("_GlowColor");
                        TMPro.ShaderUtilities.ID_GlowOffset = UnityEngine.Shader.PropertyToID("_GlowOffset");
                        TMPro.ShaderUtilities.ID_GlowPower = UnityEngine.Shader.PropertyToID("_GlowPower");
                        TMPro.ShaderUtilities.ID_GlowOuter = UnityEngine.Shader.PropertyToID("_GlowOuter");
                        TMPro.ShaderUtilities.ID_GlowInner = UnityEngine.Shader.PropertyToID("_GlowInner");

                        //ID_MaskID = Shader.PropertyToID("_MaskID");
                        TMPro.ShaderUtilities.ID_MaskCoord = UnityEngine.Shader.PropertyToID("_MaskCoord");
                        TMPro.ShaderUtilities.ID_ClipRect = UnityEngine.Shader.PropertyToID("_ClipRect");
                        TMPro.ShaderUtilities.ID_UseClipRect = UnityEngine.Shader.PropertyToID("_UseClipRect");
                        TMPro.ShaderUtilities.ID_MaskSoftnessX = UnityEngine.Shader.PropertyToID("_MaskSoftnessX");
                        TMPro.ShaderUtilities.ID_MaskSoftnessY = UnityEngine.Shader.PropertyToID("_MaskSoftnessY");
                        TMPro.ShaderUtilities.ID_VertexOffsetX = UnityEngine.Shader.PropertyToID("_VertexOffsetX");
                        TMPro.ShaderUtilities.ID_VertexOffsetY = UnityEngine.Shader.PropertyToID("_VertexOffsetY");

                        TMPro.ShaderUtilities.ID_StencilID = UnityEngine.Shader.PropertyToID("_Stencil");
                        TMPro.ShaderUtilities.ID_StencilOp = UnityEngine.Shader.PropertyToID("_StencilOp");
                        TMPro.ShaderUtilities.ID_StencilComp = UnityEngine.Shader.PropertyToID("_StencilComp");
                        TMPro.ShaderUtilities.ID_StencilReadMask = UnityEngine.Shader.PropertyToID("_StencilReadMask");
                        TMPro.ShaderUtilities.ID_StencilWriteMask = UnityEngine.Shader.PropertyToID("_StencilWriteMask");

                        TMPro.ShaderUtilities.ID_ShaderFlags = UnityEngine.Shader.PropertyToID("_ShaderFlags");
                        TMPro.ShaderUtilities.ID_ScaleRatio_A = UnityEngine.Shader.PropertyToID("_ScaleRatioA");
                        TMPro.ShaderUtilities.ID_ScaleRatio_B = UnityEngine.Shader.PropertyToID("_ScaleRatioB");
                        TMPro.ShaderUtilities.ID_ScaleRatio_C = UnityEngine.Shader.PropertyToID("_ScaleRatioC");

                        // Set internal shader references
                        if (TMPro.ShaderUtilities.k_ShaderRef_MobileSDF == null) {
                            TMPro.ShaderUtilities.k_ShaderRef_MobileSDF = UnityEngine.Shader.Find("TextMeshPro/Mobile/Distance Field");
                        }

                        if (TMPro.ShaderUtilities.k_ShaderRef_MobileBitmap == null) {
                            TMPro.ShaderUtilities.k_ShaderRef_MobileBitmap = UnityEngine.Shader.Find("TextMeshPro/Mobile/Bitmap");
                        }
                    }
                },
                /*TMPro.ShaderUtilities.GetShaderPropertyIDs:static end.*/

                /*TMPro.ShaderUtilities.UpdateShaderRatios:static start.*/
                UpdateShaderRatios: function (mat) {
if ( TRACE ) { TRACE( "TMPro.ShaderUtilities#UpdateShaderRatios", this ); }

                    //Debug.Log("UpdateShaderRatios() called.");

                    var ratio_A = 1;
                    var ratio_B = 1;
                    var ratio_C = 1;

                    var isRatioEnabled = !System.Linq.Enumerable.from(mat.shaderKeywords, System.String).contains(TMPro.ShaderUtilities.Keyword_Ratios);

                    if (!mat.HasProperty(TMPro.ShaderUtilities.ID_GradientScale) || !mat.HasProperty(TMPro.ShaderUtilities.ID_FaceDilate)) {
                        return;
                    }

                    // Compute Ratio A
                    var scale = mat.GetFloat(TMPro.ShaderUtilities.ID_GradientScale);
                    var faceDilate = mat.GetFloat(TMPro.ShaderUtilities.ID_FaceDilate);
                    var outlineThickness = mat.GetFloat(TMPro.ShaderUtilities.ID_OutlineWidth);
                    var outlineSoftness = mat.GetFloat(TMPro.ShaderUtilities.ID_OutlineSoftness);

                    var weight = UnityEngine.Mathf.Max(mat.GetFloat(TMPro.ShaderUtilities.ID_WeightNormal), mat.GetFloat(TMPro.ShaderUtilities.ID_WeightBold)) / 4.0;

                    var t = UnityEngine.Mathf.Max(1, weight + faceDilate + outlineThickness + outlineSoftness);

                    ratio_A = isRatioEnabled ? (scale - TMPro.ShaderUtilities.m_clamp) / (scale * t) : 1;

                    //float ratio_A_old = mat.GetFloat(ID_ScaleRatio_A);

                    // Only set the ratio if it has changed.
                    //if (ratio_A != ratio_A_old)
                    mat.SetFloat(TMPro.ShaderUtilities.ID_ScaleRatio_A, ratio_A);

                    // Compute Ratio B
                    if (mat.HasProperty(TMPro.ShaderUtilities.ID_GlowOffset)) {
                        var glowOffset = mat.GetFloat(TMPro.ShaderUtilities.ID_GlowOffset);
                        var glowOuter = mat.GetFloat(TMPro.ShaderUtilities.ID_GlowOuter);

                        var range = (weight + faceDilate) * (scale - TMPro.ShaderUtilities.m_clamp);

                        t = UnityEngine.Mathf.Max(1, glowOffset + glowOuter);

                        ratio_B = isRatioEnabled ? UnityEngine.Mathf.Max(0, scale - TMPro.ShaderUtilities.m_clamp - range) / (scale * t) : 1;
                        //float ratio_B_old = mat.GetFloat(ID_ScaleRatio_B);

                        // Only set the ratio if it has changed.
                        //if (ratio_B != ratio_B_old)
                        mat.SetFloat(TMPro.ShaderUtilities.ID_ScaleRatio_B, ratio_B);
                    }

                    // Compute Ratio C
                    if (mat.HasProperty(TMPro.ShaderUtilities.ID_UnderlayOffsetX)) {
                        var underlayOffsetX = mat.GetFloat(TMPro.ShaderUtilities.ID_UnderlayOffsetX);
                        var underlayOffsetY = mat.GetFloat(TMPro.ShaderUtilities.ID_UnderlayOffsetY);
                        var underlayDilate = mat.GetFloat(TMPro.ShaderUtilities.ID_UnderlayDilate);
                        var underlaySoftness = mat.GetFloat(TMPro.ShaderUtilities.ID_UnderlaySoftness);

                        var range1 = (weight + faceDilate) * (scale - TMPro.ShaderUtilities.m_clamp);

                        t = UnityEngine.Mathf.Max(1, UnityEngine.Mathf.Max(Math.abs(underlayOffsetX), Math.abs(underlayOffsetY)) + underlayDilate + underlaySoftness);

                        ratio_C = isRatioEnabled ? UnityEngine.Mathf.Max(0, scale - TMPro.ShaderUtilities.m_clamp - range1) / (scale * t) : 1;
                        //float ratio_C_old = mat.GetFloat(ID_ScaleRatio_C);

                        // Only set the ratio if it has changed.
                        //if (ratio_C != ratio_C_old)
                        mat.SetFloat(TMPro.ShaderUtilities.ID_ScaleRatio_C, ratio_C);
                    }
                },
                /*TMPro.ShaderUtilities.UpdateShaderRatios:static end.*/

                /*TMPro.ShaderUtilities.GetFontExtent:static start.*/
                GetFontExtent: function (material) {
if ( TRACE ) { TRACE( "TMPro.ShaderUtilities#GetFontExtent", this ); }

                    // Revised implementation where style no longer affects alignment
                    return pc.Vec4.ZERO.clone();

                    /* 
                    if (material == null || !material.HasProperty(ShaderUtilities.ID_GradientScale))
                       return Vector4.zero;   // We are using an non SDF Shader.

                    float scaleRatioA = material.GetFloat(ID_ScaleRatio_A);
                    float faceDilate = material.GetFloat(ID_FaceDilate) * scaleRatioA;
                    float outlineThickness = material.GetFloat(ID_OutlineWidth) * scaleRatioA;

                    float extent = Mathf.Min(1, faceDilate + outlineThickness);
                    extent *= material.GetFloat(ID_GradientScale);

                    return new Vector4(extent, extent, extent, extent);
                    */
                },
                /*TMPro.ShaderUtilities.GetFontExtent:static end.*/

                /*TMPro.ShaderUtilities.IsMaskingEnabled:static start.*/
                IsMaskingEnabled: function (material) {
if ( TRACE ) { TRACE( "TMPro.ShaderUtilities#IsMaskingEnabled", this ); }

                    if (material == null || !material.HasProperty(TMPro.ShaderUtilities.ID_ClipRect)) {
                        return false;
                    }

                    if (System.Linq.Enumerable.from(material.shaderKeywords, System.String).contains(TMPro.ShaderUtilities.Keyword_MASK_SOFT) || System.Linq.Enumerable.from(material.shaderKeywords, System.String).contains(TMPro.ShaderUtilities.Keyword_MASK_HARD) || System.Linq.Enumerable.from(material.shaderKeywords, System.String).contains(TMPro.ShaderUtilities.Keyword_MASK_TEX)) {
                        return true;
                    }

                    return false;
                },
                /*TMPro.ShaderUtilities.IsMaskingEnabled:static end.*/

                /*TMPro.ShaderUtilities.GetPadding:static start.*/
                GetPadding: function (material, enableExtraPadding, isBold) {
if ( TRACE ) { TRACE( "TMPro.ShaderUtilities#GetPadding", this ); }

                    //Debug.Log("GetPadding() called.");

                    if (TMPro.ShaderUtilities.isInitialized === false) {
                        TMPro.ShaderUtilities.GetShaderPropertyIDs();
                    }

                    // Return if Material is null
                    if (material == null) {
                        return 0;
                    }

                    var extraPadding = enableExtraPadding ? 4 : 0;

                    // Check if we are using a non Distance Field Shader
                    if (material.HasProperty(TMPro.ShaderUtilities.ID_GradientScale) === false) {
                        if (material.HasProperty(TMPro.ShaderUtilities.ID_Padding)) {
                            extraPadding += material.GetFloat(TMPro.ShaderUtilities.ID_Padding);
                        }

                        return extraPadding + 1.0;
                    }

                    var padding = pc.Vec4.ZERO.clone();
                    var maxPadding = pc.Vec4.ZERO.clone();

                    //float weight = 0;
                    var faceDilate = 0;
                    var faceSoftness = 0;
                    var outlineThickness = 0;
                    var scaleRatio_A = 0;
                    var scaleRatio_B = 0;
                    var scaleRatio_C = 0;

                    var glowOffset = 0;
                    var glowOuter = 0;

                    var uniformPadding = 0;
                    // Iterate through each of the assigned materials to find the max values to set the padding.

                    // Update Shader Ratios prior to computing padding
                    TMPro.ShaderUtilities.UpdateShaderRatios(material);

                    var shaderKeywords = material.shaderKeywords;

                    if (material.HasProperty(TMPro.ShaderUtilities.ID_ScaleRatio_A)) {
                        scaleRatio_A = material.GetFloat(TMPro.ShaderUtilities.ID_ScaleRatio_A);
                    }

                    //weight = 0; // Mathf.Max(material.GetFloat(ID_WeightNormal), material.GetFloat(ID_WeightBold)) / 2.0f * scaleRatio_A;

                    if (material.HasProperty(TMPro.ShaderUtilities.ID_FaceDilate)) {
                        faceDilate = material.GetFloat(TMPro.ShaderUtilities.ID_FaceDilate) * scaleRatio_A;
                    }

                    if (material.HasProperty(TMPro.ShaderUtilities.ID_OutlineSoftness)) {
                        faceSoftness = material.GetFloat(TMPro.ShaderUtilities.ID_OutlineSoftness) * scaleRatio_A;
                    }

                    if (material.HasProperty(TMPro.ShaderUtilities.ID_OutlineWidth)) {
                        outlineThickness = material.GetFloat(TMPro.ShaderUtilities.ID_OutlineWidth) * scaleRatio_A;
                    }

                    uniformPadding = outlineThickness + faceSoftness + faceDilate;

                    // Glow padding contribution
                    if (material.HasProperty(TMPro.ShaderUtilities.ID_GlowOffset) && System.Linq.Enumerable.from(shaderKeywords, System.String).contains(TMPro.ShaderUtilities.Keyword_Glow)) {
                        if (material.HasProperty(TMPro.ShaderUtilities.ID_ScaleRatio_B)) {
                            scaleRatio_B = material.GetFloat(TMPro.ShaderUtilities.ID_ScaleRatio_B);
                        }

                        glowOffset = material.GetFloat(TMPro.ShaderUtilities.ID_GlowOffset) * scaleRatio_B;
                        glowOuter = material.GetFloat(TMPro.ShaderUtilities.ID_GlowOuter) * scaleRatio_B;
                    }

                    uniformPadding = UnityEngine.Mathf.Max(uniformPadding, faceDilate + glowOffset + glowOuter);

                    // Underlay padding contribution
                    if (material.HasProperty(TMPro.ShaderUtilities.ID_UnderlaySoftness) && System.Linq.Enumerable.from(shaderKeywords, System.String).contains(TMPro.ShaderUtilities.Keyword_Underlay)) {
                        if (material.HasProperty(TMPro.ShaderUtilities.ID_ScaleRatio_C)) {
                            scaleRatio_C = material.GetFloat(TMPro.ShaderUtilities.ID_ScaleRatio_C);
                        }

                        var offsetX = material.GetFloat(TMPro.ShaderUtilities.ID_UnderlayOffsetX) * scaleRatio_C;
                        var offsetY = material.GetFloat(TMPro.ShaderUtilities.ID_UnderlayOffsetY) * scaleRatio_C;
                        var dilate = material.GetFloat(TMPro.ShaderUtilities.ID_UnderlayDilate) * scaleRatio_C;
                        var softness = material.GetFloat(TMPro.ShaderUtilities.ID_UnderlaySoftness) * scaleRatio_C;

                        padding.x = UnityEngine.Mathf.Max(padding.x, faceDilate + dilate + softness - offsetX);
                        padding.y = UnityEngine.Mathf.Max(padding.y, faceDilate + dilate + softness - offsetY);
                        padding.z = UnityEngine.Mathf.Max(padding.z, faceDilate + dilate + softness + offsetX);
                        padding.w = UnityEngine.Mathf.Max(padding.w, faceDilate + dilate + softness + offsetY);
                    }

                    padding.x = UnityEngine.Mathf.Max(padding.x, uniformPadding);
                    padding.y = UnityEngine.Mathf.Max(padding.y, uniformPadding);
                    padding.z = UnityEngine.Mathf.Max(padding.z, uniformPadding);
                    padding.w = UnityEngine.Mathf.Max(padding.w, uniformPadding);

                    padding.x += extraPadding;
                    padding.y += extraPadding;
                    padding.z += extraPadding;
                    padding.w += extraPadding;

                    padding.x = UnityEngine.Mathf.Min(padding.x, 1);
                    padding.y = UnityEngine.Mathf.Min(padding.y, 1);
                    padding.z = UnityEngine.Mathf.Min(padding.z, 1);
                    padding.w = UnityEngine.Mathf.Min(padding.w, 1);

                    maxPadding.x = maxPadding.x < padding.x ? padding.x : maxPadding.x;
                    maxPadding.y = maxPadding.y < padding.y ? padding.y : maxPadding.y;
                    maxPadding.z = maxPadding.z < padding.z ? padding.z : maxPadding.z;
                    maxPadding.w = maxPadding.w < padding.w ? padding.w : maxPadding.w;

                    var gradientScale = material.GetFloat(TMPro.ShaderUtilities.ID_GradientScale);
                    padding = padding.$clone().scale( gradientScale );

                    // Set UniformPadding to the maximum value of any of its components.
                    uniformPadding = UnityEngine.Mathf.Max(padding.x, padding.y);
                    uniformPadding = UnityEngine.Mathf.Max(padding.z, uniformPadding);
                    uniformPadding = UnityEngine.Mathf.Max(padding.w, uniformPadding);

                    return uniformPadding + 1.25;
                },
                /*TMPro.ShaderUtilities.GetPadding:static end.*/

                /*TMPro.ShaderUtilities.GetPadding$1:static start.*/
                GetPadding$1: function (materials, enableExtraPadding, isBold) {
if ( TRACE ) { TRACE( "TMPro.ShaderUtilities#GetPadding$1", this ); }

                    //Debug.Log("GetPadding() called.");

                    if (TMPro.ShaderUtilities.isInitialized === false) {
                        TMPro.ShaderUtilities.GetShaderPropertyIDs();
                    }

                    // Return if Material is null
                    if (materials == null) {
                        return 0;
                    }

                    var extraPadding = enableExtraPadding ? 4 : 0;

                    // Check if we are using a Bitmap Shader
                    if (materials[0].HasProperty(TMPro.ShaderUtilities.ID_Padding)) {
                        return extraPadding + materials[0].GetFloat(TMPro.ShaderUtilities.ID_Padding);
                    }

                    var padding = pc.Vec4.ZERO.clone();
                    var maxPadding = pc.Vec4.ZERO.clone();

                    var faceDilate = 0;
                    var faceSoftness = 0;
                    var outlineThickness = 0;
                    var scaleRatio_A = 0;
                    var scaleRatio_B = 0;
                    var scaleRatio_C = 0;

                    var glowOffset = 0;
                    var glowOuter = 0;

                    var uniformPadding = 0;
                    // Iterate through each of the assigned materials to find the max values to set the padding.
                    for (var i = 0; i < materials.length; i++) {
                        // Update Shader Ratios prior to computing padding
                        TMPro.ShaderUtilities.UpdateShaderRatios(materials[i]);

                        var shaderKeywords = materials[i].shaderKeywords;

                        if (materials[i].HasProperty(TMPro.ShaderUtilities.ID_ScaleRatio_A)) {
                            scaleRatio_A = materials[i].GetFloat(TMPro.ShaderUtilities.ID_ScaleRatio_A);
                        }

                        if (materials[i].HasProperty(TMPro.ShaderUtilities.ID_FaceDilate)) {
                            faceDilate = materials[i].GetFloat(TMPro.ShaderUtilities.ID_FaceDilate) * scaleRatio_A;
                        }

                        if (materials[i].HasProperty(TMPro.ShaderUtilities.ID_OutlineSoftness)) {
                            faceSoftness = materials[i].GetFloat(TMPro.ShaderUtilities.ID_OutlineSoftness) * scaleRatio_A;
                        }

                        if (materials[i].HasProperty(TMPro.ShaderUtilities.ID_OutlineWidth)) {
                            outlineThickness = materials[i].GetFloat(TMPro.ShaderUtilities.ID_OutlineWidth) * scaleRatio_A;
                        }

                        uniformPadding = outlineThickness + faceSoftness + faceDilate;

                        // Glow padding contribution
                        if (materials[i].HasProperty(TMPro.ShaderUtilities.ID_GlowOffset) && System.Linq.Enumerable.from(shaderKeywords, System.String).contains(TMPro.ShaderUtilities.Keyword_Glow)) {
                            if (materials[i].HasProperty(TMPro.ShaderUtilities.ID_ScaleRatio_B)) {
                                scaleRatio_B = materials[i].GetFloat(TMPro.ShaderUtilities.ID_ScaleRatio_B);
                            }

                            glowOffset = materials[i].GetFloat(TMPro.ShaderUtilities.ID_GlowOffset) * scaleRatio_B;
                            glowOuter = materials[i].GetFloat(TMPro.ShaderUtilities.ID_GlowOuter) * scaleRatio_B;
                        }

                        uniformPadding = UnityEngine.Mathf.Max(uniformPadding, faceDilate + glowOffset + glowOuter);

                        // Underlay padding contribution
                        if (materials[i].HasProperty(TMPro.ShaderUtilities.ID_UnderlaySoftness) && System.Linq.Enumerable.from(shaderKeywords, System.String).contains(TMPro.ShaderUtilities.Keyword_Underlay)) {
                            if (materials[i].HasProperty(TMPro.ShaderUtilities.ID_ScaleRatio_C)) {
                                scaleRatio_C = materials[i].GetFloat(TMPro.ShaderUtilities.ID_ScaleRatio_C);
                            }

                            var offsetX = materials[i].GetFloat(TMPro.ShaderUtilities.ID_UnderlayOffsetX) * scaleRatio_C;
                            var offsetY = materials[i].GetFloat(TMPro.ShaderUtilities.ID_UnderlayOffsetY) * scaleRatio_C;
                            var dilate = materials[i].GetFloat(TMPro.ShaderUtilities.ID_UnderlayDilate) * scaleRatio_C;
                            var softness = materials[i].GetFloat(TMPro.ShaderUtilities.ID_UnderlaySoftness) * scaleRatio_C;

                            padding.x = UnityEngine.Mathf.Max(padding.x, faceDilate + dilate + softness - offsetX);
                            padding.y = UnityEngine.Mathf.Max(padding.y, faceDilate + dilate + softness - offsetY);
                            padding.z = UnityEngine.Mathf.Max(padding.z, faceDilate + dilate + softness + offsetX);
                            padding.w = UnityEngine.Mathf.Max(padding.w, faceDilate + dilate + softness + offsetY);
                        }

                        padding.x = UnityEngine.Mathf.Max(padding.x, uniformPadding);
                        padding.y = UnityEngine.Mathf.Max(padding.y, uniformPadding);
                        padding.z = UnityEngine.Mathf.Max(padding.z, uniformPadding);
                        padding.w = UnityEngine.Mathf.Max(padding.w, uniformPadding);

                        padding.x += extraPadding;
                        padding.y += extraPadding;
                        padding.z += extraPadding;
                        padding.w += extraPadding;

                        padding.x = UnityEngine.Mathf.Min(padding.x, 1);
                        padding.y = UnityEngine.Mathf.Min(padding.y, 1);
                        padding.z = UnityEngine.Mathf.Min(padding.z, 1);
                        padding.w = UnityEngine.Mathf.Min(padding.w, 1);

                        maxPadding.x = maxPadding.x < padding.x ? padding.x : maxPadding.x;
                        maxPadding.y = maxPadding.y < padding.y ? padding.y : maxPadding.y;
                        maxPadding.z = maxPadding.z < padding.z ? padding.z : maxPadding.z;
                        maxPadding.w = maxPadding.w < padding.w ? padding.w : maxPadding.w;
                    }

                    var gradientScale = materials[0].GetFloat(TMPro.ShaderUtilities.ID_GradientScale);
                    padding = padding.$clone().scale( gradientScale );

                    // Set UniformPadding to the maximum value of any of its components.
                    uniformPadding = UnityEngine.Mathf.Max(padding.x, padding.y);
                    uniformPadding = UnityEngine.Mathf.Max(padding.z, uniformPadding);
                    uniformPadding = UnityEngine.Mathf.Max(padding.w, uniformPadding);

                    return uniformPadding + 0.25;
                },
                /*TMPro.ShaderUtilities.GetPadding$1:static end.*/


            }
        }
    });
    /*TMPro.ShaderUtilities end.*/

    /*TMPro.SpriteAssetUtilities.SpriteAssetImportFormats start.*/
    Bridge.define("TMPro.SpriteAssetUtilities.SpriteAssetImportFormats", {
        $kind: 6,
        statics: {
            fields: {
                None: 0,
                TexturePackerJsonArray: 1
            }
        }
    });
    /*TMPro.SpriteAssetUtilities.SpriteAssetImportFormats end.*/

    /*TMPro.SpriteAssetUtilities.TexturePacker_JsonArray start.*/
    Bridge.define("TMPro.SpriteAssetUtilities.TexturePacker_JsonArray");
    /*TMPro.SpriteAssetUtilities.TexturePacker_JsonArray end.*/

    /*TMPro.SpriteAssetUtilities.TexturePacker_JsonArray+Frame start.*/
    Bridge.define("TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Frame", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Frame#getDefaultValue", this ); }
 return new TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Frame(); }
            }
        },
        fields: {
            filename: null,
            frame: null,
            rotated: false,
            trimmed: false,
            spriteSourceSize: null,
            sourceSize: null,
            pivot: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Frame#init", this ); }

                this.frame = new TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteFrame();
                this.spriteSourceSize = new TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteFrame();
                this.sourceSize = new TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteSize();
                this.pivot = new UnityEngine.Vector2();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Frame#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Frame#getHashCode", this ); }

                var h = Bridge.addHash([1835102891, this.filename, this.frame, this.rotated, this.trimmed, this.spriteSourceSize, this.sourceSize, this.pivot]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Frame#equals", this ); }

                if (!Bridge.is(o, TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Frame)) {
                    return false;
                }
                return Bridge.equals(this.filename, o.filename) && Bridge.equals(this.frame, o.frame) && Bridge.equals(this.rotated, o.rotated) && Bridge.equals(this.trimmed, o.trimmed) && Bridge.equals(this.spriteSourceSize, o.spriteSourceSize) && Bridge.equals(this.sourceSize, o.sourceSize) && Bridge.equals(this.pivot, o.pivot);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Frame#$clone", this ); }

                var s = to || new TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Frame();
                s.filename = this.filename;
                s.frame = this.frame.$clone();
                s.rotated = this.rotated;
                s.trimmed = this.trimmed;
                s.spriteSourceSize = this.spriteSourceSize.$clone();
                s.sourceSize = this.sourceSize.$clone();
                s.pivot = this.pivot.$clone();
                return s;
            }
        }
    });
    /*TMPro.SpriteAssetUtilities.TexturePacker_JsonArray+Frame end.*/

    /*TMPro.SpriteAssetUtilities.TexturePacker_JsonArray+Meta start.*/
    Bridge.define("TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Meta", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Meta#getDefaultValue", this ); }
 return new TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Meta(); }
            }
        },
        fields: {
            app: null,
            version: null,
            image: null,
            format: null,
            size: null,
            scale: 0,
            smartupdate: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Meta#init", this ); }

                this.size = new TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteSize();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Meta#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Meta#getHashCode", this ); }

                var h = Bridge.addHash([1635018061, this.app, this.version, this.image, this.format, this.size, this.scale, this.smartupdate]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Meta#equals", this ); }

                if (!Bridge.is(o, TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Meta)) {
                    return false;
                }
                return Bridge.equals(this.app, o.app) && Bridge.equals(this.version, o.version) && Bridge.equals(this.image, o.image) && Bridge.equals(this.format, o.format) && Bridge.equals(this.size, o.size) && Bridge.equals(this.scale, o.scale) && Bridge.equals(this.smartupdate, o.smartupdate);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Meta#$clone", this ); }

                var s = to || new TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Meta();
                s.app = this.app;
                s.version = this.version;
                s.image = this.image;
                s.format = this.format;
                s.size = this.size.$clone();
                s.scale = this.scale;
                s.smartupdate = this.smartupdate;
                return s;
            }
        }
    });
    /*TMPro.SpriteAssetUtilities.TexturePacker_JsonArray+Meta end.*/

    /*TMPro.SpriteAssetUtilities.TexturePacker_JsonArray+SpriteDataObject start.*/
    Bridge.define("TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteDataObject", {
        $kind: 1002,
        fields: {
            frames: null,
            meta: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteDataObject#init", this ); }

                this.meta = new TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Meta();
            }
        }
    });
    /*TMPro.SpriteAssetUtilities.TexturePacker_JsonArray+SpriteDataObject end.*/

    /*TMPro.SpriteAssetUtilities.TexturePacker_JsonArray+SpriteFrame start.*/
    Bridge.define("TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteFrame", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteFrame#getDefaultValue", this ); }
 return new TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteFrame(); }
            }
        },
        fields: {
            x: 0,
            y: 0,
            w: 0,
            h: 0
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteFrame#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*TMPro.SpriteAssetUtilities.TexturePacker_JsonArray+SpriteFrame.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteFrame#toString", this ); }

                var s = "x: " + (System.Single.format(this.x, "f2") || "") + " y: " + (System.Single.format(this.y, "f2") || "") + " h: " + (System.Single.format(this.h, "f2") || "") + " w: " + (System.Single.format(this.w, "f2") || "");
                return s;
            },
            /*TMPro.SpriteAssetUtilities.TexturePacker_JsonArray+SpriteFrame.toString end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteFrame#getHashCode", this ); }

                var h = Bridge.addHash([3692970792, this.x, this.y, this.w, this.h]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteFrame#equals", this ); }

                if (!Bridge.is(o, TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteFrame)) {
                    return false;
                }
                return Bridge.equals(this.x, o.x) && Bridge.equals(this.y, o.y) && Bridge.equals(this.w, o.w) && Bridge.equals(this.h, o.h);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteFrame#$clone", this ); }

                var s = to || new TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteFrame();
                s.x = this.x;
                s.y = this.y;
                s.w = this.w;
                s.h = this.h;
                return s;
            }
        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*TMPro.SpriteAssetUtilities.TexturePacker_JsonArray+SpriteFrame end.*/

    /*TMPro.SpriteAssetUtilities.TexturePacker_JsonArray+SpriteSize start.*/
    Bridge.define("TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteSize", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteSize#getDefaultValue", this ); }
 return new TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteSize(); }
            }
        },
        fields: {
            w: 0,
            h: 0
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteSize#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*TMPro.SpriteAssetUtilities.TexturePacker_JsonArray+SpriteSize.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteSize#toString", this ); }

                var s = "w: " + (System.Single.format(this.w, "f2") || "") + " h: " + (System.Single.format(this.h, "f2") || "");
                return s;
            },
            /*TMPro.SpriteAssetUtilities.TexturePacker_JsonArray+SpriteSize.toString end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteSize#getHashCode", this ); }

                var h = Bridge.addHash([3536206657, this.w, this.h]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteSize#equals", this ); }

                if (!Bridge.is(o, TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteSize)) {
                    return false;
                }
                return Bridge.equals(this.w, o.w) && Bridge.equals(this.h, o.h);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteSize#$clone", this ); }

                var s = to || new TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteSize();
                s.w = this.w;
                s.h = this.h;
                return s;
            }
        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*TMPro.SpriteAssetUtilities.TexturePacker_JsonArray+SpriteSize end.*/

    /*TMPro.TagAttribute start.*/
    /**
     * Structure used to store retrieve the name and hashcode of the font and material
     *
     * @public
     * @class TMPro.TagAttribute
     */
    Bridge.define("TMPro.TagAttribute", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.TagAttribute#getDefaultValue", this ); }
 return new TMPro.TagAttribute(); }
            }
        },
        fields: {
            startIndex: 0,
            length: 0,
            hashCode: 0
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TagAttribute#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.TagAttribute#getHashCode", this ); }

                var h = Bridge.addHash([4568533802, this.startIndex, this.length, this.hashCode]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.TagAttribute#equals", this ); }

                if (!Bridge.is(o, TMPro.TagAttribute)) {
                    return false;
                }
                return Bridge.equals(this.startIndex, o.startIndex) && Bridge.equals(this.length, o.length) && Bridge.equals(this.hashCode, o.hashCode);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.TagAttribute#$clone", this ); }

                var s = to || new TMPro.TagAttribute();
                s.startIndex = this.startIndex;
                s.length = this.length;
                s.hashCode = this.hashCode;
                return s;
            }
        }
    });
    /*TMPro.TagAttribute end.*/

    /*TMPro.TagUnitType start.*/
    Bridge.define("TMPro.TagUnitType", {
        $kind: 6,
        statics: {
            fields: {
                Pixels: 0,
                FontUnits: 1,
                Percentage: 2
            }
        }
    });
    /*TMPro.TagUnitType end.*/

    /*TMPro.TagValueType start.*/
    /**
     * Defines the type of value used by a rich text tag or tag attribute.
     *
     * @public
     * @class TMPro.TagValueType
     */
    Bridge.define("TMPro.TagValueType", {
        $kind: 6,
        statics: {
            fields: {
                None: 0,
                NumericalValue: 1,
                StringValue: 2,
                ColorValue: 4
            }
        }
    });
    /*TMPro.TagValueType end.*/

    /*TMPro.TextAlignmentOptions start.*/
    Bridge.define("TMPro.TextAlignmentOptions", {
        $kind: 6,
        statics: {
            fields: {
                TopLeft: 257,
                Top: 258,
                TopRight: 260,
                TopJustified: 264,
                TopFlush: 272,
                TopGeoAligned: 288,
                Left: 513,
                Center: 514,
                Right: 516,
                Justified: 520,
                Flush: 528,
                CenterGeoAligned: 544,
                BottomLeft: 1025,
                Bottom: 1026,
                BottomRight: 1028,
                BottomJustified: 1032,
                BottomFlush: 1040,
                BottomGeoAligned: 1056,
                BaselineLeft: 2049,
                Baseline: 2050,
                BaselineRight: 2052,
                BaselineJustified: 2056,
                BaselineFlush: 2064,
                BaselineGeoAligned: 2080,
                MidlineLeft: 4097,
                Midline: 4098,
                MidlineRight: 4100,
                MidlineJustified: 4104,
                MidlineFlush: 4112,
                MidlineGeoAligned: 4128,
                CaplineLeft: 8193,
                Capline: 8194,
                CaplineRight: 8196,
                CaplineJustified: 8200,
                CaplineFlush: 8208,
                CaplineGeoAligned: 8224,
                Converted: 65535
            }
        }
    });
    /*TMPro.TextAlignmentOptions end.*/

    /*TMPro.TextContainer start.*/
    Bridge.define("TMPro.TextContainer", {
        inherits: [UnityEngine.EventSystems.UIBehaviour],
        statics: {
            fields: {
                k_defaultSize: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "TMPro.TextContainer#init", this ); }

                    this.k_defaultSize = new UnityEngine.Vector2();
                    this.k_defaultSize = new pc.Vec2( 100, 100 );
                }
            }
        },
        fields: {
            m_hasChanged: false,
            m_pivot: null,
            m_anchorPosition: 0,
            m_rect: null,
            m_isDefaultWidth: false,
            m_isDefaultHeight: false,
            m_isAutoFitting: false,
            m_corners: null,
            m_worldCorners: null,
            m_margins: null,
            m_rectTransform: null,
            m_textMeshPro: null
        },
        props: {
            hasChanged: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TextContainer#hasChanged#get", this ); }

                    return this.m_hasChanged;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TextContainer#hasChanged#set", this ); }

                    this.m_hasChanged = value;
                }
            },
            pivot: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TextContainer#pivot#get", this ); }

                    return this.m_pivot.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TextContainer#pivot#set", this ); }

                    /* Debug.Log("Pivot has changed.");*/
                    if (!pc.Vec2.equals( this.m_pivot, value )) {
                        this.m_pivot = value.$clone();
                        this.m_anchorPosition = this.GetAnchorPosition(this.m_pivot.$clone());
                        this.m_hasChanged = true;
                        this.OnContainerChanged();
                    }
                }
            },
            anchorPosition: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TextContainer#anchorPosition#get", this ); }

                    return this.m_anchorPosition;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TextContainer#anchorPosition#set", this ); }

                    /* Debug.Log("Anchor has changed.");*/
                    if (this.m_anchorPosition !== value) {
                        this.m_anchorPosition = value;
                        this.m_pivot = this.GetPivot(this.m_anchorPosition);
                        this.m_hasChanged = true;
                        this.OnContainerChanged();
                    }
                }
            },
            rect: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TextContainer#rect#get", this ); }

                    return this.m_rect.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TextContainer#rect#set", this ); }

                    /* Debug.Log("Rectangle has changed.");*/
                    if (UnityEngine.Rect.op_Inequality(this.m_rect.$clone(), value.$clone())) {
                        this.m_rect = value.$clone(); /* m_size = new Vector2(m_rect.width, m_rect.height);*/
                        this.m_hasChanged = true;
                        this.OnContainerChanged();
                    }
                }
            },
            size: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TextContainer#size#get", this ); }

                    return new pc.Vec2( this.m_rect.width, this.m_rect.height );
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TextContainer#size#set", this ); }

                    /* Debug.Log("Size has changed.");*/
                    if (!pc.Vec2.equals( new pc.Vec2( this.m_rect.width, this.m_rect.height ), value )) {
                        this.SetRect(value.$clone());
                        this.m_hasChanged = true;
                        this.m_isDefaultWidth = false;
                        this.m_isDefaultHeight = false;
                        this.OnContainerChanged();
                    }
                }
            },
            width: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TextContainer#width#get", this ); }

                    return this.m_rect.width;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TextContainer#width#set", this ); }

                    /* Debug.Log("Width has changed.");*/
                    this.SetRect(new pc.Vec2( value, this.m_rect.height ));
                    this.m_hasChanged = true;
                    this.m_isDefaultWidth = false;
                    this.OnContainerChanged();
                }
            },
            height: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TextContainer#height#get", this ); }

                    return this.m_rect.height;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TextContainer#height#set", this ); }

                    this.SetRect(new pc.Vec2( this.m_rect.width, value ));
                    this.m_hasChanged = true;
                    this.m_isDefaultHeight = false;
                    this.OnContainerChanged();
                }
            },
            isDefaultWidth: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TextContainer#isDefaultWidth#get", this ); }

                    return this.m_isDefaultWidth;
                }
            },
            isDefaultHeight: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TextContainer#isDefaultHeight#get", this ); }

                    return this.m_isDefaultHeight;
                }
            },
            isAutoFitting: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TextContainer#isAutoFitting#get", this ); }

                    return this.m_isAutoFitting;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TextContainer#isAutoFitting#set", this ); }

                    this.m_isAutoFitting = value;
                }
            },
            corners: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TextContainer#corners#get", this ); }

                    return this.m_corners;
                }
            },
            worldCorners: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TextContainer#worldCorners#get", this ); }

                    return this.m_worldCorners;
                }
            },
            margins: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TextContainer#margins#get", this ); }

                    return this.m_margins.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TextContainer#margins#set", this ); }

                    if (!pc.Vec4.equals( this.m_margins, value )) {
                        /* Debug.Log("Margins have changed.");*/
                        this.m_margins = value.$clone();
                        this.m_hasChanged = true;
                        this.OnContainerChanged();
                    }
                }
            },
            /**
             * The RectTransform used by the object
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TextContainer
             * @function rectTransform
             * @type UnityEngine.RectTransform
             */
            rectTransform: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TextContainer#rectTransform#get", this ); }

                    if (UnityEngine.Component.op_Equality(this.m_rectTransform, null)) {
                        this.m_rectTransform = this.GetComponent(UnityEngine.RectTransform);
                    }

                    return this.m_rectTransform;
                }
            },
            /**
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TextContainer
             * @function textMeshPro
             * @type TMPro.TextMeshPro
             */
            textMeshPro: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TextContainer#textMeshPro#get", this ); }

                    if (UnityEngine.MonoBehaviour.op_Equality(this.m_textMeshPro, null)) {
                        this.m_textMeshPro = this.GetComponent(TMPro.TextMeshPro);
                    }

                    return this.m_textMeshPro;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.TextContainer#init", this ); }

                this.m_pivot = new UnityEngine.Vector2();
                this.m_rect = new UnityEngine.Rect();
                this.m_margins = new UnityEngine.Vector4();
                this.m_anchorPosition = TMPro.TextContainerAnchors.Middle;
                this.m_isAutoFitting = false;
                this.m_corners = System.Array.init(4, function (){
                    return new UnityEngine.Vector3();
                }, UnityEngine.Vector3);
                this.m_worldCorners = System.Array.init(4, function (){
                    return new UnityEngine.Vector3();
                }, UnityEngine.Vector3);
            }
        },
        methods: {
            /*TMPro.TextContainer.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "TMPro.TextContainer#Awake", this ); }

                UnityEngine.Debug.LogWarning$1("The Text Container component is now Obsolete and can safely be removed from [" + (this.gameObject.name || "") + "].", this);

                return;
            },
            /*TMPro.TextContainer.Awake end.*/

            /*TMPro.TextContainer.OnEnable start.*/
            /**
             * @instance
             * @protected
             * @override
             * @this TMPro.TextContainer
             * @memberof TMPro.TextContainer
             * @return  {void}
             */
            OnEnable: function () {
if ( TRACE ) { TRACE( "TMPro.TextContainer#OnEnable", this ); }

                //Debug.Log("Text Container OnEnable() called.");

                this.OnContainerChanged();
            },
            /*TMPro.TextContainer.OnEnable end.*/

            /*TMPro.TextContainer.OnDisable start.*/
            /**
             * @instance
             * @protected
             * @override
             * @this TMPro.TextContainer
             * @memberof TMPro.TextContainer
             * @return  {void}
             */
            OnDisable: function () {
if ( TRACE ) { TRACE( "TMPro.TextContainer#OnDisable", this ); }

                //Debug.Log("OnDisable() called.");
            },
            /*TMPro.TextContainer.OnDisable end.*/

            /*TMPro.TextContainer.OnContainerChanged start.*/
            /**
             * @instance
             * @private
             * @this TMPro.TextContainer
             * @memberof TMPro.TextContainer
             * @return  {void}
             */
            OnContainerChanged: function () {
if ( TRACE ) { TRACE( "TMPro.TextContainer#OnContainerChanged", this ); }

                //Debug.Log("OnContainerChanged");

                this.UpdateCorners();
                //UpdateWorldCorners();

                if (UnityEngine.Component.op_Inequality(this.m_rectTransform, null)) {
                    this.m_rectTransform.sizeDelta = this.size.$clone();
                    this.m_rectTransform.hasChanged = true;
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.textMeshPro, null)) {
                    this.m_textMeshPro.SetVerticesDirty();
                    this.m_textMeshPro.margin = this.m_margins.$clone();
                }
            },
            /*TMPro.TextContainer.OnContainerChanged end.*/

            /*TMPro.TextContainer.OnRectTransformDimensionsChange start.*/
            /**
             * Callback from Unity to handle RectTransform changes.
             *
             * @instance
             * @protected
             * @override
             * @this TMPro.TextContainer
             * @memberof TMPro.TextContainer
             * @return  {void}
             */
            OnRectTransformDimensionsChange: function () {
if ( TRACE ) { TRACE( "TMPro.TextContainer#OnRectTransformDimensionsChange", this ); }

                // Required to add a RectTransform to objects created in previous releases.
                if (UnityEngine.Component.op_Equality(this.rectTransform, null)) {
                    this.m_rectTransform = this.gameObject.AddComponent(UnityEngine.RectTransform);
                }

                if (!pc.Vec2.equals( this.m_rectTransform.sizeDelta, TMPro.TextContainer.k_defaultSize )) {
                    this.size = this.m_rectTransform.sizeDelta.$clone();
                }

                this.pivot = this.m_rectTransform.pivot.$clone();

                this.m_hasChanged = true;
                this.OnContainerChanged();
            },
            /*TMPro.TextContainer.OnRectTransformDimensionsChange end.*/

            /*TMPro.TextContainer.SetRect start.*/
            SetRect: function (size) {
if ( TRACE ) { TRACE( "TMPro.TextContainer#SetRect", this ); }

                this.m_rect = new UnityEngine.Rect.$ctor1(this.m_rect.x, this.m_rect.y, size.x, size.y);
                //UpdateCorners();
            },
            /*TMPro.TextContainer.SetRect end.*/

            /*TMPro.TextContainer.UpdateCorners start.*/
            UpdateCorners: function () {
if ( TRACE ) { TRACE( "TMPro.TextContainer#UpdateCorners", this ); }

                this.m_corners[0] = new pc.Vec3( -this.m_pivot.x * this.m_rect.width, -this.m_pivot.y * this.m_rect.height, 0 );
                this.m_corners[1] = new pc.Vec3( -this.m_pivot.x * this.m_rect.width, (1 - this.m_pivot.y) * this.m_rect.height, 0 );
                this.m_corners[2] = new pc.Vec3( (1 - this.m_pivot.x) * this.m_rect.width, (1 - this.m_pivot.y) * this.m_rect.height, 0 );
                this.m_corners[3] = new pc.Vec3( (1 - this.m_pivot.x) * this.m_rect.width, -this.m_pivot.y * this.m_rect.height, 0 );
                //Debug.Log("Pivot " + m_pivot + "  Corners 0: " + m_corners[0] + "  1: " + m_corners[1] + "  2: " + m_corners[2] + "  3: " + m_corners[3]);

                if (UnityEngine.Component.op_Inequality(this.m_rectTransform, null)) {
                    this.m_rectTransform.pivot = this.m_pivot.$clone();
                }
            },
            /*TMPro.TextContainer.UpdateCorners end.*/

            /*TMPro.TextContainer.GetPivot start.*/
            GetPivot: function (anchor) {
if ( TRACE ) { TRACE( "TMPro.TextContainer#GetPivot", this ); }

                var pivot = pc.Vec2.ZERO.clone();

                switch (anchor) {
                    case TMPro.TextContainerAnchors.TopLeft: 
                        pivot = new pc.Vec2( 0, 1 );
                        break;
                    case TMPro.TextContainerAnchors.Top: 
                        pivot = new pc.Vec2( 0.5, 1 );
                        break;
                    case TMPro.TextContainerAnchors.TopRight: 
                        pivot = new pc.Vec2( 1, 1 );
                        break;
                    case TMPro.TextContainerAnchors.Left: 
                        pivot = new pc.Vec2( 0, 0.5 );
                        break;
                    case TMPro.TextContainerAnchors.Middle: 
                        pivot = new pc.Vec2( 0.5, 0.5 );
                        break;
                    case TMPro.TextContainerAnchors.Right: 
                        pivot = new pc.Vec2( 1, 0.5 );
                        break;
                    case TMPro.TextContainerAnchors.BottomLeft: 
                        pivot = new pc.Vec2( 0, 0 );
                        break;
                    case TMPro.TextContainerAnchors.Bottom: 
                        pivot = new pc.Vec2( 0.5, 0 );
                        break;
                    case TMPro.TextContainerAnchors.BottomRight: 
                        pivot = new pc.Vec2( 1, 0 );
                        break;
                }

                return pivot.$clone();
            },
            /*TMPro.TextContainer.GetPivot end.*/

            /*TMPro.TextContainer.GetAnchorPosition start.*/
            GetAnchorPosition: function (pivot) {
if ( TRACE ) { TRACE( "TMPro.TextContainer#GetAnchorPosition", this ); }

                if (pc.Vec2.equals( pivot, new pc.Vec2( 0, 1 ) )) {
                    return TMPro.TextContainerAnchors.TopLeft;
                } else if (pc.Vec2.equals( pivot, new pc.Vec2( 0.5, 1 ) )) {
                    return TMPro.TextContainerAnchors.Top;
                } else if (pc.Vec2.equals( pivot, new pc.Vec2( 1.0, 1 ) )) {
                    return TMPro.TextContainerAnchors.TopRight;
                } else if (pc.Vec2.equals( pivot, new pc.Vec2( 0, 0.5 ) )) {
                    return TMPro.TextContainerAnchors.Left;
                } else if (pc.Vec2.equals( pivot, new pc.Vec2( 0.5, 0.5 ) )) {
                    return TMPro.TextContainerAnchors.Middle;
                } else if (pc.Vec2.equals( pivot, new pc.Vec2( 1, 0.5 ) )) {
                    return TMPro.TextContainerAnchors.Right;
                } else if (pc.Vec2.equals( pivot, new pc.Vec2( 0, 0 ) )) {
                    return TMPro.TextContainerAnchors.BottomLeft;
                } else if (pc.Vec2.equals( pivot, new pc.Vec2( 0.5, 0 ) )) {
                    return TMPro.TextContainerAnchors.Bottom;
                } else if (pc.Vec2.equals( pivot, new pc.Vec2( 1, 0 ) )) {
                    return TMPro.TextContainerAnchors.BottomRight;
                } else {
                    return TMPro.TextContainerAnchors.Custom;
                }
            },
            /*TMPro.TextContainer.GetAnchorPosition end.*/


        }
    });
    /*TMPro.TextContainer end.*/

    /*TMPro.TextContainerAnchors start.*/
    Bridge.define("TMPro.TextContainerAnchors", {
        $kind: 6,
        statics: {
            fields: {
                TopLeft: 0,
                Top: 1,
                TopRight: 2,
                Left: 3,
                Middle: 4,
                Right: 5,
                BottomLeft: 6,
                Bottom: 7,
                BottomRight: 8,
                Custom: 9
            }
        }
    });
    /*TMPro.TextContainerAnchors end.*/

    /*TMPro.TextElementType start.*/
    Bridge.define("TMPro.TextElementType", {
        $kind: 6,
        statics: {
            fields: {
                Character: 1,
                Sprite: 2
            }
        },
        $utype: System.Byte
    });
    /*TMPro.TextElementType end.*/
    /**
     * @memberof System
     * @callback System.Action
     * @param   {TMPro.TMP_TextInfo}    arg
     * @return  {void}
     */

    /** @namespace System */

    /**
     * @memberof System
     * @callback System.Func
     * @param   {number}                 arg1    
     * @param   {string}                 arg2
     * @return  {TMPro.TMP_FontAsset}
     */


    /*TMPro.TMP_Text start.*/
    /**
     * Base class which contains common properties and functions shared between the TextMeshPro and TextMeshProUGUI component.
     *
     * @abstract
     * @public
     * @class TMPro.TMP_Text
     * @augments UnityEngine.UI.MaskableGraphic
     */
    Bridge.define("TMPro.TMP_Text", {
        inherits: [UnityEngine.UI.MaskableGraphic],
        statics: {
            fields: {
                m_materialReferences: null,
                m_materialReferenceIndexLookup: null,
                m_materialReferenceStack: null,
                s_colorWhite: null,
                m_htmlTag: null,
                m_xmlAttribute: null,
                m_attributeParameterValues: null,
                m_SavedWordWrapState: null,
                m_SavedLineState: null,
                m_SavedEllipsisState: null,
                m_SavedLastValidState: null,
                m_SavedSoftLineBreakState: null,
                m_EllipsisInsertionCandidateStack: null,
                k_LargePositiveVector2: null,
                k_LargeNegativeVector2: null,
                k_LargePositiveFloat: 0,
                k_LargeNegativeFloat: 0,
                k_LargePositiveInt: 0,
                k_LargeNegativeInt: 0
            },
            events: {
                
                
                OnFontAssetRequest: null,
                
                
                OnSpriteAssetRequest: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#init", this ); }

                    this.m_materialReferenceStack = new (TMPro.TMP_TextProcessingStack$1(TMPro.MaterialReference))();
                    this.s_colorWhite = new UnityEngine.Color32();
                    this.m_SavedWordWrapState = new TMPro.WordWrapState();
                    this.m_SavedLineState = new TMPro.WordWrapState();
                    this.m_SavedEllipsisState = new TMPro.WordWrapState();
                    this.m_SavedLastValidState = new TMPro.WordWrapState();
                    this.m_SavedSoftLineBreakState = new TMPro.WordWrapState();
                    this.m_EllipsisInsertionCandidateStack = new (TMPro.TMP_TextProcessingStack$1(TMPro.WordWrapState))();
                    this.k_LargePositiveVector2 = new UnityEngine.Vector2();
                    this.k_LargeNegativeVector2 = new UnityEngine.Vector2();
                    this.m_materialReferences = System.Array.init(4, function (){
                        return new TMPro.MaterialReference();
                    }, TMPro.MaterialReference);
                    this.m_materialReferenceIndexLookup = new (System.Collections.Generic.Dictionary$2(System.Int32,System.Int32)).ctor();
                    this.m_materialReferenceStack = new (TMPro.TMP_TextProcessingStack$1(TMPro.MaterialReference)).$ctor1(System.Array.init(16, function (){
                        return new TMPro.MaterialReference();
                    }, TMPro.MaterialReference));
                    this.s_colorWhite = new UnityEngine.Color32.$ctor1(255, 255, 255, 255);
                    this.m_htmlTag = System.Array.init(128, 0, System.Char);
                    this.m_xmlAttribute = System.Array.init(8, function (){
                        return new TMPro.RichTextTagAttribute();
                    }, TMPro.RichTextTagAttribute);
                    this.m_attributeParameterValues = System.Array.init(16, 0, System.Single);
                    this.m_EllipsisInsertionCandidateStack = new (TMPro.TMP_TextProcessingStack$1(TMPro.WordWrapState)).$ctor3(8, 8);
                    this.k_LargePositiveVector2 = new pc.Vec2( TMPro.TMP_Math.INT_MAX, TMPro.TMP_Math.INT_MAX );
                    this.k_LargeNegativeVector2 = new pc.Vec2( TMPro.TMP_Math.INT_MIN, TMPro.TMP_Math.INT_MIN );
                    this.k_LargePositiveFloat = 32767.0;
                    this.k_LargeNegativeFloat = -32767.0;
                    this.k_LargePositiveInt = 2147483647;
                    this.k_LargeNegativeInt = -2147483647;
                }
            }
        },
        fields: {
            m_text: null,
            /**
             * @instance
             * @private
             * @memberof TMPro.TMP_Text
             * @type boolean
             */
            m_IsTextBackingStringDirty: false,
            m_TextPreprocessor: null,
            m_isRightToLeft: false,
            m_fontAsset: null,
            m_currentFontAsset: null,
            m_isSDFShader: false,
            m_sharedMaterial: null,
            m_currentMaterial: null,
            m_currentMaterialIndex: 0,
            m_fontSharedMaterials: null,
            m_fontMaterial: null,
            m_fontMaterials: null,
            m_isMaterialDirty: false,
            m_fontColor32: null,
            m_fontColor: null,
            m_underlineColor: null,
            m_strikethroughColor: null,
            m_enableVertexGradient: false,
            m_colorMode: 0,
            m_fontColorGradient: null,
            m_fontColorGradientPreset: null,
            m_spriteAsset: null,
            m_tintAllSprites: false,
            m_tintSprite: false,
            m_spriteColor: null,
            m_StyleSheet: null,
            m_TextStyle: null,
            m_TextStyleHashCode: 0,
            m_overrideHtmlColors: false,
            m_faceColor: null,
            m_outlineColor: null,
            m_outlineWidth: 0,
            m_fontSize: 0,
            m_currentFontSize: 0,
            m_fontSizeBase: 0,
            m_sizeStack: null,
            m_fontWeight: 0,
            m_FontWeightInternal: 0,
            m_FontWeightStack: null,
            m_enableAutoSizing: false,
            m_maxFontSize: 0,
            m_minFontSize: 0,
            m_AutoSizeIterationCount: 0,
            m_AutoSizeMaxIterationCount: 0,
            m_IsAutoSizePointSizeSet: false,
            m_fontSizeMin: 0,
            m_fontSizeMax: 0,
            m_fontStyle: 0,
            m_FontStyleInternal: 0,
            m_fontStyleStack: null,
            m_isUsingBold: false,
            m_HorizontalAlignment: 0,
            m_VerticalAlignment: 0,
            m_textAlignment: 0,
            m_lineJustification: 0,
            m_lineJustificationStack: null,
            m_textContainerLocalCorners: null,
            m_characterSpacing: 0,
            m_cSpacing: 0,
            m_monoSpacing: 0,
            m_wordSpacing: 0,
            m_lineSpacing: 0,
            m_lineSpacingDelta: 0,
            m_lineHeight: 0,
            m_IsDrivenLineSpacing: false,
            m_lineSpacingMax: 0,
            m_paragraphSpacing: 0,
            m_charWidthMaxAdj: 0,
            m_charWidthAdjDelta: 0,
            m_enableWordWrapping: false,
            m_isCharacterWrappingEnabled: false,
            m_isNonBreakingSpace: false,
            m_isIgnoringAlignment: false,
            m_wordWrappingRatios: 0,
            m_overflowMode: 0,
            m_firstOverflowCharacterIndex: 0,
            m_linkedTextComponent: null,
            parentLinkedComponent: null,
            m_isTextTruncated: false,
            m_enableKerning: false,
            m_GlyphHorizontalAdvanceAdjustment: 0,
            m_enableExtraPadding: false,
            checkPaddingRequired: false,
            m_isRichText: false,
            m_parseCtrlCharacters: false,
            m_isOverlay: false,
            m_isOrthographic: false,
            m_isCullingEnabled: false,
            m_isMaskingEnabled: false,
            isMaskUpdateRequired: false,
            m_ignoreCulling: false,
            m_horizontalMapping: 0,
            m_verticalMapping: 0,
            m_uvLineOffset: 0,
            m_renderMode: 0,
            m_geometrySortingOrder: 0,
            m_IsTextObjectScaleStatic: false,
            m_VertexBufferAutoSizeReduction: false,
            m_firstVisibleCharacter: 0,
            m_maxVisibleCharacters: 0,
            m_maxVisibleWords: 0,
            m_maxVisibleLines: 0,
            m_useMaxVisibleDescender: false,
            m_pageToDisplay: 0,
            m_isNewPage: false,
            m_margin: null,
            m_marginLeft: 0,
            m_marginRight: 0,
            m_marginWidth: 0,
            m_marginHeight: 0,
            m_width: 0,
            m_textInfo: null,
            m_havePropertiesChanged: false,
            m_isUsingLegacyAnimationComponent: false,
            m_transform: null,
            m_rectTransform: null,
            /**
             * Used to track potential changes in RectTransform size to allow us to ignore OnRectTransformDimensionsChange getting called due to rounding errors when using Stretch Anchors.
             *
             * @instance
             * @protected
             * @memberof TMPro.TMP_Text
             * @type UnityEngine.Vector2
             */
            m_PreviousRectTransformSize: null,
            /**
             * Used to track potential changes in pivot position to allow us to ignore OnRectTransformDimensionsChange getting called due to rounding errors when using Stretch Anchors.
             *
             * @instance
             * @protected
             * @memberof TMPro.TMP_Text
             * @type UnityEngine.Vector2
             */
            m_PreviousPivotPosition: null,
            /**
             * Enables control over setting the size of the text container to match the text object.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function autoSizeTextContainer
             * @type boolean
             */
            autoSizeTextContainer: false,
            m_autoSizeTextContainer: false,
            m_mesh: null,
            m_isVolumetricText: false,
            m_spriteAnimator: null,
            m_flexibleHeight: 0,
            m_flexibleWidth: 0,
            m_minWidth: 0,
            m_minHeight: 0,
            m_maxWidth: 0,
            m_maxHeight: 0,
            m_LayoutElement: null,
            m_preferredWidth: 0,
            m_renderedWidth: 0,
            m_isPreferredWidthDirty: false,
            m_preferredHeight: 0,
            m_renderedHeight: 0,
            m_isPreferredHeightDirty: false,
            m_isCalculatingPreferredValues: false,
            m_layoutPriority: 0,
            m_isLayoutDirty: false,
            m_isAwake: false,
            m_isWaitingOnResourceLoad: false,
            m_inputSource: 0,
            m_fontScaleMultiplier: 0,
            tag_LineIndent: 0,
            tag_Indent: 0,
            m_indentStack: null,
            tag_NoParsing: false,
            m_isParsingText: false,
            m_FXMatrix: null,
            m_isFXMatrixSet: false,
            /**
             * Array containing the Unicode characters to be parsed.
             *
             * @instance
             * @memberof TMPro.TMP_Text
             * @type Array.<TMPro.TMP_Text.UnicodeChar>
             */
            m_TextProcessingArray: null,
            /**
             * The number of Unicode characters that have been parsed and contained in the m_InternalParsingBuffer
             *
             * @instance
             * @memberof TMPro.TMP_Text
             * @type number
             */
            m_InternalTextProcessingArraySize: 0,
            m_internalCharacterInfo: null,
            m_totalCharacterCount: 0,
            m_characterCount: 0,
            m_firstCharacterOfLine: 0,
            m_firstVisibleCharacterOfLine: 0,
            m_lastCharacterOfLine: 0,
            m_lastVisibleCharacterOfLine: 0,
            m_lineNumber: 0,
            m_lineVisibleCharacterCount: 0,
            m_pageNumber: 0,
            m_PageAscender: 0,
            m_maxTextAscender: 0,
            m_maxCapHeight: 0,
            m_ElementAscender: 0,
            m_ElementDescender: 0,
            m_maxLineAscender: 0,
            m_maxLineDescender: 0,
            m_startOfLineAscender: 0,
            m_startOfLineDescender: 0,
            m_lineOffset: 0,
            m_meshExtents: null,
            m_htmlColor: null,
            m_colorStack: null,
            m_underlineColorStack: null,
            m_strikethroughColorStack: null,
            m_HighlightStateStack: null,
            m_colorGradientPreset: null,
            m_colorGradientStack: null,
            m_colorGradientPresetIsTinted: false,
            m_tabSpacing: 0,
            m_spacing: 0,
            m_TextStyleStacks: null,
            m_TextStyleStackDepth: 0,
            m_ItalicAngleStack: null,
            m_ItalicAngle: 0,
            m_actionStack: null,
            m_padding: 0,
            m_baselineOffset: 0,
            m_baselineOffsetStack: null,
            m_xAdvance: 0,
            m_textElementType: 0,
            m_cached_TextElement: null,
            m_Ellipsis: null,
            m_Underline: null,
            m_defaultSpriteAsset: null,
            m_currentSpriteAsset: null,
            m_spriteCount: 0,
            m_spriteIndex: 0,
            m_spriteAnimationID: 0,
            m_ignoreActiveState: false,
            /**
             * Internal array containing the converted source text used in the text parsing process.
             *
             * @instance
             * @private
             * @memberof TMPro.TMP_Text
             * @type TMPro.TMP_Text.TextBackingContainer
             */
            m_TextBackingArray: null,
            k_Power: null
        },
        events: {
            /**
             * Event delegate to allow modifying the text geometry before it is uploaded to the mesh and rendered.
             *
             * @instance
             * @public
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @function addOnPreRenderText
             * @param   {System.Action}    value
             * @return  {void}
             */
            /**
             * Event delegate to allow modifying the text geometry before it is uploaded to the mesh and rendered.
             *
             * @instance
             * @public
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @function removeOnPreRenderText
             * @param   {System.Action}    value
             * @return  {void}
             */
            OnPreRenderText: null
        },
        props: {
            /**
             * A string containing the text to be displayed.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function text
             * @type string
             */
            text: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#text#get", this ); }

                    if (this.m_IsTextBackingStringDirty) {
                        return this.InternalTextBackingArrayToString();
                    }

                    return this.m_text;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#text#set", this ); }

                    if (this.m_IsTextBackingStringDirty === false && this.m_text != null && value != null && this.m_text.length === value.length && Bridge.referenceEquals(this.m_text, value)) {
                        return;
                    }

                    this.m_IsTextBackingStringDirty = false;
                    this.m_text = value;
                    this.m_inputSource = TMPro.TMP_Text.TextInputSources.TextString;
                    this.m_havePropertiesChanged = true;
                    this.SetVerticesDirty();
                    this.SetLayoutDirty();
                }
            },
            /**
             * The ITextPreprocessor component referenced by the text object (if any)
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function textPreprocessor
             * @type TMPro.ITextPreprocessor
             */
            textPreprocessor: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#textPreprocessor#get", this ); }

                    return this.m_TextPreprocessor;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#textPreprocessor#set", this ); }

                    this.m_TextPreprocessor = value;
                }
            },
            /**
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function isRightToLeftText
             * @type boolean
             */
            isRightToLeftText: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#isRightToLeftText#get", this ); }

                    return this.m_isRightToLeft;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#isRightToLeftText#set", this ); }

                    if (this.m_isRightToLeft === value) {
                        return;
                    }

                    this.m_isRightToLeft = value;
                    this.m_havePropertiesChanged = true;
                    this.SetVerticesDirty();
                    this.SetLayoutDirty();
                }
            },
            /**
             * The Font Asset to be assigned to this text object.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function font
             * @type TMPro.TMP_FontAsset
             */
            font: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#font#get", this ); }

                    return this.m_fontAsset;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#font#set", this ); }

                    if (Bridge.referenceEquals(this.m_fontAsset, value)) {
                        return;
                    }

                    this.m_fontAsset = value;
                    this.LoadFontAsset();
                    this.m_havePropertiesChanged = true;
                    this.SetVerticesDirty();
                    this.SetLayoutDirty();
                }
            },
            /**
             * The material to be assigned to this text object.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function fontSharedMaterial
             * @type UnityEngine.Material
             */
            fontSharedMaterial: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#fontSharedMaterial#get", this ); }

                    return this.m_sharedMaterial;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#fontSharedMaterial#set", this ); }

                    if (Bridge.referenceEquals(this.m_sharedMaterial, value)) {
                        return;
                    }

                    this.SetSharedMaterial(value);
                    this.m_havePropertiesChanged = true;
                    this.SetVerticesDirty();
                    this.SetMaterialDirty();
                }
            },
            /**
             * An array containing the materials used by the text object.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function fontSharedMaterials
             * @type Array.<UnityEngine.Material>
             */
            fontSharedMaterials: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#fontSharedMaterials#get", this ); }

                    return this.GetSharedMaterials();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#fontSharedMaterials#set", this ); }

                    this.SetSharedMaterials(value);
                    this.m_havePropertiesChanged = true;
                    this.SetVerticesDirty();
                    this.SetMaterialDirty();
                }
            },
            /**
             * The material to be assigned to this text object. An instance of the material will be assigned to the object's renderer.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function fontMaterial
             * @type UnityEngine.Material
             */
            fontMaterial: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#fontMaterial#get", this ); }

                    return this.GetMaterial(this.m_sharedMaterial);
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#fontMaterial#set", this ); }

                    if (this.m_sharedMaterial != null && this.m_sharedMaterial.GetInstanceID() === value.GetInstanceID()) {
                        return;
                    }

                    this.m_sharedMaterial = value;
                    this.m_padding = this.GetPaddingForMaterial();
                    this.m_havePropertiesChanged = true;
                    this.SetVerticesDirty();
                    this.SetMaterialDirty();
                }
            },
            /**
             * The materials to be assigned to this text object. An instance of the materials will be assigned.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function fontMaterials
             * @type Array.<UnityEngine.Material>
             */
            fontMaterials: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#fontMaterials#get", this ); }

                    return this.GetMaterials(this.m_fontSharedMaterials);
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#fontMaterials#set", this ); }

                    this.SetSharedMaterials(value);
                    this.m_havePropertiesChanged = true;
                    this.SetVerticesDirty();
                    this.SetMaterialDirty();
                }
            },
            /**
             * This is the default vertex color assigned to each vertices. Color tags will override vertex colors unless the overrideColorTags is set.
             *
             * @instance
             * @public
             * @override
             * @memberof TMPro.TMP_Text
             * @function color
             * @type UnityEngine.Color
             */
            color: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#color#get", this ); }

                    return this.m_fontColor.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#color#set", this ); }

                    if (pc.Color.equals( this.m_fontColor, value )) {
                        return;
                    }

                    this.m_havePropertiesChanged = true;
                    this.m_fontColor = value.$clone();
                    this.SetVerticesDirty();
                }
            },
            /**
             * Sets the vertex color alpha value.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function alpha
             * @type number
             */
            alpha: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#alpha#get", this ); }

                    return this.m_fontColor.a;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#alpha#set", this ); }

                    if (this.m_fontColor.a === value) {
                        return;
                    }

                    this.m_fontColor.a = value;
                    this.m_havePropertiesChanged = true;
                    this.SetVerticesDirty();
                }
            },
            /**
             * Determines if Vertex Color Gradient should be used
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function enableVertexGradient
             * @type boolean
             */
            enableVertexGradient: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#enableVertexGradient#get", this ); }

                    return this.m_enableVertexGradient;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#enableVertexGradient#set", this ); }

                    if (this.m_enableVertexGradient === value) {
                        return;
                    }

                    this.m_havePropertiesChanged = true;
                    this.m_enableVertexGradient = value;
                    this.SetVerticesDirty();
                }
            },
            /**
             * Sets the vertex colors for each of the 4 vertices of the character quads.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function colorGradient
             * @type TMPro.VertexGradient
             */
            colorGradient: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#colorGradient#get", this ); }

                    return this.m_fontColorGradient.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#colorGradient#set", this ); }

                    this.m_havePropertiesChanged = true;
                    this.m_fontColorGradient = value.$clone();
                    this.SetVerticesDirty();
                }
            },
            /**
             * Set the vertex colors of the 4 vertices of each character quads.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function colorGradientPreset
             * @type TMPro.TMP_ColorGradient
             */
            colorGradientPreset: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#colorGradientPreset#get", this ); }

                    return this.m_fontColorGradientPreset;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#colorGradientPreset#set", this ); }

                    this.m_havePropertiesChanged = true;
                    this.m_fontColorGradientPreset = value;
                    this.SetVerticesDirty();
                }
            },
            /**
             * Sprite Asset used by the text object.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function spriteAsset
             * @type TMPro.TMP_SpriteAsset
             */
            spriteAsset: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#spriteAsset#get", this ); }

                    return this.m_spriteAsset;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#spriteAsset#set", this ); }

                    this.m_spriteAsset = value;
                    this.m_havePropertiesChanged = true;
                    this.SetVerticesDirty();
                    this.SetLayoutDirty();
                }
            },
            /**
             * Determines whether or not the sprite color is multiplies by the vertex color of the text.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function tintAllSprites
             * @type boolean
             */
            tintAllSprites: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#tintAllSprites#get", this ); }

                    return this.m_tintAllSprites;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#tintAllSprites#set", this ); }

                    if (this.m_tintAllSprites === value) {
                        return;
                    }

                    this.m_tintAllSprites = value;
                    this.m_havePropertiesChanged = true;
                    this.SetVerticesDirty();
                }
            },
            /**
             * Style sheet used by the text object.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function styleSheet
             * @type TMPro.TMP_StyleSheet
             */
            styleSheet: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#styleSheet#get", this ); }

                    return this.m_StyleSheet;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#styleSheet#set", this ); }

                    this.m_StyleSheet = value;
                    this.m_havePropertiesChanged = true;
                    this.SetVerticesDirty();
                    this.SetLayoutDirty();
                }
            },
            /**
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function textStyle
             * @type TMPro.TMP_Style
             */
            textStyle: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#textStyle#get", this ); }

                    this.m_TextStyle = this.GetStyle(this.m_TextStyleHashCode);

                    if (this.m_TextStyle == null) {
                        this.m_TextStyle = TMPro.TMP_Style.NormalStyle;
                        this.m_TextStyleHashCode = this.m_TextStyle.hashCode;
                    }

                    return this.m_TextStyle;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#textStyle#set", this ); }

                    this.m_TextStyle = value;
                    this.m_TextStyleHashCode = this.m_TextStyle.hashCode;
                    this.m_havePropertiesChanged = true;
                    this.SetVerticesDirty();
                    this.SetLayoutDirty();
                }
            },
            /**
             * This overrides the color tags forcing the vertex colors to be the default font color.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function overrideColorTags
             * @type boolean
             */
            overrideColorTags: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#overrideColorTags#get", this ); }

                    return this.m_overrideHtmlColors;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#overrideColorTags#set", this ); }

                    if (this.m_overrideHtmlColors === value) {
                        return;
                    }

                    this.m_havePropertiesChanged = true;
                    this.m_overrideHtmlColors = value;
                    this.SetVerticesDirty();
                }
            },
            /**
             * Sets the color of the _FaceColor property of the assigned material. Changing face color will result in an instance of the material.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function faceColor
             * @type UnityEngine.Color32
             */
            faceColor: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#faceColor#get", this ); }

                    if (this.m_sharedMaterial == null) {
                        return this.m_faceColor.$clone();
                    }

                    this.m_faceColor = UnityEngine.Color32.op_Implicit$1(this.m_sharedMaterial.GetColor(TMPro.ShaderUtilities.ID_FaceColor));
                    return this.m_faceColor.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#faceColor#set", this ); }

                    if (TMPro.TMPro_ExtensionMethods.Compare$1(this.m_faceColor, value.$clone())) {
                        return;
                    }

                    this.SetFaceColor(value.$clone());
                    this.m_havePropertiesChanged = true;
                    this.m_faceColor = value.$clone();
                    this.SetVerticesDirty();
                    this.SetMaterialDirty();
                }
            },
            /**
             * Sets the color of the _OutlineColor property of the assigned material. Changing outline color will result in an instance of the material.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function outlineColor
             * @type UnityEngine.Color32
             */
            outlineColor: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#outlineColor#get", this ); }

                    if (this.m_sharedMaterial == null) {
                        return this.m_outlineColor.$clone();
                    }

                    this.m_outlineColor = UnityEngine.Color32.op_Implicit$1(this.m_sharedMaterial.GetColor(TMPro.ShaderUtilities.ID_OutlineColor));
                    return this.m_outlineColor.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#outlineColor#set", this ); }

                    if (TMPro.TMPro_ExtensionMethods.Compare$1(this.m_outlineColor, value.$clone())) {
                        return;
                    }

                    this.SetOutlineColor(value.$clone());
                    this.m_havePropertiesChanged = true;
                    this.m_outlineColor = value.$clone();
                    this.SetVerticesDirty();
                }
            },
            /**
             * Sets the thickness of the outline of the font. Setting this value will result in an instance of the material.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function outlineWidth
             * @type number
             */
            outlineWidth: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#outlineWidth#get", this ); }

                    if (this.m_sharedMaterial == null) {
                        return this.m_outlineWidth;
                    }

                    this.m_outlineWidth = this.m_sharedMaterial.GetFloat(TMPro.ShaderUtilities.ID_OutlineWidth);
                    return this.m_outlineWidth;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#outlineWidth#set", this ); }

                    if (this.m_outlineWidth === value) {
                        return;
                    }

                    this.SetOutlineThickness(value);
                    this.m_havePropertiesChanged = true;
                    this.m_outlineWidth = value;
                    this.SetVerticesDirty();
                }
            },
            /**
             * The point size of the font.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function fontSize
             * @type number
             */
            fontSize: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#fontSize#get", this ); }

                    return this.m_fontSize;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#fontSize#set", this ); }

                    if (this.m_fontSize === value) {
                        return;
                    }

                    this.m_havePropertiesChanged = true;
                    this.m_fontSize = value;
                    if (!this.m_enableAutoSizing) {
                        this.m_fontSizeBase = this.m_fontSize;
                    }

                    this.SetVerticesDirty();
                    this.SetLayoutDirty();
                }
            },
            /**
             * Control the weight of the font if an alternative font asset is assigned for the given weight in the font asset editor.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function fontWeight
             * @type TMPro.FontWeight
             */
            fontWeight: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#fontWeight#get", this ); }

                    return this.m_fontWeight;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#fontWeight#set", this ); }

                    if (this.m_fontWeight === value) {
                        return;
                    }

                    this.m_fontWeight = value;
                    this.m_havePropertiesChanged = true;
                    this.SetVerticesDirty();
                    this.SetLayoutDirty();
                }
            },
            /**
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_Text
             * @function pixelsPerUnit
             * @type number
             */
            pixelsPerUnit: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#pixelsPerUnit#get", this ); }

                    var localCanvas = this.canvas;
                    if (!UnityEngine.Object.op_Implicit(localCanvas)) {
                        return 1;
                    }

                    // For dynamic fonts, ensure we use one pixel per pixel on the screen.
                    if (!UnityEngine.Object.op_Implicit(this.font)) {
                        return localCanvas.scaleFactor;
                    }

                    // For non-dynamic fonts, calculate pixels per unit based on specified font size relative to font object's own font size.
                    if (this.m_currentFontAsset == null || this.m_currentFontAsset.faceInfo.pointSize <= 0 || this.m_fontSize <= 0) {
                        return 1;
                    }

                    return this.m_fontSize / this.m_currentFontAsset.faceInfo.pointSize;
                }
            },
            /**
             * Enable text auto-sizing
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function enableAutoSizing
             * @type boolean
             */
            enableAutoSizing: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#enableAutoSizing#get", this ); }

                    return this.m_enableAutoSizing;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#enableAutoSizing#set", this ); }

                    if (this.m_enableAutoSizing === value) {
                        return;
                    }

                    this.m_enableAutoSizing = value;
                    this.SetVerticesDirty();
                    this.SetLayoutDirty();
                }
            },
            /**
             * Minimum point size of the font when text auto-sizing is enabled.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function fontSizeMin
             * @type number
             */
            fontSizeMin: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#fontSizeMin#get", this ); }

                    return this.m_fontSizeMin;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#fontSizeMin#set", this ); }

                    if (this.m_fontSizeMin === value) {
                        return;
                    }

                    this.m_fontSizeMin = value;
                    this.SetVerticesDirty();
                    this.SetLayoutDirty();
                }
            },
            /**
             * Maximum point size of the font when text auto-sizing is enabled.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function fontSizeMax
             * @type number
             */
            fontSizeMax: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#fontSizeMax#get", this ); }

                    return this.m_fontSizeMax;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#fontSizeMax#set", this ); }

                    if (this.m_fontSizeMax === value) {
                        return;
                    }

                    this.m_fontSizeMax = value;
                    this.SetVerticesDirty();
                    this.SetLayoutDirty();
                }
            },
            /**
             * The style of the text
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function fontStyle
             * @type TMPro.FontStyles
             */
            fontStyle: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#fontStyle#get", this ); }

                    return this.m_fontStyle;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#fontStyle#set", this ); }

                    if (this.m_fontStyle === value) {
                        return;
                    }

                    this.m_fontStyle = value;
                    this.m_havePropertiesChanged = true;
                    this.SetVerticesDirty();
                    this.SetLayoutDirty();
                }
            },
            /**
             * Property used in conjunction with padding calculation for the geometry.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_Text
             * @function isUsingBold
             * @type boolean
             */
            isUsingBold: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#isUsingBold#get", this ); }

                    return this.m_isUsingBold;
                }
            },
            /**
             * Horizontal alignment options
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function horizontalAlignment
             * @type TMPro.HorizontalAlignmentOptions
             */
            horizontalAlignment: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#horizontalAlignment#get", this ); }

                    return this.m_HorizontalAlignment;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#horizontalAlignment#set", this ); }

                    if (this.m_HorizontalAlignment === value) {
                        return;
                    }

                    this.m_HorizontalAlignment = value;
                    this.m_havePropertiesChanged = true;
                    this.SetVerticesDirty();
                }
            },
            /**
             * Vertical alignment options
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function verticalAlignment
             * @type TMPro.VerticalAlignmentOptions
             */
            verticalAlignment: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#verticalAlignment#get", this ); }

                    return this.m_VerticalAlignment;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#verticalAlignment#set", this ); }

                    if (this.m_VerticalAlignment === value) {
                        return;
                    }

                    this.m_VerticalAlignment = value;
                    this.m_havePropertiesChanged = true;
                    this.SetVerticesDirty();
                }
            },
            /**
             * Text alignment options
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function alignment
             * @type TMPro.TextAlignmentOptions
             */
            alignment: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#alignment#get", this ); }

                    return this.m_HorizontalAlignment | this.m_VerticalAlignment;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#alignment#set", this ); }

                    var horizontalAlignment = value & 255;
                    var verticalAlignment = value & 65280;
                    if (this.m_HorizontalAlignment === horizontalAlignment && this.m_VerticalAlignment === verticalAlignment) {
                        return;
                    }

                    this.m_HorizontalAlignment = horizontalAlignment;
                    this.m_VerticalAlignment = verticalAlignment;
                    this.m_havePropertiesChanged = true;
                    this.SetVerticesDirty();
                }
            },
            /**
             * Use the extents of the text geometry for alignment instead of font metrics.
             * The amount of additional spacing between characters.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function characterSpacing
             * @type number
             */
            characterSpacing: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#characterSpacing#get", this ); }

                    return this.m_characterSpacing;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#characterSpacing#set", this ); }

                    if (this.m_characterSpacing === value) {
                        return;
                    }

                    this.m_havePropertiesChanged = true;
                    this.m_characterSpacing = value;
                    this.SetVerticesDirty();
                    this.SetLayoutDirty();
                }
            },
            /**
             * The amount of additional spacing between words.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function wordSpacing
             * @type number
             */
            wordSpacing: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#wordSpacing#get", this ); }

                    return this.m_wordSpacing;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#wordSpacing#set", this ); }

                    if (this.m_wordSpacing === value) {
                        return;
                    }

                    this.m_havePropertiesChanged = true;
                    this.m_wordSpacing = value;
                    this.SetVerticesDirty();
                    this.SetLayoutDirty();
                }
            },
            /**
             * The amount of additional spacing to add between each lines of text.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function lineSpacing
             * @type number
             */
            lineSpacing: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#lineSpacing#get", this ); }

                    return this.m_lineSpacing;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#lineSpacing#set", this ); }

                    if (this.m_lineSpacing === value) {
                        return;
                    }

                    this.m_havePropertiesChanged = true;
                    this.m_lineSpacing = value;
                    this.SetVerticesDirty();
                    this.SetLayoutDirty();
                }
            },
            /**
             * The amount of potential line spacing adjustment before text auto sizing kicks in.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function lineSpacingAdjustment
             * @type number
             */
            lineSpacingAdjustment: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#lineSpacingAdjustment#get", this ); }

                    return this.m_lineSpacingMax;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#lineSpacingAdjustment#set", this ); }

                    if (this.m_lineSpacingMax === value) {
                        return;
                    }

                    this.m_havePropertiesChanged = true;
                    this.m_lineSpacingMax = value;
                    this.SetVerticesDirty();
                    this.SetLayoutDirty();
                }
            },
            /**
             * The amount of additional spacing to add between each lines of text.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function paragraphSpacing
             * @type number
             */
            paragraphSpacing: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#paragraphSpacing#get", this ); }

                    return this.m_paragraphSpacing;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#paragraphSpacing#set", this ); }

                    if (this.m_paragraphSpacing === value) {
                        return;
                    }

                    this.m_havePropertiesChanged = true;
                    this.m_paragraphSpacing = value;
                    this.SetVerticesDirty();
                    this.SetLayoutDirty();
                }
            },
            /**
             * Percentage the width of characters can be adjusted before text auto-sizing begins to reduce the point size.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function characterWidthAdjustment
             * @type number
             */
            characterWidthAdjustment: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#characterWidthAdjustment#get", this ); }

                    return this.m_charWidthMaxAdj;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#characterWidthAdjustment#set", this ); }

                    if (this.m_charWidthMaxAdj === value) {
                        return;
                    }

                    this.m_havePropertiesChanged = true;
                    this.m_charWidthMaxAdj = value;
                    this.SetVerticesDirty();
                    this.SetLayoutDirty();
                }
            },
            /**
             * Controls whether or not word wrapping is applied. When disabled, the text will be displayed on a single line.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function enableWordWrapping
             * @type boolean
             */
            enableWordWrapping: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#enableWordWrapping#get", this ); }

                    return this.m_enableWordWrapping;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#enableWordWrapping#set", this ); }

                    if (this.m_enableWordWrapping === value) {
                        return;
                    }

                    this.m_havePropertiesChanged = true;
                    this.m_enableWordWrapping = value;
                    this.SetVerticesDirty();
                    this.SetLayoutDirty();
                }
            },
            /**
             * Controls the blending between using character and word spacing to fill-in the space for justified text.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function wordWrappingRatios
             * @type number
             */
            wordWrappingRatios: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#wordWrappingRatios#get", this ); }

                    return this.m_wordWrappingRatios;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#wordWrappingRatios#set", this ); }

                    if (this.m_wordWrappingRatios === value) {
                        return;
                    }

                    this.m_wordWrappingRatios = value;
                    this.m_havePropertiesChanged = true;
                    this.SetVerticesDirty();
                    this.SetLayoutDirty();
                }
            },
            /**
             * 
             * Controls the Text Overflow Mode
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function overflowMode
             * @type TMPro.TextOverflowModes
             */
            overflowMode: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#overflowMode#get", this ); }

                    return this.m_overflowMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#overflowMode#set", this ); }

                    if (this.m_overflowMode === value) {
                        return;
                    }

                    this.m_overflowMode = value;
                    this.m_havePropertiesChanged = true;
                    this.SetVerticesDirty();
                    this.SetLayoutDirty();
                }
            },
            /**
             * Indicates if the text exceeds the vertical bounds of its text container.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_Text
             * @function isTextOverflowing
             * @type boolean
             */
            isTextOverflowing: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#isTextOverflowing#get", this ); }

                    if (this.m_firstOverflowCharacterIndex !== -1) {
                        return true;
                    }

                    return false;
                }
            },
            /**
             * The first character which exceeds the vertical bounds of its text container.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_Text
             * @function firstOverflowCharacterIndex
             * @type number
             */
            firstOverflowCharacterIndex: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#firstOverflowCharacterIndex#get", this ); }

                    return this.m_firstOverflowCharacterIndex;
                }
            },
            /**
             * The linked text component used for flowing the text from one text component to another.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function linkedTextComponent
             * @type TMPro.TMP_Text
             */
            linkedTextComponent: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#linkedTextComponent#get", this ); }

                    return this.m_linkedTextComponent;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#linkedTextComponent#set", this ); }

                    if (UnityEngine.MonoBehaviour.op_Equality(value, null)) {
                        // Release linked text components
                        this.ReleaseLinkedTextComponent(this.m_linkedTextComponent);
                        this.m_linkedTextComponent = value;
                    } else if (this.IsSelfOrLinkedAncestor(value)) {
                        // We do nothing since new assigned is invalid
                        return;
                    } else {
                        // Release linked text components
                        this.ReleaseLinkedTextComponent(this.m_linkedTextComponent);
                        this.m_linkedTextComponent = value;
                        this.m_linkedTextComponent.parentLinkedComponent = this;
                    }

                    this.m_havePropertiesChanged = true;
                    this.SetVerticesDirty();
                    this.SetLayoutDirty();
                }
            },
            /**
             * Property indicating whether the text is Truncated or using Ellipsis.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_Text
             * @function isTextTruncated
             * @type boolean
             */
            isTextTruncated: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#isTextTruncated#get", this ); }

                    return this.m_isTextTruncated;
                }
            },
            /**
             * Determines if kerning is enabled or disabled.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function enableKerning
             * @type boolean
             */
            enableKerning: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#enableKerning#get", this ); }

                    return this.m_enableKerning;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#enableKerning#set", this ); }

                    if (this.m_enableKerning === value) {
                        return;
                    }

                    this.m_havePropertiesChanged = true;
                    this.m_enableKerning = value;
                    this.SetVerticesDirty();
                    this.SetLayoutDirty();
                }
            },
            /**
             * Adds extra padding around each character. This may be necessary when the displayed text is very small to prevent clipping.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function extraPadding
             * @type boolean
             */
            extraPadding: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#extraPadding#get", this ); }

                    return this.m_enableExtraPadding;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#extraPadding#set", this ); }

                    if (this.m_enableExtraPadding === value) {
                        return;
                    }

                    this.m_havePropertiesChanged = true;
                    this.m_enableExtraPadding = value;
                    this.UpdateMeshPadding();
                    this.SetVerticesDirty(); /* SetLayoutDirty();*/
                }
            },
            /**
             * Enables or Disables Rich Text Tags
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function richText
             * @type boolean
             */
            richText: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#richText#get", this ); }

                    return this.m_isRichText;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#richText#set", this ); }

                    if (this.m_isRichText === value) {
                        return;
                    }

                    this.m_isRichText = value;
                    this.m_havePropertiesChanged = true;
                    this.SetVerticesDirty();
                    this.SetLayoutDirty();
                }
            },
            /**
             * Enables or Disables parsing of CTRL characters in input text.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function parseCtrlCharacters
             * @type boolean
             */
            parseCtrlCharacters: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#parseCtrlCharacters#get", this ); }

                    return this.m_parseCtrlCharacters;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#parseCtrlCharacters#set", this ); }

                    if (this.m_parseCtrlCharacters === value) {
                        return;
                    }

                    this.m_parseCtrlCharacters = value;
                    this.m_havePropertiesChanged = true;
                    this.SetVerticesDirty();
                    this.SetLayoutDirty();
                }
            },
            /**
             * Sets the RenderQueue along with Ztest to force the text to be drawn last and on top of scene elements.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function isOverlay
             * @type boolean
             */
            isOverlay: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#isOverlay#get", this ); }

                    return this.m_isOverlay;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#isOverlay#set", this ); }

                    if (this.m_isOverlay === value) {
                        return;
                    }

                    this.m_isOverlay = value;
                    this.SetShaderDepth();
                    this.m_havePropertiesChanged = true;
                    this.SetVerticesDirty();
                }
            },
            
            isOrthographic: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#isOrthographic#get", this ); }

                    return this.m_isOrthographic;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#isOrthographic#set", this ); }

                    if (this.m_isOrthographic === value) {
                        return;
                    }

                    this.m_havePropertiesChanged = true;
                    this.m_isOrthographic = value;
                    this.SetVerticesDirty();
                }
            },
            /**
             * Sets the culling on the shaders. Note changing this value will result in an instance of the material.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function enableCulling
             * @type boolean
             */
            enableCulling: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#enableCulling#get", this ); }

                    return this.m_isCullingEnabled;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#enableCulling#set", this ); }

                    if (this.m_isCullingEnabled === value) {
                        return;
                    }

                    this.m_isCullingEnabled = value;
                    this.SetCulling();
                    this.m_havePropertiesChanged = true;
                }
            },
            /**
             * Forces objects that are not visible to get refreshed.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function ignoreVisibility
             * @type boolean
             */
            ignoreVisibility: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#ignoreVisibility#get", this ); }

                    return this.m_ignoreCulling;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#ignoreVisibility#set", this ); }

                    if (this.m_ignoreCulling === value) {
                        return;
                    }

                    this.m_havePropertiesChanged = true;
                    this.m_ignoreCulling = value;
                }
            },
            /**
             * Controls how the face and outline textures will be applied to the text object.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function horizontalMapping
             * @type TMPro.TextureMappingOptions
             */
            horizontalMapping: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#horizontalMapping#get", this ); }

                    return this.m_horizontalMapping;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#horizontalMapping#set", this ); }

                    if (this.m_horizontalMapping === value) {
                        return;
                    }

                    this.m_havePropertiesChanged = true;
                    this.m_horizontalMapping = value;
                    this.SetVerticesDirty();
                }
            },
            /**
             * Controls how the face and outline textures will be applied to the text object.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function verticalMapping
             * @type TMPro.TextureMappingOptions
             */
            verticalMapping: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#verticalMapping#get", this ); }

                    return this.m_verticalMapping;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#verticalMapping#set", this ); }

                    if (this.m_verticalMapping === value) {
                        return;
                    }

                    this.m_havePropertiesChanged = true;
                    this.m_verticalMapping = value;
                    this.SetVerticesDirty();
                }
            },
            /**
             * Controls the UV Offset for the various texture mapping mode on the text object.
             * Controls the horizontal offset of the UV of the texture mapping mode for each line of the text object.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function mappingUvLineOffset
             * @type number
             */
            mappingUvLineOffset: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#mappingUvLineOffset#get", this ); }

                    return this.m_uvLineOffset;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#mappingUvLineOffset#set", this ); }

                    if (this.m_uvLineOffset === value) {
                        return;
                    }

                    this.m_havePropertiesChanged = true;
                    this.m_uvLineOffset = value;
                    this.SetVerticesDirty();
                }
            },
            /**
             * Determines if the Mesh will be rendered.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function renderMode
             * @type TMPro.TextRenderFlags
             */
            renderMode: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#renderMode#get", this ); }

                    return this.m_renderMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#renderMode#set", this ); }

                    if (this.m_renderMode === value) {
                        return;
                    }

                    this.m_renderMode = value;
                    this.m_havePropertiesChanged = true;
                }
            },
            /**
             * Determines the sorting order of the geometry of the text object.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function geometrySortingOrder
             * @type TMPro.VertexSortingOrder
             */
            geometrySortingOrder: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#geometrySortingOrder#get", this ); }

                    return this.m_geometrySortingOrder;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#geometrySortingOrder#set", this ); }

                    this.m_geometrySortingOrder = value;
                    this.m_havePropertiesChanged = true;
                    this.SetVerticesDirty();
                }
            },
            /**
             * Determines if a text object will be excluded from the InternalUpdate callback used to handle updates of SDF Scale when the scale of the text object or parent(s) changes.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function isTextObjectScaleStatic
             * @type boolean
             */
            isTextObjectScaleStatic: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#isTextObjectScaleStatic#get", this ); }

                    return this.m_IsTextObjectScaleStatic;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#isTextObjectScaleStatic#set", this ); }

                    this.m_IsTextObjectScaleStatic = value;
                    if (this.m_IsTextObjectScaleStatic) {
                        TMPro.TMP_UpdateManager.UnRegisterTextObjectForUpdate(this);
                    } else {
                        TMPro.TMP_UpdateManager.RegisterTextObjectForUpdate(this);
                    }
                }
            },
            /**
             * Determines if the data structures allocated to contain the geometry of the text object will be reduced in size if the number of characters required to display the text is reduced by more than 256 characters.
             This reduction has the benefit of reducing the amount of vertex data being submitted to the graphic device but results in GC when it occurs.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function vertexBufferAutoSizeReduction
             * @type boolean
             */
            vertexBufferAutoSizeReduction: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#vertexBufferAutoSizeReduction#get", this ); }

                    return this.m_VertexBufferAutoSizeReduction;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#vertexBufferAutoSizeReduction#set", this ); }

                    this.m_VertexBufferAutoSizeReduction = value;
                    this.m_havePropertiesChanged = true;
                    this.SetVerticesDirty();
                }
            },
            /**
             * The first character which should be made visible in conjunction with the Text Overflow Linked mode.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function firstVisibleCharacter
             * @type number
             */
            firstVisibleCharacter: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#firstVisibleCharacter#get", this ); }

                    return this.m_firstVisibleCharacter;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#firstVisibleCharacter#set", this ); }

                    if (this.m_firstVisibleCharacter === value) {
                        return;
                    }

                    this.m_havePropertiesChanged = true;
                    this.m_firstVisibleCharacter = value;
                    this.SetVerticesDirty();
                }
            },
            /**
             * Allows to control how many characters are visible from the input.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function maxVisibleCharacters
             * @type number
             */
            maxVisibleCharacters: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#maxVisibleCharacters#get", this ); }

                    return this.m_maxVisibleCharacters;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#maxVisibleCharacters#set", this ); }

                    if (this.m_maxVisibleCharacters === value) {
                        return;
                    }

                    this.m_havePropertiesChanged = true;
                    this.m_maxVisibleCharacters = value;
                    this.SetVerticesDirty();
                }
            },
            /**
             * Allows to control how many words are visible from the input.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function maxVisibleWords
             * @type number
             */
            maxVisibleWords: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#maxVisibleWords#get", this ); }

                    return this.m_maxVisibleWords;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#maxVisibleWords#set", this ); }

                    if (this.m_maxVisibleWords === value) {
                        return;
                    }

                    this.m_havePropertiesChanged = true;
                    this.m_maxVisibleWords = value;
                    this.SetVerticesDirty();
                }
            },
            /**
             * Allows control over how many lines of text are displayed.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function maxVisibleLines
             * @type number
             */
            maxVisibleLines: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#maxVisibleLines#get", this ); }

                    return this.m_maxVisibleLines;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#maxVisibleLines#set", this ); }

                    if (this.m_maxVisibleLines === value) {
                        return;
                    }

                    this.m_havePropertiesChanged = true;
                    this.m_maxVisibleLines = value;
                    this.SetVerticesDirty();
                }
            },
            /**
             * Determines if the text's vertical alignment will be adjusted based on visible descender of the text.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function useMaxVisibleDescender
             * @type boolean
             */
            useMaxVisibleDescender: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#useMaxVisibleDescender#get", this ); }

                    return this.m_useMaxVisibleDescender;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#useMaxVisibleDescender#set", this ); }

                    if (this.m_useMaxVisibleDescender === value) {
                        return;
                    }

                    this.m_havePropertiesChanged = true;
                    this.m_useMaxVisibleDescender = value;
                    this.SetVerticesDirty();
                }
            },
            /**
             * Controls which page of text is shown
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function pageToDisplay
             * @type number
             */
            pageToDisplay: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#pageToDisplay#get", this ); }

                    return this.m_pageToDisplay;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#pageToDisplay#set", this ); }

                    if (this.m_pageToDisplay === value) {
                        return;
                    }

                    this.m_havePropertiesChanged = true;
                    this.m_pageToDisplay = value;
                    this.SetVerticesDirty();
                }
            },
            /**
             * The margins of the text object.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function margin
             * @type UnityEngine.Vector4
             */
            margin: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#margin#get", this ); }

                    return this.m_margin.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#margin#set", this ); }

                    if (pc.Vec4.equals( this.m_margin, value )) {
                        return;
                    }

                    this.m_margin = value.$clone();
                    this.ComputeMarginSize();
                    this.m_havePropertiesChanged = true;
                    this.SetVerticesDirty();
                }
            },
            /**
             * Returns data about the text object which includes information about each character, word, line, link, etc.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_Text
             * @function textInfo
             * @type TMPro.TMP_TextInfo
             */
            textInfo: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#textInfo#get", this ); }

                    return this.m_textInfo;
                }
            },
            /**
             * Property tracking if any of the text properties have changed. Flag is set before the text is regenerated.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function havePropertiesChanged
             * @type boolean
             */
            havePropertiesChanged: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#havePropertiesChanged#get", this ); }

                    return this.m_havePropertiesChanged;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#havePropertiesChanged#set", this ); }

                    if (this.m_havePropertiesChanged === value) {
                        return;
                    }

                    this.m_havePropertiesChanged = value;
                    this.SetAllDirty();
                }
            },
            /**
             * Property to handle legacy animation component.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function isUsingLegacyAnimationComponent
             * @type boolean
             */
            isUsingLegacyAnimationComponent: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#isUsingLegacyAnimationComponent#get", this ); }

                    return this.m_isUsingLegacyAnimationComponent;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#isUsingLegacyAnimationComponent#set", this ); }

                    this.m_isUsingLegacyAnimationComponent = value;
                }
            },
            /**
             * Returns are reference to the Transform
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_Text
             * @function transform$1
             * @type UnityEngine.Transform
             */
            transform$1: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#transform$1#get", this ); }

                    if (UnityEngine.Component.op_Equality(this.m_transform, null)) {
                        this.m_transform = this.GetComponent(UnityEngine.Transform);
                    }

                    return this.m_transform;
                }
            },
            /**
             * Returns are reference to the RectTransform
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_Text
             * @function rectTransform$1
             * @type UnityEngine.RectTransform
             */
            rectTransform$1: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#rectTransform$1#get", this ); }

                    if (UnityEngine.Component.op_Equality(this.m_rectTransform, null)) {
                        this.m_rectTransform = this.GetComponent(UnityEngine.RectTransform);
                    }

                    return this.m_rectTransform;
                }
            },
            /**
             * The mesh used by the font asset and material assigned to the text object.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_Text
             * @function mesh
             * @type UnityEngine.Mesh
             */
            mesh: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#mesh#get", this ); }

                    return this.m_mesh;
                }
            },
            /**
             * Determines if the geometry of the characters will be quads or volumetric (cubes).
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Text
             * @function isVolumetricText
             * @type boolean
             */
            isVolumetricText: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#isVolumetricText#get", this ); }

                    return this.m_isVolumetricText;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#isVolumetricText#set", this ); }

                    if (this.m_isVolumetricText === value) {
                        return;
                    }

                    this.m_havePropertiesChanged = value;
                    this.m_textInfo.ResetVertexLayout(value);
                    this.SetVerticesDirty();
                    this.SetLayoutDirty();
                }
            },
            /**
             * Returns the bounds of the mesh of the text object in world space.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_Text
             * @function bounds
             * @type UnityEngine.Bounds
             */
            bounds: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#bounds#get", this ); }

                    if (this.m_mesh == null) {
                        return new pc.BoundingBox.ctor();
                    }

                    return this.GetCompoundBounds();
                }
            },
            /**
             * Returns the bounds of the text of the text object.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_Text
             * @function textBounds
             * @type UnityEngine.Bounds
             */
            textBounds: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#textBounds#get", this ); }

                    if (this.m_textInfo == null) {
                        return new pc.BoundingBox.ctor();
                    }

                    return this.GetTextBounds();
                }
            },
            /**
             * Component used to control wrapping of text following some arbitrary shape.
             * Component used to control and animate sprites in the text object.
             *
             * @instance
             * @protected
             * @readonly
             * @memberof TMPro.TMP_Text
             * @function spriteAnimator
             * @type TMPro.TMP_SpriteAnimator
             */
            spriteAnimator: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#spriteAnimator#get", this ); }

                    if (UnityEngine.MonoBehaviour.op_Equality(this.m_spriteAnimator, null)) {
                        this.m_spriteAnimator = this.GetComponent(TMPro.TMP_SpriteAnimator);
                        if (UnityEngine.MonoBehaviour.op_Equality(this.m_spriteAnimator, null)) {
                            this.m_spriteAnimator = this.gameObject.AddComponent(TMPro.TMP_SpriteAnimator);
                        }
                    }

                    return this.m_spriteAnimator;
                }
            },
            /**
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_Text
             * @function flexibleHeight
             * @type number
             */
            flexibleHeight: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#flexibleHeight#get", this ); }

                    return this.m_flexibleHeight;
                }
            },
            /**
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_Text
             * @function flexibleWidth
             * @type number
             */
            flexibleWidth: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#flexibleWidth#get", this ); }

                    return this.m_flexibleWidth;
                }
            },
            /**
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_Text
             * @function minWidth
             * @type number
             */
            minWidth: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#minWidth#get", this ); }

                    return this.m_minWidth;
                }
            },
            /**
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_Text
             * @function minHeight
             * @type number
             */
            minHeight: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#minHeight#get", this ); }

                    return this.m_minHeight;
                }
            },
            /**
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_Text
             * @function maxWidth
             * @type number
             */
            maxWidth: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#maxWidth#get", this ); }

                    return this.m_maxWidth;
                }
            },
            /**
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_Text
             * @function maxHeight
             * @type number
             */
            maxHeight: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#maxHeight#get", this ); }

                    return this.m_maxHeight;
                }
            },
            /**
             * @instance
             * @protected
             * @readonly
             * @memberof TMPro.TMP_Text
             * @function layoutElement
             * @type UnityEngine.UI.LayoutElement
             */
            layoutElement: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#layoutElement#get", this ); }

                    if (UnityEngine.MonoBehaviour.op_Equality(this.m_LayoutElement, null)) {
                        this.m_LayoutElement = this.GetComponent(UnityEngine.UI.LayoutElement);
                    }

                    return this.m_LayoutElement;
                }
            },
            /**
             * Computed preferred width of the text object.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_Text
             * @function preferredWidth
             * @type number
             */
            preferredWidth: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#preferredWidth#get", this ); }

                    this.m_preferredWidth = this.GetPreferredWidth();
                    return this.m_preferredWidth;
                }
            },
            /**
             * Computed preferred height of the text object.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_Text
             * @function preferredHeight
             * @type number
             */
            preferredHeight: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#preferredHeight#get", this ); }

                    this.m_preferredHeight = this.GetPreferredHeight();
                    return this.m_preferredHeight;
                }
            },
            /**
             * Compute the rendered width of the text object.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_Text
             * @function renderedWidth
             * @type number
             */
            renderedWidth: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#renderedWidth#get", this ); }

                    return this.GetRenderedWidth$1();
                }
            },
            /**
             * Compute the rendered height of the text object.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_Text
             * @function renderedHeight
             * @type number
             */
            renderedHeight: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#renderedHeight#get", this ); }

                    return this.GetRenderedHeight$1();
                }
            },
            /**
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_Text
             * @function layoutPriority
             * @type number
             */
            layoutPriority: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#layoutPriority#get", this ); }

                    return this.m_layoutPriority;
                }
            }
        },
        alias: [
            "transform$1", "UnityEngine$UI$ICanvasElement$transform",
            "rectTransform$1", "UnityEngine$UI$IClippable$rectTransform"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#init", this ); }

                this.m_fontColor32 = new UnityEngine.Color32();
                this.m_fontColor = new UnityEngine.Color();
                this.m_underlineColor = new UnityEngine.Color32();
                this.m_strikethroughColor = new UnityEngine.Color32();
                this.m_fontColorGradient = new TMPro.VertexGradient();
                this.m_spriteColor = new UnityEngine.Color32();
                this.m_faceColor = new UnityEngine.Color32();
                this.m_outlineColor = new UnityEngine.Color32();
                this.m_sizeStack = new (TMPro.TMP_TextProcessingStack$1(System.Single))();
                this.m_FontWeightStack = new (TMPro.TMP_TextProcessingStack$1(TMPro.FontWeight))();
                this.m_fontStyleStack = new TMPro.TMP_FontStyleStack();
                this.m_lineJustificationStack = new (TMPro.TMP_TextProcessingStack$1(TMPro.HorizontalAlignmentOptions))();
                this.m_margin = new UnityEngine.Vector4();
                this.m_PreviousRectTransformSize = new UnityEngine.Vector2();
                this.m_PreviousPivotPosition = new UnityEngine.Vector2();
                this.m_indentStack = new (TMPro.TMP_TextProcessingStack$1(System.Single))();
                this.m_FXMatrix = new UnityEngine.Matrix4x4();
                this.m_meshExtents = new TMPro.Extents();
                this.m_htmlColor = new UnityEngine.Color32();
                this.m_colorStack = new (TMPro.TMP_TextProcessingStack$1(UnityEngine.Color32))();
                this.m_underlineColorStack = new (TMPro.TMP_TextProcessingStack$1(UnityEngine.Color32))();
                this.m_strikethroughColorStack = new (TMPro.TMP_TextProcessingStack$1(UnityEngine.Color32))();
                this.m_HighlightStateStack = new (TMPro.TMP_TextProcessingStack$1(TMPro.HighlightState))();
                this.m_colorGradientStack = new (TMPro.TMP_TextProcessingStack$1(TMPro.TMP_ColorGradient))();
                this.m_ItalicAngleStack = new (TMPro.TMP_TextProcessingStack$1(System.Int32))();
                this.m_actionStack = new (TMPro.TMP_TextProcessingStack$1(System.Int32))();
                this.m_baselineOffsetStack = new (TMPro.TMP_TextProcessingStack$1(System.Single))();
                this.m_Ellipsis = new TMPro.TMP_Text.SpecialCharacter();
                this.m_Underline = new TMPro.TMP_Text.SpecialCharacter();
                this.m_TextBackingArray = new TMPro.TMP_Text.TextBackingContainer();
                this.m_isRightToLeft = false;
                this.m_fontColor32 = UnityEngine.Color32.op_Implicit$1(new pc.Color( 1, 1, 1, 1 ));
                this.m_fontColor = new pc.Color( 1, 1, 1, 1 );
                this.m_underlineColor = TMPro.TMP_Text.s_colorWhite.$clone();
                this.m_strikethroughColor = TMPro.TMP_Text.s_colorWhite.$clone();
                this.m_colorMode = TMPro.ColorMode.FourCornersGradient;
                this.m_fontColorGradient = new TMPro.VertexGradient.$ctor1(new pc.Color( 1, 1, 1, 1 ));
                this.m_overrideHtmlColors = false;
                this.m_faceColor = UnityEngine.Color32.op_Implicit$1(new pc.Color( 1, 1, 1, 1 ));
                this.m_outlineColor = UnityEngine.Color32.op_Implicit$1(new pc.Color( 0, 0, 0, 1 ));
                this.m_outlineWidth = 0.0;
                this.m_fontSize = -99;
                this.m_fontSizeBase = 36;
                this.m_sizeStack = new (TMPro.TMP_TextProcessingStack$1(System.Single)).$ctor2(16);
                this.m_fontWeight = TMPro.FontWeight.Regular;
                this.m_FontWeightInternal = TMPro.FontWeight.Regular;
                this.m_FontWeightStack = new (TMPro.TMP_TextProcessingStack$1(TMPro.FontWeight)).$ctor2(8);
                this.m_AutoSizeMaxIterationCount = 100;
                this.m_fontSizeMin = 0;
                this.m_fontSizeMax = 0;
                this.m_fontStyle = TMPro.FontStyles.Normal;
                this.m_FontStyleInternal = TMPro.FontStyles.Normal;
                this.m_isUsingBold = false;
                this.m_HorizontalAlignment = TMPro.HorizontalAlignmentOptions.Left;
                this.m_VerticalAlignment = TMPro.VerticalAlignmentOptions.Top;
                this.m_textAlignment = TMPro.TextAlignmentOptions.Converted;
                this.m_lineJustificationStack = new (TMPro.TMP_TextProcessingStack$1(TMPro.HorizontalAlignmentOptions)).$ctor1(System.Array.init(16, 0, TMPro.HorizontalAlignmentOptions));
                this.m_textContainerLocalCorners = System.Array.init(4, function (){
                    return new UnityEngine.Vector3();
                }, UnityEngine.Vector3);
                this.m_characterSpacing = 0;
                this.m_cSpacing = 0;
                this.m_monoSpacing = 0;
                this.m_wordSpacing = 0;
                this.m_lineSpacing = 0;
                this.m_lineSpacingDelta = 0;
                this.m_lineHeight = -32767.0;
                this.m_lineSpacingMax = 0;
                this.m_paragraphSpacing = 0;
                this.m_charWidthMaxAdj = 0.0;
                this.m_charWidthAdjDelta = 0;
                this.m_enableWordWrapping = false;
                this.m_isCharacterWrappingEnabled = false;
                this.m_isNonBreakingSpace = false;
                this.m_wordWrappingRatios = 0.4;
                this.m_overflowMode = TMPro.TextOverflowModes.Overflow;
                this.m_firstOverflowCharacterIndex = -1;
                this.m_enableExtraPadding = false;
                this.m_isRichText = true;
                this.m_parseCtrlCharacters = true;
                this.m_isOverlay = false;
                this.m_isOrthographic = false;
                this.m_isCullingEnabled = false;
                this.m_ignoreCulling = true;
                this.m_horizontalMapping = TMPro.TextureMappingOptions.Character;
                this.m_verticalMapping = TMPro.TextureMappingOptions.Character;
                this.m_uvLineOffset = 0.0;
                this.m_renderMode = TMPro.TextRenderFlags.Render;
                this.m_VertexBufferAutoSizeReduction = false;
                this.m_maxVisibleCharacters = 99999;
                this.m_maxVisibleWords = 99999;
                this.m_maxVisibleLines = 99999;
                this.m_useMaxVisibleDescender = true;
                this.m_pageToDisplay = 1;
                this.m_isNewPage = false;
                this.m_margin = new pc.Vec4( 0, 0, 0, 0 );
                this.m_width = -1;
                this.m_flexibleHeight = -1.0;
                this.m_flexibleWidth = -1.0;
                this.m_layoutPriority = 0;
                this.tag_LineIndent = 0;
                this.tag_Indent = 0;
                this.m_indentStack = new (TMPro.TMP_TextProcessingStack$1(System.Single)).$ctor1(System.Array.init(16, 0, System.Single));
                this.m_TextProcessingArray = System.Array.init(8, function (){
                    return new TMPro.TMP_Text.UnicodeChar();
                }, TMPro.TMP_Text.UnicodeChar);
                this.m_htmlColor = UnityEngine.Color32.op_Implicit$1(new pc.Color( 255, 255, 255, 128 ));
                this.m_colorStack = new (TMPro.TMP_TextProcessingStack$1(UnityEngine.Color32)).$ctor1(System.Array.init(16, function (){
                    return new UnityEngine.Color32();
                }, UnityEngine.Color32));
                this.m_underlineColorStack = new (TMPro.TMP_TextProcessingStack$1(UnityEngine.Color32)).$ctor1(System.Array.init(16, function (){
                    return new UnityEngine.Color32();
                }, UnityEngine.Color32));
                this.m_strikethroughColorStack = new (TMPro.TMP_TextProcessingStack$1(UnityEngine.Color32)).$ctor1(System.Array.init(16, function (){
                    return new UnityEngine.Color32();
                }, UnityEngine.Color32));
                this.m_HighlightStateStack = new (TMPro.TMP_TextProcessingStack$1(TMPro.HighlightState)).$ctor1(System.Array.init(16, function (){
                    return new TMPro.HighlightState();
                }, TMPro.HighlightState));
                this.m_colorGradientStack = new (TMPro.TMP_TextProcessingStack$1(TMPro.TMP_ColorGradient)).$ctor1(System.Array.init(16, null, TMPro.TMP_ColorGradient));
                this.m_tabSpacing = 0;
                this.m_spacing = 0;
                this.m_TextStyleStacks = System.Array.init(8, function (){
                    return new (TMPro.TMP_TextProcessingStack$1(System.Int32))();
                }, TMPro.TMP_TextProcessingStack$1(System.Int32));
                this.m_TextStyleStackDepth = 0;
                this.m_ItalicAngleStack = new (TMPro.TMP_TextProcessingStack$1(System.Int32)).$ctor1(System.Array.init(16, 0, System.Int32));
                this.m_actionStack = new (TMPro.TMP_TextProcessingStack$1(System.Int32)).$ctor1(System.Array.init(16, 0, System.Int32));
                this.m_padding = 0;
                this.m_baselineOffsetStack = new (TMPro.TMP_TextProcessingStack$1(System.Single)).$ctor1(System.Array.init(16, 0, System.Single));
                this.m_spriteCount = 0;
                this.m_TextBackingArray = new TMPro.TMP_Text.TextBackingContainer.$ctor1(4);
                this.k_Power = System.Array.init([
                    System.Decimal(0.5, 1), 
                    System.Decimal(0.05, 2), 
                    System.Decimal(0.005, 3), 
                    System.Decimal(0.0005, 4), 
                    System.Decimal(0.00005, 5), 
                    System.Decimal(0.000005, 6), 
                    System.Decimal(0.0000005, 7), 
                    System.Decimal(0.00000005, 8), 
                    System.Decimal(0.000000005, 9), 
                    System.Decimal(0.0000000005, 10)
                ], System.Decimal);
                Bridge.event(this, "OnPreRenderText", function () { });
            }
        },
        methods: {
            /*TMPro.TMP_Text.LoadFontAsset start.*/
            /**
             * Method which derived classes need to override to load Font Assets.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @return  {void}
             */
            LoadFontAsset: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#LoadFontAsset", this ); }
 },
            /*TMPro.TMP_Text.LoadFontAsset end.*/

            /*TMPro.TMP_Text.SetSharedMaterial start.*/
            /**
             * Function called internally when a new shared material is assigned via the fontSharedMaterial property.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {UnityEngine.Material}    mat
             * @return  {void}
             */
            SetSharedMaterial: function (mat) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#SetSharedMaterial", this ); }
 },
            /*TMPro.TMP_Text.SetSharedMaterial end.*/

            /*TMPro.TMP_Text.GetMaterial start.*/
            /**
             * Function called internally when a new material is assigned via the fontMaterial property.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {UnityEngine.Material}    mat
             * @return  {UnityEngine.Material}
             */
            GetMaterial: function (mat) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetMaterial", this ); }

                return null;
            },
            /*TMPro.TMP_Text.GetMaterial end.*/

            /*TMPro.TMP_Text.SetFontBaseMaterial start.*/
            /**
             * Function called internally when assigning a new base material.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {UnityEngine.Material}    mat
             * @return  {void}
             */
            SetFontBaseMaterial: function (mat) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#SetFontBaseMaterial", this ); }
 },
            /*TMPro.TMP_Text.SetFontBaseMaterial end.*/

            /*TMPro.TMP_Text.GetSharedMaterials start.*/
            /**
             * Method which returns an array containing the materials used by the text object.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @return  {Array.<UnityEngine.Material>}
             */
            GetSharedMaterials: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetSharedMaterials", this ); }

                return null;
            },
            /*TMPro.TMP_Text.GetSharedMaterials end.*/

            /*TMPro.TMP_Text.SetSharedMaterials start.*/
            /**
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {Array.<UnityEngine.Material>}    materials
             * @return  {void}
             */
            SetSharedMaterials: function (materials) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#SetSharedMaterials", this ); }
 },
            /*TMPro.TMP_Text.SetSharedMaterials end.*/

            /*TMPro.TMP_Text.GetMaterials start.*/
            /**
             * Method returning instances of the materials used by the text object.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {Array.<UnityEngine.Material>}    mats
             * @return  {Array.<UnityEngine.Material>}
             */
            GetMaterials: function (mats) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetMaterials", this ); }

                return null;
            },
            /*TMPro.TMP_Text.GetMaterials end.*/

            /*TMPro.TMP_Text.CreateMaterialInstance start.*/
            /**
             * Method to set the materials of the text and sub text objects.
             * Function used to create an instance of the material
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {UnityEngine.Material}    source
             * @return  {UnityEngine.Material}
             */
            CreateMaterialInstance: function (source) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#CreateMaterialInstance", this ); }

                var mat = new UnityEngine.Material.$ctor1(source);
                mat.shaderKeywords = source.shaderKeywords;
                mat.name = (mat.name || "") + " (Instance)";

                return mat;
            },
            /*TMPro.TMP_Text.CreateMaterialInstance end.*/

            /*TMPro.TMP_Text.SetVertexColorGradient start.*/
            SetVertexColorGradient: function (gradient) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#SetVertexColorGradient", this ); }

                if (gradient == null) {
                    return;
                }

                this.m_fontColorGradient.bottomLeft = gradient.bottomLeft.$clone();
                this.m_fontColorGradient.bottomRight = gradient.bottomRight.$clone();
                this.m_fontColorGradient.topLeft = gradient.topLeft.$clone();
                this.m_fontColorGradient.topRight = gradient.topRight.$clone();

                this.SetVerticesDirty();
            },
            /*TMPro.TMP_Text.SetVertexColorGradient end.*/

            /*TMPro.TMP_Text.SetTextSortingOrder$1 start.*/
            /**
             * Function to control the sorting of the geometry of the text object.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {TMPro.VertexSortingOrder}    order
             * @return  {void}
             */
            SetTextSortingOrder$1: function (order) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#SetTextSortingOrder$1", this ); }
 },
            /*TMPro.TMP_Text.SetTextSortingOrder$1 end.*/

            /*TMPro.TMP_Text.SetTextSortingOrder start.*/
            /**
             * Function to sort the geometry of the text object in accordance to the provided order.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {Array.<number>}    order
             * @return  {void}
             */
            SetTextSortingOrder: function (order) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#SetTextSortingOrder", this ); }
 },
            /*TMPro.TMP_Text.SetTextSortingOrder end.*/

            /*TMPro.TMP_Text.SetFaceColor start.*/
            /**
             * Function called internally to set the face color of the material. This will results in an instance of the material.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {UnityEngine.Color32}    color
             * @return  {void}
             */
            SetFaceColor: function (color) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#SetFaceColor", this ); }
 },
            /*TMPro.TMP_Text.SetFaceColor end.*/

            /*TMPro.TMP_Text.SetOutlineColor start.*/
            /**
             * Function called internally to set the outline color of the material. This will results in an instance of the material.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {UnityEngine.Color32}    color
             * @return  {void}
             */
            SetOutlineColor: function (color) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#SetOutlineColor", this ); }
 },
            /*TMPro.TMP_Text.SetOutlineColor end.*/

            /*TMPro.TMP_Text.SetOutlineThickness start.*/
            /**
             * Function called internally to set the outline thickness property of the material. This will results in an instance of the material.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {number}    thickness
             * @return  {void}
             */
            SetOutlineThickness: function (thickness) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#SetOutlineThickness", this ); }
 },
            /*TMPro.TMP_Text.SetOutlineThickness end.*/

            /*TMPro.TMP_Text.SetShaderDepth start.*/
            /**
             * Set the Render Queue and ZTest mode on the current material
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @return  {void}
             */
            SetShaderDepth: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#SetShaderDepth", this ); }
 },
            /*TMPro.TMP_Text.SetShaderDepth end.*/

            /*TMPro.TMP_Text.SetCulling start.*/
            /**
             * Set the culling mode on the material.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @return  {void}
             */
            SetCulling: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#SetCulling", this ); }
 },
            /*TMPro.TMP_Text.SetCulling end.*/

            /*TMPro.TMP_Text.UpdateCulling start.*/
            /**
             * @instance
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @return  {void}
             */
            UpdateCulling: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#UpdateCulling", this ); }
 },
            /*TMPro.TMP_Text.UpdateCulling end.*/

            /*TMPro.TMP_Text.GetPaddingForMaterial start.*/
            /**
             * Get the padding value for the currently assigned material
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @return  {number}
             */
            GetPaddingForMaterial: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetPaddingForMaterial", this ); }

                TMPro.ShaderUtilities.GetShaderPropertyIDs();

                if (this.m_sharedMaterial == null) {
                    return 0;
                }

                this.m_padding = TMPro.ShaderUtilities.GetPadding(this.m_sharedMaterial, this.m_enableExtraPadding, this.m_isUsingBold);
                this.m_isMaskingEnabled = TMPro.ShaderUtilities.IsMaskingEnabled(this.m_sharedMaterial);
                this.m_isSDFShader = this.m_sharedMaterial.HasProperty(TMPro.ShaderUtilities.ID_WeightNormal);

                return this.m_padding;
            },
            /*TMPro.TMP_Text.GetPaddingForMaterial end.*/

            /*TMPro.TMP_Text.GetPaddingForMaterial$1 start.*/
            /**
             * Get the padding value for the given material
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {UnityEngine.Material}    mat
             * @return  {number}
             */
            GetPaddingForMaterial$1: function (mat) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetPaddingForMaterial$1", this ); }

                if (mat == null) {
                    return 0;
                }

                this.m_padding = TMPro.ShaderUtilities.GetPadding(mat, this.m_enableExtraPadding, this.m_isUsingBold);
                this.m_isMaskingEnabled = TMPro.ShaderUtilities.IsMaskingEnabled(this.m_sharedMaterial);
                this.m_isSDFShader = mat.HasProperty(TMPro.ShaderUtilities.ID_WeightNormal);

                return this.m_padding;
            },
            /*TMPro.TMP_Text.GetPaddingForMaterial$1 end.*/

            /*TMPro.TMP_Text.GetTextContainerLocalCorners start.*/
            /**
             * Method to return the local corners of the Text Container or RectTransform.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @return  {Array.<UnityEngine.Vector3>}
             */
            GetTextContainerLocalCorners: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetTextContainerLocalCorners", this ); }

                return null;
            },
            /*TMPro.TMP_Text.GetTextContainerLocalCorners end.*/

            /*TMPro.TMP_Text.ForceMeshUpdate start.*/
            /**
             * Function to force regeneration of the text object before its normal process time. This is useful when changes to the text object properties need to be applied immediately.
             *
             * @instance
             * @public
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {boolean}    ignoreActiveState     Ignore Active State of text objects. Inactive objects are ignored by default.
             * @param   {boolean}    forceTextReparsing    Force re-parsing of the text.
             * @return  {void}
             */
            ForceMeshUpdate: function (ignoreActiveState, forceTextReparsing) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#ForceMeshUpdate", this ); }

                if (ignoreActiveState === void 0) { ignoreActiveState = false; }
                if (forceTextReparsing === void 0) { forceTextReparsing = false; }
            },
            /*TMPro.TMP_Text.ForceMeshUpdate end.*/

            /*TMPro.TMP_Text.UpdateGeometry$1 start.*/
            /**
             * Function to update the geometry of the main and sub text objects.
             *
             * @instance
             * @public
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {UnityEngine.Mesh}    mesh     
             * @param   {number}              index
             * @return  {void}
             */
            UpdateGeometry$1: function (mesh, index) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#UpdateGeometry$1", this ); }
 },
            /*TMPro.TMP_Text.UpdateGeometry$1 end.*/

            /*TMPro.TMP_Text.UpdateVertexData$1 start.*/
            /**
             * Function to push the updated vertex data into the mesh and renderer.
             *
             * @instance
             * @public
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {TMPro.TMP_VertexDataUpdateFlags}    flags
             * @return  {void}
             */
            UpdateVertexData$1: function (flags) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#UpdateVertexData$1", this ); }
 },
            /*TMPro.TMP_Text.UpdateVertexData$1 end.*/

            /*TMPro.TMP_Text.UpdateVertexData start.*/
            /**
             * Function to push the updated vertex data into the mesh and renderer.
             *
             * @instance
             * @public
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @return  {void}
             */
            UpdateVertexData: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#UpdateVertexData", this ); }
 },
            /*TMPro.TMP_Text.UpdateVertexData end.*/

            /*TMPro.TMP_Text.SetVertices start.*/
            /**
             * Function to push a new set of vertices to the mesh.
             *
             * @instance
             * @public
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {Array.<UnityEngine.Vector3>}    vertices
             * @return  {void}
             */
            SetVertices: function (vertices) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#SetVertices", this ); }
 },
            /*TMPro.TMP_Text.SetVertices end.*/

            /*TMPro.TMP_Text.UpdateMeshPadding start.*/
            /**
             * Function to be used to force recomputing of character padding when Shader / Material properties have been changed via script.
             *
             * @instance
             * @public
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @return  {void}
             */
            UpdateMeshPadding: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#UpdateMeshPadding", this ); }
 },
            /*TMPro.TMP_Text.UpdateMeshPadding end.*/

            /*TMPro.TMP_Text.CrossFadeColor start.*/
            /**
             * 
             * Tweens the CanvasRenderer color associated with this Graphic.
             *
             * @instance
             * @public
             * @override
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {UnityEngine.Color}    targetColor        Target color.
             * @param   {number}               duration           Tween duration.
             * @param   {boolean}              ignoreTimeScale    Should ignore Time.scale?
             * @param   {boolean}              useAlpha           Should also Tween the alpha channel?
             * @return  {void}
             */
            CrossFadeColor: function (targetColor, duration, ignoreTimeScale, useAlpha) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#CrossFadeColor", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.CrossFadeColor.call(this, targetColor.$clone(), duration, ignoreTimeScale, useAlpha);
                this.InternalCrossFadeColor(targetColor.$clone(), duration, ignoreTimeScale, useAlpha);
            },
            /*TMPro.TMP_Text.CrossFadeColor end.*/

            /*TMPro.TMP_Text.CrossFadeAlpha start.*/
            /**
             * Tweens the alpha of the CanvasRenderer color associated with this Graphic.
             *
             * @instance
             * @public
             * @override
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {number}     alpha              Target alpha.
             * @param   {number}     duration           Duration of the tween in seconds.
             * @param   {boolean}    ignoreTimeScale    Should ignore Time.scale?
             * @return  {void}
             */
            CrossFadeAlpha: function (alpha, duration, ignoreTimeScale) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#CrossFadeAlpha", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.CrossFadeAlpha.call(this, alpha, duration, ignoreTimeScale);
                this.InternalCrossFadeAlpha(alpha, duration, ignoreTimeScale);
            },
            /*TMPro.TMP_Text.CrossFadeAlpha end.*/

            /*TMPro.TMP_Text.InternalCrossFadeColor start.*/
            /**
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {UnityEngine.Color}    targetColor        
             * @param   {number}               duration           
             * @param   {boolean}              ignoreTimeScale    
             * @param   {boolean}              useAlpha
             * @return  {void}
             */
            InternalCrossFadeColor: function (targetColor, duration, ignoreTimeScale, useAlpha) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#InternalCrossFadeColor", this ); }
 },
            /*TMPro.TMP_Text.InternalCrossFadeColor end.*/

            /*TMPro.TMP_Text.InternalCrossFadeAlpha start.*/
            /**
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {number}     alpha              
             * @param   {number}     duration           
             * @param   {boolean}    ignoreTimeScale
             * @return  {void}
             */
            InternalCrossFadeAlpha: function (alpha, duration, ignoreTimeScale) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#InternalCrossFadeAlpha", this ); }
 },
            /*TMPro.TMP_Text.InternalCrossFadeAlpha end.*/

            /*TMPro.TMP_Text.ParseInputText start.*/
            /**
             * Method to parse the input text based on its source
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @return  {void}
             */
            ParseInputText: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#ParseInputText", this ); }

                switch (this.m_inputSource) {
                    case TMPro.TMP_Text.TextInputSources.TextString: 
                    case TMPro.TMP_Text.TextInputSources.TextInputBox: 
                        this.PopulateTextBackingArray$1(this.m_TextPreprocessor == null ? this.m_text : this.m_TextPreprocessor.TMPro$ITextPreprocessor$PreprocessText(this.m_text));
                        this.PopulateTextProcessingArray();
                        break;
                    case TMPro.TMP_Text.TextInputSources.SetText: 
                        break;
                    case TMPro.TMP_Text.TextInputSources.SetTextArray: 
                        break;
                }

                this.SetArraySizes(this.m_TextProcessingArray);
            },
            /*TMPro.TMP_Text.ParseInputText end.*/

            /*TMPro.TMP_Text.PopulateTextBackingArray$1 start.*/
            /**
             * Convert source text to Unicode (uint) and populate internal text backing array.
             *
             * @instance
             * @private
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {string}    sourceText    Source text to be converted
             * @return  {void}
             */
            PopulateTextBackingArray$1: function (sourceText) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#PopulateTextBackingArray$1", this ); }

                var srcLength = sourceText == null ? 0 : sourceText.length;

                this.PopulateTextBackingArray$2(sourceText, 0, srcLength);
            },
            /*TMPro.TMP_Text.PopulateTextBackingArray$1 end.*/

            /*TMPro.TMP_Text.PopulateTextBackingArray$2 start.*/
            /**
             * Convert source text to uint and populate internal text backing array.
             *
             * @instance
             * @private
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {string}    sourceText    string containing the source text to be converted
             * @param   {number}    start         Index of the first element of the source array to be converted and copied to the internal text backing array.
             * @param   {number}    length        Number of elements in the array to be converted and copied to the internal text backing array.
             * @return  {void}
             */
            PopulateTextBackingArray$2: function (sourceText, start, length) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#PopulateTextBackingArray$2", this ); }

                var readIndex;
                var writeIndex = 0;

                // Range check
                if (sourceText == null) {
                    readIndex = 0;
                    length = 0;
                } else {
                    readIndex = Math.max(0, Math.min(start, sourceText.length));
                    length = Math.max(0, Math.min(length, start + length < sourceText.length ? length : sourceText.length - start));
                }

                // Make sure array size is appropriate
                if (length >= this.m_TextBackingArray.Capacity) {
                    this.m_TextBackingArray.Resize(length);
                }

                var end = readIndex + length;
                for (; readIndex < end; readIndex++) {
                    this.m_TextBackingArray.setItem(writeIndex, sourceText.charCodeAt(readIndex));
                    writeIndex += 1;
                }

                // Terminate array with zero as we are not clearing the array on new invocation of this function.
                this.m_TextBackingArray.setItem(writeIndex, 0);
                this.m_TextBackingArray.Count = writeIndex;
            },
            /*TMPro.TMP_Text.PopulateTextBackingArray$2 end.*/

            /*TMPro.TMP_Text.PopulateTextBackingArray$3 start.*/
            /**
             * Convert source text to uint and populate internal text backing array.
             *
             * @instance
             * @private
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {System.Text.StringBuilder}    sourceText    char array containing the source text to be converted
             * @param   {number}                       start         Index of the first element of the source array to be converted and copied to the internal text backing array.
             * @param   {number}                       length        Number of elements in the array to be converted and copied to the internal text backing array.
             * @return  {void}
             */
            PopulateTextBackingArray$3: function (sourceText, start, length) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#PopulateTextBackingArray$3", this ); }

                var readIndex;
                var writeIndex = 0;

                // Range check
                if (sourceText == null) {
                    readIndex = 0;
                    length = 0;
                } else {
                    readIndex = Math.max(0, Math.min(start, sourceText.getLength()));
                    length = Math.max(0, Math.min(length, start + length < sourceText.getLength() ? length : sourceText.getLength() - start));
                }

                // Make sure array size is appropriate
                if (length >= this.m_TextBackingArray.Capacity) {
                    this.m_TextBackingArray.Resize(length);
                }

                var end = readIndex + length;
                for (; readIndex < end; readIndex++) {
                    this.m_TextBackingArray.setItem(writeIndex, sourceText.getChar(readIndex));
                    writeIndex += 1;
                }

                // Terminate array with zero as we are not clearing the array on new invocation of this function.
                this.m_TextBackingArray.setItem(writeIndex, 0);
                this.m_TextBackingArray.Count = writeIndex;
            },
            /*TMPro.TMP_Text.PopulateTextBackingArray$3 end.*/

            /*TMPro.TMP_Text.PopulateTextBackingArray start.*/
            /**
             * Convert source text to Unicode (uint) and populate internal text backing array.
             *
             * @instance
             * @private
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {Array.<number>}    sourceText    char array containing the source text to be converted
             * @param   {number}            start         Index of the first element of the source array to be converted and copied to the internal text backing array.
             * @param   {number}            length        Number of elements in the array to be converted and copied to the internal text backing array.
             * @return  {void}
             */
            PopulateTextBackingArray: function (sourceText, start, length) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#PopulateTextBackingArray", this ); }

                var readIndex;
                var writeIndex = 0;

                // Range check
                if (sourceText == null) {
                    readIndex = 0;
                    length = 0;
                } else {
                    readIndex = Math.max(0, Math.min(start, sourceText.length));
                    length = Math.max(0, Math.min(length, start + length < sourceText.length ? length : sourceText.length - start));
                }

                // Make sure array size is appropriate
                if (length >= this.m_TextBackingArray.Capacity) {
                    this.m_TextBackingArray.Resize(length);
                }

                var end = readIndex + length;
                for (; readIndex < end; readIndex++) {
                    this.m_TextBackingArray.setItem(writeIndex, sourceText[readIndex]);
                    writeIndex += 1;
                }

                // Terminate array with zero as we are not clearing the array on new invocation of this function.
                this.m_TextBackingArray.setItem(writeIndex, 0);
                this.m_TextBackingArray.Count = writeIndex;
            },
            /*TMPro.TMP_Text.PopulateTextBackingArray end.*/

            /*TMPro.TMP_Text.PopulateTextProcessingArray start.*/
            /**
             * @instance
             * @private
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @return  {void}
             */
            PopulateTextProcessingArray: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#PopulateTextProcessingArray", this ); }

                var srcLength = this.m_TextBackingArray.Count;

                // Make sure parsing buffer is large enough to handle the required text.
                if (this.m_TextProcessingArray.length < srcLength) {
                    this.ResizeInternalArray$1(TMPro.TMP_Text.UnicodeChar, Bridge.ref(this, "m_TextProcessingArray"), srcLength);
                }

                // Reset Style stack back to default
                TMPro.TMP_TextProcessingStack$1(System.Int32).SetDefault(this.m_TextStyleStacks, 0);

                this.m_TextStyleStackDepth = 0;
                var writeIndex = { v : 0 };

                // Insert Opening Style
                if (this.textStyle.hashCode !== TMPro.MarkupTag.NORMAL) {
                    this.InsertOpeningStyleTag(this.m_TextStyle, 0, Bridge.ref(this, "m_TextProcessingArray"), writeIndex);
                }

                var readIndex = 0;
                for (; readIndex < srcLength; readIndex++) {
                    var c = this.m_TextBackingArray.getItem(readIndex);

                    if (c === 0) {
                        break;
                    }

                    if (this.m_inputSource === TMPro.TMP_Text.TextInputSources.TextInputBox && c === 92 && readIndex < srcLength - 1) {
                        switch (this.m_TextBackingArray.getItem(readIndex + 1)) {
                            case 92:  // \ escape
                                if (!this.m_parseCtrlCharacters) {
                                    break;
                                }
                                if (srcLength <= readIndex + 2) {
                                    break;
                                }
                                if (writeIndex.v + 2 > this.m_TextProcessingArray.length) {
                                    this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, Bridge.ref(this, "m_TextProcessingArray"));
                                }
                                this.m_TextProcessingArray[writeIndex.v].unicode = Math.floor(this.m_TextBackingArray.getItem(readIndex + 1));
                                this.m_TextProcessingArray[writeIndex.v].stringIndex = readIndex;
                                this.m_TextProcessingArray[writeIndex.v].length = 1;
                                this.m_TextProcessingArray[writeIndex.v + 1].unicode = Math.floor(this.m_TextBackingArray.getItem(readIndex + 2));
                                this.m_TextProcessingArray[writeIndex.v + 1].stringIndex = readIndex;
                                this.m_TextProcessingArray[writeIndex.v + 1].length = 1;
                                readIndex += 2;
                                writeIndex.v += 2;
                                continue;
                            case 110:  // \n LineFeed
                                if (!this.m_parseCtrlCharacters) {
                                    break;
                                }
                                if (writeIndex.v === this.m_TextProcessingArray.length) {
                                    this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, Bridge.ref(this, "m_TextProcessingArray"));
                                }
                                this.m_TextProcessingArray[writeIndex.v].unicode = 10;
                                this.m_TextProcessingArray[writeIndex.v].stringIndex = readIndex;
                                this.m_TextProcessingArray[writeIndex.v].length = 1;
                                readIndex += 1;
                                writeIndex.v += 1;
                                continue;
                            case 114:  // \r Carriage Return
                                if (!this.m_parseCtrlCharacters) {
                                    break;
                                }
                                if (writeIndex.v === this.m_TextProcessingArray.length) {
                                    this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, Bridge.ref(this, "m_TextProcessingArray"));
                                }
                                this.m_TextProcessingArray[writeIndex.v].unicode = 13;
                                this.m_TextProcessingArray[writeIndex.v].stringIndex = readIndex;
                                this.m_TextProcessingArray[writeIndex.v].length = 1;
                                readIndex += 1;
                                writeIndex.v += 1;
                                continue;
                            case 116:  // \t Tab
                                if (!this.m_parseCtrlCharacters) {
                                    break;
                                }
                                if (writeIndex.v === this.m_TextProcessingArray.length) {
                                    this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, Bridge.ref(this, "m_TextProcessingArray"));
                                }
                                this.m_TextProcessingArray[writeIndex.v].unicode = 9;
                                this.m_TextProcessingArray[writeIndex.v].stringIndex = readIndex;
                                this.m_TextProcessingArray[writeIndex.v].length = 1;
                                readIndex += 1;
                                writeIndex.v += 1;
                                continue;
                            case 118:  // \v Vertical tab used as soft line break
                                if (!this.m_parseCtrlCharacters) {
                                    break;
                                }
                                if (writeIndex.v === this.m_TextProcessingArray.length) {
                                    this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, Bridge.ref(this, "m_TextProcessingArray"));
                                }
                                this.m_TextProcessingArray[writeIndex.v].unicode = 11;
                                this.m_TextProcessingArray[writeIndex.v].stringIndex = readIndex;
                                this.m_TextProcessingArray[writeIndex.v].length = 1;
                                readIndex += 1;
                                writeIndex.v += 1;
                                continue;
                            case 117:  // \u0000 for UTF-16 Unicode
                                if (srcLength > readIndex + 5) {
                                    if (writeIndex.v === this.m_TextProcessingArray.length) {
                                        this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, Bridge.ref(this, "m_TextProcessingArray"));
                                    }

                                    this.m_TextProcessingArray[writeIndex.v].unicode = this.GetUTF16$4(this.m_TextBackingArray.$clone(), readIndex + 2);
                                    this.m_TextProcessingArray[writeIndex.v].stringIndex = readIndex;
                                    this.m_TextProcessingArray[writeIndex.v].length = 6;

                                    readIndex += 5;
                                    writeIndex.v += 1;
                                    continue;
                                }
                                break;
                            case 85:  // \U00000000 for UTF-32 Unicode
                                if (srcLength > readIndex + 9) {
                                    if (writeIndex.v === this.m_TextProcessingArray.length) {
                                        this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, Bridge.ref(this, "m_TextProcessingArray"));
                                    }

                                    this.m_TextProcessingArray[writeIndex.v].unicode = this.GetUTF32$4(this.m_TextBackingArray.$clone(), readIndex + 2);
                                    this.m_TextProcessingArray[writeIndex.v].stringIndex = readIndex;
                                    this.m_TextProcessingArray[writeIndex.v].length = 10;

                                    readIndex += 9;
                                    writeIndex.v += 1;
                                    continue;
                                }
                                break;
                        }
                    }

                    // Handle surrogate pair conversion in string, StringBuilder and char[] source.
                    if (c >= TMPro.CodePoint.HIGH_SURROGATE_START && c <= TMPro.CodePoint.HIGH_SURROGATE_END && srcLength > readIndex + 1 && this.m_TextBackingArray.getItem(readIndex + 1) >= TMPro.CodePoint.LOW_SURROGATE_START && this.m_TextBackingArray.getItem(readIndex + 1) <= TMPro.CodePoint.LOW_SURROGATE_END) {
                        if (writeIndex.v === this.m_TextProcessingArray.length) {
                            this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, Bridge.ref(this, "m_TextProcessingArray"));
                        }

                        this.m_TextProcessingArray[writeIndex.v].unicode = Math.floor(TMPro.TMP_TextParsingUtilities.ConvertToUTF32(c, this.m_TextBackingArray.getItem(readIndex + 1)));
                        this.m_TextProcessingArray[writeIndex.v].stringIndex = readIndex;
                        this.m_TextProcessingArray[writeIndex.v].length = 2;

                        readIndex += 1;
                        writeIndex.v += 1;
                        continue;
                    }

                    // Handle inline replacement of <style> and <br> tags.
                    if (c === 60 && this.m_isRichText) {
                        // Read tag hash code
                        var hashCode = this.GetMarkupTagHashCode$1(this.m_TextBackingArray.$clone(), readIndex + 1);

                        switch (hashCode) {
                            case TMPro.MarkupTag.BR: 
                                if (writeIndex.v === this.m_TextProcessingArray.length) {
                                    this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, Bridge.ref(this, "m_TextProcessingArray"));
                                }
                                this.m_TextProcessingArray[writeIndex.v].unicode = 10;
                                this.m_TextProcessingArray[writeIndex.v].stringIndex = readIndex;
                                this.m_TextProcessingArray[writeIndex.v].length = 4;
                                writeIndex.v += 1;
                                readIndex += 3;
                                continue;
                            case TMPro.MarkupTag.NBSP: 
                                if (writeIndex.v === this.m_TextProcessingArray.length) {
                                    this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, Bridge.ref(this, "m_TextProcessingArray"));
                                }
                                this.m_TextProcessingArray[writeIndex.v].unicode = 160;
                                this.m_TextProcessingArray[writeIndex.v].stringIndex = readIndex;
                                this.m_TextProcessingArray[writeIndex.v].length = 6;
                                writeIndex.v += 1;
                                readIndex += 5;
                                continue;
                            case TMPro.MarkupTag.ZWSP: 
                                if (writeIndex.v === this.m_TextProcessingArray.length) {
                                    this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, Bridge.ref(this, "m_TextProcessingArray"));
                                }
                                this.m_TextProcessingArray[writeIndex.v].unicode = 8203;
                                this.m_TextProcessingArray[writeIndex.v].stringIndex = readIndex;
                                this.m_TextProcessingArray[writeIndex.v].length = 6;
                                writeIndex.v += 1;
                                readIndex += 5;
                                continue;
                            case TMPro.MarkupTag.STYLE: 
                                var openWriteIndex = writeIndex.v;
                                {
                                    var srcOffset = { };
                                    if (this.ReplaceOpeningStyleTag$1(Bridge.ref(this, "m_TextBackingArray"), readIndex, srcOffset, Bridge.ref(this, "m_TextProcessingArray"), writeIndex)) {
                                        // Update potential text elements added by the opening style.
                                        for (; openWriteIndex < writeIndex.v; openWriteIndex++) {
                                            this.m_TextProcessingArray[openWriteIndex].stringIndex = readIndex;
                                            this.m_TextProcessingArray[openWriteIndex].length = srcOffset.v - readIndex + 1;
                                        }

                                        readIndex = srcOffset.v;
                                        continue;
                                    }
                                }
                                break;
                            case TMPro.MarkupTag.SLASH_STYLE: 
                                var closeWriteIndex = writeIndex.v;
                                this.ReplaceClosingStyleTag$1(Bridge.ref(this, "m_TextBackingArray"), readIndex, Bridge.ref(this, "m_TextProcessingArray"), writeIndex);
                                // Update potential text elements added by the closing style.
                                for (; closeWriteIndex < writeIndex.v; closeWriteIndex++) {
                                    this.m_TextProcessingArray[closeWriteIndex].stringIndex = readIndex;
                                    this.m_TextProcessingArray[closeWriteIndex].length = 8;
                                }
                                readIndex += 7;
                                continue;
                        }
                    }

                    if (writeIndex.v === this.m_TextProcessingArray.length) {
                        this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, Bridge.ref(this, "m_TextProcessingArray"));
                    }

                    this.m_TextProcessingArray[writeIndex.v].unicode = Math.floor(c);
                    this.m_TextProcessingArray[writeIndex.v].stringIndex = readIndex;
                    this.m_TextProcessingArray[writeIndex.v].length = 1;

                    writeIndex.v += 1;
                }

                this.m_TextStyleStackDepth = 0;

                // Insert Closing Style
                if (this.textStyle.hashCode !== TMPro.MarkupTag.NORMAL) {
                    this.InsertClosingStyleTag(Bridge.ref(this, "m_TextProcessingArray"), writeIndex);
                }

                if (writeIndex.v === this.m_TextProcessingArray.length) {
                    this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, Bridge.ref(this, "m_TextProcessingArray"));
                }

                this.m_TextProcessingArray[writeIndex.v].unicode = 0;
                this.m_InternalTextProcessingArraySize = writeIndex.v;
            },
            /*TMPro.TMP_Text.PopulateTextProcessingArray end.*/

            /*TMPro.TMP_Text.SetTextInternal start.*/
            /**
             * Function used in conjunction with GetPreferredValues
             *
             * @instance
             * @private
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {string}    sourceText
             * @return  {void}
             */
            SetTextInternal: function (sourceText) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#SetTextInternal", this ); }

                var srcLength = sourceText == null ? 0 : sourceText.length;

                this.PopulateTextBackingArray$2(sourceText, 0, srcLength);

                // Set input source
                var currentInputSource = this.m_inputSource;
                this.m_inputSource = TMPro.TMP_Text.TextInputSources.TextString;

                this.PopulateTextProcessingArray();

                this.m_inputSource = currentInputSource;
            },
            /*TMPro.TMP_Text.SetTextInternal end.*/

            /*TMPro.TMP_Text.SetText$2 start.*/
            /**
             * This function is the same as using the text property to set the text.
             *
             * @instance
             * @public
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {string}     sourceText          String containing the text.
             * @param   {boolean}    syncTextInputBox    This optional parameter no longer provides any functionality as this function now simple sets the .text property which is reflected in the Text Input Box.
             * @return  {void}
             */
            SetText$2: function (sourceText, syncTextInputBox) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#SetText$2", this ); }

                if (syncTextInputBox === void 0) { syncTextInputBox = true; }
                var srcLength = sourceText == null ? 0 : sourceText.length;

                this.PopulateTextBackingArray$2(sourceText, 0, srcLength);

                this.m_text = sourceText;

                // Set input source
                this.m_inputSource = TMPro.TMP_Text.TextInputSources.TextString;

                this.PopulateTextProcessingArray();

                this.m_havePropertiesChanged = true;

                this.SetVerticesDirty();
                this.SetLayoutDirty();
            },
            /*TMPro.TMP_Text.SetText$2 end.*/

            /*TMPro.TMP_Text.SetText$3 start.*/
            /**
             * <p>Formatted string containing a pattern and a value representing the text to be rendered.</p><p>Ex. TMP_Text.SetText("A = {0}, B = {1:00}, C = {2:000.0}", 10.75f, 10.75f, 10.75f);</p><p>Results "A = 10.75, B = 11, C = 010.8."</p>
             *
             * @instance
             * @public
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {string}    sourceText    String containing the pattern.
             * @param   {number}    arg0          First float value.
             * @return  {void}
             */
            SetText$3: function (sourceText, arg0) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#SetText$3", this ); }

                this.SetText$10(sourceText, arg0, 0, 0, 0, 0, 0, 0, 0);
            },
            /*TMPro.TMP_Text.SetText$3 end.*/

            /*TMPro.TMP_Text.SetText$4 start.*/
            /**
             * <p>Formatted string containing a pattern and a value representing the text to be rendered.</p><p>Ex. TMP_Text.SetText("A = {0}, B = {1:00}, C = {2:000.0}", 10.75f, 10.75f, 10.75f);</p><p>Results "A = 10.75, B = 11, C = 010.8."</p>
             *
             * @instance
             * @public
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {string}    sourceText    String containing the pattern.
             * @param   {number}    arg0          First float value.
             * @param   {number}    arg1          Second float value.
             * @return  {void}
             */
            SetText$4: function (sourceText, arg0, arg1) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#SetText$4", this ); }

                this.SetText$10(sourceText, arg0, arg1, 0, 0, 0, 0, 0, 0);
            },
            /*TMPro.TMP_Text.SetText$4 end.*/

            /*TMPro.TMP_Text.SetText$5 start.*/
            /**
             * <p>Formatted string containing a pattern and a value representing the text to be rendered.</p><p>Ex. TMP_Text.SetText("A = {0}, B = {1:00}, C = {2:000.0}", 10.75f, 10.75f, 10.75f);</p><p>Results "A = 10.75, B = 11, C = 010.8."</p>
             *
             * @instance
             * @public
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {string}    sourceText    String containing the pattern.
             * @param   {number}    arg0          First float value.
             * @param   {number}    arg1          Second float value.
             * @param   {number}    arg2          Third float value.
             * @return  {void}
             */
            SetText$5: function (sourceText, arg0, arg1, arg2) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#SetText$5", this ); }

                this.SetText$10(sourceText, arg0, arg1, arg2, 0, 0, 0, 0, 0);
            },
            /*TMPro.TMP_Text.SetText$5 end.*/

            /*TMPro.TMP_Text.SetText$6 start.*/
            /**
             * <p>Formatted string containing a pattern and a value representing the text to be rendered.</p><p>Ex. TMP_Text.SetText("A = {0}, B = {1:00}, C = {2:000.0}", 10.75f, 10.75f, 10.75f);</p><p>Results "A = 10.75, B = 11, C = 010.8."</p>
             *
             * @instance
             * @public
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {string}    sourceText    String containing the pattern.
             * @param   {number}    arg0          First float value.
             * @param   {number}    arg1          Second float value.
             * @param   {number}    arg2          Third float value.
             * @param   {number}    arg3          Forth float value.
             * @return  {void}
             */
            SetText$6: function (sourceText, arg0, arg1, arg2, arg3) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#SetText$6", this ); }

                this.SetText$10(sourceText, arg0, arg1, arg2, arg3, 0, 0, 0, 0);
            },
            /*TMPro.TMP_Text.SetText$6 end.*/

            /*TMPro.TMP_Text.SetText$7 start.*/
            /**
             * <p>Formatted string containing a pattern and a value representing the text to be rendered.</p><p>Ex. TMP_Text.SetText("A = {0}, B = {1:00}, C = {2:000.0}", 10.75f, 10.75f, 10.75f);</p><p>Results "A = 10.75, B = 11, C = 010.8."</p>
             *
             * @instance
             * @public
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {string}    sourceText    String containing the pattern.
             * @param   {number}    arg0          First float value.
             * @param   {number}    arg1          Second float value.
             * @param   {number}    arg2          Third float value.
             * @param   {number}    arg3          Forth float value.
             * @param   {number}    arg4          Fifth float value.
             * @return  {void}
             */
            SetText$7: function (sourceText, arg0, arg1, arg2, arg3, arg4) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#SetText$7", this ); }

                this.SetText$10(sourceText, arg0, arg1, arg2, arg3, arg4, 0, 0, 0);
            },
            /*TMPro.TMP_Text.SetText$7 end.*/

            /*TMPro.TMP_Text.SetText$8 start.*/
            /**
             * <p>Formatted string containing a pattern and a value representing the text to be rendered.</p><p>Ex. TMP_Text.SetText("A = {0}, B = {1:00}, C = {2:000.0}", 10.75f, 10.75f, 10.75f);</p><p>Results "A = 10.75, B = 11, C = 010.8."</p>
             *
             * @instance
             * @public
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {string}    sourceText    String containing the pattern.
             * @param   {number}    arg0          First float value.
             * @param   {number}    arg1          Second float value.
             * @param   {number}    arg2          Third float value.
             * @param   {number}    arg3          Forth float value.
             * @param   {number}    arg4          Fifth float value.
             * @param   {number}    arg5          Sixth float value.
             * @return  {void}
             */
            SetText$8: function (sourceText, arg0, arg1, arg2, arg3, arg4, arg5) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#SetText$8", this ); }

                this.SetText$10(sourceText, arg0, arg1, arg2, arg3, arg4, arg5, 0, 0);
            },
            /*TMPro.TMP_Text.SetText$8 end.*/

            /*TMPro.TMP_Text.SetText$9 start.*/
            /**
             * <p>Formatted string containing a pattern and a value representing the text to be rendered.</p><p>Ex. TMP_Text.SetText("A = {0}, B = {1:00}, C = {2:000.0}", 10.75f, 10.75f, 10.75f);</p><p>Results "A = 10.75, B = 11, C = 010.8."</p>
             *
             * @instance
             * @public
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {string}    sourceText    String containing the pattern.
             * @param   {number}    arg0          First float value.
             * @param   {number}    arg1          Second float value.
             * @param   {number}    arg2          Third float value.
             * @param   {number}    arg3          Forth float value.
             * @param   {number}    arg4          Fifth float value.
             * @param   {number}    arg5          Sixth float value.
             * @param   {number}    arg6          Seventh float value.
             * @return  {void}
             */
            SetText$9: function (sourceText, arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#SetText$9", this ); }

                this.SetText$10(sourceText, arg0, arg1, arg2, arg3, arg4, arg5, arg6, 0);
            },
            /*TMPro.TMP_Text.SetText$9 end.*/

            /*TMPro.TMP_Text.SetText$10 start.*/
            /**
             * <p>Formatted string containing a pattern and a value representing the text to be rendered.</p><p>Ex. TMP_Text.SetText("A = {0}, B = {1:00}, C = {2:000.0}", 10.75f, 10.75f, 10.75f);</p><p>Results "A = 10.75, B = 11, C = 010.8."</p>
             *
             * @instance
             * @public
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {string}    sourceText    String containing the pattern.
             * @param   {number}    arg0          First float value.
             * @param   {number}    arg1          Second float value.
             * @param   {number}    arg2          Third float value.
             * @param   {number}    arg3          Forth float value.
             * @param   {number}    arg4          Fifth float value.
             * @param   {number}    arg5          Sixth float value.
             * @param   {number}    arg6          Seventh float value.
             * @param   {number}    arg7          Eighth float value.
             * @return  {void}
             */
            SetText$10: function (sourceText, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#SetText$10", this ); }

                var argIndex = 0;
                var padding = 0;
                var decimalPrecision = 0;

                var readFlag = 0;

                var readIndex = 0;
                var writeIndex = { v : 0 };

                for (; readIndex < sourceText.length; readIndex++) {
                    var c = sourceText.charCodeAt(readIndex);

                    if (c === 123) {
                        readFlag = 1;
                        continue;
                    }

                    if (c === 125) {
                        // Add arg(index) to array
                        switch (argIndex) {
                            case 0: 
                                this.AddFloatToInternalTextBackingArray(arg0, padding, decimalPrecision, writeIndex);
                                break;
                            case 1: 
                                this.AddFloatToInternalTextBackingArray(arg1, padding, decimalPrecision, writeIndex);
                                break;
                            case 2: 
                                this.AddFloatToInternalTextBackingArray(arg2, padding, decimalPrecision, writeIndex);
                                break;
                            case 3: 
                                this.AddFloatToInternalTextBackingArray(arg3, padding, decimalPrecision, writeIndex);
                                break;
                            case 4: 
                                this.AddFloatToInternalTextBackingArray(arg4, padding, decimalPrecision, writeIndex);
                                break;
                            case 5: 
                                this.AddFloatToInternalTextBackingArray(arg5, padding, decimalPrecision, writeIndex);
                                break;
                            case 6: 
                                this.AddFloatToInternalTextBackingArray(arg6, padding, decimalPrecision, writeIndex);
                                break;
                            case 7: 
                                this.AddFloatToInternalTextBackingArray(arg7, padding, decimalPrecision, writeIndex);
                                break;
                        }

                        argIndex = 0;
                        readFlag = 0;
                        padding = 0;
                        decimalPrecision = 0;
                        continue;
                    }

                    // Read Argument index
                    if (readFlag === 1) {
                        if (c >= 48 && c <= 56) {
                            argIndex = c - 48;
                            readFlag = 2;
                            continue;
                        }
                    }

                    // Read formatting for integral part of the value
                    if (readFlag === 2) {
                        // Skip ':' separator
                        if (c === 58) {
                            continue;
                        }

                        // Done reading integral formatting and value
                        if (c === 46) {
                            readFlag = 3;
                            continue;
                        }

                        if (c === 35) {
                            // do something
                            continue;
                        }

                        if (c === 48) {
                            padding += 1;
                            continue;
                        }

                        if (c === 44) {
                            // Use commas in the integral value
                            continue;
                        }

                        // Legacy mode
                        if (c >= 49 && c <= 57) {
                            decimalPrecision = c - 48;
                            continue;
                        }
                    }

                    // Read Decimal Precision value
                    if (readFlag === 3) {
                        if (c === 48) {
                            decimalPrecision += 1;
                            continue;
                        }
                    }

                    // Write value
                    this.m_TextBackingArray.setItem(writeIndex.v, c);
                    writeIndex.v += 1;
                }

                this.m_TextBackingArray.setItem(writeIndex.v, 0);
                this.m_TextBackingArray.Count = writeIndex.v;

                this.m_IsTextBackingStringDirty = true;


                this.m_inputSource = TMPro.TMP_Text.TextInputSources.SetText;

                this.PopulateTextProcessingArray();

                this.m_havePropertiesChanged = true;

                this.SetVerticesDirty();
                this.SetLayoutDirty();
            },
            /*TMPro.TMP_Text.SetText$10 end.*/

            /*TMPro.TMP_Text.SetText$11 start.*/
            /**
             * Set the text using a StringBuilder object as the source.
             *
             * @instance
             * @public
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {System.Text.StringBuilder}    sourceText    The StringBuilder object containing the source text.
             * @return  {void}
             */
            SetText$11: function (sourceText) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#SetText$11", this ); }

                var srcLength = sourceText == null ? 0 : sourceText.getLength();

                this.SetText$12(sourceText, 0, srcLength);
            },
            /*TMPro.TMP_Text.SetText$11 end.*/

            /*TMPro.TMP_Text.SetText$12 start.*/
            /**
             * Set the text using a StringBuilder object and specifying the starting character index and length.
             *
             * @instance
             * @private
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {System.Text.StringBuilder}    sourceText    The StringBuilder object containing the source text.
             * @param   {number}                       start         The index of the first character to read from in the array.
             * @param   {number}                       length        The number of characters in the array to be read.
             * @return  {void}
             */
            SetText$12: function (sourceText, start, length) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#SetText$12", this ); }

                this.PopulateTextBackingArray$3(sourceText, start, length);

                this.m_IsTextBackingStringDirty = true;


                // Set input source
                this.m_inputSource = TMPro.TMP_Text.TextInputSources.SetTextArray;

                this.PopulateTextProcessingArray();

                this.m_havePropertiesChanged = true;

                this.SetVerticesDirty();
                this.SetLayoutDirty();
            },
            /*TMPro.TMP_Text.SetText$12 end.*/

            /*TMPro.TMP_Text.SetText start.*/
            /**
             * Set the text using a char array.
             *
             * @instance
             * @public
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {Array.<number>}    sourceText    Source char array containing the Unicode characters of the text.
             * @return  {void}
             */
            SetText: function (sourceText) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#SetText", this ); }

                var srcLength = sourceText == null ? 0 : sourceText.length;

                this.SetCharArray$1(sourceText, 0, srcLength);
            },
            /*TMPro.TMP_Text.SetText end.*/

            /*TMPro.TMP_Text.SetText$1 start.*/
            /**
             * Set the text using a char array and specifying the starting character index and length.
             *
             * @instance
             * @public
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {Array.<number>}    sourceText    Source char array containing the Unicode characters of the text.
             * @param   {number}            start         Index of the first character to read from in the array.
             * @param   {number}            length        The number of characters in the array to be read.
             * @return  {void}
             */
            SetText$1: function (sourceText, start, length) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#SetText$1", this ); }

                this.SetCharArray$1(sourceText, start, length);
            },
            /*TMPro.TMP_Text.SetText$1 end.*/

            /*TMPro.TMP_Text.SetCharArray start.*/
            /**
             * Set the text using a char array.
             *
             * @instance
             * @public
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {Array.<number>}    sourceText    Source char array containing the Unicode characters of the text.
             * @return  {void}
             */
            SetCharArray: function (sourceText) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#SetCharArray", this ); }

                var srcLength = sourceText == null ? 0 : sourceText.length;

                this.SetCharArray$1(sourceText, 0, srcLength);
            },
            /*TMPro.TMP_Text.SetCharArray end.*/

            /*TMPro.TMP_Text.SetCharArray$1 start.*/
            /**
             * Set the text using a char array and specifying the starting character index and length.
             *
             * @instance
             * @public
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {Array.<number>}    sourceText    Source char array containing the Unicode characters of the text.
             * @param   {number}            start         The index of the first character to read from in the array.
             * @param   {number}            length        The number of characters in the array to be read.
             * @return  {void}
             */
            SetCharArray$1: function (sourceText, start, length) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#SetCharArray$1", this ); }

                this.PopulateTextBackingArray(sourceText, start, length);

                this.m_IsTextBackingStringDirty = true;


                // Set input source
                this.m_inputSource = TMPro.TMP_Text.TextInputSources.SetTextArray;

                this.PopulateTextProcessingArray();

                this.m_havePropertiesChanged = true;

                this.SetVerticesDirty();
                this.SetLayoutDirty();
            },
            /*TMPro.TMP_Text.SetCharArray$1 end.*/

            /*TMPro.TMP_Text.GetStyle start.*/
            /**
             * @instance
             * @private
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {number}             hashCode
             * @return  {TMPro.TMP_Style}
             */
            GetStyle: function (hashCode) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetStyle", this ); }

                var style = null;

                // Get Style from Style Sheet potentially assigned to text object.
                if (this.m_StyleSheet != null) {
                    style = this.m_StyleSheet.GetStyle(hashCode);

                    if (style != null) {
                        return style;
                    }
                }

                if (TMPro.TMP_Settings.defaultStyleSheet != null) {
                    style = TMPro.TMP_Settings.defaultStyleSheet.GetStyle(hashCode);
                }

                return style;
            },
            /*TMPro.TMP_Text.GetStyle end.*/

            /*TMPro.TMP_Text.ReplaceOpeningStyleTag$1 start.*/
            /**
             * Method to handle inline replacement of style tag by opening style definition.
             *
             * @instance
             * @private
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {TMPro.TMP_Text.TextBackingContainer}    sourceText    
             * @param   {number}                                 srcIndex      
             * @param   {System.Int32}                           srcOffset     
             * @param   {TMPro.UnicodeChar}                      charBuffer    
             * @param   {System.Int32}                           writeIndex
             * @return  {boolean}
             */
            ReplaceOpeningStyleTag$1: function (sourceText, srcIndex, srcOffset, charBuffer, writeIndex) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#ReplaceOpeningStyleTag$1", this ); }

                // Validate <style> tag.
                var styleHashCode = this.GetStyleHashCode$1(sourceText, srcIndex + 7, srcOffset);
                var style = this.GetStyle(styleHashCode);

                // Return if we don't have a valid style.
                if (style == null || srcOffset.v === 0) {
                    return false;
                }

                // Increase style depth
                this.m_TextStyleStackDepth += 1;

                // Push style hashcode onto stack
                this.m_TextStyleStacks[this.m_TextStyleStackDepth].Push(style.hashCode);

                var styleLength = style.styleOpeningTagArray.length;

                // Replace <style> tag with opening definition
                var tagDefinition = { v : style.styleOpeningTagArray };

                for (var i = 0; i < styleLength; i++) {
                    var c = tagDefinition.v[i];

                    if (c === 92 && i + 1 < styleLength) {
                        switch (tagDefinition.v[i + 1]) {
                            case 92: 
                                i += 1;
                                break;
                            case 110: 
                                c = 10;
                                i += 1;
                                break;
                            case 114: 
                                break;
                            case 116: 
                                break;
                            case 117: 
                                // UTF16 format is "\uFF00" or u + 2 hex pairs.
                                if (i + 5 < styleLength) {
                                    c = this.GetUTF16$1(tagDefinition.v, i + 2);

                                    i += 5;
                                }
                                break;
                            case 85: 
                                // UTF32 format is "\UFF00FF00" or U + 4 hex pairs.
                                if (i + 9 < styleLength) {
                                    c = this.GetUTF32$1(tagDefinition.v, i + 2);

                                    i += 9;
                                }
                                break;
                        }
                    }

                    if (c === 60) {
                        var hashCode = this.GetMarkupTagHashCode(tagDefinition.v, i + 1);

                        switch (hashCode) {
                            case TMPro.MarkupTag.BR: 
                                if (writeIndex.v === charBuffer.v.length) {
                                    this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, charBuffer);
                                }
                                charBuffer.v[writeIndex.v].unicode = 10;
                                writeIndex.v += 1;
                                i += 3;
                                continue;
                            case TMPro.MarkupTag.NBSP: 
                                if (writeIndex.v === charBuffer.v.length) {
                                    this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, charBuffer);
                                }
                                charBuffer.v[writeIndex.v].unicode = 160;
                                writeIndex.v += 1;
                                i += 5;
                                continue;
                            case TMPro.MarkupTag.ZWSP: 
                                if (writeIndex.v === charBuffer.v.length) {
                                    this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, charBuffer);
                                }
                                charBuffer.v[writeIndex.v].unicode = 8203;
                                writeIndex.v += 1;
                                i += 5;
                                continue;
                            case TMPro.MarkupTag.STYLE: 
                                {
                                    var offset = { };
                                    if (this.ReplaceOpeningStyleTag(tagDefinition, i, offset, charBuffer, writeIndex)) {
                                        i = offset.v;
                                        continue;
                                    }
                                }
                                break;
                            case TMPro.MarkupTag.SLASH_STYLE: 
                                this.ReplaceClosingStyleTag(tagDefinition, i, charBuffer, writeIndex);
                                i += 7;
                                continue;
                        }
                    }

                    if (writeIndex.v === charBuffer.v.length) {
                        this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, charBuffer);
                    }

                    charBuffer.v[writeIndex.v].unicode = c;
                    writeIndex.v += 1;
                }

                this.m_TextStyleStackDepth -= 1;

                return true;
            },
            /*TMPro.TMP_Text.ReplaceOpeningStyleTag$1 end.*/

            /*TMPro.TMP_Text.ReplaceOpeningStyleTag start.*/
            /**
             * Method to handle inline replacement of style tag by opening style definition.
             *
             * @instance
             * @private
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {System.Int32}         sourceText    
             * @param   {number}               srcIndex      
             * @param   {System.Int32}         srcOffset     
             * @param   {TMPro.UnicodeChar}    charBuffer    
             * @param   {System.Int32}         writeIndex
             * @return  {boolean}
             */
            ReplaceOpeningStyleTag: function (sourceText, srcIndex, srcOffset, charBuffer, writeIndex) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#ReplaceOpeningStyleTag", this ); }

                // Validate <style> tag.
                var styleHashCode = this.GetStyleHashCode(sourceText, srcIndex + 7, srcOffset);
                var style = this.GetStyle(styleHashCode);

                // Return if we don't have a valid style.
                if (style == null || srcOffset.v === 0) {
                    return false;
                }

                // Increase style depth
                this.m_TextStyleStackDepth += 1;

                // Push style hashcode onto stack
                this.m_TextStyleStacks[this.m_TextStyleStackDepth].Push(style.hashCode);

                var styleLength = style.styleOpeningTagArray.length;

                // Replace <style> tag with opening definition
                var tagDefinition = { v : style.styleOpeningTagArray };

                for (var i = 0; i < styleLength; i++) {
                    var c = tagDefinition.v[i];

                    if (c === 92 && i + 1 < styleLength) {
                        switch (tagDefinition.v[i + 1]) {
                            case 92: 
                                i += 1;
                                break;
                            case 110: 
                                c = 10;
                                i += 1;
                                break;
                            case 114: 
                                break;
                            case 116: 
                                break;
                            case 117: 
                                // UTF16 format is "\uFF00" or u + 2 hex pairs.
                                if (i + 5 < styleLength) {
                                    c = this.GetUTF16$1(tagDefinition.v, i + 2);

                                    i += 5;
                                }
                                break;
                            case 85: 
                                // UTF32 format is "\UFF00FF00" or U + 4 hex pairs.
                                if (i + 9 < styleLength) {
                                    c = this.GetUTF32$1(tagDefinition.v, i + 2);

                                    i += 9;
                                }
                                break;
                        }
                    }

                    if (c === 60) {
                        var hashCode = this.GetMarkupTagHashCode(tagDefinition.v, i + 1);

                        switch (hashCode) {
                            case TMPro.MarkupTag.BR: 
                                if (writeIndex.v === charBuffer.v.length) {
                                    this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, charBuffer);
                                }
                                charBuffer.v[writeIndex.v].unicode = 10;
                                writeIndex.v += 1;
                                i += 3;
                                continue;
                            case TMPro.MarkupTag.NBSP: 
                                if (writeIndex.v === charBuffer.v.length) {
                                    this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, charBuffer);
                                }
                                charBuffer.v[writeIndex.v].unicode = 160;
                                writeIndex.v += 1;
                                i += 5;
                                continue;
                            case TMPro.MarkupTag.ZWSP: 
                                if (writeIndex.v === charBuffer.v.length) {
                                    this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, charBuffer);
                                }
                                charBuffer.v[writeIndex.v].unicode = 8203;
                                writeIndex.v += 1;
                                i += 5;
                                continue;
                            case TMPro.MarkupTag.STYLE: 
                                {
                                    var offset = { };
                                    if (this.ReplaceOpeningStyleTag(tagDefinition, i, offset, charBuffer, writeIndex)) {
                                        i = offset.v;
                                        continue;
                                    }
                                }
                                break;
                            case TMPro.MarkupTag.SLASH_STYLE: 
                                this.ReplaceClosingStyleTag(tagDefinition, i, charBuffer, writeIndex);
                                i += 7;
                                continue;
                        }
                    }

                    if (writeIndex.v === charBuffer.v.length) {
                        this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, charBuffer);
                    }

                    charBuffer.v[writeIndex.v].unicode = c;
                    writeIndex.v += 1;
                }

                this.m_TextStyleStackDepth -= 1;

                return true;
            },
            /*TMPro.TMP_Text.ReplaceOpeningStyleTag end.*/

            /*TMPro.TMP_Text.ReplaceClosingStyleTag$1 start.*/
            /**
             * Method to handle inline replacement of style tag by closing style definition.
             *
             * @instance
             * @private
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {TMPro.TMP_Text.TextBackingContainer}    sourceText    
             * @param   {number}                                 srcIndex      
             * @param   {TMPro.UnicodeChar}                      charBuffer    
             * @param   {System.Int32}                           writeIndex
             * @return  {void}
             */
            ReplaceClosingStyleTag$1: function (sourceText, srcIndex, charBuffer, writeIndex) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#ReplaceClosingStyleTag$1", this ); }

                // Get style from the Style Stack
                var styleHashCode = this.m_TextStyleStacks[this.m_TextStyleStackDepth + 1].Pop();
                var style = this.GetStyle(styleHashCode);

                // Return if we don't have a valid style.
                if (style == null) {
                    return;
                }

                // Increase style depth
                this.m_TextStyleStackDepth += 1;

                var styleLength = style.styleClosingTagArray.length;

                // Replace <style> tag with opening definition
                var tagDefinition = { v : style.styleClosingTagArray };

                for (var i = 0; i < styleLength; i++) {
                    var c = tagDefinition.v[i];

                    if (c === 92 && i + 1 < styleLength) {
                        switch (tagDefinition.v[i + 1]) {
                            case 92: 
                                i += 1;
                                break;
                            case 110: 
                                c = 10;
                                i += 1;
                                break;
                            case 114: 
                                break;
                            case 116: 
                                break;
                            case 117: 
                                // UTF16 format is "\uFF00" or u + 2 hex pairs.
                                if (i + 5 < styleLength) {
                                    c = this.GetUTF16$1(tagDefinition.v, i + 2);

                                    i += 5;
                                }
                                break;
                            case 85: 
                                // UTF32 format is "\UFF00FF00" or U + 4 hex pairs.
                                if (i + 9 < styleLength) {
                                    c = this.GetUTF32$1(tagDefinition.v, i + 2);

                                    i += 9;
                                }
                                break;
                        }
                    }

                    if (c === 60) {
                        var hashCode = this.GetMarkupTagHashCode(tagDefinition.v, i + 1);

                        switch (hashCode) {
                            case TMPro.MarkupTag.BR: 
                                if (writeIndex.v === charBuffer.v.length) {
                                    this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, charBuffer);
                                }
                                charBuffer.v[writeIndex.v].unicode = 10;
                                writeIndex.v += 1;
                                i += 3;
                                continue;
                            case TMPro.MarkupTag.NBSP: 
                                if (writeIndex.v === charBuffer.v.length) {
                                    this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, charBuffer);
                                }
                                charBuffer.v[writeIndex.v].unicode = 160;
                                writeIndex.v += 1;
                                i += 5;
                                continue;
                            case TMPro.MarkupTag.ZWSP: 
                                if (writeIndex.v === charBuffer.v.length) {
                                    this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, charBuffer);
                                }
                                charBuffer.v[writeIndex.v].unicode = 8203;
                                writeIndex.v += 1;
                                i += 5;
                                continue;
                            case TMPro.MarkupTag.STYLE: 
                                {
                                    var offset = { };
                                    if (this.ReplaceOpeningStyleTag(tagDefinition, i, offset, charBuffer, writeIndex)) {
                                        i = offset.v;
                                        continue;
                                    }
                                }
                                break;
                            case TMPro.MarkupTag.SLASH_STYLE: 
                                this.ReplaceClosingStyleTag(tagDefinition, i, charBuffer, writeIndex);
                                i += 7;
                                continue;
                        }
                    }

                    if (writeIndex.v === charBuffer.v.length) {
                        this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, charBuffer);
                    }

                    charBuffer.v[writeIndex.v].unicode = c;
                    writeIndex.v += 1;
                }

                this.m_TextStyleStackDepth -= 1;
            },
            /*TMPro.TMP_Text.ReplaceClosingStyleTag$1 end.*/

            /*TMPro.TMP_Text.ReplaceClosingStyleTag start.*/
            /**
             * Method to handle inline replacement of style tag by closing style definition.
             *
             * @instance
             * @private
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {System.Int32}         sourceText    
             * @param   {number}               srcIndex      
             * @param   {TMPro.UnicodeChar}    charBuffer    
             * @param   {System.Int32}         writeIndex
             * @return  {void}
             */
            ReplaceClosingStyleTag: function (sourceText, srcIndex, charBuffer, writeIndex) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#ReplaceClosingStyleTag", this ); }

                // Get style from the Style Stack
                var styleHashCode = this.m_TextStyleStacks[this.m_TextStyleStackDepth + 1].Pop();
                var style = this.GetStyle(styleHashCode);

                // Return if we don't have a valid style.
                if (style == null) {
                    return;
                }

                // Increase style depth
                this.m_TextStyleStackDepth += 1;

                var styleLength = style.styleClosingTagArray.length;

                // Replace <style> tag with opening definition
                var tagDefinition = { v : style.styleClosingTagArray };

                for (var i = 0; i < styleLength; i++) {
                    var c = tagDefinition.v[i];

                    if (c === 92 && i + 1 < styleLength) {
                        switch (tagDefinition.v[i + 1]) {
                            case 92: 
                                i += 1;
                                break;
                            case 110: 
                                c = 10;
                                i += 1;
                                break;
                            case 114: 
                                break;
                            case 116: 
                                break;
                            case 117: 
                                // UTF16 format is "\uFF00" or u + 2 hex pairs.
                                if (i + 5 < styleLength) {
                                    c = this.GetUTF16$1(tagDefinition.v, i + 2);

                                    i += 5;
                                }
                                break;
                            case 85: 
                                // UTF32 format is "\UFF00FF00" or U + 4 hex pairs.
                                if (i + 9 < styleLength) {
                                    c = this.GetUTF32$1(tagDefinition.v, i + 2);

                                    i += 9;
                                }
                                break;
                        }
                    }

                    if (c === 60) {
                        var hashCode = this.GetMarkupTagHashCode(tagDefinition.v, i + 1);

                        switch (hashCode) {
                            case TMPro.MarkupTag.BR: 
                                if (writeIndex.v === charBuffer.v.length) {
                                    this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, charBuffer);
                                }
                                charBuffer.v[writeIndex.v].unicode = 10;
                                writeIndex.v += 1;
                                i += 3;
                                continue;
                            case TMPro.MarkupTag.NBSP: 
                                if (writeIndex.v === charBuffer.v.length) {
                                    this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, charBuffer);
                                }
                                charBuffer.v[writeIndex.v].unicode = 160;
                                writeIndex.v += 1;
                                i += 5;
                                continue;
                            case TMPro.MarkupTag.ZWSP: 
                                if (writeIndex.v === charBuffer.v.length) {
                                    this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, charBuffer);
                                }
                                charBuffer.v[writeIndex.v].unicode = 8203;
                                writeIndex.v += 1;
                                i += 5;
                                continue;
                            case TMPro.MarkupTag.STYLE: 
                                {
                                    var offset = { };
                                    if (this.ReplaceOpeningStyleTag(tagDefinition, i, offset, charBuffer, writeIndex)) {
                                        i = offset.v;
                                        continue;
                                    }
                                }
                                break;
                            case TMPro.MarkupTag.SLASH_STYLE: 
                                this.ReplaceClosingStyleTag(tagDefinition, i, charBuffer, writeIndex);
                                i += 7;
                                continue;
                        }
                    }

                    if (writeIndex.v === charBuffer.v.length) {
                        this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, charBuffer);
                    }

                    charBuffer.v[writeIndex.v].unicode = c;
                    writeIndex.v += 1;
                }

                this.m_TextStyleStackDepth -= 1;
            },
            /*TMPro.TMP_Text.ReplaceClosingStyleTag end.*/

            /*TMPro.TMP_Text.InsertOpeningStyleTag start.*/
            /**
             * @instance
             * @private
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {TMPro.TMP_Style}      style         
             * @param   {number}               srcIndex      
             * @param   {TMPro.UnicodeChar}    charBuffer    
             * @param   {System.Int32}         writeIndex
             * @return  {boolean}
             */
            InsertOpeningStyleTag: function (style, srcIndex, charBuffer, writeIndex) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#InsertOpeningStyleTag", this ); }

                // Return if we don't have a valid style.
                if (style == null) {
                    return false;
                }

                this.m_TextStyleStacks[0].Push(style.hashCode);

                var styleLength = style.styleOpeningTagArray.length;

                // Replace <style> tag with opening definition
                var tagDefinition = { v : style.styleOpeningTagArray };

                for (var i = 0; i < styleLength; i++) {
                    var c = tagDefinition.v[i];

                    if (c === 92 && i + 1 < styleLength) {
                        switch (tagDefinition.v[i + 1]) {
                            case 92: 
                                i += 1;
                                break;
                            case 110: 
                                c = 10;
                                i += 1;
                                break;
                            case 114: 
                                break;
                            case 116: 
                                break;
                            case 117: 
                                // UTF16 format is "\uFF00" or u + 2 hex pairs.
                                if (i + 5 < styleLength) {
                                    c = this.GetUTF16$1(tagDefinition.v, i + 2);

                                    i += 5;
                                }
                                break;
                            case 85: 
                                // UTF32 format is "\UFF00FF00" or U + 4 hex pairs.
                                if (i + 9 < styleLength) {
                                    c = this.GetUTF32$1(tagDefinition.v, i + 2);

                                    i += 9;
                                }
                                break;
                        }
                    }

                    if (c === 60) {
                        var hashCode = this.GetMarkupTagHashCode(tagDefinition.v, i + 1);

                        switch (hashCode) {
                            case TMPro.MarkupTag.BR: 
                                if (writeIndex.v === charBuffer.v.length) {
                                    this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, charBuffer);
                                }
                                charBuffer.v[writeIndex.v].unicode = 10;
                                writeIndex.v += 1;
                                i += 3;
                                continue;
                            case TMPro.MarkupTag.NBSP: 
                                if (writeIndex.v === charBuffer.v.length) {
                                    this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, charBuffer);
                                }
                                charBuffer.v[writeIndex.v].unicode = 160;
                                writeIndex.v += 1;
                                i += 5;
                                continue;
                            case TMPro.MarkupTag.ZWSP: 
                                if (writeIndex.v === charBuffer.v.length) {
                                    this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, charBuffer);
                                }
                                charBuffer.v[writeIndex.v].unicode = 8203;
                                writeIndex.v += 1;
                                i += 5;
                                continue;
                            case TMPro.MarkupTag.STYLE: 
                                {
                                    var offset = { };
                                    if (this.ReplaceOpeningStyleTag(tagDefinition, i, offset, charBuffer, writeIndex)) {
                                        i = offset.v;
                                        continue;
                                    }
                                }
                                break;
                            case TMPro.MarkupTag.SLASH_STYLE: 
                                this.ReplaceClosingStyleTag(tagDefinition, i, charBuffer, writeIndex);
                                i += 7;
                                continue;
                        }
                    }

                    if (writeIndex.v === charBuffer.v.length) {
                        this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, charBuffer);
                    }

                    charBuffer.v[writeIndex.v].unicode = c;
                    writeIndex.v += 1;
                }

                this.m_TextStyleStackDepth = 0;

                return true;
            },
            /*TMPro.TMP_Text.InsertOpeningStyleTag end.*/

            /*TMPro.TMP_Text.InsertClosingStyleTag start.*/
            /**
             * @instance
             * @private
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {TMPro.UnicodeChar}    charBuffer    
             * @param   {System.Int32}         writeIndex
             * @return  {void}
             */
            InsertClosingStyleTag: function (charBuffer, writeIndex) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#InsertClosingStyleTag", this ); }

                // Get style from the Style Stack
                var styleHashCode = this.m_TextStyleStacks[0].Pop();
                var style = this.GetStyle(styleHashCode);

                var styleLength = style.styleClosingTagArray.length;

                // Replace <style> tag with opening definition
                var tagDefinition = { v : style.styleClosingTagArray };

                for (var i = 0; i < styleLength; i++) {
                    var c = tagDefinition.v[i];

                    if (c === 92 && i + 1 < styleLength) {
                        switch (tagDefinition.v[i + 1]) {
                            case 92: 
                                i += 1;
                                break;
                            case 110: 
                                c = 10;
                                i += 1;
                                break;
                            case 114: 
                                break;
                            case 116: 
                                break;
                            case 117: 
                                // UTF16 format is "\uFF00" or u + 2 hex pairs.
                                if (i + 5 < styleLength) {
                                    c = this.GetUTF16$1(tagDefinition.v, i + 2);

                                    i += 5;
                                }
                                break;
                            case 85: 
                                // UTF32 format is "\UFF00FF00" or U + 4 hex pairs.
                                if (i + 9 < styleLength) {
                                    c = this.GetUTF32$1(tagDefinition.v, i + 2);

                                    i += 9;
                                }
                                break;
                        }
                    }

                    if (c === 60) {
                        var hashCode = this.GetMarkupTagHashCode(tagDefinition.v, i + 1);

                        switch (hashCode) {
                            case TMPro.MarkupTag.BR: 
                                if (writeIndex.v === charBuffer.v.length) {
                                    this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, charBuffer);
                                }
                                charBuffer.v[writeIndex.v].unicode = 10;
                                writeIndex.v += 1;
                                i += 3;
                                continue;
                            case TMPro.MarkupTag.NBSP: 
                                if (writeIndex.v === charBuffer.v.length) {
                                    this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, charBuffer);
                                }
                                charBuffer.v[writeIndex.v].unicode = 160;
                                writeIndex.v += 1;
                                i += 5;
                                continue;
                            case TMPro.MarkupTag.ZWSP: 
                                if (writeIndex.v === charBuffer.v.length) {
                                    this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, charBuffer);
                                }
                                charBuffer.v[writeIndex.v].unicode = 8203;
                                writeIndex.v += 1;
                                i += 5;
                                continue;
                            case TMPro.MarkupTag.STYLE: 
                                {
                                    var offset = { };
                                    if (this.ReplaceOpeningStyleTag(tagDefinition, i, offset, charBuffer, writeIndex)) {
                                        i = offset.v;
                                        continue;
                                    }
                                }
                                break;
                            case TMPro.MarkupTag.SLASH_STYLE: 
                                this.ReplaceClosingStyleTag(tagDefinition, i, charBuffer, writeIndex);
                                i += 7;
                                continue;
                        }
                    }

                    if (writeIndex.v === charBuffer.v.length) {
                        this.ResizeInternalArray(TMPro.TMP_Text.UnicodeChar, charBuffer);
                    }

                    charBuffer.v[writeIndex.v].unicode = c;
                    writeIndex.v += 1;
                }

                this.m_TextStyleStackDepth = 0;
            },
            /*TMPro.TMP_Text.InsertClosingStyleTag end.*/

            /*TMPro.TMP_Text.GetMarkupTagHashCode start.*/
            /**
             * @instance
             * @private
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {Array.<number>}    tagDefinition    
             * @param   {number}            readIndex
             * @return  {number}
             */
            GetMarkupTagHashCode: function (tagDefinition, readIndex) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetMarkupTagHashCode", this ); }

                var hashCode = 0;
                var maxReadIndex = readIndex + 16;
                var tagDefinitionLength = tagDefinition.length;

                for (; readIndex < maxReadIndex && readIndex < tagDefinitionLength; readIndex++) {
                    var c = tagDefinition[readIndex];

                    if (c === 62 || c === 61 || c === 32) {
                        return hashCode;
                    }

                    hashCode = ((hashCode << 5) + hashCode) ^ TMPro.TMP_TextUtilities.ToUpperASCIIFast(c);
                }

                return hashCode;
            },
            /*TMPro.TMP_Text.GetMarkupTagHashCode end.*/

            /*TMPro.TMP_Text.GetMarkupTagHashCode$1 start.*/
            /**
             * @instance
             * @private
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {TMPro.TMP_Text.TextBackingContainer}    tagDefinition    
             * @param   {number}                                 readIndex
             * @return  {number}
             */
            GetMarkupTagHashCode$1: function (tagDefinition, readIndex) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetMarkupTagHashCode$1", this ); }

                var hashCode = 0;
                var maxReadIndex = readIndex + 16;
                var tagDefinitionLength = tagDefinition.Capacity;

                for (; readIndex < maxReadIndex && readIndex < tagDefinitionLength; readIndex++) {
                    var c = tagDefinition.getItem(readIndex);

                    if (c === 62 || c === 61 || c === 32) {
                        return hashCode;
                    }

                    hashCode = ((hashCode << 5) + hashCode) ^ TMPro.TMP_TextUtilities.ToUpperASCIIFast(c);
                }

                return hashCode;
            },
            /*TMPro.TMP_Text.GetMarkupTagHashCode$1 end.*/

            /*TMPro.TMP_Text.GetStyleHashCode start.*/
            /**
             * Get Hashcode for a given tag.
             *
             * @instance
             * @private
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {System.Int32}    text          
             * @param   {number}          index         
             * @param   {System.Int32}    closeIndex
             * @return  {number}
             */
            GetStyleHashCode: function (text, index, closeIndex) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetStyleHashCode", this ); }

                var hashCode = 0;
                closeIndex.v = 0;

                for (var i = index; i < text.v.length; i++) {
                    // Skip quote '"' character
                    if (text.v[i] === 34) {
                        continue;
                    }

                    // Break at '>'
                    if (text.v[i] === 62) {
                        closeIndex.v = i;
                        break;
                    }

                    hashCode = ((hashCode << 5) + hashCode) ^ TMPro.TMP_TextParsingUtilities.ToUpperASCIIFast(text.v[i]);
                }

                return hashCode;
            },
            /*TMPro.TMP_Text.GetStyleHashCode end.*/

            /*TMPro.TMP_Text.GetStyleHashCode$1 start.*/
            /**
             * Get Hashcode for a given tag.
             *
             * @instance
             * @private
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {TMPro.TMP_Text.TextBackingContainer}    text          
             * @param   {number}                                 index         
             * @param   {System.Int32}                           closeIndex
             * @return  {number}
             */
            GetStyleHashCode$1: function (text, index, closeIndex) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetStyleHashCode$1", this ); }

                var hashCode = 0;
                closeIndex.v = 0;

                for (var i = index; i < text.v.Capacity; i++) {
                    // Skip quote '"' character
                    if (text.v.getItem(i) === 34) {
                        continue;
                    }

                    // Break at '>'
                    if (text.v.getItem(i) === 62) {
                        closeIndex.v = i;
                        break;
                    }

                    hashCode = ((hashCode << 5) + hashCode) ^ TMPro.TMP_TextParsingUtilities.ToUpperASCIIFast(text.v.getItem(i));
                }

                return hashCode;
            },
            /*TMPro.TMP_Text.GetStyleHashCode$1 end.*/

            /*TMPro.TMP_Text.ResizeInternalArray start.*/
            /**
             * @instance
             * @private
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {Function}    T        
             * @param   {T}           array
             * @return  {void}
             */
            ResizeInternalArray: function (T, array) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#ResizeInternalArray", this ); }

                var size = UnityEngine.Mathf.NextPowerOfTwo(array.v.length + 1);

                System.Array.resize(array, size, function () {
                    return Bridge.getDefaultValue(T);
                }, T);
            },
            /*TMPro.TMP_Text.ResizeInternalArray end.*/

            /*TMPro.TMP_Text.ResizeInternalArray$1 start.*/
            ResizeInternalArray$1: function (T, array, size) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#ResizeInternalArray$1", this ); }

                size = UnityEngine.Mathf.NextPowerOfTwo(size + 1);

                System.Array.resize(array, size, function () {
                    return Bridge.getDefaultValue(T);
                }, T);
            },
            /*TMPro.TMP_Text.ResizeInternalArray$1 end.*/

            /*TMPro.TMP_Text.AddFloatToInternalTextBackingArray start.*/
            AddFloatToInternalTextBackingArray: function (value, padding, precision, writeIndex) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#AddFloatToInternalTextBackingArray", this ); }

                if (value < 0) {
                    this.m_TextBackingArray.setItem(writeIndex.v, 45);
                    writeIndex.v += 1;
                    value = -value;
                }

                // Using decimal type due to floating point precision impacting formatting
                var valueD = System.Decimal(value, null, System.Single);

                // Round up value to the specified prevision otherwise set precision to max.
                if (padding === 0 && precision === 0) {
                    precision = 9;
                } else {
                    valueD = valueD.add(this.k_Power[UnityEngine.Mathf.Min(9, precision)]);
                }

                var integer = System.Decimal.toInt(valueD, System.Int64);

                this.AddIntegerToInternalTextBackingArray(System.Int64.toNumber(integer), padding, writeIndex);

                if (precision > 0) {
                    valueD = valueD.sub(System.Decimal(integer));

                    // Add decimal point and values only if remainder is not zero.
                    if (valueD.ne(System.Decimal(0))) {
                        // Add decimal point
                        this.m_TextBackingArray.setItem(writeIndex.v++, 46);

                        for (var p = 0; p < precision; p++) {
                            valueD = valueD.mul(System.Decimal(10));
                            var d = System.Decimal.toInt(valueD, System.Int64);

                            this.m_TextBackingArray.setItem(writeIndex.v++, System.Int64.clipu16(d.add(System.Int64(48))));
                            valueD = valueD.sub(System.Decimal(d));

                            if (valueD.equalsT(System.Decimal(0))) {
                                p = precision;
                            }
                        }
                    }
                }
            },
            /*TMPro.TMP_Text.AddFloatToInternalTextBackingArray end.*/

            /*TMPro.TMP_Text.AddIntegerToInternalTextBackingArray start.*/
            /**
             * @instance
             * @private
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {number}          number        
             * @param   {number}          padding       
             * @param   {System.Int32}    writeIndex
             * @return  {void}
             */
            AddIntegerToInternalTextBackingArray: function (number, padding, writeIndex) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#AddIntegerToInternalTextBackingArray", this ); }

                var integralCount = 0;
                var i = writeIndex.v;

                do {
                    this.m_TextBackingArray.setItem(i++, number % 10 + 48);
                    number /= 10;
                    integralCount += 1;
                } while (number > 0.999999999999999 || integralCount < padding);

                var lastIndex = i;

                while (writeIndex.v + 1 < i) {
                    i -= 1;
                    var t = this.m_TextBackingArray.getItem(writeIndex.v);
                    this.m_TextBackingArray.setItem(writeIndex.v, this.m_TextBackingArray.getItem(i));
                    this.m_TextBackingArray.setItem(i, t);
                    writeIndex.v += 1;
                }

                writeIndex.v = lastIndex;
            },
            /*TMPro.TMP_Text.AddIntegerToInternalTextBackingArray end.*/

            /*TMPro.TMP_Text.InternalTextBackingArrayToString start.*/
            InternalTextBackingArrayToString: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#InternalTextBackingArrayToString", this ); }

                var array = System.Array.init(this.m_TextBackingArray.Count, 0, System.Char);

                for (var i = 0; i < this.m_TextBackingArray.Capacity; i++) {
                    var c = this.m_TextBackingArray.getItem(i);

                    if (c === 0) {
                        break;
                    }

                    array[i] = c;
                }

                this.m_IsTextBackingStringDirty = false;

                return System.String.fromCharArray(array);
            },
            /*TMPro.TMP_Text.InternalTextBackingArrayToString end.*/

            /*TMPro.TMP_Text.SetArraySizes start.*/
            /**
             * Method used to determine the number of visible characters and required buffer allocations.
             *
             * @instance
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {Array.<TMPro.TMP_Text.UnicodeChar>}    unicodeChars
             * @return  {number}
             */
            SetArraySizes: function (unicodeChars) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#SetArraySizes", this ); }

                return 0;
            },
            /*TMPro.TMP_Text.SetArraySizes end.*/

            /*TMPro.TMP_Text.GetPreferredValues start.*/
            /**
             * Function to Calculate the Preferred Width and Height of the text object.
             *
             * @instance
             * @public
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @return  {UnityEngine.Vector2}
             */
            GetPreferredValues: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetPreferredValues", this ); }

                // CALCULATE PREFERRED WIDTH
                this.m_isPreferredWidthDirty = true;
                var preferredWidth = this.GetPreferredWidth();

                // CALCULATE PREFERRED HEIGHT
                this.m_isPreferredHeightDirty = true;
                var preferredHeight = this.GetPreferredHeight();

                // Reset dirty states as we always want to recalculate preferred values when this function is called.
                this.m_isPreferredWidthDirty = true;
                this.m_isPreferredHeightDirty = true;

                return new pc.Vec2( preferredWidth, preferredHeight );
            },
            /*TMPro.TMP_Text.GetPreferredValues end.*/

            /*TMPro.TMP_Text.GetPreferredValues$1 start.*/
            /**
             * Function to Calculate the Preferred Width and Height of the text object given the provided width and height.
             *
             * @instance
             * @public
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {number}                 width     
             * @param   {number}                 height
             * @return  {UnityEngine.Vector2}
             */
            GetPreferredValues$1: function (width, height) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetPreferredValues$1", this ); }

                // Reparse input text
                this.m_isCalculatingPreferredValues = true;
                this.ParseInputText();

                var margin = new pc.Vec2( width, height );

                // CALCULATE PREFERRED WIDTH
                var preferredWidth = this.GetPreferredWidth$1(margin.$clone());

                // CALCULATE PREFERRED HEIGHT
                var preferredHeight = this.GetPreferredHeight$1(margin.$clone());

                return new pc.Vec2( preferredWidth, preferredHeight );
            },
            /*TMPro.TMP_Text.GetPreferredValues$1 end.*/

            /*TMPro.TMP_Text.GetPreferredValues$2 start.*/
            /**
             * Function to Calculate the Preferred Width and Height of the text object given a certain string.
             *
             * @instance
             * @public
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {string}                 text
             * @return  {UnityEngine.Vector2}
             */
            GetPreferredValues$2: function (text) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetPreferredValues$2", this ); }

                this.m_isCalculatingPreferredValues = true;

                this.SetTextInternal(text);
                this.SetArraySizes(this.m_TextProcessingArray);

                var margin = TMPro.TMP_Text.k_LargePositiveVector2.$clone();

                // CALCULATE PREFERRED WIDTH
                var preferredWidth = this.GetPreferredWidth$1(margin.$clone());

                // CALCULATE PREFERRED HEIGHT
                var preferredHeight = this.GetPreferredHeight$1(margin.$clone());

                return new pc.Vec2( preferredWidth, preferredHeight );
            },
            /*TMPro.TMP_Text.GetPreferredValues$2 end.*/

            /*TMPro.TMP_Text.GetPreferredValues$3 start.*/
            /**
             * Function to Calculate the Preferred Width and Height of the text object given a certain string and size of text container.
             *
             * @instance
             * @public
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {string}                 text      
             * @param   {number}                 width     
             * @param   {number}                 height
             * @return  {UnityEngine.Vector2}
             */
            GetPreferredValues$3: function (text, width, height) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetPreferredValues$3", this ); }

                this.m_isCalculatingPreferredValues = true;

                this.SetTextInternal(text);
                this.SetArraySizes(this.m_TextProcessingArray);

                var margin = new pc.Vec2( width, height );

                // CALCULATE PREFERRED WIDTH
                var preferredWidth = this.GetPreferredWidth$1(margin.$clone());

                // CALCULATE PREFERRED HEIGHT
                var preferredHeight = this.GetPreferredHeight$1(margin.$clone());

                return new pc.Vec2( preferredWidth, preferredHeight );
            },
            /*TMPro.TMP_Text.GetPreferredValues$3 end.*/

            /*TMPro.TMP_Text.GetPreferredWidth start.*/
            /**
             * Method to calculate the preferred width of a text object.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @return  {number}
             */
            GetPreferredWidth: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetPreferredWidth", this ); }

                if (TMPro.TMP_Settings.instance == null) {
                    return 0;
                }

                // Return cached preferred height if already computed
                if (!this.m_isPreferredWidthDirty) {
                    return this.m_preferredWidth;
                }

                var fontSize = { v : this.m_enableAutoSizing ? this.m_fontSizeMax : this.m_fontSize };

                // Reset auto sizing point size bounds
                this.m_minFontSize = this.m_fontSizeMin;
                this.m_maxFontSize = this.m_fontSizeMax;
                this.m_charWidthAdjDelta = 0;

                // Set Margins to Infinity
                var margin = TMPro.TMP_Text.k_LargePositiveVector2.$clone();

                this.m_isCalculatingPreferredValues = true;
                this.ParseInputText();

                this.m_AutoSizeIterationCount = 0;
                var preferredWidth = this.CalculatePreferredValues(fontSize, margin.$clone(), false, false).x;

                this.m_isPreferredWidthDirty = false;

                //Debug.Log("GetPreferredWidth() called on Object ID: " + GetInstanceID() + " on frame: " + Time.frameCount + ". Returning width of " + preferredWidth);

                return preferredWidth;
            },
            /*TMPro.TMP_Text.GetPreferredWidth end.*/

            /*TMPro.TMP_Text.GetPreferredWidth$1 start.*/
            /**
             * Method to calculate the preferred width of a text object.
             *
             * @instance
             * @private
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {UnityEngine.Vector2}    margin
             * @return  {number}
             */
            GetPreferredWidth$1: function (margin) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetPreferredWidth$1", this ); }

                var fontSize = { v : this.m_enableAutoSizing ? this.m_fontSizeMax : this.m_fontSize };

                // Reset auto sizing point size bounds
                this.m_minFontSize = this.m_fontSizeMin;
                this.m_maxFontSize = this.m_fontSizeMax;
                this.m_charWidthAdjDelta = 0;

                this.m_AutoSizeIterationCount = 0;
                var preferredWidth = this.CalculatePreferredValues(fontSize, margin.$clone(), false, false).x;

                //Debug.Log("GetPreferredWidth() Called. Returning width of " + preferredWidth);

                return preferredWidth;
            },
            /*TMPro.TMP_Text.GetPreferredWidth$1 end.*/

            /*TMPro.TMP_Text.GetPreferredHeight start.*/
            /**
             * Method to calculate the preferred height of a text object.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @return  {number}
             */
            GetPreferredHeight: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetPreferredHeight", this ); }

                if (TMPro.TMP_Settings.instance == null) {
                    return 0;
                }

                // Return cached preferred height if already computed
                if (!this.m_isPreferredHeightDirty) {
                    return this.m_preferredHeight;
                }

                var fontSize = { v : this.m_enableAutoSizing ? this.m_fontSizeMax : this.m_fontSize };

                // Reset auto sizing point size bounds
                this.m_minFontSize = this.m_fontSizeMin;
                this.m_maxFontSize = this.m_fontSizeMax;
                this.m_charWidthAdjDelta = 0;

                var margin = new pc.Vec2( this.m_marginWidth !== 0 ? this.m_marginWidth : TMPro.TMP_Text.k_LargePositiveFloat, TMPro.TMP_Text.k_LargePositiveFloat );

                this.m_isCalculatingPreferredValues = true;
                this.ParseInputText();

                // Reset Text Auto Size iteration tracking.
                this.m_IsAutoSizePointSizeSet = false;
                this.m_AutoSizeIterationCount = 0;

                // The CalculatePreferredValues function is potentially called repeatedly when text auto size is enabled.
                // This is a revised implementation to remove the use of recursion which could potentially result in stack overflow issues.
                var preferredHeight = 0;

                while (this.m_IsAutoSizePointSizeSet === false) {
                    preferredHeight = this.CalculatePreferredValues(fontSize, margin.$clone(), this.m_enableAutoSizing, this.m_enableWordWrapping).y;
                    this.m_AutoSizeIterationCount += 1;
                }

                this.m_isPreferredHeightDirty = false;

                //Debug.Log("GetPreferredHeight() called on Object ID: " + GetInstanceID() + " on frame: " + Time.frameCount +". Returning height of " + preferredHeight);

                return preferredHeight;
            },
            /*TMPro.TMP_Text.GetPreferredHeight end.*/

            /*TMPro.TMP_Text.GetPreferredHeight$1 start.*/
            /**
             * Method to calculate the preferred height of a text object.
             *
             * @instance
             * @private
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {UnityEngine.Vector2}    margin
             * @return  {number}
             */
            GetPreferredHeight$1: function (margin) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetPreferredHeight$1", this ); }

                var fontSize = { v : this.m_enableAutoSizing ? this.m_fontSizeMax : this.m_fontSize };

                // Reset auto sizing point size bounds
                this.m_minFontSize = this.m_fontSizeMin;
                this.m_maxFontSize = this.m_fontSizeMax;
                this.m_charWidthAdjDelta = 0;

                // Reset Text Auto Size iteration tracking.
                this.m_IsAutoSizePointSizeSet = false;
                this.m_AutoSizeIterationCount = 0;

                // The CalculatePreferredValues function is potentially called repeatedly when text auto size is enabled.
                // This is a revised implementation to remove the use of recursion which could potentially result in stack overflow issues.
                var preferredHeight = 0;

                while (this.m_IsAutoSizePointSizeSet === false) {
                    preferredHeight = this.CalculatePreferredValues(fontSize, margin.$clone(), this.m_enableAutoSizing, this.m_enableWordWrapping).y;
                    this.m_AutoSizeIterationCount += 1;
                }

                //Debug.Log("GetPreferredHeight() Called. Returning height of " + preferredHeight);

                return preferredHeight;
            },
            /*TMPro.TMP_Text.GetPreferredHeight$1 end.*/

            /*TMPro.TMP_Text.GetRenderedValues start.*/
            /**
             * Method returning the rendered width and height of the text object.
             *
             * @instance
             * @public
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @return  {UnityEngine.Vector2}
             */
            GetRenderedValues: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetRenderedValues", this ); }

                return UnityEngine.Vector2.FromVector3(this.GetTextBounds().halfExtents.$clone().scale( 2 ).$clone());
            },
            /*TMPro.TMP_Text.GetRenderedValues end.*/

            /*TMPro.TMP_Text.GetRenderedValues$1 start.*/
            /**
             * @instance
             * @public
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {boolean}                onlyVisibleCharacters    Should returned value only factor in visible characters and exclude those greater than maxVisibleCharacters for instance.
             * @return  {UnityEngine.Vector2}
             */
            GetRenderedValues$1: function (onlyVisibleCharacters) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetRenderedValues$1", this ); }

                return UnityEngine.Vector2.FromVector3(this.GetTextBounds$1(onlyVisibleCharacters).halfExtents.$clone().scale( 2 ).$clone());
            },
            /*TMPro.TMP_Text.GetRenderedValues$1 end.*/

            /*TMPro.TMP_Text.GetRenderedWidth$1 start.*/
            /**
             * Method returning the rendered width of the text object.
             *
             * @instance
             * @private
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @return  {number}
             */
            GetRenderedWidth$1: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetRenderedWidth$1", this ); }

                return this.GetRenderedValues().x;
            },
            /*TMPro.TMP_Text.GetRenderedWidth$1 end.*/

            /*TMPro.TMP_Text.GetRenderedWidth start.*/
            /**
             * Method returning the rendered width of the text object.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {boolean}    onlyVisibleCharacters
             * @return  {number}
             */
            GetRenderedWidth: function (onlyVisibleCharacters) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetRenderedWidth", this ); }

                return this.GetRenderedValues$1(onlyVisibleCharacters).x;
            },
            /*TMPro.TMP_Text.GetRenderedWidth end.*/

            /*TMPro.TMP_Text.GetRenderedHeight$1 start.*/
            /**
             * Method returning the rendered height of the text object.
             *
             * @instance
             * @private
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @return  {number}
             */
            GetRenderedHeight$1: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetRenderedHeight$1", this ); }

                return this.GetRenderedValues().y;
            },
            /*TMPro.TMP_Text.GetRenderedHeight$1 end.*/

            /*TMPro.TMP_Text.GetRenderedHeight start.*/
            /**
             * Method returning the rendered height of the text object.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {boolean}    onlyVisibleCharacters
             * @return  {number}
             */
            GetRenderedHeight: function (onlyVisibleCharacters) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetRenderedHeight", this ); }

                return this.GetRenderedValues$1(onlyVisibleCharacters).y;
            },
            /*TMPro.TMP_Text.GetRenderedHeight end.*/

            /*TMPro.TMP_Text.CalculatePreferredValues start.*/
            /**
             * Method to calculate the preferred width and height of the text object.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {System.Single}          fontSize                   
             * @param   {UnityEngine.Vector2}    marginSize                 
             * @param   {boolean}                isTextAutoSizingEnabled    
             * @param   {boolean}                isWordWrappingEnabled
             * @return  {UnityEngine.Vector2}
             */
            CalculatePreferredValues: function (fontSize, marginSize, isTextAutoSizingEnabled, isWordWrappingEnabled) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#CalculatePreferredValues", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5;
                //Debug.Log("*** CalculatePreferredValues() ***"); // ***** Frame: " + Time.frameCount);

                // Early exit if no font asset was assigned. This should not be needed since LiberationSans SDF will be assigned by default.
                if (this.m_fontAsset == null || this.m_fontAsset.characterLookupTable == null) {
                    UnityEngine.Debug.LogWarning$1("Can't Generate Mesh! No Font Asset has been assigned to Object ID: " + this.GetInstanceID());

                    this.m_IsAutoSizePointSizeSet = true;
                    return pc.Vec2.ZERO.clone();
                }

                // Early exit if we don't have any Text to generate.
                if (this.m_TextProcessingArray == null || this.m_TextProcessingArray.length === 0 || this.m_TextProcessingArray[0].unicode === 0) {
                    this.m_IsAutoSizePointSizeSet = true;
                    return pc.Vec2.ZERO.clone();
                }

                this.m_currentFontAsset = this.m_fontAsset;
                this.m_currentMaterial = this.m_sharedMaterial;
                this.m_currentMaterialIndex = 0;
                TMPro.TMP_Text.m_materialReferenceStack.SetDefault(new TMPro.MaterialReference.$ctor1(0, this.m_currentFontAsset, null, this.m_currentMaterial, this.m_padding));

                // Total character count is computed when the text is parsed.
                var totalCharacterCount = this.m_totalCharacterCount; // m_VisibleCharacters.Count;

                if (this.m_internalCharacterInfo == null || totalCharacterCount > this.m_internalCharacterInfo.length) {
                    this.m_internalCharacterInfo = System.Array.init(totalCharacterCount > 1024 ? totalCharacterCount + 256 : UnityEngine.Mathf.NextPowerOfTwo(totalCharacterCount), function (){
                        return new TMPro.TMP_CharacterInfo();
                    }, TMPro.TMP_CharacterInfo);
                }

                // Calculate the scale of the font based on selected font size and sampling point size.
                // baseScale is calculated using the font asset assigned to the text object.
                var baseScale = fontSize.v / this.m_fontAsset.faceInfo.pointSize * this.m_fontAsset.faceInfo.scale * (this.m_isOrthographic ? 1 : 0.1);
                var currentElementScale = baseScale;
                var currentEmScale = fontSize.v * 0.01 * (this.m_isOrthographic ? 1 : 0.1);
                this.m_fontScaleMultiplier = 1;

                this.m_currentFontSize = fontSize.v;
                this.m_sizeStack.SetDefault(this.m_currentFontSize);
                var fontSizeDelta = 0;

                this.m_FontStyleInternal = this.m_fontStyle; // Set the default style.

                this.m_lineJustification = this.m_HorizontalAlignment; // m_textAlignment; // Sets the line justification mode to match editor alignment.
                this.m_lineJustificationStack.SetDefault(this.m_lineJustification);

                this.m_baselineOffset = 0; // Used by subscript characters.
                this.m_baselineOffsetStack.Clear();

                this.m_lineOffset = 0; // Amount of space between lines (font line spacing + m_linespacing).
                this.m_lineHeight = TMPro.TMP_Math.FLOAT_UNSET;
                var lineGap = this.m_currentFontAsset.faceInfo.lineHeight - (this.m_currentFontAsset.faceInfo.ascentLine - this.m_currentFontAsset.faceInfo.descentLine);

                this.m_cSpacing = 0; // Amount of space added between characters as a result of the use of the <cspace> tag.
                this.m_monoSpacing = 0;
                //float lineOffsetDelta = 0;
                this.m_xAdvance = 0; // Used to track the position of each character.
                var maxXAdvance = 0; // Used to determine Preferred Width.

                this.tag_LineIndent = 0; // Used for indentation of text.
                this.tag_Indent = 0;
                this.m_indentStack.SetDefault(0);
                this.tag_NoParsing = false;
                //m_isIgnoringAlignment = false;

                this.m_characterCount = 0; // Total characters in the char[]


                // Tracking of line information
                this.m_firstCharacterOfLine = 0;
                this.m_maxLineAscender = TMPro.TMP_Text.k_LargeNegativeFloat;
                this.m_maxLineDescender = TMPro.TMP_Text.k_LargePositiveFloat;
                this.m_lineNumber = 0;
                this.m_startOfLineAscender = 0;
                this.m_IsDrivenLineSpacing = false;

                var marginWidth = marginSize.x;
                var marginHeight = marginSize.y;
                this.m_marginLeft = 0;
                this.m_marginRight = 0;

                var lineMarginLeft = 0;
                var lineMarginRight = 0;

                this.m_width = -1;
                var widthOfTextArea = marginWidth + 0.0001 - this.m_marginLeft - this.m_marginRight;

                // Used by Unity's Auto Layout system.
                var renderedWidth = 0;
                var renderedHeight = 0;
                var textWidth = 0;
                this.m_isCalculatingPreferredValues = true;

                // Tracking of the highest Ascender
                this.m_maxCapHeight = 0;
                this.m_maxTextAscender = 0;
                this.m_ElementDescender = 0;
                var maxVisibleDescender = 0;
                var isMaxVisibleDescenderSet = false;

                // Initialize struct to track states of word wrapping
                var isFirstWordOfLine = true;
                this.m_isNonBreakingSpace = false;
                //bool isLastBreakingChar = false;
                var isLastCharacterCJK = false;
                //int lastSoftLineBreak = 0;

                var characterToSubstitute = new TMPro.TMP_Text.CharacterSubstitution.$ctor1(-1, 0);
                var isSoftHyphenIgnored = false;

                var internalWordWrapState = { v : new TMPro.WordWrapState() };
                var internalLineState = { v : new TMPro.WordWrapState() };
                var internalSoftLineBreak = { v : new TMPro.WordWrapState() };

                var characterInfo = new TMPro.TMP_CharacterInfo();
                var internalCharacterInfo = new TMPro.TMP_CharacterInfo();

                // Counter to prevent recursive lockup when computing preferred values.
                this.m_AutoSizeIterationCount += 1;

                // Parse through Character buffer to read HTML tags and begin creating mesh.
                for (var i = 0; i < this.m_TextProcessingArray.length && this.m_TextProcessingArray[i].unicode !== 0; i++) {
                    var charCode = this.m_TextProcessingArray[i].unicode;

                    characterInfo = this.m_textInfo.characterInfo[ this.m_characterCount ];
                    internalCharacterInfo = this.m_internalCharacterInfo[ this.m_characterCount ];

                    // Parse Rich Text Tag


                    if (this.m_isRichText && charCode === 60) {
                        this.m_isParsingText = true;
                        this.m_textElementType = TMPro.TMP_TextElementType.Character;
                        var endTagIndex = { };

                        // Check if Tag is valid. If valid, skip to the end of the validated tag.
                        if (this.ValidateHtmlTag(this.m_TextProcessingArray, i + 1, endTagIndex)) {
                            i = endTagIndex.v;

                            // Continue to next character or handle the sprite element
                            if (this.m_textElementType === TMPro.TMP_TextElementType.Character) {
                                continue;
                            }
                        }
                    } else {
                        this.m_textElementType = characterInfo.elementType;
                        this.m_currentMaterialIndex = characterInfo.materialReferenceIndex;
                        this.m_currentFontAsset = characterInfo.fontAsset;
                    }


                    var prev_MaterialIndex = this.m_currentMaterialIndex;
                    var isUsingAltTypeface = characterInfo.isUsingAlternateTypeface;

                    this.m_isParsingText = false;

                    // Handle potential character substitutions


                    var isInjectingCharacter = false;

                    if (characterToSubstitute.index === this.m_characterCount) {
                        charCode = characterToSubstitute.unicode;
                        this.m_textElementType = TMPro.TMP_TextElementType.Character;
                        isInjectingCharacter = true;

                        switch (charCode) {
                            case 3: 
                                internalCharacterInfo.textElement = this.m_currentFontAsset.characterLookupTable.getItem(3);
                                this.m_isTextTruncated = true;
                                break;
                            case 45: 
                                //
                                break;
                            case 8230: 
                                internalCharacterInfo.textElement = this.m_Ellipsis.character;
                                internalCharacterInfo.elementType = TMPro.TMP_TextElementType.Character;
                                internalCharacterInfo.fontAsset = this.m_Ellipsis.fontAsset;
                                internalCharacterInfo.material = this.m_Ellipsis.material;
                                internalCharacterInfo.materialReferenceIndex = this.m_Ellipsis.materialIndex;
                                // Indicates the source parsing data has been modified.
                                this.m_isTextTruncated = true;
                                // End Of Text
                                characterToSubstitute.index = this.m_characterCount + 1;
                                characterToSubstitute.unicode = 3;
                                break;
                        }
                    }



                    // When using Linked text, mark character as ignored and skip to next character.


                    if (this.m_characterCount < this.m_firstVisibleCharacter && charCode !== 3) {
                        internalCharacterInfo.isVisible = false;
                        internalCharacterInfo.character = 8203;
                        internalCharacterInfo.lineNumber = 0;
                        this.m_characterCount += 1;
                        continue;
                    }



                    // Handle Font Styles like LowerCase, UpperCase and SmallCaps.


                    var smallCapsMultiplier = 1.0;

                    if (this.m_textElementType === TMPro.TMP_TextElementType.Character) {
                        if ((this.m_FontStyleInternal & TMPro.FontStyles.UpperCase) === TMPro.FontStyles.UpperCase) {
                            // If this character is lowercase, switch to uppercase.
                            if (Bridge.isLower(charCode)) {
                                charCode = String.fromCharCode(charCode).toUpperCase().charCodeAt(0);
                            }
                        } else if ((this.m_FontStyleInternal & TMPro.FontStyles.LowerCase) === TMPro.FontStyles.LowerCase) {
                            // If this character is uppercase, switch to lowercase.
                            if (Bridge.isUpper(charCode)) {
                                charCode = String.fromCharCode(charCode).toLowerCase().charCodeAt(0);
                            }
                        } else if ((this.m_FontStyleInternal & TMPro.FontStyles.SmallCaps) === TMPro.FontStyles.SmallCaps) {
                            if (Bridge.isLower(charCode)) {
                                smallCapsMultiplier = 0.8;
                                charCode = String.fromCharCode(charCode).toUpperCase().charCodeAt(0);
                            }
                        }
                    }



                    // Look up Character Data from Dictionary and cache it.


                    //float baselineOffset = 0;
                    var elementAscentLine = 0;
                    var elementDescentLine = 0;
                    if (this.m_textElementType === TMPro.TMP_TextElementType.Sprite) {
                        // If a sprite is used as a fallback then get a reference to it and set the color to white.
                        this.m_currentSpriteAsset = ($t = this.m_textInfo.characterInfo)[this.m_characterCount].spriteAsset;
                        this.m_spriteIndex = ($t1 = this.m_textInfo.characterInfo)[this.m_characterCount].spriteIndex;

                        var sprite = this.m_currentSpriteAsset.spriteCharacterTable.getItem(this.m_spriteIndex);
                        if (sprite == null) {
                            continue;
                        }

                        // Sprites are assigned in the E000 Private Area + sprite Index
                        if (charCode === 60) {
                            charCode = 57344 + this.m_spriteIndex;
                        }

                        // The sprite scale calculations are based on the font asset assigned to the text object.
                        if (this.m_currentSpriteAsset.faceInfo.pointSize > 0) {
                            var spriteScale = this.m_currentFontSize / this.m_currentSpriteAsset.faceInfo.pointSize * this.m_currentSpriteAsset.faceInfo.scale * (this.m_isOrthographic ? 1 : 0.1);
                            currentElementScale = sprite.scale * sprite.glyph.scale * spriteScale;
                            elementAscentLine = this.m_currentSpriteAsset.faceInfo.ascentLine;
                            //baselineOffset = m_currentSpriteAsset.faceInfo.baseline * m_fontScale * m_fontScaleMultiplier * m_currentSpriteAsset.faceInfo.scale;
                            elementDescentLine = this.m_currentSpriteAsset.faceInfo.descentLine;
                        } else {
                            var spriteScale1 = this.m_currentFontSize / this.m_currentFontAsset.faceInfo.pointSize * this.m_currentFontAsset.faceInfo.scale * (this.m_isOrthographic ? 1 : 0.1);
                            currentElementScale = this.m_currentFontAsset.faceInfo.ascentLine / sprite.glyph.metrics.height * sprite.scale * sprite.glyph.scale * spriteScale1;
                            var scaleDelta = spriteScale1 / currentElementScale;
                            elementAscentLine = this.m_currentFontAsset.faceInfo.ascentLine * scaleDelta;
                            //baselineOffset = m_currentFontAsset.faceInfo.baseline * m_fontScale * m_fontScaleMultiplier * m_currentFontAsset.faceInfo.scale;
                            elementDescentLine = this.m_currentFontAsset.faceInfo.descentLine * scaleDelta;
                        }

                        this.m_cached_TextElement = sprite;

                        internalCharacterInfo.elementType = TMPro.TMP_TextElementType.Sprite;
                        internalCharacterInfo.scale = currentElementScale;

                        this.m_currentMaterialIndex = prev_MaterialIndex;
                    } else if (this.m_textElementType === TMPro.TMP_TextElementType.Character) {
                        this.m_cached_TextElement = characterInfo.textElement;
                        if (this.m_cached_TextElement == null) {
                            continue;
                        }

                        this.m_currentMaterialIndex = ($t2 = this.m_textInfo.characterInfo)[this.m_characterCount].materialReferenceIndex;

                        var adjustedScale;
                        if (isInjectingCharacter && this.m_TextProcessingArray[i].unicode === 10 && this.m_characterCount !== this.m_firstCharacterOfLine) {
                            adjustedScale = ($t3 = this.m_textInfo.characterInfo)[this.m_characterCount - 1].pointSize * smallCapsMultiplier / this.m_currentFontAsset.m_FaceInfo.pointSize * this.m_currentFontAsset.m_FaceInfo.scale * (this.m_isOrthographic ? 1 : 0.1);
                        } else {
                            adjustedScale = this.m_currentFontSize * smallCapsMultiplier / this.m_currentFontAsset.m_FaceInfo.pointSize * this.m_currentFontAsset.m_FaceInfo.scale * (this.m_isOrthographic ? 1 : 0.1);
                        }

                        // Special handling for injected Ellipsis
                        if (isInjectingCharacter && charCode === 8230) {
                            elementAscentLine = 0;
                            elementDescentLine = 0;
                        } else {
                            elementAscentLine = this.m_currentFontAsset.m_FaceInfo.ascentLine;
                            elementDescentLine = this.m_currentFontAsset.m_FaceInfo.descentLine;
                        }

                        currentElementScale = adjustedScale * this.m_fontScaleMultiplier * this.m_cached_TextElement.scale;
                        //baselineOffset = m_currentFontAsset.faceInfo.baseline * m_fontScale * m_fontScaleMultiplier * m_currentFontAsset.faceInfo.scale;

                        this.m_internalCharacterInfo[this.m_characterCount].elementType = TMPro.TMP_TextElementType.Character;
                    }



                    // Handle Soft Hyphen


                    var currentElementUnmodifiedScale = currentElementScale;
                    if (charCode === 173 || charCode === 3) {
                        currentElementScale = 0;
                    }



                    // Store some of the text object's information
                    internalCharacterInfo.character = charCode;

                    // Cache glyph metrics
                    var currentGlyphMetrics = this.m_cached_TextElement.m_Glyph.metrics.$clone();

                    // Optimization to avoid calling this more than once per character.
                    var isWhiteSpace = charCode <= 65535 && System.Char.isWhiteSpace(String.fromCharCode(charCode));


                    // Handle Kerning if Enabled.


                    var glyphAdjustments = new TMPro.TMP_GlyphValueRecord.ctor();
                    var characterSpacingAdjustment = this.m_characterSpacing;
                    this.m_GlyphHorizontalAdvanceAdjustment = 0;
                    if (this.m_enableKerning) {
                        var adjustmentPair = { };
                        var baseGlyphIndex = this.m_cached_TextElement.m_GlyphIndex;

                        if (this.m_characterCount < totalCharacterCount - 1) {
                            var nextGlyphIndex = ($t4 = this.m_textInfo.characterInfo)[this.m_characterCount + 1].textElement.m_GlyphIndex;
                            var key = (nextGlyphIndex << 16) | baseGlyphIndex;

                            if (this.m_currentFontAsset.m_FontFeatureTable.m_GlyphPairAdjustmentRecordLookupDictionary.tryGetValue(key, adjustmentPair)) {
                                glyphAdjustments = adjustmentPair.v.m_FirstAdjustmentRecord.m_GlyphValueRecord.$clone();
                                characterSpacingAdjustment = (adjustmentPair.v.m_FeatureLookupFlags & TMPro.FontFeatureLookupFlags.IgnoreSpacingAdjustments) === TMPro.FontFeatureLookupFlags.IgnoreSpacingAdjustments ? 0 : characterSpacingAdjustment;
                            }
                        }

                        if (this.m_characterCount >= 1) {
                            var previousGlyphIndex = ($t5 = this.m_textInfo.characterInfo)[this.m_characterCount - 1].textElement.m_GlyphIndex;
                            var key1 = (baseGlyphIndex << 16) | previousGlyphIndex;

                            if (this.m_currentFontAsset.m_FontFeatureTable.m_GlyphPairAdjustmentRecordLookupDictionary.tryGetValue(key1, adjustmentPair)) {
                                glyphAdjustments = TMPro.TMP_GlyphValueRecord.op_Addition(glyphAdjustments.$clone(), adjustmentPair.v.m_SecondAdjustmentRecord.m_GlyphValueRecord.$clone());
                                characterSpacingAdjustment = (adjustmentPair.v.m_FeatureLookupFlags & TMPro.FontFeatureLookupFlags.IgnoreSpacingAdjustments) === TMPro.FontFeatureLookupFlags.IgnoreSpacingAdjustments ? 0 : characterSpacingAdjustment;
                            }
                        }

                        this.m_GlyphHorizontalAdvanceAdjustment = glyphAdjustments.m_XAdvance;
                    }



                    // Initial Implementation for RTL support.


                    //if (m_isRightToLeft)
                    //{
                    //    m_xAdvance -= ((m_cached_TextElement.xAdvance * bold_xAdvance_multiplier + m_characterSpacing + m_wordSpacing + m_currentFontAsset.normalSpacingOffset) * currentElementScale + m_cSpacing) * (1 - m_charWidthAdjDelta);

                    //    if (char.IsWhiteSpace((char)charCode) || charCode == 0x200B)
                    //        m_xAdvance -= m_wordSpacing * currentElementScale;
                    //}



                    // Handle Mono Spacing


                    var monoAdvance = 0;
                    if (this.m_monoSpacing !== 0) {
                        monoAdvance = (this.m_monoSpacing / 2 - (this.m_cached_TextElement.glyph.metrics.width / 2 + this.m_cached_TextElement.glyph.metrics.horizontalBearingX) * currentElementScale) * (1 - this.m_charWidthAdjDelta);
                        this.m_xAdvance += monoAdvance;
                    }



                    // Set Padding based on selected font style


                    var boldSpacingAdjustment = 0;
                    if (this.m_textElementType === TMPro.TMP_TextElementType.Character && !isUsingAltTypeface && (this.m_FontStyleInternal & TMPro.FontStyles.Bold) === TMPro.FontStyles.Bold) {
                        boldSpacingAdjustment = this.m_currentFontAsset.boldSpacing;
                    }


                    internalCharacterInfo.baseLine = 0 - this.m_lineOffset + this.m_baselineOffset;

                    // Compute text metrics


                    // Element Ascender in line space
                    var elementAscender = this.m_textElementType === TMPro.TMP_TextElementType.Character ? elementAscentLine * currentElementScale / smallCapsMultiplier + this.m_baselineOffset : elementAscentLine * currentElementScale + this.m_baselineOffset;

                    // Element Descender in line space
                    var elementDescender = this.m_textElementType === TMPro.TMP_TextElementType.Character ? elementDescentLine * currentElementScale / smallCapsMultiplier + this.m_baselineOffset : elementDescentLine * currentElementScale + this.m_baselineOffset;

                    var adjustedAscender = elementAscender;
                    var adjustedDescender = elementDescender;

                    var isFirstCharacterOfLine = this.m_characterCount === this.m_firstCharacterOfLine;
                    // Max line ascender and descender in line space
                    if (isFirstCharacterOfLine || isWhiteSpace === false) {
                        // Special handling for Superscript and Subscript where we use the unadjusted line ascender and descender
                        if (this.m_baselineOffset !== 0) {
                            adjustedAscender = UnityEngine.Mathf.Max((elementAscender - this.m_baselineOffset) / this.m_fontScaleMultiplier, adjustedAscender);
                            adjustedDescender = UnityEngine.Mathf.Min((elementDescender - this.m_baselineOffset) / this.m_fontScaleMultiplier, adjustedDescender);
                        }

                        this.m_maxLineAscender = UnityEngine.Mathf.Max(adjustedAscender, this.m_maxLineAscender);
                        this.m_maxLineDescender = UnityEngine.Mathf.Min(adjustedDescender, this.m_maxLineDescender);
                    }

                    // Element Ascender and Descender in object space
                    if (isFirstCharacterOfLine || isWhiteSpace === false) {
                        internalCharacterInfo.adjustedAscender = adjustedAscender;
                        internalCharacterInfo.adjustedDescender = adjustedDescender;

                        this.m_ElementAscender = (internalCharacterInfo.ascender = elementAscender - this.m_lineOffset);
                        this.m_ElementDescender = (internalCharacterInfo.descender = elementDescender - this.m_lineOffset);
                    } else {
                        internalCharacterInfo.adjustedAscender = this.m_maxLineAscender;
                        internalCharacterInfo.adjustedDescender = this.m_maxLineDescender;

                        this.m_ElementAscender = (internalCharacterInfo.ascender = this.m_maxLineAscender - this.m_lineOffset);
                        this.m_ElementDescender = (internalCharacterInfo.descender = this.m_maxLineDescender - this.m_lineOffset);
                    }

                    // Max text object ascender and cap height
                    if (this.m_lineNumber === 0 || this.m_isNewPage) {
                        if (isFirstCharacterOfLine || isWhiteSpace === false) {
                            this.m_maxTextAscender = this.m_maxLineAscender;
                            this.m_maxCapHeight = UnityEngine.Mathf.Max(this.m_maxCapHeight, this.m_currentFontAsset.m_FaceInfo.capLine * currentElementScale / smallCapsMultiplier);
                        }
                    }

                    // Page ascender
                    if (this.m_lineOffset === 0) {
                        if (!isWhiteSpace || this.m_characterCount === this.m_firstCharacterOfLine) {
                            this.m_PageAscender = this.m_PageAscender > elementAscender ? this.m_PageAscender : elementAscender;
                        }
                    }


                    var isJustifiedOrFlush = (this.m_lineJustification & TMPro.HorizontalAlignmentOptions.Flush) === TMPro.HorizontalAlignmentOptions.Flush || (this.m_lineJustification & TMPro.HorizontalAlignmentOptions.Justified) === TMPro.HorizontalAlignmentOptions.Justified;

                    // Setup Mesh for visible text elements. ie. not a SPACE / LINEFEED / CARRIAGE RETURN.


                    if (charCode === 9 || isWhiteSpace === false && charCode !== 8203 && charCode !== 173 && charCode !== 3 || charCode === 173 && isSoftHyphenIgnored === false || this.m_textElementType === TMPro.TMP_TextElementType.Sprite) {
                        //float marginLeft = m_marginLeft;
                        //float marginRight = m_marginRight;

                        // Injected characters do not override margins
                        //if (isInjectingCharacter)
                        //{
                        //    marginLeft = m_textInfo.lineInfo[m_lineNumber].marginLeft;
                        //    marginRight = m_textInfo.lineInfo[m_lineNumber].marginRight;
                        //}

                        widthOfTextArea = this.m_width !== -1 ? UnityEngine.Mathf.Min(marginWidth + 0.0001 - this.m_marginLeft - this.m_marginRight, this.m_width) : marginWidth + 0.0001 - this.m_marginLeft - this.m_marginRight;

                        // Calculate the line breaking width of the text.
                        textWidth = Math.abs(this.m_xAdvance) + currentGlyphMetrics.horizontalAdvance * (1 - this.m_charWidthAdjDelta) * (charCode === 173 ? currentElementUnmodifiedScale : currentElementScale);

                        var testedCharacterCount = this.m_characterCount;

                        // Handling of Horizontal Bounds


                        if (textWidth > widthOfTextArea * (isJustifiedOrFlush ? 1.05 : 1.0)) {
                            // Handle Line Breaking (if still possible)
                            if (isWordWrappingEnabled && this.m_characterCount !== this.m_firstCharacterOfLine) {
                                // Restore state to previous safe line breaking
                                i = this.RestoreWordWrappingState(internalWordWrapState);

                                // Replace Soft Hyphen by Hyphen Minus 0x2D


                                if (this.m_internalCharacterInfo[ this.m_characterCount - 1 ].character === 173 && isSoftHyphenIgnored === false && this.m_overflowMode === TMPro.TextOverflowModes.Overflow) {
                                    characterToSubstitute.index = this.m_characterCount - 1;
                                    characterToSubstitute.unicode = 45;

                                    i -= 1;
                                    this.m_characterCount -= 1;
                                    continue;
                                }

                                isSoftHyphenIgnored = false;

                                // Ignore Soft Hyphen to prevent it from wrapping
                                if (internalCharacterInfo.character === 173) {
                                    isSoftHyphenIgnored = true;
                                    continue;
                                }


                                // Adjust character spacing before breaking up word if auto size is enabled


                                if (isTextAutoSizingEnabled && isFirstWordOfLine) {
                                    // Handle Character Width Adjustments


                                    if (this.m_charWidthAdjDelta < this.m_charWidthMaxAdj / 100 && this.m_AutoSizeIterationCount < this.m_AutoSizeMaxIterationCount) {
                                        var adjustedTextWidth = textWidth;

                                        // Determine full width of the text
                                        if (this.m_charWidthAdjDelta > 0) {
                                            adjustedTextWidth /= 1.0 - this.m_charWidthAdjDelta;
                                        }

                                        var adjustmentDelta = textWidth - (widthOfTextArea - 0.0001) * (isJustifiedOrFlush ? 1.05 : 1.0);
                                        this.m_charWidthAdjDelta += adjustmentDelta / adjustedTextWidth;
                                        this.m_charWidthAdjDelta = UnityEngine.Mathf.Min(this.m_charWidthAdjDelta, this.m_charWidthMaxAdj / 100);

                                        //Debug.Log("[" + m_AutoSizeIterationCount + "] Reducing Character Width by " + (m_charWidthAdjDelta * 100) + "%");
                                        return pc.Vec2.ZERO.clone();
                                    }


                                    // Handle Text Auto-sizing resulting from text exceeding vertical bounds.


                                    if (fontSize.v > this.m_fontSizeMin && this.m_AutoSizeIterationCount < this.m_AutoSizeMaxIterationCount) {
                                        this.m_maxFontSize = fontSize.v;

                                        var sizeDelta = UnityEngine.Mathf.Max((fontSize.v - this.m_minFontSize) / 2, 0.05);
                                        fontSize.v -= sizeDelta;
                                        fontSize.v = UnityEngine.Mathf.Max((fontSize.v * 20 + 0.5) / 20.0, this.m_fontSizeMin);

                                        //Debug.Log("[" + m_AutoSizeIterationCount + "] Reducing Point Size from [" + m_maxFontSize.ToString("f3") + "] to [" + m_fontSize.ToString("f3") + "] with delta of [" + sizeDelta.ToString("f3") + "].");
                                        return pc.Vec2.ZERO.clone();
                                    }

                                }


                                // Adjust line spacing if necessary
                                var baselineAdjustmentDelta = this.m_maxLineAscender - this.m_startOfLineAscender;
                                if (this.m_lineOffset > 0 && Math.abs(baselineAdjustmentDelta) > 0.01 && this.m_IsDrivenLineSpacing === false && !this.m_isNewPage) {
                                    //AdjustLineOffset(m_firstCharacterOfLine, m_characterCount, baselineAdjustmentDelta);
                                    this.m_ElementDescender -= baselineAdjustmentDelta;
                                    this.m_lineOffset += baselineAdjustmentDelta;
                                }

                                // Calculate line ascender and make sure if last character is superscript or subscript that we check that as well.
                                var lineAscender = this.m_maxLineAscender - this.m_lineOffset;
                                var lineDescender = this.m_maxLineDescender - this.m_lineOffset;

                                // Update maxDescender and maxVisibleDescender
                                this.m_ElementDescender = this.m_ElementDescender < lineDescender ? this.m_ElementDescender : lineDescender;
                                if (!isMaxVisibleDescenderSet) {
                                    maxVisibleDescender = this.m_ElementDescender;
                                }

                                if (this.m_useMaxVisibleDescender && (this.m_characterCount >= this.m_maxVisibleCharacters || this.m_lineNumber >= this.m_maxVisibleLines)) {
                                    isMaxVisibleDescenderSet = true;
                                }

                                // Store first character of the next line.
                                this.m_firstCharacterOfLine = this.m_characterCount;
                                this.m_lineVisibleCharacterCount = 0;

                                // Compute Preferred Width & Height
                                renderedWidth += this.m_xAdvance;

                                if (isWordWrappingEnabled) {
                                    renderedHeight = this.m_maxTextAscender - this.m_ElementDescender;
                                } else {
                                    renderedHeight = UnityEngine.Mathf.Max(renderedHeight, lineAscender - lineDescender);
                                }

                                // Store the state of the line before starting on the new line.
                                this.SaveWordWrappingState(internalLineState, i, this.m_characterCount - 1);

                                this.m_lineNumber += 1;

                                var ascender = internalCharacterInfo.adjustedAscender;

                                // Compute potential new line offset in the event a line break is needed.
                                if (this.m_lineHeight === TMPro.TMP_Math.FLOAT_UNSET) {
                                    this.m_lineOffset += 0 - this.m_maxLineDescender + ascender + (lineGap + this.m_lineSpacingDelta) * baseScale + this.m_lineSpacing * currentEmScale;
                                    this.m_IsDrivenLineSpacing = false;
                                } else {
                                    this.m_lineOffset += this.m_lineHeight + this.m_lineSpacing * currentEmScale;
                                    this.m_IsDrivenLineSpacing = true;
                                }

                                this.m_maxLineAscender = TMPro.TMP_Text.k_LargeNegativeFloat;
                                this.m_maxLineDescender = TMPro.TMP_Text.k_LargePositiveFloat;
                                this.m_startOfLineAscender = ascender;

                                this.m_xAdvance = 0 + this.tag_Indent;
                                //isStartOfNewLine = true;
                                isFirstWordOfLine = true;
                                continue;
                            }
                        }


                        lineMarginLeft = this.m_marginLeft;
                        lineMarginRight = this.m_marginRight;
                    }



                    // Check if Line Spacing of previous line needs to be adjusted.


                    /* if (m_lineOffset > 0 && !TMP_Math.Approximately(m_maxLineAscender, m_startOfLineAscender) && m_IsDrivenLineSpacing == false && !m_isNewPage)
                    {
                       float offsetDelta = m_maxLineAscender - m_startOfLineAscender;
                       //AdjustLineOffset(m_firstCharacterOfLine, m_characterCount, offsetDelta);
                       m_ElementDescender -= offsetDelta;
                       m_lineOffset += offsetDelta;

                       m_startOfLineAscender += offsetDelta;
                       internalWordWrapState.lineOffset = m_lineOffset;
                       internalWordWrapState.startOfLineAscender = m_startOfLineAscender;
                    }*/



                    // Handle xAdvance & Tabulation Stops. Tab stops at every 25% of Font Size.


                    if (charCode === 9) {
                        var tabSize = this.m_currentFontAsset.faceInfo.tabWidth * this.m_currentFontAsset.tabSize * currentElementScale;
                        var tabs = Math.ceil(this.m_xAdvance / tabSize) * tabSize;
                        this.m_xAdvance = tabs > this.m_xAdvance ? tabs : this.m_xAdvance + tabSize;
                    } else if (this.m_monoSpacing !== 0) {
                        this.m_xAdvance += (this.m_monoSpacing - monoAdvance + (this.m_currentFontAsset.normalSpacingOffset + characterSpacingAdjustment) * currentEmScale + this.m_cSpacing) * (1 - this.m_charWidthAdjDelta);

                        if (isWhiteSpace || charCode === 8203) {
                            this.m_xAdvance += this.m_wordSpacing * currentEmScale;
                        }
                    } else {
                        this.m_xAdvance += ((currentGlyphMetrics.horizontalAdvance + glyphAdjustments.xAdvance) * currentElementScale + (this.m_currentFontAsset.normalSpacingOffset + characterSpacingAdjustment + boldSpacingAdjustment) * currentEmScale + this.m_cSpacing) * (1 - this.m_charWidthAdjDelta);

                        if (isWhiteSpace || charCode === 8203) {
                            this.m_xAdvance += this.m_wordSpacing * currentEmScale;
                        }
                    }



                    // Handle Carriage Return


                    if (charCode === 13) {
                        maxXAdvance = UnityEngine.Mathf.Max(maxXAdvance, renderedWidth + this.m_xAdvance);
                        renderedWidth = 0;
                        this.m_xAdvance = 0 + this.tag_Indent;
                    }



                    // Handle Line Spacing Adjustments + Word Wrapping & special case for last line.


                    if (charCode === 10 || charCode === 11 || charCode === 3 || charCode === 8232 || charCode === 8233 || this.m_characterCount === totalCharacterCount - 1) {
                        // Check if Line Spacing of previous line needs to be adjusted.
                        var baselineAdjustmentDelta1 = this.m_maxLineAscender - this.m_startOfLineAscender;
                        if (this.m_lineOffset > 0 && Math.abs(baselineAdjustmentDelta1) > 0.01 && this.m_IsDrivenLineSpacing === false && !this.m_isNewPage) {
                            this.m_ElementDescender -= baselineAdjustmentDelta1;
                            this.m_lineOffset += baselineAdjustmentDelta1;
                        }

                        this.m_isNewPage = false;

                        // Calculate lineAscender & make sure if last character is superscript or subscript that we check that as well.
                        //float lineAscender = m_maxLineAscender - m_lineOffset;
                        var lineDescender1 = this.m_maxLineDescender - this.m_lineOffset;

                        // Update maxDescender and maxVisibleDescender
                        this.m_ElementDescender = this.m_ElementDescender < lineDescender1 ? this.m_ElementDescender : lineDescender1;

                        // Store PreferredWidth paying attention to linefeed and last character of text.
                        if (this.m_characterCount === totalCharacterCount - 1) {
                            renderedWidth = UnityEngine.Mathf.Max(maxXAdvance, renderedWidth + textWidth + lineMarginLeft + lineMarginRight);
                        } else {
                            maxXAdvance = UnityEngine.Mathf.Max(maxXAdvance, renderedWidth + textWidth + lineMarginLeft + lineMarginRight);
                            renderedWidth = 0;
                        }

                        renderedHeight = this.m_maxTextAscender - this.m_ElementDescender;

                        // Add new line if not last lines or character.
                        if (charCode === 10 || charCode === 11 || charCode === 45 || charCode === 8232 || charCode === 8233) {
                            // Store the state of the line before starting on the new line.
                            this.SaveWordWrappingState(internalLineState, i, this.m_characterCount);
                            // Store the state of the last Character before the new line.
                            this.SaveWordWrappingState(internalWordWrapState, i, this.m_characterCount);

                            this.m_lineNumber += 1;
                            this.m_firstCharacterOfLine = this.m_characterCount + 1;

                            var ascender1 = internalCharacterInfo.adjustedAscender;

                            // Apply Line Spacing with special handling for VT char(11)
                            if (this.m_lineHeight === TMPro.TMP_Math.FLOAT_UNSET) {
                                var lineOffsetDelta = 0 - this.m_maxLineDescender + ascender1 + (lineGap + this.m_lineSpacingDelta) * baseScale + (this.m_lineSpacing + (charCode === 10 || charCode === 8233 ? this.m_paragraphSpacing : 0)) * currentEmScale;
                                this.m_lineOffset += lineOffsetDelta;
                                this.m_IsDrivenLineSpacing = false;
                            } else {
                                this.m_lineOffset += this.m_lineHeight + (this.m_lineSpacing + (charCode === 10 || charCode === 8233 ? this.m_paragraphSpacing : 0)) * currentEmScale;
                                this.m_IsDrivenLineSpacing = true;
                            }

                            this.m_maxLineAscender = TMPro.TMP_Text.k_LargeNegativeFloat;
                            this.m_maxLineDescender = TMPro.TMP_Text.k_LargePositiveFloat;
                            this.m_startOfLineAscender = ascender1;

                            this.m_xAdvance = 0 + this.tag_LineIndent + this.tag_Indent;

                            this.m_characterCount += 1;
                            continue;
                        }

                        // If End of Text
                        if (charCode === 3) {
                            i = this.m_TextProcessingArray.length;
                        }
                    }



                    // Save State of Mesh Creation for handling of Word Wrapping


                    if (isWordWrappingEnabled || this.m_overflowMode === TMPro.TextOverflowModes.Truncate || this.m_overflowMode === TMPro.TextOverflowModes.Ellipsis) {
                        if ((isWhiteSpace || charCode === 8203 || charCode === 45 || charCode === 173) && !this.m_isNonBreakingSpace && charCode !== 160 && charCode !== 8199 && charCode !== 8209 && charCode !== 8239 && charCode !== 8288) {
                            // We store the state of numerous variables for the most recent Space, LineFeed or Carriage Return to enable them to be restored
                            // for Word Wrapping.
                            this.SaveWordWrappingState(internalWordWrapState, i, this.m_characterCount);
                            isFirstWordOfLine = false;
                            isLastCharacterCJK = false;

                            // Reset soft line breaking point since we now have a valid hard break point.
                            internalSoftLineBreak.v.previous_WordBreak = -1;
                        } else if (this.m_isNonBreakingSpace === false && ((charCode > 4352 && charCode < 4607 || charCode > 43360 && charCode < 43391 || charCode > 44032 && charCode < 55295) && TMPro.TMP_Settings.useModernHangulLineBreakingRules === false || charCode > 11904 && charCode < 40959 || charCode > 63744 && charCode < 64255 || charCode > 65072 && charCode < 65103 || charCode > 65280 && charCode < 65519)) {
                            var isLeadingCharacter = TMPro.TMP_Settings.linebreakingRules.leadingCharacters.containsKey(charCode);
                            var isFollowingCharacter = this.m_characterCount < totalCharacterCount - 1 && TMPro.TMP_Settings.linebreakingRules.followingCharacters.containsKey(this.m_internalCharacterInfo[ this.m_characterCount + 1 ].character);
                            if (isFirstWordOfLine || isLeadingCharacter === false) {
                                if (isFollowingCharacter === false) {
                                    this.SaveWordWrappingState(internalWordWrapState, i, this.m_characterCount);
                                    isFirstWordOfLine = false;
                                }

                                if (isFirstWordOfLine) {
                                    // Special handling for non-breaking space and soft line breaks
                                    if (isWhiteSpace) {
                                        this.SaveWordWrappingState(internalSoftLineBreak, i, this.m_characterCount);
                                    }

                                    this.SaveWordWrappingState(internalWordWrapState, i, this.m_characterCount);
                                }
                            }

                            isLastCharacterCJK = true;
                        } else if (isLastCharacterCJK) {
                            var isLeadingCharacter1 = TMPro.TMP_Settings.linebreakingRules.leadingCharacters.containsKey(charCode);

                            if (isLeadingCharacter1 === false) {
                                this.SaveWordWrappingState(internalWordWrapState, i, this.m_characterCount);
                            }

                            isLastCharacterCJK = false;
                        } else if (isFirstWordOfLine) {
                            // Special handling for non-breaking space and soft line breaks
                            if (isWhiteSpace || charCode === 173 && isSoftHyphenIgnored === false) {
                                this.SaveWordWrappingState(internalSoftLineBreak, i, this.m_characterCount);
                            }

                            this.SaveWordWrappingState(internalWordWrapState, i, this.m_characterCount);
                            isLastCharacterCJK = false;
                        }
                    }


                    this.m_characterCount += 1;
                }

                // Check Auto Sizing and increase font size to fill text container.


                fontSizeDelta = this.m_maxFontSize - this.m_minFontSize;
                if (isTextAutoSizingEnabled && fontSizeDelta > 0.051 && fontSize.v < this.m_fontSizeMax && this.m_AutoSizeIterationCount < this.m_AutoSizeMaxIterationCount) {
                    // Reset character width adjustment delta
                    if (this.m_charWidthAdjDelta < this.m_charWidthMaxAdj / 100) {
                        this.m_charWidthAdjDelta = 0;
                    }

                    this.m_minFontSize = fontSize.v;

                    var sizeDelta1 = UnityEngine.Mathf.Max((this.m_maxFontSize - fontSize.v) / 2, 0.05);
                    fontSize.v += sizeDelta1;
                    fontSize.v = UnityEngine.Mathf.Min((fontSize.v * 20 + 0.5) / 20.0, this.m_fontSizeMax);

                    //Debug.Log("[" + m_AutoSizeIterationCount + "] Increasing Point Size from [" + m_minFontSize.ToString("f3") + "] to [" + m_fontSize.ToString("f3") + "] with delta of [" + sizeDelta.ToString("f3") + "].");
                    return pc.Vec2.ZERO.clone();
                }


                this.m_IsAutoSizePointSizeSet = true;

                this.m_isCalculatingPreferredValues = false;

                // Adjust Preferred Width and Height to account for Margins.
                renderedWidth += this.m_margin.x > 0 ? this.m_margin.x : 0;
                renderedWidth += this.m_margin.z > 0 ? this.m_margin.z : 0;

                renderedHeight += this.m_margin.y > 0 ? this.m_margin.y : 0;
                renderedHeight += this.m_margin.w > 0 ? this.m_margin.w : 0;

                // Round Preferred Values to nearest 5/100.
                renderedWidth = (renderedWidth * 100 + 1.0) / 100.0;
                renderedHeight = (renderedHeight * 100 + 1.0) / 100.0;

                //Debug.Log("Preferred Values: (" + renderedWidth + ", " + renderedHeight + ") with Recursive count of " + m_recursiveCount);

                return new pc.Vec2( renderedWidth, renderedHeight );
            },
            /*TMPro.TMP_Text.CalculatePreferredValues end.*/

            /*TMPro.TMP_Text.GetCompoundBounds start.*/
            /**
             * Method returning the compound bounds of the text object and child sub objects.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @return  {UnityEngine.Bounds}
             */
            GetCompoundBounds: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetCompoundBounds", this ); }

                return new pc.BoundingBox.ctor();
            },
            /*TMPro.TMP_Text.GetCompoundBounds end.*/

            /*TMPro.TMP_Text.GetCanvasSpaceClippingRect start.*/
            GetCanvasSpaceClippingRect: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetCanvasSpaceClippingRect", this ); }

                return UnityEngine.Rect.zero.$clone();
            },
            /*TMPro.TMP_Text.GetCanvasSpaceClippingRect end.*/

            /*TMPro.TMP_Text.GetTextBounds start.*/
            /**
             * Method which returns the bounds of the text object;
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @return  {UnityEngine.Bounds}
             */
            GetTextBounds: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetTextBounds", this ); }

                var $t, $t1, $t2, $t3, $t4;
                if (this.m_textInfo == null || this.m_textInfo.characterCount > this.m_textInfo.characterInfo.length) {
                    return new pc.BoundingBox.ctor();
                }

                var extent = new TMPro.Extents.$ctor1(TMPro.TMP_Text.k_LargePositiveVector2.$clone(), TMPro.TMP_Text.k_LargeNegativeVector2.$clone());

                for (var i = 0; i < this.m_textInfo.characterCount && i < this.m_textInfo.characterInfo.length; i++) {
                    if (!($t = this.m_textInfo.characterInfo)[i].isVisible) {
                        continue;
                    }

                    extent.min.x = UnityEngine.Mathf.Min(extent.min.x, ($t1 = this.m_textInfo.characterInfo)[i].origin);
                    extent.min.y = UnityEngine.Mathf.Min(extent.min.y, ($t2 = this.m_textInfo.characterInfo)[i].descender);

                    extent.max.x = UnityEngine.Mathf.Max(extent.max.x, ($t3 = this.m_textInfo.characterInfo)[i].xAdvance);
                    extent.max.y = UnityEngine.Mathf.Max(extent.max.y, ($t4 = this.m_textInfo.characterInfo)[i].ascender);
                }

                var size = new UnityEngine.Vector2();
                size.x = extent.max.x - extent.min.x;
                size.y = extent.max.y - extent.min.y;

                var center = UnityEngine.Vector3.FromVector2((extent.min.$clone().add( extent.max )).scale( 1.0 / ( 2 ) ));

                return new pc.BoundingBox( center.$clone(), UnityEngine.Vector3.FromVector2(size.$clone()).scale( 0.5 ) );
            },
            /*TMPro.TMP_Text.GetTextBounds end.*/

            /*TMPro.TMP_Text.GetTextBounds$1 start.*/
            /**
             * Method which returns the bounds of the text object;
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {boolean}               onlyVisibleCharacters
             * @return  {UnityEngine.Bounds}
             */
            GetTextBounds$1: function (onlyVisibleCharacters) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetTextBounds$1", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5;
                if (this.m_textInfo == null) {
                    return new pc.BoundingBox.ctor();
                }

                var extent = new TMPro.Extents.$ctor1(TMPro.TMP_Text.k_LargePositiveVector2.$clone(), TMPro.TMP_Text.k_LargeNegativeVector2.$clone());

                for (var i = 0; i < this.m_textInfo.characterCount; i++) {
                    if ((i > this.maxVisibleCharacters || ($t = this.m_textInfo.characterInfo)[i].lineNumber > this.m_maxVisibleLines) && onlyVisibleCharacters) {
                        break;
                    }

                    if (onlyVisibleCharacters && !($t1 = this.m_textInfo.characterInfo)[i].isVisible) {
                        continue;
                    }

                    extent.min.x = UnityEngine.Mathf.Min(extent.min.x, ($t2 = this.m_textInfo.characterInfo)[i].origin);
                    extent.min.y = UnityEngine.Mathf.Min(extent.min.y, ($t3 = this.m_textInfo.characterInfo)[i].descender);

                    extent.max.x = UnityEngine.Mathf.Max(extent.max.x, ($t4 = this.m_textInfo.characterInfo)[i].xAdvance);
                    extent.max.y = UnityEngine.Mathf.Max(extent.max.y, ($t5 = this.m_textInfo.characterInfo)[i].ascender);
                }

                var size = new UnityEngine.Vector2();
                size.x = extent.max.x - extent.min.x;
                size.y = extent.max.y - extent.min.y;

                var center = (extent.min.$clone().add( extent.max )).scale( 1.0 / ( 2 ) );

                return new pc.BoundingBox( UnityEngine.Vector3.FromVector2(center.$clone()), UnityEngine.Vector3.FromVector2(size.$clone()).scale( 0.5 ) );
            },
            /*TMPro.TMP_Text.GetTextBounds$1 end.*/

            /*TMPro.TMP_Text.AdjustLineOffset start.*/
            /**
             * Method to adjust line spacing as a result of using different fonts or font point size.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {number}    startIndex    
             * @param   {number}    endIndex      
             * @param   {number}    offset
             * @return  {void}
             */
            AdjustLineOffset: function (startIndex, endIndex, offset) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#AdjustLineOffset", this ); }

                var vertexOffset = new pc.Vec3( 0, offset, 0 );

                for (var i = startIndex; i <= endIndex; i++) {
                    //this.m_textInfo.characterInfo[ i ].bottomLeft.sub( vertexOffset );
                this.m_textInfo.characterInfo[ i ].bottomLeft.sub( vertexOffset );
                this.m_textInfo.characterInfo[ i ].topLeft.sub( vertexOffset );
                this.m_textInfo.characterInfo[ i ].topRight.sub( vertexOffset );
                this.m_textInfo.characterInfo[ i ].bottomRight.sub( vertexOffset );

                this.m_textInfo.characterInfo[ i ].ascender -=  vertexOffset.y;
                this.m_textInfo.characterInfo[ i ].baseLine -=  vertexOffset.y;
                this.m_textInfo.characterInfo[ i ].descender -=  vertexOffset.y;
                
                if ( this.m_textInfo.characterInfo[ i ].isVisible ) {
                    this.m_textInfo.characterInfo[ i ].vertex_BL.position.sub( vertexOffset );
                    this.m_textInfo.characterInfo[ i ].vertex_TL.position.sub( vertexOffset );
                    this.m_textInfo.characterInfo[ i ].vertex_TR.position.sub( vertexOffset );
                    this.m_textInfo.characterInfo[ i ].vertex_BR.position.sub( vertexOffset );
                }

                }
            },
            /*TMPro.TMP_Text.AdjustLineOffset end.*/

            /*TMPro.TMP_Text.ResizeLineExtents start.*/
            /**
             * Function to increase the size of the Line Extents Array.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {number}    size
             * @return  {void}
             */
            ResizeLineExtents: function (size) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#ResizeLineExtents", this ); }

                var $t;
                size = size > 1024 ? size + 256 : UnityEngine.Mathf.NextPowerOfTwo(size + 1);

                var temp_lineInfo = System.Array.init(size, function (){
                    return new TMPro.TMP_LineInfo();
                }, TMPro.TMP_LineInfo);
                for (var i = 0; i < size; i++) {
                    if (i < this.m_textInfo.lineInfo.length) {
                        temp_lineInfo[i] = ($t = this.m_textInfo.lineInfo)[i].$clone();
                    } else {
                        temp_lineInfo[i].lineExtents.min = TMPro.TMP_Text.k_LargePositiveVector2.$clone();
                        temp_lineInfo[i].lineExtents.max = TMPro.TMP_Text.k_LargeNegativeVector2.$clone();

                        temp_lineInfo[i].ascender = TMPro.TMP_Text.k_LargeNegativeFloat;
                        temp_lineInfo[i].descender = TMPro.TMP_Text.k_LargePositiveFloat;
                    }
                }

                this.m_textInfo.lineInfo = temp_lineInfo;
            },
            /*TMPro.TMP_Text.ResizeLineExtents end.*/

            /*TMPro.TMP_Text.GetTextInfo start.*/
            /**
             * Function used to evaluate the length of a text string.
             *
             * @instance
             * @public
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {string}                text
             * @return  {TMPro.TMP_TextInfo}
             */
            GetTextInfo: function (text) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetTextInfo", this ); }

                return null;
            },
            /*TMPro.TMP_Text.GetTextInfo end.*/

            /*TMPro.TMP_Text.ComputeMarginSize start.*/
            /**
             * Function to force an update of the margin size.
             *
             * @instance
             * @public
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @return  {void}
             */
            ComputeMarginSize: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#ComputeMarginSize", this ); }
 },
            /*TMPro.TMP_Text.ComputeMarginSize end.*/

            /*TMPro.TMP_Text.InsertNewLine start.*/
            /**
             * Function used in conjunction with GetTextInfo to figure out Array allocations.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {number}            i                             
             * @param   {number}            baseScale                     
             * @param   {number}            currentElementScale           
             * @param   {number}            currentEmScale                
             * @param   {number}            glyphAdjustment               
             * @param   {number}            boldSpacingAdjustment         
             * @param   {number}            characterSpacingAdjustment    
             * @param   {number}            width                         
             * @param   {number}            lineGap                       
             * @param   {System.Boolean}    isMaxVisibleDescenderSet      
             * @param   {System.Single}     maxVisibleDescender
             * @return  {void}
             */
            InsertNewLine: function (i, baseScale, currentElementScale, currentEmScale, glyphAdjustment, boldSpacingAdjustment, characterSpacingAdjustment, width, lineGap, isMaxVisibleDescenderSet, maxVisibleDescender) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#InsertNewLine", this ); }

                // Adjust line spacing if necessary
                var baselineAdjustmentDelta = this.m_maxLineAscender - this.m_startOfLineAscender;
                if (this.m_lineOffset > 0 && Math.abs(baselineAdjustmentDelta) > 0.01 && this.m_IsDrivenLineSpacing === false && !this.m_isNewPage) {
                    this.AdjustLineOffset(this.m_firstCharacterOfLine, this.m_characterCount, baselineAdjustmentDelta);
                    this.m_ElementDescender -= baselineAdjustmentDelta;
                    this.m_lineOffset += baselineAdjustmentDelta;
                }

                // Calculate lineAscender & make sure if last character is superscript or subscript that we check that as well.
                var lineAscender = this.m_maxLineAscender - this.m_lineOffset;
                var lineDescender = this.m_maxLineDescender - this.m_lineOffset;

                // Update maxDescender and maxVisibleDescender
                this.m_ElementDescender = this.m_ElementDescender < lineDescender ? this.m_ElementDescender : lineDescender;
                if (!isMaxVisibleDescenderSet.v) {
                    maxVisibleDescender.v = this.m_ElementDescender;
                }

                if (this.m_useMaxVisibleDescender && (this.m_characterCount >= this.m_maxVisibleCharacters || this.m_lineNumber >= this.m_maxVisibleLines)) {
                    isMaxVisibleDescenderSet.v = true;
                }

                // Track & Store lineInfo for the new line
                
            this.m_textInfo.lineInfo[ this.m_lineNumber ].firstCharacterIndex = this.m_firstCharacterOfLine;
            this.m_textInfo.lineInfo[ this.m_lineNumber ].firstVisibleCharacterIndex = this.m_firstVisibleCharacterOfLine = this.m_firstCharacterOfLine > this.m_firstVisibleCharacterOfLine ? this.m_firstCharacterOfLine : this.m_firstVisibleCharacterOfLine;
            var lastCharacterIndex = this.m_textInfo.lineInfo[ this.m_lineNumber ].lastCharacterIndex = this.m_lastCharacterOfLine = this.m_characterCount - 1 > 0 ? this.m_characterCount - 1 : 0;
            this.m_textInfo.lineInfo[ this.m_lineNumber ].lastVisibleCharacterIndex = this.m_lastVisibleCharacterOfLine = this.m_lastVisibleCharacterOfLine < this.m_firstVisibleCharacterOfLine ? this.m_firstVisibleCharacterOfLine : this.m_lastVisibleCharacterOfLine;

            this.m_textInfo.lineInfo[ this.m_lineNumber ].characterCount = this.m_textInfo.lineInfo[ this.m_lineNumber ].lastCharacterIndex - this.m_textInfo.lineInfo[ this.m_lineNumber ].firstCharacterIndex + 1;
            this.m_textInfo.lineInfo[ this.m_lineNumber ].visibleCharacterCount = this.m_lineVisibleCharacterCount;
            this.m_textInfo.lineInfo[ this.m_lineNumber ].lineExtents.min.set( this.m_textInfo.characterInfo[ this.m_firstVisibleCharacterOfLine ].bottomLeft.x, lineDescender );
            this.m_textInfo.lineInfo[ this.m_lineNumber ].lineExtents.max.set( this.m_textInfo.characterInfo[ this.m_lastVisibleCharacterOfLine ].topRight.x, lineAscender );
            this.m_textInfo.lineInfo[ this.m_lineNumber ].length = this.m_textInfo.lineInfo[ this.m_lineNumber ].lineExtents.max.x;
            this.m_textInfo.lineInfo[ this.m_lineNumber ].width = width;

            var maxAdvanceOffset = ( ( glyphAdjustment + boldSpacingAdjustment ) * currentElementScale + ( this.m_currentFontAsset.normalSpacingOffset + characterSpacingAdjustment ) * currentEmScale - this.m_cSpacing ) * ( 1 - this.m_charWidthAdjDelta );
            var adjustedHorizontalAdvance = this.m_textInfo.lineInfo[ this.m_lineNumber ].maxAdvance = this.m_textInfo.characterInfo[ this.m_lastVisibleCharacterOfLine ].xAdvance + ( this.m_isRightToLeft ? maxAdvanceOffset : -maxAdvanceOffset );
            this.m_textInfo.characterInfo[ lastCharacterIndex ].xAdvance = adjustedHorizontalAdvance;

            this.m_textInfo.lineInfo[ this.m_lineNumber ].baseline = 0 - this.m_lineOffset;
            this.m_textInfo.lineInfo[ this.m_lineNumber ].ascender = lineAscender;
            this.m_textInfo.lineInfo[ this.m_lineNumber ].descender = lineDescender;
            this.m_textInfo.lineInfo[ this.m_lineNumber ].lineHeight = lineAscender - lineDescender + lineGap * baseScale;


                this.m_firstCharacterOfLine = this.m_characterCount; // Store first character of the next line.
                this.m_lineVisibleCharacterCount = 0;

                // Store the state of the line before starting on the new line.
                this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedLineState"), i, this.m_characterCount - 1);

                this.m_lineNumber += 1;

                // Check to make sure Array is large enough to hold a new line.
                if (this.m_lineNumber >= this.m_textInfo.lineInfo.length) {
                    this.ResizeLineExtents(this.m_lineNumber);
                }

                // Apply Line Spacing based on scale of the last character of the line.
                if (this.m_lineHeight === TMPro.TMP_Math.FLOAT_UNSET) {
                    var ascender = this.m_textInfo.characterInfo[ this.m_characterCount ].adjustedAscender;
                    var lineOffsetDelta = 0 - this.m_maxLineDescender + ascender + (lineGap + this.m_lineSpacingDelta) * baseScale + this.m_lineSpacing * currentEmScale;
                    this.m_lineOffset += lineOffsetDelta;

                    this.m_startOfLineAscender = ascender;
                } else {
                    this.m_lineOffset += this.m_lineHeight + this.m_lineSpacing * currentEmScale;
                }

                this.m_maxLineAscender = TMPro.TMP_Text.k_LargeNegativeFloat;
                this.m_maxLineDescender = TMPro.TMP_Text.k_LargePositiveFloat;

                this.m_xAdvance = 0 + this.tag_Indent;
            },
            /*TMPro.TMP_Text.InsertNewLine end.*/

            /*TMPro.TMP_Text.SaveWordWrappingState start.*/
            /**
             * Save the State of various variables used in the mesh creation loop in conjunction with Word Wrapping
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {TMPro.WordWrapState}    state    
             * @param   {number}                 index    
             * @param   {number}                 count
             * @return  {void}
             */
            SaveWordWrappingState: function (state, index, count) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#SaveWordWrappingState", this ); }

                var $t;
                // Multi Font & Material support related
                state.v.currentFontAsset = this.m_currentFontAsset;
                state.v.currentSpriteAsset = this.m_currentSpriteAsset;
                state.v.currentMaterial = this.m_currentMaterial;
                state.v.currentMaterialIndex = this.m_currentMaterialIndex;

                state.v.previous_WordBreak = index;
                state.v.total_CharacterCount = count;
                state.v.visible_CharacterCount = this.m_lineVisibleCharacterCount;
                //state.visible_CharacterCount = m_visibleCharacterCount;
                //state.visible_SpriteCount = m_visibleSpriteCount;
                state.v.visible_LinkCount = this.m_textInfo.linkCount;

                state.v.firstCharacterIndex = this.m_firstCharacterOfLine;
                state.v.firstVisibleCharacterIndex = this.m_firstVisibleCharacterOfLine;
                state.v.lastVisibleCharIndex = this.m_lastVisibleCharacterOfLine;

                state.v.fontStyle = this.m_FontStyleInternal;
                state.v.italicAngle = this.m_ItalicAngle;
                //state.maxFontScale = m_maxFontScale;
                state.v.fontScaleMultiplier = this.m_fontScaleMultiplier;
                state.v.currentFontSize = this.m_currentFontSize;

                state.v.xAdvance = this.m_xAdvance;
                state.v.maxCapHeight = this.m_maxCapHeight;
                state.v.maxAscender = this.m_maxTextAscender;
                state.v.maxDescender = this.m_ElementDescender;
                state.v.startOfLineAscender = this.m_startOfLineAscender;
                state.v.maxLineAscender = this.m_maxLineAscender;
                state.v.maxLineDescender = this.m_maxLineDescender;
                state.v.pageAscender = this.m_PageAscender;

                state.v.preferredWidth = this.m_preferredWidth;
                state.v.preferredHeight = this.m_preferredHeight;
                state.v.meshExtents = this.m_meshExtents.$clone();

                state.v.lineNumber = this.m_lineNumber;
                state.v.lineOffset = this.m_lineOffset;
                state.v.baselineOffset = this.m_baselineOffset;
                state.v.isDrivenLineSpacing = this.m_IsDrivenLineSpacing;
                state.v.glyphHorizontalAdvanceAdjustment = this.m_GlyphHorizontalAdvanceAdjustment;

                state.v.cSpace = this.m_cSpacing;
                state.v.mSpace = this.m_monoSpacing;

                state.v.horizontalAlignment = this.m_lineJustification;
                state.v.marginLeft = this.m_marginLeft;
                state.v.marginRight = this.m_marginRight;

                state.v.vertexColor.Copy(this.m_htmlColor);
                state.v.underlineColor.Copy(this.m_underlineColor);
                state.v.strikethroughColor.Copy(this.m_strikethroughColor);

                state.v.isNonBreakingSpace = this.m_isNonBreakingSpace;
                state.v.tagNoParsing = this.tag_NoParsing;

                // XML Tag Stack
                state.v.basicStyleStack.Copy(this.m_fontStyleStack);
                state.v.italicAngleStack.Copy(this.m_ItalicAngleStack);
                state.v.colorStack.CopyStruct(this.m_colorStack);
                state.v.underlineColorStack.CopyStruct(this.m_underlineColorStack);
                state.v.strikethroughColorStack.CopyStruct(this.m_strikethroughColorStack);
                state.v.highlightStateStack.CopyStruct(this.m_HighlightStateStack);
                state.v.colorGradientStack.Copy(this.m_colorGradientStack);
                state.v.sizeStack.Copy(this.m_sizeStack);
                state.v.indentStack.Copy(this.m_indentStack);
                state.v.fontWeightStack.Copy(this.m_FontWeightStack);
                //state.styleStack = m_styleStack;

                state.v.baselineStack.Copy(this.m_baselineOffsetStack);
                state.v.actionStack.Copy(this.m_actionStack);
                state.v.materialReferenceStack.CopyStruct(TMPro.TMP_Text.m_materialReferenceStack);
                state.v.lineJustificationStack.Copy(this.m_lineJustificationStack);
                //state.spriteAnimationStack = m_spriteAnimationStack;

                state.v.spriteAnimationID = this.m_spriteAnimationID;

                if (this.m_lineNumber < this.m_textInfo.lineInfo.length) {
                    state.v.lineInfo = ($t = this.m_textInfo.lineInfo)[this.m_lineNumber].$clone();
                }
            },
            /*TMPro.TMP_Text.SaveWordWrappingState end.*/

            /*TMPro.TMP_Text.RestoreWordWrappingState start.*/
            /**
             * Restore the State of various variables used in the mesh creation loop.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {TMPro.WordWrapState}    state
             * @return  {number}
             */
            RestoreWordWrappingState: function (state) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#RestoreWordWrappingState", this ); }

                var $t;
                var index = state.v.previous_WordBreak;

                // Multi Font & Material support related
                this.m_currentFontAsset = state.v.currentFontAsset;
                this.m_currentSpriteAsset = state.v.currentSpriteAsset;
                this.m_currentMaterial = state.v.currentMaterial;
                this.m_currentMaterialIndex = state.v.currentMaterialIndex;

                this.m_characterCount = state.v.total_CharacterCount + 1;
                this.m_lineVisibleCharacterCount = state.v.visible_CharacterCount;
                //m_visibleCharacterCount = state.visible_CharacterCount;
                //m_visibleSpriteCount = state.visible_SpriteCount;
                this.m_textInfo.linkCount = state.v.visible_LinkCount;

                this.m_firstCharacterOfLine = state.v.firstCharacterIndex;
                this.m_firstVisibleCharacterOfLine = state.v.firstVisibleCharacterIndex;
                this.m_lastVisibleCharacterOfLine = state.v.lastVisibleCharIndex;

                this.m_FontStyleInternal = state.v.fontStyle;
                this.m_ItalicAngle = state.v.italicAngle;
                this.m_fontScaleMultiplier = state.v.fontScaleMultiplier;
                //m_maxFontScale = state.maxFontScale;
                this.m_currentFontSize = state.v.currentFontSize;

                this.m_xAdvance = state.v.xAdvance;
                this.m_maxCapHeight = state.v.maxCapHeight;
                this.m_maxTextAscender = state.v.maxAscender;
                this.m_ElementDescender = state.v.maxDescender;
                this.m_startOfLineAscender = state.v.startOfLineAscender;
                this.m_maxLineAscender = state.v.maxLineAscender;
                this.m_maxLineDescender = state.v.maxLineDescender;
                this.m_PageAscender = state.v.pageAscender;

                this.m_preferredWidth = state.v.preferredWidth;
                this.m_preferredHeight = state.v.preferredHeight;
                this.m_meshExtents = state.v.meshExtents.$clone();

                this.m_lineNumber = state.v.lineNumber;
                this.m_lineOffset = state.v.lineOffset;
                this.m_baselineOffset = state.v.baselineOffset;
                this.m_IsDrivenLineSpacing = state.v.isDrivenLineSpacing;
                this.m_GlyphHorizontalAdvanceAdjustment = state.v.glyphHorizontalAdvanceAdjustment;

                this.m_cSpacing = state.v.cSpace;
                this.m_monoSpacing = state.v.mSpace;

                this.m_lineJustification = state.v.horizontalAlignment;
                this.m_marginLeft = state.v.marginLeft;
                this.m_marginRight = state.v.marginRight;

                this.m_htmlColor.Copy(state.v.vertexColor);
                this.m_underlineColor.Copy(state.v.underlineColor);
                this.m_strikethroughColor.Copy(state.v.strikethroughColor);

                this.m_isNonBreakingSpace = state.v.isNonBreakingSpace;
                this.tag_NoParsing = state.v.tagNoParsing;

                // XML Tag Stack
                this.m_fontStyleStack.Copy(state.v.basicStyleStack);
                this.m_ItalicAngleStack.Copy(state.v.italicAngleStack);
                this.m_colorStack.CopyStruct(state.v.colorStack);
                this.m_underlineColorStack.CopyStruct(state.v.underlineColorStack);
                this.m_strikethroughColorStack.CopyStruct(state.v.strikethroughColorStack);
                this.m_HighlightStateStack.CopyStruct(state.v.highlightStateStack);
                this.m_colorGradientStack.Copy(state.v.colorGradientStack);
                this.m_sizeStack.Copy(state.v.sizeStack);
                this.m_indentStack.Copy(state.v.indentStack);
                this.m_FontWeightStack.Copy(state.v.fontWeightStack);
                //m_styleStack = state.styleStack;

                this.m_baselineOffsetStack.Copy(state.v.baselineStack);
                this.m_actionStack.Copy(state.v.actionStack);
                TMPro.TMP_Text.m_materialReferenceStack.CopyStruct(state.v.materialReferenceStack);
                this.m_lineJustificationStack.Copy(state.v.lineJustificationStack);
                //m_spriteAnimationStack = state.spriteAnimationStack;

                this.m_spriteAnimationID = state.v.spriteAnimationID;

                if (this.m_lineNumber < this.m_textInfo.lineInfo.length) {
                    ($t = this.m_textInfo.lineInfo)[this.m_lineNumber] = state.v.lineInfo.$clone();
                }

                return index;
            },
            /*TMPro.TMP_Text.RestoreWordWrappingState end.*/

            /*TMPro.TMP_Text.SaveGlyphVertexInfo start.*/
            /**
             * Store vertex information for each character.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {number}                 padding          
             * @param   {number}                 style_padding    Style_padding.
             * @param   {UnityEngine.Color32}    vertexColor      Vertex color.
             * @return  {void}
             */
            SaveGlyphVertexInfo: function (padding, style_padding, vertexColor) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#SaveGlyphVertexInfo", this ); }

                
                // Save the Vertex Position for the Character
                var characterInfo = this.m_textInfo.characterInfo[ this.m_characterCount ];
                var preset = null;
                var cachedTextElement = this.m_cached_TextElement;
                var currentFontAsset = this.m_currentFontAsset;
                var faceInfo = this.m_currentFontAsset.faceInfo;

                characterInfo.vertex_BL.position.copy( characterInfo.bottomLeft );
                characterInfo.vertex_TL.position.copy( characterInfo.topLeft );
                characterInfo.vertex_TR.position.copy( characterInfo.topRight );
                characterInfo.vertex_BR.position.copy( characterInfo.bottomRight );

                // Alpha is the lower of the vertex color or tag color alpha used.
                vertexColor.a = this.m_fontColor32.a < vertexColor.a ? this.m_fontColor32.a : vertexColor.a;

                characterInfo.vertex_BL.color.Copy( vertexColor );
                characterInfo.vertex_TL.color.Copy( vertexColor );
                characterInfo.vertex_TR.color.Copy( vertexColor );
                characterInfo.vertex_BR.color.Copy( vertexColor );

                // Handle Vertex Colors & Vertex Color Gradient
                if ( this.m_enableVertexGradient && (this.m_overrideHtmlColors || this.m_colorStack.index <= 1) ) {
                    preset = this.m_fontColorGradientPreset || this.m_fontColorGradient;

                    characterInfo.vertex_BL.color.MultiplyByColor( preset.bottomLeft );
                    characterInfo.vertex_TL.color.MultiplyByColor( preset.topLeft );
                    characterInfo.vertex_TR.color.MultiplyByColor( preset.topRight );
                    characterInfo.vertex_BR.color.MultiplyByColor( preset.bottomRight );
                }

                if (this.m_colorGradientPreset != null) {
                    preset = this.m_colorGradientPreset;
                    
                    if ( this.m_colorGradientPresetIsTinted ) {
                        characterInfo.vertex_BL.color.MultiplyByColor( preset.bottomLeft );
                        characterInfo.vertex_TL.color.MultiplyByColor( preset.topLeft );
                        characterInfo.vertex_TR.color.MultiplyByColor( preset.topRight );
                        characterInfo.vertex_BR.color.MultiplyByColor( preset.bottomRight );
                    } else {
                        characterInfo.vertex_BL.color.Copy(m_colorGradientPreset.bottomLeft.MinAlpha(vertexColor));
                        characterInfo.vertex_TL.color.Copy(m_colorGradientPreset.topLeft.MinAlpha(vertexColor));
                        characterInfo.vertex_TR.color.Copy(m_colorGradientPreset.topRight.MinAlpha(vertexColor));
                        characterInfo.vertex_BR.color.Copy(m_colorGradientPreset.bottomRight.MinAlpha(vertexColor));
                    }
                }

                // Apply style_padding only if this is a SDF Shader.
                if ( !this.m_isSDFShader ) {
                    style_padding = 0;
                }

                // Store UV Information
                var glyphRect = cachedTextElement.m_Glyph.glyphRect;

                characterInfo.vertex_BL.uv.set(
                    (glyphRect.x - padding - style_padding) / currentFontAsset.m_AtlasWidth,
                    (glyphRect.y - padding - style_padding) / currentFontAsset.m_AtlasHeight
                );

                characterInfo.vertex_TL.uv.set(
                    characterInfo.vertex_BL.uv.x,
                    (glyphRect.y + padding + style_padding + glyphRect.height) / currentFontAsset.m_AtlasHeight
                );

                characterInfo.vertex_TR.uv.set(
                    (glyphRect.x + padding + style_padding + glyphRect.width) / currentFontAsset.m_AtlasWidth,
                    characterInfo.vertex_TL.uv.y
                );

                characterInfo.vertex_BR.uv.set(
                    characterInfo.vertex_TR.uv.x,
                    characterInfo.vertex_BL.uv.y
                );
            
            },
            /*TMPro.TMP_Text.SaveGlyphVertexInfo end.*/

            /*TMPro.TMP_Text.SaveSpriteVertexInfo start.*/
            /**
             * Store vertex information for each sprite.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {UnityEngine.Color32}    vertexColor
             * @return  {void}
             */
            SaveSpriteVertexInfo: function (vertexColor) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#SaveSpriteVertexInfo", this ); }

                
                var characterInfo = this.m_textInfo.characterInfo[ this.m_characterCount ];

                characterInfo.vertex_BL.position.copy( characterInfo.bottomLeft );
                characterInfo.vertex_TL.position.copy( characterInfo.topLeft );
                characterInfo.vertex_TR.position.copy( characterInfo.topRight );
                characterInfo.vertex_BR.position.copy( characterInfo.bottomRight );

                if ( this.m_tintAllSprites ) {
                    this.m_tintSprite = true;
                }

                characterInfo.vertex_BL.color.Copy( this.m_spriteColor );
                characterInfo.vertex_TL.color.Copy( this.m_spriteColor );
                characterInfo.vertex_TR.color.Copy( this.m_spriteColor );
                characterInfo.vertex_BR.color.Copy( this.m_spriteColor );

                if ( this.m_tintSprite ) {
                    characterInfo.vertex_BL.color.MultiplyByColor32( vertexColor );
                    characterInfo.vertex_TL.color.MultiplyByColor32( vertexColor );
                    characterInfo.vertex_TR.color.MultiplyByColor32( vertexColor );
                    characterInfo.vertex_BR.color.MultiplyByColor32( vertexColor );
                }

                var spriteColor = characterInfo.vertex_BL.color;
                var alpha = ( spriteColor.a < this.m_fontColor32.a ) ? ( spriteColor.a < vertexColor.a ? spriteColor.a : vertexColor.a ) : this.m_fontColor32.a;

                characterInfo.vertex_BL.color.a = alpha;
                characterInfo.vertex_TL.color.a = alpha;
                characterInfo.vertex_TR.color.a = alpha;
                characterInfo.vertex_BR.color.a = alpha;                

                var present = null;

                if ( this.m_tintSprite && this.m_enableVertexGradient ) {
                    if (this.m_fontColorGradientPreset != null) {
                        preset = this.m_fontColorGradientPreset;
                    } else {
                        preset = this.m_fontColorGradient;
                    }

                    characterInfo.vertex_BL.color.MultiplyByColor32( preset.bottomLeft );
                    characterInfo.vertex_TL.color.MultiplyByColor32( preset.topLeft );
                    characterInfo.vertex_TR.color.MultiplyByColor32( preset.topRight );
                    characterInfo.vertex_BR.color.MultiplyByColor32( preset.bottomRight );
                }

                if ( this.m_tintSprite && this.m_colorGradientPreset != null ) {
                    preset = this.m_colorGradientPreset;

                    characterInfo.vertex_BL.color.MultiplyByColor32( preset.bottomLeft );
                    characterInfo.vertex_TL.color.MultiplyByColor32( preset.topLeft );
                    characterInfo.vertex_TR.color.MultiplyByColor32( preset.topRight );
                    characterInfo.vertex_BR.color.MultiplyByColor32( preset.bottomRight );
                }

                characterInfo.vertex_BL.uv.set(
                    this.m_cached_TextElement.glyph.glyphRect.x / this.m_currentSpriteAsset.spriteSheet.width,
                    this.m_cached_TextElement.glyph.glyphRect.y / this.m_currentSpriteAsset.spriteSheet.height
                );

                characterInfo.vertex_TL.uv.set(
                    characterInfo.vertex_BL.uv.x,
                    (this.m_cached_TextElement.glyph.glyphRect.y + this.m_cached_TextElement.glyph.glyphRect.height) / this.m_currentSpriteAsset.spriteSheet.height
                );

                characterInfo.vertex_TR.uv.set(
                    (this.m_cached_TextElement.glyph.glyphRect.x + this.m_cached_TextElement.glyph.glyphRect.width) / this.m_currentSpriteAsset.spriteSheet.width,
                    characterInfo.vertex_TL.uv.y
                );

                characterInfo.vertex_BR.uv.set(
                    characterInfo.vertex_TR.uv.x,
                    characterInfo.vertex_BL.uv.y
                );
            
            },
            /*TMPro.TMP_Text.SaveSpriteVertexInfo end.*/

            /*TMPro.TMP_Text.FillCharacterVertexBuffers start.*/
            /**
             * Store vertex attributes into the appropriate TMP_MeshInfo.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {number}    i           
             * @param   {number}    index_X4
             * @return  {void}
             */
            FillCharacterVertexBuffers: function (i, index_X4) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#FillCharacterVertexBuffers", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20, $t21, $t22, $t23, $t24, $t25, $t26, $t27, $t28, $t29, $t30, $t31, $t32, $t33, $t34, $t35, $t36, $t37;
                var materialIndex = ($t = this.m_textInfo.characterInfo)[i].materialReferenceIndex;
                index_X4 = ($t1 = this.m_textInfo.meshInfo)[materialIndex].vertexCount;

                // Check to make sure our current mesh buffer allocations can hold these new Quads.
                if (index_X4 >= ($t2 = this.m_textInfo.meshInfo)[materialIndex].vertices.length) {
                    ($t3 = this.m_textInfo.meshInfo)[materialIndex].ResizeMeshInfo(UnityEngine.Mathf.NextPowerOfTwo((index_X4 + 4) / 4));
                }


                var characterInfoArray = this.m_textInfo.characterInfo;
                ($t4 = this.m_textInfo.characterInfo)[i].vertexIndex = index_X4;

                // Setup Vertices for Characters
                ($t5 = ($t6 = this.m_textInfo.meshInfo)[materialIndex].vertices)[0 + index_X4] = characterInfoArray[i].vertex_BL.position.$clone();
                ($t7 = ($t8 = this.m_textInfo.meshInfo)[materialIndex].vertices)[1 + index_X4] = characterInfoArray[i].vertex_TL.position.$clone();
                ($t9 = ($t10 = this.m_textInfo.meshInfo)[materialIndex].vertices)[2 + index_X4] = characterInfoArray[i].vertex_TR.position.$clone();
                ($t11 = ($t12 = this.m_textInfo.meshInfo)[materialIndex].vertices)[3 + index_X4] = characterInfoArray[i].vertex_BR.position.$clone();


                // Setup UVS0
                ($t13 = ($t14 = this.m_textInfo.meshInfo)[materialIndex].uvs0)[0 + index_X4] = characterInfoArray[i].vertex_BL.uv.$clone();
                ($t15 = ($t16 = this.m_textInfo.meshInfo)[materialIndex].uvs0)[1 + index_X4] = characterInfoArray[i].vertex_TL.uv.$clone();
                ($t17 = ($t18 = this.m_textInfo.meshInfo)[materialIndex].uvs0)[2 + index_X4] = characterInfoArray[i].vertex_TR.uv.$clone();
                ($t19 = ($t20 = this.m_textInfo.meshInfo)[materialIndex].uvs0)[3 + index_X4] = characterInfoArray[i].vertex_BR.uv.$clone();


                // Setup UVS2
                ($t21 = ($t22 = this.m_textInfo.meshInfo)[materialIndex].uvs2)[0 + index_X4] = characterInfoArray[i].vertex_BL.uv2.$clone();
                ($t23 = ($t24 = this.m_textInfo.meshInfo)[materialIndex].uvs2)[1 + index_X4] = characterInfoArray[i].vertex_TL.uv2.$clone();
                ($t25 = ($t26 = this.m_textInfo.meshInfo)[materialIndex].uvs2)[2 + index_X4] = characterInfoArray[i].vertex_TR.uv2.$clone();
                ($t27 = ($t28 = this.m_textInfo.meshInfo)[materialIndex].uvs2)[3 + index_X4] = characterInfoArray[i].vertex_BR.uv2.$clone();


                // Setup UVS4
                //m_textInfo.meshInfo[0].uvs4[0 + index_X4] = characterInfoArray[i].vertex_BL.uv4;
                //m_textInfo.meshInfo[0].uvs4[1 + index_X4] = characterInfoArray[i].vertex_TL.uv4;
                //m_textInfo.meshInfo[0].uvs4[2 + index_X4] = characterInfoArray[i].vertex_TR.uv4;
                //m_textInfo.meshInfo[0].uvs4[3 + index_X4] = characterInfoArray[i].vertex_BR.uv4;


                // setup Vertex Colors
                ($t29 = ($t30 = this.m_textInfo.meshInfo)[materialIndex].colors32)[0 + index_X4] = characterInfoArray[i].vertex_BL.color.$clone();
                ($t31 = ($t32 = this.m_textInfo.meshInfo)[materialIndex].colors32)[1 + index_X4] = characterInfoArray[i].vertex_TL.color.$clone();
                ($t33 = ($t34 = this.m_textInfo.meshInfo)[materialIndex].colors32)[2 + index_X4] = characterInfoArray[i].vertex_TR.color.$clone();
                ($t35 = ($t36 = this.m_textInfo.meshInfo)[materialIndex].colors32)[3 + index_X4] = characterInfoArray[i].vertex_BR.color.$clone();

                ($t37 = this.m_textInfo.meshInfo)[materialIndex].vertexCount = index_X4 + 4;
            },
            /*TMPro.TMP_Text.FillCharacterVertexBuffers end.*/

            /*TMPro.TMP_Text.FillCharacterVertexBuffers$1 start.*/
            FillCharacterVertexBuffers$1: function (i, index_X4, isVolumetric) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#FillCharacterVertexBuffers$1", this ); }

                
                var characterInfo = this.m_textInfo.characterInfo[i];
                var materialIndex = characterInfo.materialReferenceIndex;
                var meshInfo = this.m_textInfo.meshInfo[materialIndex];
                var vertices = meshInfo.vertices;
                var uvs0 = meshInfo.uvs0;
                var uvs2 = meshInfo.uvs2;
                var colors32 = meshInfo.colors32;

                index_X4 = meshInfo.vertexCount;

                // Check to make sure our current mesh buffer allocations can hold these new Quads.
                if (index_X4 >= meshInfo.vertices.Length)
                    meshInfo.ResizeMeshInfo(UnityEngine.Mathf.NextPowerOfTwo((index_X4 + (isVolumetric ? 8 : 4)) / 4));

                characterInfo.vertexIndex = index_X4;

                vertices[0 + index_X4].copy( characterInfo.vertex_BL.position );
                vertices[1 + index_X4].copy( characterInfo.vertex_TL.position );
                vertices[2 + index_X4].copy( characterInfo.vertex_TR.position );
                vertices[3 + index_X4].copy( characterInfo.vertex_BR.position );

                if ( isVolumetric ) {
                    vertices[4 + index_X4].copy( characterInfo.vertex_BL.position ).z += this.m_fontSize * this.m_fontScale;
                    vertices[5 + index_X4].copy( characterInfo.vertex_TL.position ).z += this.m_fontSize * this.m_fontScale;
                    vertices[6 + index_X4].copy( characterInfo.vertex_TR.position ).z += this.m_fontSize * this.m_fontScale;
                    vertices[7 + index_X4].copy( characterInfo.vertex_BR.position ).z += this.m_fontSize * this.m_fontScale;
                }

                uvs0[0 + index_X4].copy( characterInfo.vertex_BL.uv );
                uvs0[1 + index_X4].copy( characterInfo.vertex_TL.uv );
                uvs0[2 + index_X4].copy( characterInfo.vertex_TR.uv );
                uvs0[3 + index_X4].copy( characterInfo.vertex_BR.uv );

                if ( isVolumetric ) {
                    uvs0[4 + index_X4].copy( characterInfo.vertex_BL.uv );
                    uvs0[5 + index_X4].copy( characterInfo.vertex_TL.uv );
                    uvs0[6 + index_X4].copy( characterInfo.vertex_TR.uv );
                    uvs0[7 + index_X4].copy( characterInfo.vertex_BR.uv );
                }

                uvs2[0 + index_X4].copy( characterInfo.vertex_BL.uv2 );
                uvs2[1 + index_X4].copy( characterInfo.vertex_TL.uv2 );
                uvs2[2 + index_X4].copy( characterInfo.vertex_TR.uv2 );
                uvs2[3 + index_X4].copy( characterInfo.vertex_BR.uv2 );

                if ( isVolumetric ) {
                    uvs2[4 + index_X4].copy( characterInfo.vertex_BL.uv2 );
                    uvs2[5 + index_X4].copy( characterInfo.vertex_TL.uv2 );
                    uvs2[6 + index_X4].copy( characterInfo.vertex_TR.uv2 );
                    uvs2[7 + index_X4].copy( characterInfo.vertex_BR.uv2 );
                }

                colors32[0 + index_X4].Copy( characterInfo.vertex_BL.color );
                colors32[1 + index_X4].Copy( characterInfo.vertex_TL.color );
                colors32[2 + index_X4].Copy( characterInfo.vertex_TR.color );
                colors32[3 + index_X4].Copy( characterInfo.vertex_BR.color );

                if ( isVolumetric ) {
                    colors32[4 + index_X4].Set( 1.0, 1.0, 1.0, 1.0 );
                    colors32[5 + index_X4].Set( 1.0, 1.0, 1.0, 1.0 );
                    colors32[6 + index_X4].Set( 1.0, 1.0, 1.0, 1.0 );
                    colors32[7 + index_X4].Set( 1.0, 1.0, 1.0, 1.0 );
                }

                meshInfo.vertexCount = index_X4 + (!isVolumetric ? 4 : 8);
            
            },
            /*TMPro.TMP_Text.FillCharacterVertexBuffers$1 end.*/

            /*TMPro.TMP_Text.FillSpriteVertexBuffers start.*/
            /**
             * Fill Vertex Buffers for Sprites
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {number}    i           
             * @param   {number}    index_X4
             * @return  {void}
             */
            FillSpriteVertexBuffers: function (i, index_X4) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#FillSpriteVertexBuffers", this ); }

                
                var characterInfo = this.m_textInfo.characterInfo[ i ];
                var materialIndex = characterInfo.materialReferenceIndex;
                var meshInfo = this.m_textInfo.meshInfo[ materialIndex ];

                var vertices = meshInfo.vertices;
                var uvs0 = meshInfo.uvs0;
                var uvs2 = meshInfo.uvs2;
                var colors32 = meshInfo.colors32;

                index_X4 = meshInfo.vertexCount;

                characterInfo.vertexIndex = index_X4;

                if( index_X4 >= vertices.Length ) {
                    meshInfo.ResizeMeshInfo( UnityEngine.Mathf.NextPowerOfTwo((index_X4 + 4) / 4) );
                }

                vertices[ 0 + index_X4 ].copy( characterInfo.vertex_BL.position );
                vertices[ 1 + index_X4 ].copy( characterInfo.vertex_TL.position );
                vertices[ 2 + index_X4 ].copy( characterInfo.vertex_TR.position );
                vertices[ 3 + index_X4 ].copy( characterInfo.vertex_BR.position );

                uvs0[ 0 + index_X4 ].copy( characterInfo.vertex_BL.uv );
                uvs0[ 1 + index_X4 ].copy( characterInfo.vertex_TL.uv );
                uvs0[ 2 + index_X4 ].copy( characterInfo.vertex_TR.uv );
                uvs0[ 3 + index_X4 ].copy( characterInfo.vertex_BR.uv );

                uvs2[ 0 + index_X4 ].copy( characterInfo.vertex_BL.uv2 );
                uvs2[ 1 + index_X4 ].copy( characterInfo.vertex_TL.uv2 );
                uvs2[ 2 + index_X4 ].copy( characterInfo.vertex_TR.uv2 );
                uvs2[ 3 + index_X4 ].copy( characterInfo.vertex_BR.uv2 );

                colors32[ 0 + index_X4 ].Copy( characterInfo.vertex_BL.color );
                colors32[ 1 + index_X4 ].Copy( characterInfo.vertex_TL.color );
                colors32[ 2 + index_X4 ].Copy( characterInfo.vertex_TR.color );
                colors32[ 3 + index_X4 ].Copy( characterInfo.vertex_BR.color );

                meshInfo.vertexCount = index_X4 + 4;
            
            },
            /*TMPro.TMP_Text.FillSpriteVertexBuffers end.*/

            /*TMPro.TMP_Text.DrawUnderlineMesh start.*/
            /**
             * Method to add the underline geometry.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {UnityEngine.Vector3}    start             
             * @param   {UnityEngine.Vector3}    end               
             * @param   {System.Int32}           index             
             * @param   {number}                 startScale        
             * @param   {number}                 endScale          
             * @param   {number}                 maxScale          
             * @param   {number}                 sdfScale          
             * @param   {UnityEngine.Color32}    underlineColor
             * @return  {void}
             */
            DrawUnderlineMesh: function (start, end, index, startScale, endScale, maxScale, sdfScale, underlineColor) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#DrawUnderlineMesh", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5;
                // Get Underline special character from the primary font asset.
                this.GetUnderlineSpecialCharacter(this.m_fontAsset);

                if (this.m_Underline.character == null) {
                    if (!TMPro.TMP_Settings.warningsDisabled) {
                        UnityEngine.Debug.LogWarning$1("Unable to add underline since the primary Font Asset doesn't contain the underline character.", this);
                    }

                    return;
                }

                var underlineMaterialIndex = this.m_Underline.materialIndex;

                var verticesCount = index.v + 12;

                // Check to make sure our current mesh buffer allocations can hold these new Quads.
                if (verticesCount > ($t = this.m_textInfo.meshInfo)[underlineMaterialIndex].vertices.length) {
                    // Resize Mesh Buffers
                    ($t1 = this.m_textInfo.meshInfo)[underlineMaterialIndex].ResizeMeshInfo(verticesCount / 4);
                }

                // Adjust the position of the underline based on the lowest character. This matters for subscript character.
                start.y = UnityEngine.Mathf.Min(start.y, end.y);
                end.y = UnityEngine.Mathf.Min(start.y, end.y);

                var underlineGlyphMetrics = this.m_Underline.character.glyph.metrics.$clone();
                var underlineGlyphRect = this.m_Underline.character.glyph.glyphRect.$clone();

                var segmentWidth = underlineGlyphMetrics.width / 2 * maxScale;

                if (end.x - start.x < underlineGlyphMetrics.width * maxScale) {
                    segmentWidth = (end.x - start.x) / 2.0;
                }

                var startPadding = this.m_padding * startScale / maxScale;
                var endPadding = this.m_padding * endScale / maxScale;

                var underlineThickness = this.m_Underline.fontAsset.faceInfo.underlineThickness;

                // UNDERLINE VERTICES FOR (3) LINE SEGMENTS


                var vertices = ($t2 = this.m_textInfo.meshInfo)[underlineMaterialIndex].vertices;

                // Front Part of the Underline
                vertices[index.v + 0] = start.$clone().add( new pc.Vec3( 0, 0 - (underlineThickness + this.m_padding) * maxScale, 0 ) ); // BL
                vertices[index.v + 1] = start.$clone().add( new pc.Vec3( 0, this.m_padding * maxScale, 0 ) ); // TL
                vertices[index.v + 2] = vertices[index.v + 1].$clone().add( new pc.Vec3( segmentWidth, 0, 0 ) ); // TR
                vertices[index.v + 3] = vertices[index.v + 0].$clone().add( new pc.Vec3( segmentWidth, 0, 0 ) ); // BR

                // Middle Part of the Underline
                vertices[index.v + 4] = vertices[index.v + 3].$clone(); // BL
                vertices[index.v + 5] = vertices[index.v + 2].$clone(); // TL
                vertices[index.v + 6] = end.$clone().add( new pc.Vec3( -segmentWidth, this.m_padding * maxScale, 0 ) ); // TR
                vertices[index.v + 7] = end.$clone().add( new pc.Vec3( -segmentWidth, -(underlineThickness + this.m_padding) * maxScale, 0 ) ); // BR

                // End Part of the Underline
                vertices[index.v + 8] = vertices[index.v + 7].$clone(); // BL
                vertices[index.v + 9] = vertices[index.v + 6].$clone(); // TL
                vertices[index.v + 10] = end.$clone().add( new pc.Vec3( 0, this.m_padding * maxScale, 0 ) ); // TR
                vertices[index.v + 11] = end.$clone().add( new pc.Vec3( 0, -(underlineThickness + this.m_padding) * maxScale, 0 ) ); // BR


                // UNDERLINE UV0


                var uvs0 = ($t3 = this.m_textInfo.meshInfo)[underlineMaterialIndex].uvs0;

                var atlasWidth = this.m_Underline.fontAsset.atlasWidth;
                var atlasHeight = this.m_Underline.fontAsset.atlasHeight;

                // Calculate UV required to setup the 3 Quads for the Underline.
                var uv0 = new pc.Vec2( (underlineGlyphRect.x - startPadding) / atlasWidth, (underlineGlyphRect.y - this.m_padding) / atlasHeight ); // bottom left
                var uv1 = new pc.Vec2( uv0.x, (underlineGlyphRect.y + underlineGlyphRect.height + this.m_padding) / atlasHeight ); // top left
                var uv2 = new pc.Vec2( (underlineGlyphRect.x - startPadding + underlineGlyphRect.width / 2) / atlasWidth, uv1.y ); // Mid Top Left
                var uv3 = new pc.Vec2( uv2.x, uv0.y ); // Mid Bottom Left
                var uv4 = new pc.Vec2( (underlineGlyphRect.x + endPadding + underlineGlyphRect.width / 2) / atlasWidth, uv1.y ); // Mid Top Right
                var uv5 = new pc.Vec2( uv4.x, uv0.y ); // Mid Bottom right
                var uv6 = new pc.Vec2( (underlineGlyphRect.x + endPadding + underlineGlyphRect.width) / atlasWidth, uv1.y ); // End Part - Bottom Right
                var uv7 = new pc.Vec2( uv6.x, uv0.y ); // End Part - Top Right

                // Left Part of the Underline
                uvs0[0 + index.v] = uv0.$clone(); // BL
                uvs0[1 + index.v] = uv1.$clone(); // TL
                uvs0[2 + index.v] = uv2.$clone(); // TR
                uvs0[3 + index.v] = uv3.$clone(); // BR

                // Middle Part of the Underline
                uvs0[4 + index.v] = new pc.Vec2( uv2.x - uv2.x * 0.001, uv0.y );
                uvs0[5 + index.v] = new pc.Vec2( uv2.x - uv2.x * 0.001, uv1.y );
                uvs0[6 + index.v] = new pc.Vec2( uv2.x + uv2.x * 0.001, uv1.y );
                uvs0[7 + index.v] = new pc.Vec2( uv2.x + uv2.x * 0.001, uv0.y );

                // Right Part of the Underline
                uvs0[8 + index.v] = uv5.$clone();
                uvs0[9 + index.v] = uv4.$clone();
                uvs0[10 + index.v] = uv6.$clone();
                uvs0[11 + index.v] = uv7.$clone();


                // UNDERLINE UV2


                // UV1 contains Face / Border UV layout.
                var min_UvX = 0;
                var max_UvX = (vertices[index.v + 2].x - start.x) / (end.x - start.x);

                //Calculate the xScale or how much the UV's are getting stretched on the X axis for the middle section of the underline.
                var xScale = Math.abs(sdfScale);

                var uvs2 = ($t4 = this.m_textInfo.meshInfo)[underlineMaterialIndex].uvs2;

                uvs2[0 + index.v] = this.PackUV$1(0, 0, xScale);
                uvs2[1 + index.v] = this.PackUV$1(0, 1, xScale);
                uvs2[2 + index.v] = this.PackUV$1(max_UvX, 1, xScale);
                uvs2[3 + index.v] = this.PackUV$1(max_UvX, 0, xScale);

                min_UvX = (vertices[index.v + 4].x - start.x) / (end.x - start.x);
                max_UvX = (vertices[index.v + 6].x - start.x) / (end.x - start.x);

                uvs2[4 + index.v] = this.PackUV$1(min_UvX, 0, xScale);
                uvs2[5 + index.v] = this.PackUV$1(min_UvX, 1, xScale);
                uvs2[6 + index.v] = this.PackUV$1(max_UvX, 1, xScale);
                uvs2[7 + index.v] = this.PackUV$1(max_UvX, 0, xScale);

                min_UvX = (vertices[index.v + 8].x - start.x) / (end.x - start.x);

                uvs2[8 + index.v] = this.PackUV$1(min_UvX, 0, xScale);
                uvs2[9 + index.v] = this.PackUV$1(min_UvX, 1, xScale);
                uvs2[10 + index.v] = this.PackUV$1(1, 1, xScale);
                uvs2[11 + index.v] = this.PackUV$1(1, 0, xScale);


                // UNDERLINE VERTEX COLORS


                // Alpha is the lower of the vertex color or tag color alpha used.
                underlineColor.a = this.m_fontColor32.a < underlineColor.a ? this.m_fontColor32.a : underlineColor.a;

                var colors32 = ($t5 = this.m_textInfo.meshInfo)[underlineMaterialIndex].colors32;
                colors32[0 + index.v] = underlineColor.$clone();
                colors32[1 + index.v] = underlineColor.$clone();
                colors32[2 + index.v] = underlineColor.$clone();
                colors32[3 + index.v] = underlineColor.$clone();

                colors32[4 + index.v] = underlineColor.$clone();
                colors32[5 + index.v] = underlineColor.$clone();
                colors32[6 + index.v] = underlineColor.$clone();
                colors32[7 + index.v] = underlineColor.$clone();

                colors32[8 + index.v] = underlineColor.$clone();
                colors32[9 + index.v] = underlineColor.$clone();
                colors32[10 + index.v] = underlineColor.$clone();
                colors32[11 + index.v] = underlineColor.$clone();


                index.v += 12;
            },
            /*TMPro.TMP_Text.DrawUnderlineMesh end.*/

            /*TMPro.TMP_Text.DrawTextHighlight start.*/
            DrawTextHighlight: function (start, end, index, highlightColor) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#DrawTextHighlight", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5;
                if (this.m_Underline.character == null) {
                    this.GetUnderlineSpecialCharacter(this.m_fontAsset);

                    if (this.m_Underline.character == null) {
                        if (!TMPro.TMP_Settings.warningsDisabled) {
                            UnityEngine.Debug.LogWarning$1("Unable to add highlight since the primary Font Asset doesn't contain the underline character.", this);
                        }

                        return;
                    }
                }

                var underlineMaterialIndex = this.m_Underline.materialIndex;

                var verticesCount = index.v + 4;

                // Check to make sure our current mesh buffer allocations can hold these new Quads.
                if (verticesCount > ($t = this.m_textInfo.meshInfo)[underlineMaterialIndex].vertices.length) {
                    // Resize Mesh Buffers
                    ($t1 = this.m_textInfo.meshInfo)[underlineMaterialIndex].ResizeMeshInfo(verticesCount / 4);
                }

                // UNDERLINE VERTICES FOR (3) LINE SEGMENTS


                var vertices = ($t2 = this.m_textInfo.meshInfo)[underlineMaterialIndex].vertices;

                // Front Part of the Underline
                vertices[index.v + 0] = start.$clone(); // BL
                vertices[index.v + 1] = new pc.Vec3( start.x, end.y, 0 ); // TL
                vertices[index.v + 2] = end.$clone(); // TR
                vertices[index.v + 3] = new pc.Vec3( end.x, start.y, 0 ); // BR


                // UNDERLINE UV0


                var uvs0 = ($t3 = this.m_textInfo.meshInfo)[underlineMaterialIndex].uvs0;

                var atlasWidth = this.m_Underline.fontAsset.atlasWidth;
                var atlasHeight = this.m_Underline.fontAsset.atlasHeight;
                var glyphRect = this.m_Underline.character.glyph.glyphRect.$clone();

                // Calculate UV
                var uv0 = new pc.Vec2( (glyphRect.x + glyphRect.width / 2) / atlasWidth, (glyphRect.y + glyphRect.height / 2) / atlasHeight ); // bottom left

                // UVs for the Quad
                uvs0[0 + index.v] = uv0.$clone(); // BL
                uvs0[1 + index.v] = uv0.$clone(); // TL
                uvs0[2 + index.v] = uv0.$clone(); // TR
                uvs0[3 + index.v] = uv0.$clone(); // BR


                // HIGHLIGHT UV2


                var uvs2 = ($t4 = this.m_textInfo.meshInfo)[underlineMaterialIndex].uvs2;
                var customUV = new pc.Vec2( 0, 1 );
                uvs2[0 + index.v] = customUV.$clone();
                uvs2[1 + index.v] = customUV.$clone();
                uvs2[2 + index.v] = customUV.$clone();
                uvs2[3 + index.v] = customUV.$clone();


                // HIGHLIGHT VERTEX COLORS


                // Alpha is the lower of the vertex color or tag color alpha used.
                highlightColor.a = this.m_fontColor32.a < highlightColor.a ? this.m_fontColor32.a : highlightColor.a;

                var colors32 = ($t5 = this.m_textInfo.meshInfo)[underlineMaterialIndex].colors32;
                colors32[0 + index.v] = highlightColor.$clone();
                colors32[1 + index.v] = highlightColor.$clone();
                colors32[2 + index.v] = highlightColor.$clone();
                colors32[3 + index.v] = highlightColor.$clone();


                index.v += 4;
            },
            /*TMPro.TMP_Text.DrawTextHighlight end.*/

            /*TMPro.TMP_Text.LoadDefaultSettings start.*/
            /**
             * Internal function used to load the default settings of text objects.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @return  {void}
             */
            LoadDefaultSettings: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#LoadDefaultSettings", this ); }

                if (this.m_fontSize === -99 || this.m_isWaitingOnResourceLoad) {
                    this.m_rectTransform = this.rectTransform$1;

                    if (TMPro.TMP_Settings.autoSizeTextContainer) {
                        this.autoSizeTextContainer = true;
                    } else {
                        if (Bridge.referenceEquals(Bridge.getType(this), TMPro.TextMeshPro)) {
                            if (pc.Vec2.equals( this.m_rectTransform.sizeDelta, new pc.Vec2( 100, 100 ) )) {
                                this.m_rectTransform.sizeDelta = TMPro.TMP_Settings.defaultTextMeshProTextContainerSize.$clone();
                            }
                        } else {
                            if (pc.Vec2.equals( this.m_rectTransform.sizeDelta, new pc.Vec2( 100, 100 ) )) {
                                this.m_rectTransform.sizeDelta = TMPro.TMP_Settings.defaultTextMeshProUITextContainerSize.$clone();
                            }
                        }
                    }

                    this.m_enableWordWrapping = TMPro.TMP_Settings.enableWordWrapping;
                    this.m_enableKerning = TMPro.TMP_Settings.enableKerning;
                    this.m_enableExtraPadding = TMPro.TMP_Settings.enableExtraPadding;
                    this.m_tintAllSprites = TMPro.TMP_Settings.enableTintAllSprites;
                    this.m_parseCtrlCharacters = TMPro.TMP_Settings.enableParseEscapeCharacters;
                    this.m_fontSize = (this.m_fontSizeBase = TMPro.TMP_Settings.defaultFontSize);
                    this.m_fontSizeMin = this.m_fontSize * TMPro.TMP_Settings.defaultTextAutoSizingMinRatio;
                    this.m_fontSizeMax = this.m_fontSize * TMPro.TMP_Settings.defaultTextAutoSizingMaxRatio;
                    this.m_isWaitingOnResourceLoad = false;
                    this.raycastTarget = TMPro.TMP_Settings.enableRaycastTarget;
                    this.m_IsTextObjectScaleStatic = TMPro.TMP_Settings.isTextObjectScaleStatic;
                } else if (this.m_textAlignment < 255) {
                    // Convert Legacy TextAlignmentOptions enumerations from Unity 5.2 / 5.3.
                    this.m_textAlignment = TMPro.TMP_Compatibility.ConvertTextAlignmentEnumValues(this.m_textAlignment);
                }

                // Convert text alignment to independent horizontal and vertical alignment properties
                if (this.m_textAlignment !== TMPro.TextAlignmentOptions.Converted) {
                    this.m_HorizontalAlignment = this.m_textAlignment & 255;
                    this.m_VerticalAlignment = this.m_textAlignment & 65280;
                    this.m_textAlignment = TMPro.TextAlignmentOptions.Converted;
                }
            },
            /*TMPro.TMP_Text.LoadDefaultSettings end.*/

            /*TMPro.TMP_Text.GetSpecialCharacters start.*/
            /**
             * Method used to find and cache references to the Underline and Ellipsis characters.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {TMPro.TMP_FontAsset}    fontAsset
             * @return  {void}
             */
            GetSpecialCharacters: function (fontAsset) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetSpecialCharacters", this ); }

                this.GetEllipsisSpecialCharacter(fontAsset);

                this.GetUnderlineSpecialCharacter(fontAsset);
            },
            /*TMPro.TMP_Text.GetSpecialCharacters end.*/

            /*TMPro.TMP_Text.GetEllipsisSpecialCharacter start.*/
            GetEllipsisSpecialCharacter: function (fontAsset) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetEllipsisSpecialCharacter", this ); }

                var isUsingAlternativeTypeface = { };

                // Search base font asset
                var character = TMPro.TMP_FontAssetUtilities.GetCharacterFromFontAsset(8230, fontAsset, false, this.m_FontStyleInternal, this.m_FontWeightInternal, isUsingAlternativeTypeface);

                if (character == null) {
                    // Search primary fallback list
                    if (fontAsset.m_FallbackFontAssetTable != null && fontAsset.m_FallbackFontAssetTable.Count > 0) {
                        character = TMPro.TMP_FontAssetUtilities.GetCharacterFromFontAssets(8230, fontAsset, fontAsset.m_FallbackFontAssetTable, true, this.m_FontStyleInternal, this.m_FontWeightInternal, isUsingAlternativeTypeface);
                    }
                }

                // Search TMP Settings general fallback list
                if (character == null) {
                    if (TMPro.TMP_Settings.fallbackFontAssets != null && TMPro.TMP_Settings.fallbackFontAssets.Count > 0) {
                        character = TMPro.TMP_FontAssetUtilities.GetCharacterFromFontAssets(8230, fontAsset, TMPro.TMP_Settings.fallbackFontAssets, true, this.m_FontStyleInternal, this.m_FontWeightInternal, isUsingAlternativeTypeface);
                    }
                }

                // Search TMP Settings' default font asset
                if (character == null) {
                    if (TMPro.TMP_Settings.defaultFontAsset != null) {
                        character = TMPro.TMP_FontAssetUtilities.GetCharacterFromFontAsset(8230, TMPro.TMP_Settings.defaultFontAsset, true, this.m_FontStyleInternal, this.m_FontWeightInternal, isUsingAlternativeTypeface);
                    }
                }

                if (character != null) {
                    this.m_Ellipsis = new TMPro.TMP_Text.SpecialCharacter.$ctor1(character, 0);
                }
            },
            /*TMPro.TMP_Text.GetEllipsisSpecialCharacter end.*/

            /*TMPro.TMP_Text.GetUnderlineSpecialCharacter start.*/
            GetUnderlineSpecialCharacter: function (fontAsset) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetUnderlineSpecialCharacter", this ); }

                var isUsingAlternativeTypeface = { };

                // Search primary font asset for underline character while ignoring font style and weight as these do not affect the underline character.
                var character = TMPro.TMP_FontAssetUtilities.GetCharacterFromFontAsset(95, fontAsset, false, TMPro.FontStyles.Normal, TMPro.FontWeight.Regular, isUsingAlternativeTypeface);

                /* 
                if (m_Underline.character == null)
                {
                   // Search primary fallback list
                   if (fontAsset.m_FallbackFontAssetTable != null && fontAsset.m_FallbackFontAssetTable.Count > 0)
                       m_Underline.character = TMP_FontAssetUtilities.GetCharacterFromFontAssets(0x5F, fontAsset.m_FallbackFontAssetTable, true, m_FontStyleInternal, m_FontWeightInternal, out isUsingAlternativeTypeface, out tempFontAsset);
                }

                // Search TMP Settings general fallback list
                if (m_Underline.character == null)
                {
                   if (TMP_Settings.fallbackFontAssets != null && TMP_Settings.fallbackFontAssets.Count > 0)
                       m_Underline.character = TMP_FontAssetUtilities.GetCharacterFromFontAssets(0x5F, TMP_Settings.fallbackFontAssets, true, m_FontStyleInternal, m_FontWeightInternal, out isUsingAlternativeTypeface, out tempFontAsset);
                }

                // Search TMP Settings' default font asset
                if (m_Underline.character == null)
                {
                   if (TMP_Settings.defaultFontAsset != null)
                       m_Underline.character = TMP_FontAssetUtilities.GetCharacterFromFontAsset(0x5F, TMP_Settings.defaultFontAsset, true, m_FontStyleInternal, m_FontWeightInternal, out isUsingAlternativeTypeface, out tempFontAsset);
                }
                */

                if (character != null) {
                    this.m_Underline = new TMPro.TMP_Text.SpecialCharacter.$ctor1(character, 0);
                } else {
                    if (!TMPro.TMP_Settings.warningsDisabled) {
                        UnityEngine.Debug.LogWarning$1("The character used for Underline is not available in font asset [" + (fontAsset.name || "") + "].", this);
                    }
                }
            },
            /*TMPro.TMP_Text.GetUnderlineSpecialCharacter end.*/

            /*TMPro.TMP_Text.ReplaceTagWithCharacter start.*/
            /**
             * Replace a given number of characters (tag) in the array with a new character and shift subsequent characters in the array.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {Array.<number>}    chars             Array which contains the text.
             * @param   {number}            insertionIndex    The index of where the new character will be inserted
             * @param   {number}            tagLength         Length of the tag being replaced.
             * @param   {number}            c                 The replacement character.
             * @return  {void}
             */
            ReplaceTagWithCharacter: function (chars, insertionIndex, tagLength, c) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#ReplaceTagWithCharacter", this ); }

                chars[insertionIndex] = c;

                for (var i = insertionIndex + tagLength; i < chars.length; i++) {
                    chars[i - 3] = chars[i];
                }
            },
            /*TMPro.TMP_Text.ReplaceTagWithCharacter end.*/

            /*TMPro.TMP_Text.GetFontAssetForWeight start.*/
            /**
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {number}                 fontWeight
             * @return  {TMPro.TMP_FontAsset}
             */
            GetFontAssetForWeight: function (fontWeight) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetFontAssetForWeight", this ); }

                var $t, $t1;
                var isItalic = (this.m_FontStyleInternal & TMPro.FontStyles.Italic) === TMPro.FontStyles.Italic || (this.m_fontStyle & TMPro.FontStyles.Italic) === TMPro.FontStyles.Italic;

                var fontAsset = null;

                var weightIndex = fontWeight / 100;

                if (isItalic) {
                    fontAsset = ($t = this.m_currentFontAsset.fontWeightTable)[weightIndex].italicTypeface;
                } else {
                    fontAsset = ($t1 = this.m_currentFontAsset.fontWeightTable)[weightIndex].regularTypeface;
                }

                return fontAsset;
            },
            /*TMPro.TMP_Text.GetFontAssetForWeight end.*/

            /*TMPro.TMP_Text.GetTextElement start.*/
            GetTextElement: function (unicode, fontAsset, fontStyle, fontWeight, isUsingAlternativeTypeface) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetTextElement", this ); }

                var character = TMPro.TMP_FontAssetUtilities.GetCharacterFromFontAsset(unicode, fontAsset, false, fontStyle, fontWeight, isUsingAlternativeTypeface);

                if (character != null) {
                    return character;
                }

                // Search potential list of fallback font assets assigned to the font asset.
                if (fontAsset.m_FallbackFontAssetTable != null && fontAsset.m_FallbackFontAssetTable.Count > 0) {
                    character = TMPro.TMP_FontAssetUtilities.GetCharacterFromFontAssets(unicode, fontAsset, fontAsset.m_FallbackFontAssetTable, true, fontStyle, fontWeight, isUsingAlternativeTypeface);
                }

                if (character != null) {
                    // Add character to font asset lookup cache
                    //fontAsset.AddCharacterToLookupCache(unicode, character);

                    return character;
                }

                // Search for the character in the primary font asset if not the current font asset
                if (fontAsset.instanceID !== this.m_fontAsset.instanceID) {
                    // Search primary font asset
                    character = TMPro.TMP_FontAssetUtilities.GetCharacterFromFontAsset(unicode, this.m_fontAsset, false, fontStyle, fontWeight, isUsingAlternativeTypeface);

                    // Use material and index of primary font asset.
                    if (character != null) {
                        this.m_currentMaterialIndex = 0;
                        this.m_currentMaterial = TMPro.TMP_Text.m_materialReferences[0].material;

                        // Add character to font asset lookup cache
                        //fontAsset.AddCharacterToLookupCache(unicode, character);

                        return character;
                    }

                    // Search list of potential fallback font assets assigned to the primary font asset.
                    if (this.m_fontAsset.m_FallbackFontAssetTable != null && this.m_fontAsset.m_FallbackFontAssetTable.Count > 0) {
                        character = TMPro.TMP_FontAssetUtilities.GetCharacterFromFontAssets(unicode, fontAsset, this.m_fontAsset.m_FallbackFontAssetTable, true, fontStyle, fontWeight, isUsingAlternativeTypeface);
                    }

                    if (character != null) {
                        // Add character to font asset lookup cache
                        //fontAsset.AddCharacterToLookupCache(unicode, character);

                        return character;
                    }
                }

                // Search for the character in potential local Sprite Asset assigned to the text object.
                if (this.m_spriteAsset != null) {
                    var spriteCharacter = TMPro.TMP_FontAssetUtilities.GetSpriteCharacterFromSpriteAsset(unicode, this.m_spriteAsset, true);

                    if (spriteCharacter != null) {
                        return spriteCharacter;
                    }
                }

                // Search for the character in the list of fallback assigned in the TMP Settings (General Fallbacks).
                if (TMPro.TMP_Settings.fallbackFontAssets != null && TMPro.TMP_Settings.fallbackFontAssets.Count > 0) {
                    character = TMPro.TMP_FontAssetUtilities.GetCharacterFromFontAssets(unicode, fontAsset, TMPro.TMP_Settings.fallbackFontAssets, true, fontStyle, fontWeight, isUsingAlternativeTypeface);
                }

                if (character != null) {
                    // Add character to font asset lookup cache
                    //fontAsset.AddCharacterToLookupCache(unicode, character);

                    return character;
                }

                // Search for the character in the Default Font Asset assigned in the TMP Settings file.
                if (TMPro.TMP_Settings.defaultFontAsset != null) {
                    character = TMPro.TMP_FontAssetUtilities.GetCharacterFromFontAsset(unicode, TMPro.TMP_Settings.defaultFontAsset, true, fontStyle, fontWeight, isUsingAlternativeTypeface);
                }

                if (character != null) {
                    // Add character to font asset lookup cache
                    //fontAsset.AddCharacterToLookupCache(unicode, character);

                    return character;
                }

                // Search for the character in the Default Sprite Asset assigned in the TMP Settings file.
                if (TMPro.TMP_Settings.defaultSpriteAsset != null) {
                    var spriteCharacter1 = TMPro.TMP_FontAssetUtilities.GetSpriteCharacterFromSpriteAsset(unicode, TMPro.TMP_Settings.defaultSpriteAsset, true);

                    if (spriteCharacter1 != null) {
                        return spriteCharacter1;
                    }
                }

                return null;
            },
            /*TMPro.TMP_Text.GetTextElement end.*/

            /*TMPro.TMP_Text.SetActiveSubMeshes start.*/
            /**
             * Method to Enable or Disable child SubMesh objects.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {boolean}    state
             * @return  {void}
             */
            SetActiveSubMeshes: function (state) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#SetActiveSubMeshes", this ); }
 },
            /*TMPro.TMP_Text.SetActiveSubMeshes end.*/

            /*TMPro.TMP_Text.DestroySubMeshObjects start.*/
            /**
             * Destroy Sub Mesh Objects.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @return  {void}
             */
            DestroySubMeshObjects: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#DestroySubMeshObjects", this ); }
 },
            /*TMPro.TMP_Text.DestroySubMeshObjects end.*/

            /*TMPro.TMP_Text.ClearMesh start.*/
            /**
             * Function to clear the geometry of the Primary and Sub Text objects.
             *
             * @instance
             * @public
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @return  {void}
             */
            ClearMesh: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#ClearMesh", this ); }
 },
            /*TMPro.TMP_Text.ClearMesh end.*/

            /*TMPro.TMP_Text.ClearMesh$1 start.*/
            /**
             * Function to clear the geometry of the Primary and Sub Text objects.
             *
             * @instance
             * @public
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {boolean}    uploadGeometry
             * @return  {void}
             */
            ClearMesh$1: function (uploadGeometry) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#ClearMesh$1", this ); }
 },
            /*TMPro.TMP_Text.ClearMesh$1 end.*/

            /*TMPro.TMP_Text.GetParsedText start.*/
            /**
             * Function which returns the text after it has been parsed and rich text tags removed.
             *
             * @instance
             * @public
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @return  {string}
             */
            GetParsedText: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetParsedText", this ); }

                var $t;
                if (this.m_textInfo == null) {
                    return "";
                }

                var characterCount = this.m_textInfo.characterCount;

                // TODO - Could implement some static buffer pool shared by all instances of TMP objects.
                var buffer = System.Array.init(characterCount, 0, System.Char);

                for (var i = 0; i < characterCount && i < this.m_textInfo.characterInfo.length; i++) {
                    buffer[i] = ($t = this.m_textInfo.characterInfo)[i].character;
                }

                return System.String.fromCharArray(buffer);
            },
            /*TMPro.TMP_Text.GetParsedText end.*/

            /*TMPro.TMP_Text.IsSelfOrLinkedAncestor start.*/
            IsSelfOrLinkedAncestor: function (targetTextComponent) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#IsSelfOrLinkedAncestor", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(targetTextComponent, null)) {
                    return true;
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.parentLinkedComponent, null)) {
                    if (this.parentLinkedComponent.IsSelfOrLinkedAncestor(targetTextComponent)) {
                        return true;
                    }
                }

                if (this.GetInstanceID() === targetTextComponent.GetInstanceID()) {
                    return true;
                }

                return false;
            },
            /*TMPro.TMP_Text.IsSelfOrLinkedAncestor end.*/

            /*TMPro.TMP_Text.ReleaseLinkedTextComponent start.*/
            ReleaseLinkedTextComponent: function (targetTextComponent) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#ReleaseLinkedTextComponent", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(targetTextComponent, null)) {
                    return;
                }

                var childLinkedComponent = targetTextComponent.linkedTextComponent;

                if (UnityEngine.MonoBehaviour.op_Inequality(childLinkedComponent, null)) {
                    this.ReleaseLinkedTextComponent(childLinkedComponent);
                }

                targetTextComponent.text = "";
                targetTextComponent.firstVisibleCharacter = 0;
                targetTextComponent.linkedTextComponent = null;
                targetTextComponent.parentLinkedComponent = null;
            },
            /*TMPro.TMP_Text.ReleaseLinkedTextComponent end.*/

            /*TMPro.TMP_Text.PackUV$1 start.*/
            /**
             * Function to pack scale information in the UV2 Channel.
             * Function to pack scale information in the UV2 Channel.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {number}                 x        
             * @param   {number}                 y        
             * @param   {number}                 scale
             * @return  {UnityEngine.Vector2}
             */
            PackUV$1: function (x, y, scale) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#PackUV$1", this ); }

                var output = new UnityEngine.Vector2();

                output.x = Math.floor(x * 511);
                output.y = Math.floor(y * 511);
                output.x = output.x * 4096 + output.y;
                output.y = scale;

                return output.$clone();
            },
            /*TMPro.TMP_Text.PackUV$1 end.*/

            /*TMPro.TMP_Text.PackUV start.*/
            /**
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {number}    x    
             * @param   {number}    y
             * @return  {number}
             */
            PackUV: function (x, y) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#PackUV", this ); }

                var x0 = Math.floor(x * 511);
                var y0 = Math.floor(y * 511);

                return x0 * 4096 + y0;
            },
            /*TMPro.TMP_Text.PackUV end.*/

            /*TMPro.TMP_Text.InternalUpdate start.*/
            /**
             * Function used as a replacement for LateUpdate()
             *
             * @instance
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @return  {void}
             */
            InternalUpdate: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#InternalUpdate", this ); }
 },
            /*TMPro.TMP_Text.InternalUpdate end.*/

            /*TMPro.TMP_Text.HexToInt start.*/
            /**
             * Function to pack scale information in the UV2 Channel.
             * 
             * Method to convert Hex to Int
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {number}    hex
             * @return  {number}
             */
            HexToInt: function (hex) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#HexToInt", this ); }

                switch (hex) {
                    case 48: 
                        return 0;
                    case 49: 
                        return 1;
                    case 50: 
                        return 2;
                    case 51: 
                        return 3;
                    case 52: 
                        return 4;
                    case 53: 
                        return 5;
                    case 54: 
                        return 6;
                    case 55: 
                        return 7;
                    case 56: 
                        return 8;
                    case 57: 
                        return 9;
                    case 65: 
                        return 10;
                    case 66: 
                        return 11;
                    case 67: 
                        return 12;
                    case 68: 
                        return 13;
                    case 69: 
                        return 14;
                    case 70: 
                        return 15;
                    case 97: 
                        return 10;
                    case 98: 
                        return 11;
                    case 99: 
                        return 12;
                    case 100: 
                        return 13;
                    case 101: 
                        return 14;
                    case 102: 
                        return 15;
                }

                return 15;
            },
            /*TMPro.TMP_Text.HexToInt end.*/

            /*TMPro.TMP_Text.GetUTF16$2 start.*/
            /**
             * Convert UTF-16 Hex to Char
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {string}    text    
             * @param   {number}    i       The index.
             * @return  {number}            The Unicode hex.
             */
            GetUTF16$2: function (text, i) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetUTF16$2", this ); }

                var unicode = 0;
                unicode += this.HexToInt(text.charCodeAt(i)) << 12;
                unicode += this.HexToInt(text.charCodeAt(i + 1)) << 8;
                unicode += this.HexToInt(text.charCodeAt(i + 2)) << 4;
                unicode += this.HexToInt(text.charCodeAt(i + 3));
                return unicode;
            },
            /*TMPro.TMP_Text.GetUTF16$2 end.*/

            /*TMPro.TMP_Text.GetUTF16$1 start.*/
            GetUTF16$1: function (text, i) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetUTF16$1", this ); }

                var unicode = 0;
                unicode += this.HexToInt(text[i]) << 12;
                unicode += this.HexToInt(text[i + 1]) << 8;
                unicode += this.HexToInt(text[i + 2]) << 4;
                unicode += this.HexToInt(text[i + 3]);
                return unicode;
            },
            /*TMPro.TMP_Text.GetUTF16$1 end.*/

            /*TMPro.TMP_Text.GetUTF16 start.*/
            GetUTF16: function (text, i) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetUTF16", this ); }

                var unicode = 0;
                unicode += this.HexToInt(text[i]) << 12;
                unicode += this.HexToInt(text[i + 1]) << 8;
                unicode += this.HexToInt(text[i + 2]) << 4;
                unicode += this.HexToInt(text[i + 3]);
                return unicode;
            },
            /*TMPro.TMP_Text.GetUTF16 end.*/

            /*TMPro.TMP_Text.GetUTF16$3 start.*/
            /**
             * Convert UTF-16 Hex to Char
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {System.Text.StringBuilder}    text    
             * @param   {number}                       i       The index.
             * @return  {number}                               The Unicode hex.
             */
            GetUTF16$3: function (text, i) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetUTF16$3", this ); }

                var unicode = 0;
                unicode += this.HexToInt(text.getChar(i)) << 12;
                unicode += this.HexToInt(text.getChar(i + 1)) << 8;
                unicode += this.HexToInt(text.getChar(i + 2)) << 4;
                unicode += this.HexToInt(text.getChar(i + 3));
                return unicode;
            },
            /*TMPro.TMP_Text.GetUTF16$3 end.*/

            /*TMPro.TMP_Text.GetUTF16$4 start.*/
            GetUTF16$4: function (text, i) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetUTF16$4", this ); }

                var unicode = 0;
                unicode += this.HexToInt(text.getItem(i)) << 12;
                unicode += this.HexToInt(text.getItem(i + 1)) << 8;
                unicode += this.HexToInt(text.getItem(i + 2)) << 4;
                unicode += this.HexToInt(text.getItem(i + 3));
                return unicode;
            },
            /*TMPro.TMP_Text.GetUTF16$4 end.*/

            /*TMPro.TMP_Text.GetUTF32$2 start.*/
            /**
             * Convert UTF-32 Hex to Char
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {string}    text    
             * @param   {number}    i       The index.
             * @return  {number}            The Unicode hex.
             */
            GetUTF32$2: function (text, i) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetUTF32$2", this ); }

                var unicode = 0;
                unicode += this.HexToInt(text.charCodeAt(i)) << 28;
                unicode += this.HexToInt(text.charCodeAt(i + 1)) << 24;
                unicode += this.HexToInt(text.charCodeAt(i + 2)) << 20;
                unicode += this.HexToInt(text.charCodeAt(i + 3)) << 16;
                unicode += this.HexToInt(text.charCodeAt(i + 4)) << 12;
                unicode += this.HexToInt(text.charCodeAt(i + 5)) << 8;
                unicode += this.HexToInt(text.charCodeAt(i + 6)) << 4;
                unicode += this.HexToInt(text.charCodeAt(i + 7));
                return unicode;
            },
            /*TMPro.TMP_Text.GetUTF32$2 end.*/

            /*TMPro.TMP_Text.GetUTF32$1 start.*/
            GetUTF32$1: function (text, i) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetUTF32$1", this ); }

                var unicode = 0;
                unicode += this.HexToInt(text[i]) << 28;
                unicode += this.HexToInt(text[i + 1]) << 24;
                unicode += this.HexToInt(text[i + 2]) << 20;
                unicode += this.HexToInt(text[i + 3]) << 16;
                unicode += this.HexToInt(text[i + 4]) << 12;
                unicode += this.HexToInt(text[i + 5]) << 8;
                unicode += this.HexToInt(text[i + 6]) << 4;
                unicode += this.HexToInt(text[i + 7]);
                return unicode;
            },
            /*TMPro.TMP_Text.GetUTF32$1 end.*/

            /*TMPro.TMP_Text.GetUTF32 start.*/
            GetUTF32: function (text, i) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetUTF32", this ); }

                var unicode = 0;
                unicode += this.HexToInt(text[i]) << 28;
                unicode += this.HexToInt(text[i + 1]) << 24;
                unicode += this.HexToInt(text[i + 2]) << 20;
                unicode += this.HexToInt(text[i + 3]) << 16;
                unicode += this.HexToInt(text[i + 4]) << 12;
                unicode += this.HexToInt(text[i + 5]) << 8;
                unicode += this.HexToInt(text[i + 6]) << 4;
                unicode += this.HexToInt(text[i + 7]);
                return unicode;
            },
            /*TMPro.TMP_Text.GetUTF32 end.*/

            /*TMPro.TMP_Text.GetUTF32$3 start.*/
            /**
             * Convert UTF-32 Hex to Char
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {System.Text.StringBuilder}    text    
             * @param   {number}                       i       The index.
             * @return  {number}                               The Unicode hex.
             */
            GetUTF32$3: function (text, i) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetUTF32$3", this ); }

                var unicode = 0;
                unicode += this.HexToInt(text.getChar(i)) << 28;
                unicode += this.HexToInt(text.getChar(i + 1)) << 24;
                unicode += this.HexToInt(text.getChar(i + 2)) << 20;
                unicode += this.HexToInt(text.getChar(i + 3)) << 16;
                unicode += this.HexToInt(text.getChar(i + 4)) << 12;
                unicode += this.HexToInt(text.getChar(i + 5)) << 8;
                unicode += this.HexToInt(text.getChar(i + 6)) << 4;
                unicode += this.HexToInt(text.getChar(i + 7));
                return unicode;
            },
            /*TMPro.TMP_Text.GetUTF32$3 end.*/

            /*TMPro.TMP_Text.GetUTF32$4 start.*/
            GetUTF32$4: function (text, i) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetUTF32$4", this ); }

                var unicode = 0;
                unicode += this.HexToInt(text.getItem(i)) << 28;
                unicode += this.HexToInt(text.getItem(i + 1)) << 24;
                unicode += this.HexToInt(text.getItem(i + 2)) << 20;
                unicode += this.HexToInt(text.getItem(i + 3)) << 16;
                unicode += this.HexToInt(text.getItem(i + 4)) << 12;
                unicode += this.HexToInt(text.getItem(i + 5)) << 8;
                unicode += this.HexToInt(text.getItem(i + 6)) << 4;
                unicode += this.HexToInt(text.getItem(i + 7));
                return unicode;
            },
            /*TMPro.TMP_Text.GetUTF32$4 end.*/

            /*TMPro.TMP_Text.HexCharsToColor start.*/
            /**
             * Method to convert Hex color values to Color32
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {Array.<number>}         hexChars    
             * @param   {number}                 tagCount
             * @return  {UnityEngine.Color32}
             */
            HexCharsToColor: function (hexChars, tagCount) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#HexCharsToColor", this ); }

                if (tagCount === 4) {
                    var r = this.HexToInt(hexChars[1]) * 16 + this.HexToInt(hexChars[1]);
                    var g = this.HexToInt(hexChars[2]) * 16 + this.HexToInt(hexChars[2]);
                    var b = this.HexToInt(hexChars[3]) * 16 + this.HexToInt(hexChars[3]);

                    return new UnityEngine.Color32.$ctor1(r, g, b, 255);
                } else if (tagCount === 5) {
                    var r1 = this.HexToInt(hexChars[1]) * 16 + this.HexToInt(hexChars[1]);
                    var g1 = this.HexToInt(hexChars[2]) * 16 + this.HexToInt(hexChars[2]);
                    var b1 = this.HexToInt(hexChars[3]) * 16 + this.HexToInt(hexChars[3]);
                    var a = this.HexToInt(hexChars[4]) * 16 + this.HexToInt(hexChars[4]);

                    return new UnityEngine.Color32.$ctor1(r1, g1, b1, a);
                } else if (tagCount === 7) {
                    var r2 = this.HexToInt(hexChars[1]) * 16 + this.HexToInt(hexChars[2]);
                    var g2 = this.HexToInt(hexChars[3]) * 16 + this.HexToInt(hexChars[4]);
                    var b2 = this.HexToInt(hexChars[5]) * 16 + this.HexToInt(hexChars[6]);

                    return new UnityEngine.Color32.$ctor1(r2, g2, b2, 255);
                } else if (tagCount === 9) {
                    var r3 = this.HexToInt(hexChars[1]) * 16 + this.HexToInt(hexChars[2]);
                    var g3 = this.HexToInt(hexChars[3]) * 16 + this.HexToInt(hexChars[4]);
                    var b3 = this.HexToInt(hexChars[5]) * 16 + this.HexToInt(hexChars[6]);
                    var a1 = this.HexToInt(hexChars[7]) * 16 + this.HexToInt(hexChars[8]);

                    return new UnityEngine.Color32.$ctor1(r3, g3, b3, a1);
                } else if (tagCount === 10) {
                    var r4 = this.HexToInt(hexChars[7]) * 16 + this.HexToInt(hexChars[7]);
                    var g4 = this.HexToInt(hexChars[8]) * 16 + this.HexToInt(hexChars[8]);
                    var b4 = this.HexToInt(hexChars[9]) * 16 + this.HexToInt(hexChars[9]);

                    return new UnityEngine.Color32.$ctor1(r4, g4, b4, 255);
                } else if (tagCount === 11) {
                    var r5 = this.HexToInt(hexChars[7]) * 16 + this.HexToInt(hexChars[7]);
                    var g5 = this.HexToInt(hexChars[8]) * 16 + this.HexToInt(hexChars[8]);
                    var b5 = this.HexToInt(hexChars[9]) * 16 + this.HexToInt(hexChars[9]);
                    var a2 = this.HexToInt(hexChars[10]) * 16 + this.HexToInt(hexChars[10]);

                    return new UnityEngine.Color32.$ctor1(r5, g5, b5, a2);
                } else if (tagCount === 13) {
                    var r6 = this.HexToInt(hexChars[7]) * 16 + this.HexToInt(hexChars[8]);
                    var g6 = this.HexToInt(hexChars[9]) * 16 + this.HexToInt(hexChars[10]);
                    var b6 = this.HexToInt(hexChars[11]) * 16 + this.HexToInt(hexChars[12]);

                    return new UnityEngine.Color32.$ctor1(r6, g6, b6, 255);
                } else if (tagCount === 15) {
                    var r7 = this.HexToInt(hexChars[7]) * 16 + this.HexToInt(hexChars[8]);
                    var g7 = this.HexToInt(hexChars[9]) * 16 + this.HexToInt(hexChars[10]);
                    var b7 = this.HexToInt(hexChars[11]) * 16 + this.HexToInt(hexChars[12]);
                    var a3 = this.HexToInt(hexChars[13]) * 16 + this.HexToInt(hexChars[14]);

                    return new UnityEngine.Color32.$ctor1(r7, g7, b7, a3);
                }

                return new UnityEngine.Color32.$ctor1(255, 255, 255, 255);
            },
            /*TMPro.TMP_Text.HexCharsToColor end.*/

            /*TMPro.TMP_Text.HexCharsToColor$1 start.*/
            /**
             * Method to convert Hex Color values to Color32
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {Array.<number>}         hexChars      
             * @param   {number}                 startIndex    
             * @param   {number}                 length
             * @return  {UnityEngine.Color32}
             */
            HexCharsToColor$1: function (hexChars, startIndex, length) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#HexCharsToColor$1", this ); }

                if (length === 7) {
                    var r = this.HexToInt(hexChars[startIndex + 1]) * 16 + this.HexToInt(hexChars[startIndex + 2]);
                    var g = this.HexToInt(hexChars[startIndex + 3]) * 16 + this.HexToInt(hexChars[startIndex + 4]);
                    var b = this.HexToInt(hexChars[startIndex + 5]) * 16 + this.HexToInt(hexChars[startIndex + 6]);

                    return new UnityEngine.Color32.$ctor1(r, g, b, 255);
                } else if (length === 9) {
                    var r1 = this.HexToInt(hexChars[startIndex + 1]) * 16 + this.HexToInt(hexChars[startIndex + 2]);
                    var g1 = this.HexToInt(hexChars[startIndex + 3]) * 16 + this.HexToInt(hexChars[startIndex + 4]);
                    var b1 = this.HexToInt(hexChars[startIndex + 5]) * 16 + this.HexToInt(hexChars[startIndex + 6]);
                    var a = this.HexToInt(hexChars[startIndex + 7]) * 16 + this.HexToInt(hexChars[startIndex + 8]);

                    return new UnityEngine.Color32.$ctor1(r1, g1, b1, a);
                }

                return TMPro.TMP_Text.s_colorWhite.$clone();
            },
            /*TMPro.TMP_Text.HexCharsToColor$1 end.*/

            /*TMPro.TMP_Text.GetAttributeParameters start.*/
            /**
             * Method which returns the number of parameters used in a tag attribute and populates an array with such values.
             *
             * @instance
             * @private
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {Array.<number>}    chars         Char[] containing the tag attribute and data
             * @param   {number}            startIndex    The index of the first char of the data
             * @param   {number}            length        The length of the data
             * @param   {System.Single}     parameters    The number of parameters contained in the Char[]
             * @return  {number}
             */
            GetAttributeParameters: function (chars, startIndex, length, parameters) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#GetAttributeParameters", this ); }

                var endIndex = { v : startIndex };
                var attributeCount = 0;

                while (endIndex.v < startIndex + length) {
                    parameters.v[attributeCount] = this.ConvertToFloat$1(chars, startIndex, length, endIndex);

                    length -= endIndex.v - startIndex + 1;
                    startIndex = endIndex.v + 1;

                    attributeCount += 1;
                }

                return attributeCount;
            },
            /*TMPro.TMP_Text.GetAttributeParameters end.*/

            /*TMPro.TMP_Text.ConvertToFloat start.*/
            /**
             * Extracts a float value from char[] assuming we know the position of the start, end and decimal point.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {Array.<number>}    chars         
             * @param   {number}            startIndex    
             * @param   {number}            length
             * @return  {number}
             */
            ConvertToFloat: function (chars, startIndex, length) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#ConvertToFloat", this ); }

                var lastIndex = { };

                return this.ConvertToFloat$1(chars, startIndex, length, lastIndex);
            },
            /*TMPro.TMP_Text.ConvertToFloat end.*/

            /*TMPro.TMP_Text.ConvertToFloat$1 start.*/
            /**
             * Extracts a float value from char[] given a start index and length.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {Array.<number>}    chars         
             * @param   {number}            startIndex    
             * @param   {number}            length        
             * @param   {System.Int32}      lastIndex
             * @return  {number}
             */
            ConvertToFloat$1: function (chars, startIndex, length, lastIndex) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#ConvertToFloat$1", this ); }

                if (startIndex === 0) {
                    lastIndex.v = 0;
                    return -32768;
                }

                var endIndex = startIndex + length;

                var isIntegerValue = true;
                var decimalPointMultiplier = 0;

                // Set value multiplier checking the first character to determine if we are using '+' or '-'
                var valueSignMultiplier = 1;
                if (chars[startIndex] === 43) {
                    valueSignMultiplier = 1;
                    startIndex += 1;
                } else if (chars[startIndex] === 45) {
                    valueSignMultiplier = -1;
                    startIndex += 1;
                }

                var value = 0;

                for (var i = startIndex; i < endIndex; i++) {
                    var c = chars[i];

                    if (c >= 48 && c <= 57 || c === 46) {
                        if (c === 46) {
                            isIntegerValue = false;
                            decimalPointMultiplier = 0.1;
                            continue;
                        }

                        //Calculate integer and floating point value
                        if (isIntegerValue) {
                            value = ( value * 10 + ( c - 48 ) * valueSignMultiplier ) | 0;
                        } else {
                            value = value + (c - 48) * decimalPointMultiplier * valueSignMultiplier;
                            decimalPointMultiplier *= 0.1;
                        }

                        continue;
                    } else if (c === 44) {
                        if (i + 1 < endIndex && chars[i + 1] === 32) {
                            lastIndex.v = i + 1;
                        } else {
                            lastIndex.v = i;
                        }

                        // Make sure value is within reasonable range.
                        if (value > 32767) {
                            return -32768;
                        }

                        return value;
                    }
                }

                lastIndex.v = endIndex;

                // Make sure value is within reasonable range.
                if (value > 32767) {
                    return -32768;
                }

                return value;
            },
            /*TMPro.TMP_Text.ConvertToFloat$1 end.*/

            /*TMPro.TMP_Text.ValidateHtmlTag start.*/
            /**
             * Function to identify and validate the rich tag. Returns the position of the &gt; if the tag was valid.
             *
             * @instance
             * @this TMPro.TMP_Text
             * @memberof TMPro.TMP_Text
             * @param   {Array.<TMPro.TMP_Text.UnicodeChar>}    chars         
             * @param   {number}                                startIndex    
             * @param   {System.Int32}                          endIndex
             * @return  {boolean}
             */
            ValidateHtmlTag: function (chars, startIndex, endIndex) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text#ValidateHtmlTag", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14;
                var tagCharCount = 0;
                var attributeFlag = 0;

                var attributeIndex = 0;
                TMPro.TMP_Text.m_xmlAttribute[attributeIndex].nameHashCode = 0;
                TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueHashCode = 0;
                TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueStartIndex = 0;
                TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueLength = 0;
                var tagValueType = ($t = TMPro.TagValueType.None, TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueType = $t, $t);
                var tagUnitType = ($t1 = TMPro.TagUnitType.Pixels, TMPro.TMP_Text.m_xmlAttribute[attributeIndex].unitType = $t1, $t1);

                // Clear attribute name hash codes
                TMPro.TMP_Text.m_xmlAttribute[1].nameHashCode = 0;
                TMPro.TMP_Text.m_xmlAttribute[2].nameHashCode = 0;
                TMPro.TMP_Text.m_xmlAttribute[3].nameHashCode = 0;
                TMPro.TMP_Text.m_xmlAttribute[4].nameHashCode = 0;

                endIndex.v = startIndex;
                var isTagSet = false;
                var isValidHtmlTag = false;

                for (var i = startIndex; i < chars.length && chars[i].unicode !== 0 && tagCharCount < TMPro.TMP_Text.m_htmlTag.length && chars[i].unicode !== 60; i++) {
                    var unicode = chars[i].unicode;

                    if (unicode === 62) {
                        isValidHtmlTag = true;
                        endIndex.v = i;
                        TMPro.TMP_Text.m_htmlTag[tagCharCount] = 0;
                        break;
                    }

                    TMPro.TMP_Text.m_htmlTag[tagCharCount] = unicode;
                    tagCharCount += 1;

                    if (attributeFlag === 1) {
                        if (tagValueType === TMPro.TagValueType.None) {
                            // Check for attribute type
                            if (unicode === 43 || unicode === 45 || unicode === 46 || unicode >= 48 && unicode <= 57) {
                                tagUnitType = TMPro.TagUnitType.Pixels;
                                tagValueType = ($t2 = TMPro.TagValueType.NumericalValue, TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueType = $t2, $t2);
                                TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueStartIndex = tagCharCount - 1;
                                TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueLength += 1;
                            } else if (unicode === 35) {
                                tagUnitType = TMPro.TagUnitType.Pixels;
                                tagValueType = ($t3 = TMPro.TagValueType.ColorValue, TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueType = $t3, $t3);
                                TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueStartIndex = tagCharCount - 1;
                                TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueLength += 1;
                            } else if (unicode === 34) {
                                tagUnitType = TMPro.TagUnitType.Pixels;
                                tagValueType = ($t4 = TMPro.TagValueType.StringValue, TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueType = $t4, $t4);
                                TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueStartIndex = tagCharCount;
                            } else {
                                tagUnitType = TMPro.TagUnitType.Pixels;
                                tagValueType = ($t5 = TMPro.TagValueType.StringValue, TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueType = $t5, $t5);
                                TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueStartIndex = tagCharCount - 1;
                                TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueHashCode = ((TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueHashCode << 5) + TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueHashCode) ^ unicode;
                                TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueLength += 1;
                            }
                        } else {
                            if (tagValueType === TMPro.TagValueType.NumericalValue) {
                                // Check for termination of numerical value.
                                if (unicode === 112 || unicode === 101 || unicode === 37 || unicode === 32) {
                                    attributeFlag = 2;
                                    tagValueType = TMPro.TagValueType.None;

                                    switch (unicode) {
                                        case 101: 
                                            TMPro.TMP_Text.m_xmlAttribute[attributeIndex].unitType = (tagUnitType = TMPro.TagUnitType.FontUnits);
                                            break;
                                        case 37: 
                                            TMPro.TMP_Text.m_xmlAttribute[attributeIndex].unitType = (tagUnitType = TMPro.TagUnitType.Percentage);
                                            break;
                                        default: 
                                            TMPro.TMP_Text.m_xmlAttribute[attributeIndex].unitType = (tagUnitType = TMPro.TagUnitType.Pixels);
                                            break;
                                    }

                                    attributeIndex += 1;
                                    TMPro.TMP_Text.m_xmlAttribute[attributeIndex].nameHashCode = 0;
                                    TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueHashCode = 0;
                                    TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueType = TMPro.TagValueType.None;
                                    TMPro.TMP_Text.m_xmlAttribute[attributeIndex].unitType = TMPro.TagUnitType.Pixels;
                                    TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueStartIndex = 0;
                                    TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueLength = 0;
                                } else if (attributeFlag !== 2) {
                                    TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueLength += 1;
                                }
                            } else if (tagValueType === TMPro.TagValueType.ColorValue) {
                                if (unicode !== 32) {
                                    TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueLength += 1;
                                } else {
                                    attributeFlag = 2;
                                    tagValueType = TMPro.TagValueType.None;
                                    tagUnitType = TMPro.TagUnitType.Pixels;
                                    attributeIndex += 1;
                                    TMPro.TMP_Text.m_xmlAttribute[attributeIndex].nameHashCode = 0;
                                    TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueType = TMPro.TagValueType.None;
                                    TMPro.TMP_Text.m_xmlAttribute[attributeIndex].unitType = TMPro.TagUnitType.Pixels;
                                    TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueHashCode = 0;
                                    TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueStartIndex = 0;
                                    TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueLength = 0;
                                }
                            } else if (tagValueType === TMPro.TagValueType.StringValue) {
                                // Compute HashCode value for the named tag.
                                if (unicode !== 34) {
                                    TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueHashCode = ((TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueHashCode << 5) + TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueHashCode) ^ unicode;
                                    TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueLength += 1;
                                } else {
                                    attributeFlag = 2;
                                    tagValueType = TMPro.TagValueType.None;
                                    tagUnitType = TMPro.TagUnitType.Pixels;
                                    attributeIndex += 1;
                                    TMPro.TMP_Text.m_xmlAttribute[attributeIndex].nameHashCode = 0;
                                    TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueType = TMPro.TagValueType.None;
                                    TMPro.TMP_Text.m_xmlAttribute[attributeIndex].unitType = TMPro.TagUnitType.Pixels;
                                    TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueHashCode = 0;
                                    TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueStartIndex = 0;
                                    TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueLength = 0;
                                }
                            }
                        }
                    }


                    if (unicode === 61) {
                        attributeFlag = 1;
                    }

                    // Compute HashCode for the name of the attribute
                    if (attributeFlag === 0 && unicode === 32) {
                        if (isTagSet) {
                            return false;
                        }

                        isTagSet = true;
                        attributeFlag = 2;

                        tagValueType = TMPro.TagValueType.None;
                        tagUnitType = TMPro.TagUnitType.Pixels;
                        attributeIndex += 1;
                        TMPro.TMP_Text.m_xmlAttribute[attributeIndex].nameHashCode = 0;
                        TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueType = TMPro.TagValueType.None;
                        TMPro.TMP_Text.m_xmlAttribute[attributeIndex].unitType = TMPro.TagUnitType.Pixels;
                        TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueHashCode = 0;
                        TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueStartIndex = 0;
                        TMPro.TMP_Text.m_xmlAttribute[attributeIndex].valueLength = 0;
                    }

                    if (attributeFlag === 0) {
                        TMPro.TMP_Text.m_xmlAttribute[attributeIndex].nameHashCode = (TMPro.TMP_Text.m_xmlAttribute[attributeIndex].nameHashCode << 3) - TMPro.TMP_Text.m_xmlAttribute[attributeIndex].nameHashCode + unicode;
                    }

                    if (attributeFlag === 2 && unicode === 32) {
                        attributeFlag = 0;
                    }
                }

                if (!isValidHtmlTag) {
                    return false;
                }

                //Debug.Log("Tag is [" + m_htmlTag.ArrayToString() + "].  Tag HashCode: " + m_xmlAttribute[0].nameHashCode + "  Tag Value HashCode: " + m_xmlAttribute[0].valueHashCode + "  Attribute 1 HashCode: " + m_xmlAttribute[1].nameHashCode + " Value HashCode: " + m_xmlAttribute[1].valueHashCode);
                //for (int i = 0; i < attributeIndex; i++)
                //    Debug.Log("Tag [" + i + "] with HashCode: " + m_xmlAttribute[i].nameHashCode + " has value of [" + new string(m_htmlTag, m_xmlAttribute[i].valueStartIndex, m_xmlAttribute[i].valueLength) + "] Numerical Value: " + ConvertToFloat(m_htmlTag, m_xmlAttribute[i].valueStartIndex, m_xmlAttribute[i].valueLength));


                // Special handling of the no parsing tag </noparse> </NOPARSE> tag
                if (this.tag_NoParsing && TMPro.TMP_Text.m_xmlAttribute[0].nameHashCode !== 53822163 && TMPro.TMP_Text.m_xmlAttribute[0].nameHashCode !== 49429939) {
                    return false;
                } else if (TMPro.TMP_Text.m_xmlAttribute[0].nameHashCode === 53822163 || TMPro.TMP_Text.m_xmlAttribute[0].nameHashCode === 49429939) {
                    this.tag_NoParsing = false;
                    return true;
                }

                // Color <#FFF> 3 Hex values (short form)
                if (TMPro.TMP_Text.m_htmlTag[0] === 35 && tagCharCount === 4) {
                    this.m_htmlColor = this.HexCharsToColor(TMPro.TMP_Text.m_htmlTag, tagCharCount);
                    this.m_colorStack.Add(this.m_htmlColor.$clone());
                    return true;
                } else if (TMPro.TMP_Text.m_htmlTag[0] === 35 && tagCharCount === 5) {
                    this.m_htmlColor = this.HexCharsToColor(TMPro.TMP_Text.m_htmlTag, tagCharCount);
                    this.m_colorStack.Add(this.m_htmlColor.$clone());
                    return true;
                } else if (TMPro.TMP_Text.m_htmlTag[0] === 35 && tagCharCount === 7) {
                    this.m_htmlColor = this.HexCharsToColor(TMPro.TMP_Text.m_htmlTag, tagCharCount);
                    this.m_colorStack.Add(this.m_htmlColor.$clone());
                    return true;
                } else if (TMPro.TMP_Text.m_htmlTag[0] === 35 && tagCharCount === 9) {
                    this.m_htmlColor = this.HexCharsToColor(TMPro.TMP_Text.m_htmlTag, tagCharCount);
                    this.m_colorStack.Add(this.m_htmlColor.$clone());
                    return true;
                } else {
                    var value = 0;
                    var fontScale;

                    switch (TMPro.TMP_Text.m_xmlAttribute[0].nameHashCode) {
                        case 98: 
                        case 66:  // <b> // <B>
                            this.m_FontStyleInternal |= TMPro.FontStyles.Bold;
                            this.m_fontStyleStack.Add(TMPro.FontStyles.Bold);
                            this.m_FontWeightInternal = TMPro.FontWeight.Bold;
                            return true;
                        case 427: 
                        case 395:  // </b> // </B>
                            if ((this.m_fontStyle & TMPro.FontStyles.Bold) !== TMPro.FontStyles.Bold) {
                                if (this.m_fontStyleStack.Remove(TMPro.FontStyles.Bold) === 0) {
                                    this.m_FontStyleInternal &= -2;
                                    this.m_FontWeightInternal = this.m_FontWeightStack.Peek();
                                }
                            }
                            return true;
                        case 105: 
                        case 73:  // <i> // <I>
                            this.m_FontStyleInternal |= TMPro.FontStyles.Italic;
                            this.m_fontStyleStack.Add(TMPro.FontStyles.Italic);
                            if (TMPro.TMP_Text.m_xmlAttribute[1].nameHashCode === 276531 || TMPro.TMP_Text.m_xmlAttribute[1].nameHashCode === 186899) {
                                this.m_ItalicAngle = this.ConvertToFloat(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[1].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[1].valueLength);

                                // Make sure angle is within valid range.
                                if (this.m_ItalicAngle < -180 || this.m_ItalicAngle > 180) {
                                    return false;
                                }
                            } else {
                                this.m_ItalicAngle = this.m_currentFontAsset.italicStyle;
                            }
                            this.m_ItalicAngleStack.Add(this.m_ItalicAngle);
                            return true;
                        case 434: 
                        case 402:  // </i> // </I>
                            if ((this.m_fontStyle & TMPro.FontStyles.Italic) !== TMPro.FontStyles.Italic) {
                                this.m_ItalicAngle = this.m_ItalicAngleStack.Remove();

                                if (this.m_fontStyleStack.Remove(TMPro.FontStyles.Italic) === 0) {
                                    this.m_FontStyleInternal &= -3;
                                }
                            }
                            return true;
                        case 115: 
                        case 83:  // <s> // <S>
                            this.m_FontStyleInternal |= TMPro.FontStyles.Strikethrough;
                            this.m_fontStyleStack.Add(TMPro.FontStyles.Strikethrough);
                            if (TMPro.TMP_Text.m_xmlAttribute[1].nameHashCode === 281955 || TMPro.TMP_Text.m_xmlAttribute[1].nameHashCode === 192323) {
                                this.m_strikethroughColor = this.HexCharsToColor$1(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[1].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[1].valueLength);
                                this.m_strikethroughColor.a = this.m_htmlColor.a < this.m_strikethroughColor.a ? this.m_htmlColor.a : this.m_strikethroughColor.a;
                            } else {
                                this.m_strikethroughColor = this.m_htmlColor.$clone();
                            }
                            this.m_strikethroughColorStack.Add(this.m_strikethroughColor.$clone());
                            return true;
                        case 444: 
                        case 412:  // </s> // </S>
                            if ((this.m_fontStyle & TMPro.FontStyles.Strikethrough) !== TMPro.FontStyles.Strikethrough) {
                                if (this.m_fontStyleStack.Remove(TMPro.FontStyles.Strikethrough) === 0) {
                                    this.m_FontStyleInternal &= -65;
                                }
                            }
                            this.m_strikethroughColor = this.m_strikethroughColorStack.Remove().$clone();
                            return true;
                        case 117: 
                        case 85:  // <u> // <U>
                            this.m_FontStyleInternal |= TMPro.FontStyles.Underline;
                            this.m_fontStyleStack.Add(TMPro.FontStyles.Underline);
                            if (TMPro.TMP_Text.m_xmlAttribute[1].nameHashCode === 281955 || TMPro.TMP_Text.m_xmlAttribute[1].nameHashCode === 192323) {
                                this.m_underlineColor = this.HexCharsToColor$1(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[1].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[1].valueLength);
                                this.m_underlineColor.a = this.m_htmlColor.a < this.m_underlineColor.a ? this.m_htmlColor.a : this.m_underlineColor.a;
                            } else {
                                this.m_underlineColor = this.m_htmlColor.$clone();
                            }
                            this.m_underlineColorStack.Add(this.m_underlineColor.$clone());
                            return true;
                        case 446: 
                        case 414:  // </u> // </U>
                            if ((this.m_fontStyle & TMPro.FontStyles.Underline) !== TMPro.FontStyles.Underline) {
                                this.m_underlineColor = this.m_underlineColorStack.Remove().$clone();

                                if (this.m_fontStyleStack.Remove(TMPro.FontStyles.Underline) === 0) {
                                    this.m_FontStyleInternal &= -5;
                                }
                            }
                            this.m_underlineColor = this.m_underlineColorStack.Remove().$clone();
                            return true;
                        case 43045: 
                        case 30245:  // <mark=#FF00FF80> // <MARK>
                            this.m_FontStyleInternal |= TMPro.FontStyles.Highlight;
                            this.m_fontStyleStack.Add(TMPro.FontStyles.Highlight);
                            var highlightColor = new UnityEngine.Color32.$ctor1(255, 255, 0, 64);
                            var highlightPadding = TMPro.TMP_Offset.zero.$clone();
                            // Handle Mark Tag and potential attributes
                            for (var i1 = 0; i1 < TMPro.TMP_Text.m_xmlAttribute.length && TMPro.TMP_Text.m_xmlAttribute[i1].nameHashCode !== 0; i1++) {
                                var nameHashCode = TMPro.TMP_Text.m_xmlAttribute[i1].nameHashCode;

                                switch (nameHashCode) {
                                    case 43045: 
                                    case 30245: 
                                        if (TMPro.TMP_Text.m_xmlAttribute[i1].valueType === TMPro.TagValueType.ColorValue) {
                                            highlightColor = this.HexCharsToColor$1(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[0].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[0].valueLength);
                                        }
                                        break;
                                    case 281955: 
                                        highlightColor = this.HexCharsToColor$1(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[i1].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[i1].valueLength);
                                        break;
                                    case 15087385: 
                                        var paramCount = this.GetAttributeParameters(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[i1].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[i1].valueLength, Bridge.ref(TMPro.TMP_Text, "m_attributeParameterValues"));
                                        if (paramCount !== 4) {
                                            return false;
                                        }
                                        highlightPadding = new TMPro.TMP_Offset.$ctor2(TMPro.TMP_Text.m_attributeParameterValues[0], TMPro.TMP_Text.m_attributeParameterValues[1], TMPro.TMP_Text.m_attributeParameterValues[2], TMPro.TMP_Text.m_attributeParameterValues[3]);
                                        highlightPadding = TMPro.TMP_Offset.op_Multiply(highlightPadding.$clone(), this.m_fontSize * 0.01 * (this.m_isOrthographic ? 1 : 0.1));
                                        break;
                                }
                            }
                            highlightColor.a = this.m_htmlColor.a < highlightColor.a ? this.m_htmlColor.a : highlightColor.a;
                            var state = new TMPro.HighlightState.$ctor1(highlightColor.$clone(), highlightPadding.$clone());
                            this.m_HighlightStateStack.Push(state.$clone());
                            return true;
                        case 155892: 
                        case 143092:  // </mark> // </MARK>
                            if ((this.m_fontStyle & TMPro.FontStyles.Highlight) !== TMPro.FontStyles.Highlight) {
                                this.m_HighlightStateStack.Remove();

                                if (this.m_fontStyleStack.Remove(TMPro.FontStyles.Highlight) === 0) {
                                    this.m_FontStyleInternal &= -513;
                                }
                            }
                            return true;
                        case 6552: 
                        case 4728:  // <sub> // <SUB>
                            this.m_fontScaleMultiplier *= this.m_currentFontAsset.faceInfo.subscriptSize > 0 ? this.m_currentFontAsset.faceInfo.subscriptSize : 1;
                            this.m_baselineOffsetStack.Push(this.m_baselineOffset);
                            fontScale = this.m_currentFontSize / this.m_currentFontAsset.faceInfo.pointSize * this.m_currentFontAsset.faceInfo.scale * (this.m_isOrthographic ? 1 : 0.1);
                            this.m_baselineOffset += this.m_currentFontAsset.faceInfo.subscriptOffset * fontScale * this.m_fontScaleMultiplier;
                            this.m_fontStyleStack.Add(TMPro.FontStyles.Subscript);
                            this.m_FontStyleInternal |= TMPro.FontStyles.Subscript;
                            return true;
                        case 22673: 
                        case 20849:  // </sub> // </SUB>
                            if ((this.m_FontStyleInternal & TMPro.FontStyles.Subscript) === TMPro.FontStyles.Subscript) {
                                if (this.m_fontScaleMultiplier < 1) {
                                    this.m_baselineOffset = this.m_baselineOffsetStack.Pop();
                                    this.m_fontScaleMultiplier /= this.m_currentFontAsset.faceInfo.subscriptSize > 0 ? this.m_currentFontAsset.faceInfo.subscriptSize : 1;
                                }

                                if (this.m_fontStyleStack.Remove(TMPro.FontStyles.Subscript) === 0) {
                                    this.m_FontStyleInternal &= -257;
                                }
                            }
                            return true;
                        case 6566: 
                        case 4742:  // <sup> // <SUP>
                            this.m_fontScaleMultiplier *= this.m_currentFontAsset.faceInfo.superscriptSize > 0 ? this.m_currentFontAsset.faceInfo.superscriptSize : 1;
                            this.m_baselineOffsetStack.Push(this.m_baselineOffset);
                            fontScale = this.m_currentFontSize / this.m_currentFontAsset.faceInfo.pointSize * this.m_currentFontAsset.faceInfo.scale * (this.m_isOrthographic ? 1 : 0.1);
                            this.m_baselineOffset += this.m_currentFontAsset.faceInfo.superscriptOffset * fontScale * this.m_fontScaleMultiplier;
                            this.m_fontStyleStack.Add(TMPro.FontStyles.Superscript);
                            this.m_FontStyleInternal |= TMPro.FontStyles.Superscript;
                            return true;
                        case 22687: 
                        case 20863:  // </sup> // </SUP>
                            if ((this.m_FontStyleInternal & TMPro.FontStyles.Superscript) === TMPro.FontStyles.Superscript) {
                                if (this.m_fontScaleMultiplier < 1) {
                                    this.m_baselineOffset = this.m_baselineOffsetStack.Pop();
                                    this.m_fontScaleMultiplier /= this.m_currentFontAsset.faceInfo.superscriptSize > 0 ? this.m_currentFontAsset.faceInfo.superscriptSize : 1;
                                }

                                if (this.m_fontStyleStack.Remove(TMPro.FontStyles.Superscript) === 0) {
                                    this.m_FontStyleInternal &= -129;
                                }
                            }
                            return true;
                        case -330774850: 
                        case 2012149182:  // <font-weight> // <FONT-WEIGHT>
                            value = this.ConvertToFloat(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[0].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[0].valueLength);
                            // Reject tag if value is invalid.
                            if (value === -32768) {
                                return false;
                            }
                            switch (value) {
                                case 100: 
                                    this.m_FontWeightInternal = TMPro.FontWeight.Thin;
                                    break;
                                case 200: 
                                    this.m_FontWeightInternal = TMPro.FontWeight.ExtraLight;
                                    break;
                                case 300: 
                                    this.m_FontWeightInternal = TMPro.FontWeight.Light;
                                    break;
                                case 400: 
                                    this.m_FontWeightInternal = TMPro.FontWeight.Regular;
                                    break;
                                case 500: 
                                    this.m_FontWeightInternal = TMPro.FontWeight.Medium;
                                    break;
                                case 600: 
                                    this.m_FontWeightInternal = TMPro.FontWeight.SemiBold;
                                    break;
                                case 700: 
                                    this.m_FontWeightInternal = TMPro.FontWeight.Bold;
                                    break;
                                case 800: 
                                    this.m_FontWeightInternal = TMPro.FontWeight.Heavy;
                                    break;
                                case 900: 
                                    this.m_FontWeightInternal = TMPro.FontWeight.Black;
                                    break;
                            }
                            this.m_FontWeightStack.Add(this.m_FontWeightInternal);
                            return true;
                        case -1885698441: 
                        case 457225591:  // </font-weight> // </FONT-WEIGHT>
                            this.m_FontWeightStack.Remove();
                            if (this.m_FontStyleInternal === TMPro.FontStyles.Bold) {
                                this.m_FontWeightInternal = TMPro.FontWeight.Bold;
                            } else {
                                this.m_FontWeightInternal = this.m_FontWeightStack.Peek();
                            }
                            return true;
                        case 6380: 
                        case 4556:  // <pos=000.00px> <pos=0em> <pos=50%> // <POS>
                            value = this.ConvertToFloat(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[0].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[0].valueLength);
                            // Reject tag if value is invalid.
                            if (value === -32768) {
                                return false;
                            }
                            switch (tagUnitType) {
                                case TMPro.TagUnitType.Pixels: 
                                    this.m_xAdvance = value * (this.m_isOrthographic ? 1.0 : 0.1);
                                    //m_isIgnoringAlignment = true;
                                    return true;
                                case TMPro.TagUnitType.FontUnits: 
                                    this.m_xAdvance = value * this.m_currentFontSize * (this.m_isOrthographic ? 1.0 : 0.1);
                                    //m_isIgnoringAlignment = true;
                                    return true;
                                case TMPro.TagUnitType.Percentage: 
                                    this.m_xAdvance = this.m_marginWidth * value / 100;
                                    //m_isIgnoringAlignment = true;
                                    return true;
                            }
                            return false;
                        case 22501: 
                        case 20677:  // </pos> // </POS>
                            this.m_isIgnoringAlignment = false;
                            return true;
                        case 16034505: 
                        case 11642281:  // <voffset> // <VOFFSET>
                            value = this.ConvertToFloat(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[0].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[0].valueLength);
                            // Reject tag if value is invalid.
                            if (value === -32768) {
                                return false;
                            }
                            switch (tagUnitType) {
                                case TMPro.TagUnitType.Pixels: 
                                    this.m_baselineOffset = value * (this.m_isOrthographic ? 1 : 0.1);
                                    return true;
                                case TMPro.TagUnitType.FontUnits: 
                                    this.m_baselineOffset = value * (this.m_isOrthographic ? 1 : 0.1) * this.m_currentFontSize;
                                    return true;
                                case TMPro.TagUnitType.Percentage: 
                                    //m_baselineOffset = m_marginHeight * val / 100;
                                    return false;
                            }
                            return false;
                        case 54741026: 
                        case 50348802:  // </voffset> // </VOFFSET>
                            this.m_baselineOffset = 0;
                            return true;
                        case 43991: 
                        case 31191:  // <page> // <PAGE>
                            // This tag only works when Overflow - Page mode is used.
                            if (this.m_overflowMode === TMPro.TextOverflowModes.Page) {
                                this.m_xAdvance = 0 + this.tag_LineIndent + this.tag_Indent;
                                this.m_lineOffset = 0;
                                this.m_pageNumber += 1;
                                this.m_isNewPage = true;
                            }
                            return true;
                        case 43969: 
                        case 31169:  // <nobr> // <NOBR>
                            this.m_isNonBreakingSpace = true;
                            return true;
                        case 156816: 
                        case 144016:  // </nobr> // </NOBR>
                            this.m_isNonBreakingSpace = false;
                            return true;
                        case 45545: 
                        case 32745:  // <size=> // <SIZE>
                            value = this.ConvertToFloat(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[0].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[0].valueLength);
                            // Reject tag if value is invalid.
                            if (value === -32768) {
                                return false;
                            }
                            switch (tagUnitType) {
                                case TMPro.TagUnitType.Pixels: 
                                    if (TMPro.TMP_Text.m_htmlTag[5] === 43) {
                                        this.m_currentFontSize = this.m_fontSize + value;
                                        this.m_sizeStack.Add(this.m_currentFontSize);
                                        return true;
                                    } else if (TMPro.TMP_Text.m_htmlTag[5] === 45) {
                                        this.m_currentFontSize = this.m_fontSize + value;
                                        this.m_sizeStack.Add(this.m_currentFontSize);
                                        return true;
                                    } else {
                                        this.m_currentFontSize = value;
                                        this.m_sizeStack.Add(this.m_currentFontSize);
                                        return true;
                                    }
                                case TMPro.TagUnitType.FontUnits: 
                                    this.m_currentFontSize = this.m_fontSize * value;
                                    this.m_sizeStack.Add(this.m_currentFontSize);
                                    return true;
                                case TMPro.TagUnitType.Percentage: 
                                    this.m_currentFontSize = this.m_fontSize * value / 100;
                                    this.m_sizeStack.Add(this.m_currentFontSize);
                                    return true;
                            }
                            return false;
                        case 158392: 
                        case 145592:  // </size> // </SIZE>
                            this.m_currentFontSize = this.m_sizeStack.Remove();
                            return true;
                        case 41311: 
                        case 28511:  // <font=xx> // <FONT>
                            var fontHashCode = TMPro.TMP_Text.m_xmlAttribute[0].valueHashCode;
                            var materialAttributeHashCode = TMPro.TMP_Text.m_xmlAttribute[1].nameHashCode;
                            var materialHashCode = TMPro.TMP_Text.m_xmlAttribute[1].valueHashCode;
                            // Special handling for <font=default> or <font=Default>
                            if (fontHashCode === 764638571 || fontHashCode === 523367755) {
                                this.m_currentFontAsset = TMPro.TMP_Text.m_materialReferences[0].fontAsset;
                                this.m_currentMaterial = TMPro.TMP_Text.m_materialReferences[0].material;
                                this.m_currentMaterialIndex = 0;
                                //Debug.Log("<font=Default> assigning Font Asset [" + m_currentFontAsset.name + "] with Material [" + m_currentMaterial.name + "].");

                                TMPro.TMP_Text.m_materialReferenceStack.Add(TMPro.TMP_Text.m_materialReferences[0].$clone());

                                return true;
                            }
                            var tempFont = { };
                            var tempMaterial = { };
                            // HANDLE NEW FONT ASSET
                            //TMP_ResourceManager.TryGetFontAsset(fontHashCode, out tempFont);
                            // Check if we already have a reference to this font asset.
                            TMPro.MaterialReferenceManager.TryGetFontAsset(fontHashCode, tempFont);
                            // Try loading font asset from potential delegate or resources.
                            if (tempFont.v == null) {
                                // Check for anyone registered to this callback
                                tempFont.v = !Bridge.staticEquals(TMPro.TMP_Text.OnFontAssetRequest, null) ? TMPro.TMP_Text.OnFontAssetRequest(fontHashCode, System.String.fromCharArray(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[0].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[0].valueLength)) : null;

                                if (tempFont.v == null) {
                                    // Load Font Asset
                                    tempFont.v = UnityEngine.Resources.Load(TMPro.TMP_FontAsset, (TMPro.TMP_Settings.defaultFontAssetPath || "") + (System.String.fromCharArray(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[0].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[0].valueLength) || ""));
                                }

                                if (tempFont.v == null) {
                                    return false;
                                }

                                // Add new reference to the font asset as well as default material to the MaterialReferenceManager
                                TMPro.MaterialReferenceManager.AddFontAsset(tempFont.v);
                            }
                            // HANDLE NEW MATERIAL
                            if (materialAttributeHashCode === 0 && materialHashCode === 0) {
                                // No material specified then use default font asset material.
                                this.m_currentMaterial = tempFont.v.material;

                                this.m_currentMaterialIndex = TMPro.MaterialReference.AddMaterialReference(this.m_currentMaterial, tempFont.v, Bridge.ref(TMPro.TMP_Text, "m_materialReferences"), TMPro.TMP_Text.m_materialReferenceIndexLookup);

                                TMPro.TMP_Text.m_materialReferenceStack.Add(TMPro.TMP_Text.m_materialReferences[this.m_currentMaterialIndex].$clone());
                            } else if (materialAttributeHashCode === 103415287 || materialAttributeHashCode === 72669687) {
                                if (TMPro.MaterialReferenceManager.TryGetMaterial(materialHashCode, tempMaterial)) {
                                    this.m_currentMaterial = tempMaterial.v;

                                    this.m_currentMaterialIndex = TMPro.MaterialReference.AddMaterialReference(this.m_currentMaterial, tempFont.v, Bridge.ref(TMPro.TMP_Text, "m_materialReferences"), TMPro.TMP_Text.m_materialReferenceIndexLookup);

                                    TMPro.TMP_Text.m_materialReferenceStack.Add(TMPro.TMP_Text.m_materialReferences[this.m_currentMaterialIndex].$clone());
                                } else {
                                    // Load new material
                                    tempMaterial.v = UnityEngine.Resources.Load(UnityEngine.Material, (TMPro.TMP_Settings.defaultFontAssetPath || "") + (System.String.fromCharArray(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[1].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[1].valueLength) || ""));

                                    if (tempMaterial.v == null) {
                                        return false;
                                    }

                                    // Add new reference to this material in the MaterialReferenceManager
                                    TMPro.MaterialReferenceManager.AddFontMaterial(materialHashCode, tempMaterial.v);

                                    this.m_currentMaterial = tempMaterial.v;

                                    this.m_currentMaterialIndex = TMPro.MaterialReference.AddMaterialReference(this.m_currentMaterial, tempFont.v, Bridge.ref(TMPro.TMP_Text, "m_materialReferences"), TMPro.TMP_Text.m_materialReferenceIndexLookup);

                                    TMPro.TMP_Text.m_materialReferenceStack.Add(TMPro.TMP_Text.m_materialReferences[this.m_currentMaterialIndex].$clone());
                                }
                            } else {
                                return false;
                            }
                            this.m_currentFontAsset = tempFont.v;
                            return true;
                        case 154158: 
                        case 141358:  // </font> // </FONT>
                            {
                                var materialReference = TMPro.TMP_Text.m_materialReferenceStack.Remove().$clone();

                                this.m_currentFontAsset = materialReference.fontAsset;
                                this.m_currentMaterial = materialReference.material;
                                this.m_currentMaterialIndex = materialReference.index;

                                return true;
                            }
                        case 103415287: 
                        case 72669687:  // <material="material name"> // <MATERIAL>
                            materialHashCode = TMPro.TMP_Text.m_xmlAttribute[0].valueHashCode;
                            // Special handling for <material=default> or <material=Default>
                            if (materialHashCode === 764638571 || materialHashCode === 523367755) {
                                // Check if material font atlas texture matches that of the current font asset.
                                //if (m_currentFontAsset.atlas.GetInstanceID() != m_currentMaterial.GetTexture(ShaderUtilities.ID_MainTex).GetInstanceID()) return false;

                                this.m_currentMaterial = TMPro.TMP_Text.m_materialReferences[0].material;
                                this.m_currentMaterialIndex = 0;

                                TMPro.TMP_Text.m_materialReferenceStack.Add(TMPro.TMP_Text.m_materialReferences[0].$clone());

                                return true;
                            }
                            // Check if material
                            if (TMPro.MaterialReferenceManager.TryGetMaterial(materialHashCode, tempMaterial)) {
                                // Check if material font atlas texture matches that of the current font asset.
                                //if (m_currentFontAsset.atlas.GetInstanceID() != tempMaterial.GetTexture(ShaderUtilities.ID_MainTex).GetInstanceID()) return false;

                                this.m_currentMaterial = tempMaterial;

                                this.m_currentMaterialIndex = TMPro.MaterialReference.AddMaterialReference(this.m_currentMaterial, this.m_currentFontAsset, Bridge.ref(TMPro.TMP_Text, "m_materialReferences"), TMPro.TMP_Text.m_materialReferenceIndexLookup);

                                TMPro.TMP_Text.m_materialReferenceStack.Add(TMPro.TMP_Text.m_materialReferences[this.m_currentMaterialIndex].$clone());
                            } else {
                                // Load new material
                                tempMaterial = UnityEngine.Resources.Load(UnityEngine.Material, (TMPro.TMP_Settings.defaultFontAssetPath || "") + (System.String.fromCharArray(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[0].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[0].valueLength) || ""));

                                if (tempMaterial == null) {
                                    return false;
                                }

                                // Check if material font atlas texture matches that of the current font asset.
                                //if (m_currentFontAsset.atlas.GetInstanceID() != tempMaterial.GetTexture(ShaderUtilities.ID_MainTex).GetInstanceID()) return false;

                                // Add new reference to this material in the MaterialReferenceManager
                                TMPro.MaterialReferenceManager.AddFontMaterial(materialHashCode, tempMaterial);

                                this.m_currentMaterial = tempMaterial;

                                this.m_currentMaterialIndex = TMPro.MaterialReference.AddMaterialReference(this.m_currentMaterial, this.m_currentFontAsset, Bridge.ref(TMPro.TMP_Text, "m_materialReferences"), TMPro.TMP_Text.m_materialReferenceIndexLookup);

                                TMPro.TMP_Text.m_materialReferenceStack.Add(TMPro.TMP_Text.m_materialReferences[this.m_currentMaterialIndex].$clone());
                            }
                            return true;
                        case 374360934: 
                        case 343615334:  // </material> // </MATERIAL>
                            {
                                //if (m_currentMaterial.GetTexture(ShaderUtilities.ID_MainTex).GetInstanceID() != m_materialReferenceStack.PreviousItem().material.GetTexture(ShaderUtilities.ID_MainTex).GetInstanceID())
                                //    return false;

                                var materialReference1 = TMPro.TMP_Text.m_materialReferenceStack.Remove().$clone();

                                this.m_currentMaterial = materialReference1.material;
                                this.m_currentMaterialIndex = materialReference1.index;

                                return true;
                            }
                        case 320078: 
                        case 230446:  // <space=000.00> // <SPACE>
                            value = this.ConvertToFloat(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[0].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[0].valueLength);
                            // Reject tag if value is invalid.
                            if (value === -32768) {
                                return false;
                            }
                            switch (tagUnitType) {
                                case TMPro.TagUnitType.Pixels: 
                                    this.m_xAdvance += value * (this.m_isOrthographic ? 1 : 0.1);
                                    return true;
                                case TMPro.TagUnitType.FontUnits: 
                                    this.m_xAdvance += value * (this.m_isOrthographic ? 1 : 0.1) * this.m_currentFontSize;
                                    return true;
                                case TMPro.TagUnitType.Percentage: 
                                    // Not applicable
                                    return false;
                            }
                            return false;
                        case 276254: 
                        case 186622:  // <alpha=#FF> // <ALPHA>
                            if (TMPro.TMP_Text.m_xmlAttribute[0].valueLength !== 3) {
                                return false;
                            }
                            this.m_htmlColor.a = this.HexToInt(TMPro.TMP_Text.m_htmlTag[7]) * 16 + this.HexToInt(TMPro.TMP_Text.m_htmlTag[8]);
                            return true;
                        case 1750458:  // <a name=" ">
                            return false;
                        case 426:  // </a>
                            return true;
                        case 43066: 
                        case 30266:  // <link="name"> // <LINK>
                            if (this.m_isParsingText && !this.m_isCalculatingPreferredValues) {
                                var index = this.m_textInfo.linkCount;

                                if (index + 1 > this.m_textInfo.linkInfo.length) {
                                    TMPro.TMP_TextInfo.Resize(TMPro.TMP_LinkInfo, Bridge.ref(this.m_textInfo, "linkInfo"), index + 1);
                                }

                                ($t6 = this.m_textInfo.linkInfo)[index].textComponent = this;
                                ($t7 = this.m_textInfo.linkInfo)[index].hashCode = TMPro.TMP_Text.m_xmlAttribute[0].valueHashCode;
                                ($t8 = this.m_textInfo.linkInfo)[index].linkTextfirstCharacterIndex = this.m_characterCount;

                                ($t9 = this.m_textInfo.linkInfo)[index].linkIdFirstCharacterIndex = startIndex + TMPro.TMP_Text.m_xmlAttribute[0].valueStartIndex;
                                ($t10 = this.m_textInfo.linkInfo)[index].linkIdLength = TMPro.TMP_Text.m_xmlAttribute[0].valueLength;
                                ($t11 = this.m_textInfo.linkInfo)[index].SetLinkID(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[0].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[0].valueLength);
                            }
                            return true;
                        case 155913: 
                        case 143113:  // </link> // </LINK>
                            if (this.m_isParsingText && !this.m_isCalculatingPreferredValues) {
                                if (this.m_textInfo.linkCount < this.m_textInfo.linkInfo.length) {
                                    ($t12 = this.m_textInfo.linkInfo)[this.m_textInfo.linkCount].linkTextLength = this.m_characterCount - ($t13 = this.m_textInfo.linkInfo)[this.m_textInfo.linkCount].linkTextfirstCharacterIndex;

                                    this.m_textInfo.linkCount += 1;
                                }
                            }
                            return true;
                        case 275917: 
                        case 186285:  // <align=> // <ALIGN>
                            switch (TMPro.TMP_Text.m_xmlAttribute[0].valueHashCode) {
                                case 3774683:  // <align=left>
                                    this.m_lineJustification = TMPro.HorizontalAlignmentOptions.Left;
                                    this.m_lineJustificationStack.Add(this.m_lineJustification);
                                    return true;
                                case 136703040:  // <align=right>
                                    this.m_lineJustification = TMPro.HorizontalAlignmentOptions.Right;
                                    this.m_lineJustificationStack.Add(this.m_lineJustification);
                                    return true;
                                case -458210101:  // <align=center>
                                    this.m_lineJustification = TMPro.HorizontalAlignmentOptions.Center;
                                    this.m_lineJustificationStack.Add(this.m_lineJustification);
                                    return true;
                                case -523808257:  // <align=justified>
                                    this.m_lineJustification = TMPro.HorizontalAlignmentOptions.Justified;
                                    this.m_lineJustificationStack.Add(this.m_lineJustification);
                                    return true;
                                case 122383428:  // <align=flush>
                                    this.m_lineJustification = TMPro.HorizontalAlignmentOptions.Flush;
                                    this.m_lineJustificationStack.Add(this.m_lineJustification);
                                    return true;
                            }
                            return false;
                        case 1065846: 
                        case 976214:  // </align> // </ALIGN>
                            this.m_lineJustification = this.m_lineJustificationStack.Remove();
                            return true;
                        case 327550: 
                        case 237918:  // <width=xx> // <WIDTH>
                            value = this.ConvertToFloat(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[0].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[0].valueLength);
                            // Reject tag if value is invalid.
                            if (value === -32768) {
                                return false;
                            }
                            switch (tagUnitType) {
                                case TMPro.TagUnitType.Pixels: 
                                    this.m_width = value * (this.m_isOrthographic ? 1 : 0.1);
                                    break;
                                case TMPro.TagUnitType.FontUnits: 
                                    return false;
                                case TMPro.TagUnitType.Percentage: 
                                    this.m_width = this.m_marginWidth * value / 100;
                                    break;
                            }
                            return true;
                        case 1117479: 
                        case 1027847:  // </width> // </WIDTH>
                            this.m_width = -1;
                            return true;
                        case 281955: 
                        case 192323:  // <color> <color=#FF00FF> or <color=#FF00FF00> // <COLOR=#FF00FF>
                            // <color=#FFF> 3 Hex (short hand)
                            if (TMPro.TMP_Text.m_htmlTag[6] === 35 && tagCharCount === 10) {
                                this.m_htmlColor = this.HexCharsToColor(TMPro.TMP_Text.m_htmlTag, tagCharCount);
                                this.m_colorStack.Add(this.m_htmlColor.$clone());
                                return true;
                            } else if (TMPro.TMP_Text.m_htmlTag[6] === 35 && tagCharCount === 11) {
                                this.m_htmlColor = this.HexCharsToColor(TMPro.TMP_Text.m_htmlTag, tagCharCount);
                                this.m_colorStack.Add(this.m_htmlColor.$clone());
                                return true;
                            }
                            // <color=#FF00FF> 3 Hex pairs
                            if (TMPro.TMP_Text.m_htmlTag[6] === 35 && tagCharCount === 13) {
                                this.m_htmlColor = this.HexCharsToColor(TMPro.TMP_Text.m_htmlTag, tagCharCount);
                                this.m_colorStack.Add(this.m_htmlColor.$clone());
                                return true;
                            } else if (TMPro.TMP_Text.m_htmlTag[6] === 35 && tagCharCount === 15) {
                                this.m_htmlColor = this.HexCharsToColor(TMPro.TMP_Text.m_htmlTag, tagCharCount);
                                this.m_colorStack.Add(this.m_htmlColor.$clone());
                                return true;
                            }
                            // <color=name>
                            switch (TMPro.TMP_Text.m_xmlAttribute[0].valueHashCode) {
                                case 125395:  // <color=red>
                                    this.m_htmlColor = UnityEngine.Color32.op_Implicit$1(new pc.Color( 1, 0, 0, 1 ));
                                    this.m_colorStack.Add(this.m_htmlColor.$clone());
                                    return true;
                                case -992792864:  // <color=lightblue>
                                    this.m_htmlColor = new UnityEngine.Color32.$ctor1(173, 216, 230, 255);
                                    this.m_colorStack.Add(this.m_htmlColor.$clone());
                                    return true;
                                case 3573310:  // <color=blue>
                                    this.m_htmlColor = UnityEngine.Color32.op_Implicit$1(new pc.Color( 0, 0, 1, 1 ));
                                    this.m_colorStack.Add(this.m_htmlColor.$clone());
                                    return true;
                                case 3680713:  // <color=grey>
                                    this.m_htmlColor = new UnityEngine.Color32.$ctor1(128, 128, 128, 255);
                                    this.m_colorStack.Add(this.m_htmlColor.$clone());
                                    return true;
                                case 117905991:  // <color=black>
                                    this.m_htmlColor = UnityEngine.Color32.op_Implicit$1(new pc.Color( 0, 0, 0, 1 ));
                                    this.m_colorStack.Add(this.m_htmlColor.$clone());
                                    return true;
                                case 121463835:  // <color=green>
                                    this.m_htmlColor = UnityEngine.Color32.op_Implicit$1(new pc.Color( 0, 1, 0, 1 ));
                                    this.m_colorStack.Add(this.m_htmlColor.$clone());
                                    return true;
                                case 140357351:  // <color=white>
                                    this.m_htmlColor = UnityEngine.Color32.op_Implicit$1(new pc.Color( 1, 1, 1, 1 ));
                                    this.m_colorStack.Add(this.m_htmlColor.$clone());
                                    return true;
                                case 26556144:  // <color=orange>
                                    this.m_htmlColor = new UnityEngine.Color32.$ctor1(255, 128, 0, 255);
                                    this.m_colorStack.Add(this.m_htmlColor.$clone());
                                    return true;
                                case -36881330:  // <color=purple>
                                    this.m_htmlColor = new UnityEngine.Color32.$ctor1(160, 32, 240, 255);
                                    this.m_colorStack.Add(this.m_htmlColor.$clone());
                                    return true;
                                case 554054276:  // <color=yellow>
                                    this.m_htmlColor = UnityEngine.Color32.op_Implicit$1(new pc.Color( 1, 1, 0, 1 ));
                                    this.m_colorStack.Add(this.m_htmlColor.$clone());
                                    return true;
                            }
                            return false;
                        case 100149144: 
                        case 69403544:  //<gradient> // <GRADIENT>
                            var gradientPresetHashCode = TMPro.TMP_Text.m_xmlAttribute[0].valueHashCode;
                            var tempColorGradientPreset = { };
                            // Check if Color Gradient Preset has already been loaded.
                            if (TMPro.MaterialReferenceManager.TryGetColorGradientPreset(gradientPresetHashCode, tempColorGradientPreset)) {
                                this.m_colorGradientPreset = tempColorGradientPreset.v;
                            } else {
                                // Load Color Gradient Preset
                                if (tempColorGradientPreset.v == null) {
                                    tempColorGradientPreset.v = UnityEngine.Resources.Load(TMPro.TMP_ColorGradient, (TMPro.TMP_Settings.defaultColorGradientPresetsPath || "") + (System.String.fromCharArray(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[0].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[0].valueLength) || ""));
                                }

                                if (tempColorGradientPreset.v == null) {
                                    return false;
                                }

                                TMPro.MaterialReferenceManager.AddColorGradientPreset(gradientPresetHashCode, tempColorGradientPreset.v);
                                this.m_colorGradientPreset = tempColorGradientPreset.v;
                            }
                            this.m_colorGradientPresetIsTinted = false;
                            // Check Attributes
                            for (var i2 = 1; i2 < TMPro.TMP_Text.m_xmlAttribute.length && TMPro.TMP_Text.m_xmlAttribute[i2].nameHashCode !== 0; i2++) {
                                // Get attribute name
                                var nameHashCode1 = TMPro.TMP_Text.m_xmlAttribute[i2].nameHashCode;

                                switch (nameHashCode1) {
                                    case 45819: 
                                    case 33019:  // tint // TINT
                                        this.m_colorGradientPresetIsTinted = this.ConvertToFloat(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[i2].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[i2].valueLength) !== 0;
                                        break;
                                }
                            }
                            this.m_colorGradientStack.Add(this.m_colorGradientPreset);
                            // TODO : Add support for defining preset in the tag itself
                            return true;
                        case 371094791: 
                        case 340349191:  // </gradient> // </GRADIENT>
                            this.m_colorGradientPreset = this.m_colorGradientStack.Remove();
                            return true;
                        case 1983971: 
                        case 1356515:  // <cspace=xx.x> // <CSPACE>
                            value = this.ConvertToFloat(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[0].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[0].valueLength);
                            // Reject tag if value is invalid.
                            if (value === -32768) {
                                return false;
                            }
                            switch (tagUnitType) {
                                case TMPro.TagUnitType.Pixels: 
                                    this.m_cSpacing = value * (this.m_isOrthographic ? 1 : 0.1);
                                    break;
                                case TMPro.TagUnitType.FontUnits: 
                                    this.m_cSpacing = value * (this.m_isOrthographic ? 1 : 0.1) * this.m_currentFontSize;
                                    break;
                                case TMPro.TagUnitType.Percentage: 
                                    return false;
                            }
                            return true;
                        case 7513474: 
                        case 6886018:  // </cspace> // </CSPACE>
                            if (!this.m_isParsingText) {
                                return true;
                            }
                            // Adjust xAdvance to remove extra space from last character.
                            if (this.m_characterCount > 0) {
                                this.m_xAdvance -= this.m_cSpacing;
                                ($t14 = this.m_textInfo.characterInfo)[this.m_characterCount - 1].xAdvance = this.m_xAdvance;
                            }
                            this.m_cSpacing = 0;
                            return true;
                        case 2152041: 
                        case 1524585:  // <mspace=xx.x> // <MSPACE>
                            value = this.ConvertToFloat(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[0].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[0].valueLength);
                            // Reject tag if value is invalid.
                            if (value === -32768) {
                                return false;
                            }
                            switch (tagUnitType) {
                                case TMPro.TagUnitType.Pixels: 
                                    this.m_monoSpacing = value * (this.m_isOrthographic ? 1 : 0.1);
                                    break;
                                case TMPro.TagUnitType.FontUnits: 
                                    this.m_monoSpacing = value * (this.m_isOrthographic ? 1 : 0.1) * this.m_currentFontSize;
                                    break;
                                case TMPro.TagUnitType.Percentage: 
                                    return false;
                            }
                            return true;
                        case 7681544: 
                        case 7054088:  // </mspace> // </MSPACE>
                            this.m_monoSpacing = 0;
                            return true;
                        case 280416:  // <class="name">
                            return false;
                        case 1071884: 
                        case 982252:  // </color> // </COLOR>
                            this.m_htmlColor = this.m_colorStack.Remove().$clone();
                            return true;
                        case 2068980: 
                        case 1441524:  // <indent=10px> <indent=10em> <indent=50%> // <INDENT>
                            value = this.ConvertToFloat(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[0].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[0].valueLength);
                            // Reject tag if value is invalid.
                            if (value === -32768) {
                                return false;
                            }
                            switch (tagUnitType) {
                                case TMPro.TagUnitType.Pixels: 
                                    this.tag_Indent = value * (this.m_isOrthographic ? 1 : 0.1);
                                    break;
                                case TMPro.TagUnitType.FontUnits: 
                                    this.tag_Indent = value * (this.m_isOrthographic ? 1 : 0.1) * this.m_currentFontSize;
                                    break;
                                case TMPro.TagUnitType.Percentage: 
                                    this.tag_Indent = this.m_marginWidth * value / 100;
                                    break;
                            }
                            this.m_indentStack.Add(this.tag_Indent);
                            this.m_xAdvance = this.tag_Indent;
                            return true;
                        case 7598483: 
                        case 6971027:  // </indent> // </INDENT>
                            this.tag_Indent = this.m_indentStack.Remove();
                            //m_xAdvance = tag_Indent;
                            return true;
                        case 1109386397: 
                        case -842656867:  // <line-indent> // <LINE-INDENT>
                            value = this.ConvertToFloat(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[0].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[0].valueLength);
                            // Reject tag if value is invalid.
                            if (value === -32768) {
                                return false;
                            }
                            switch (tagUnitType) {
                                case TMPro.TagUnitType.Pixels: 
                                    this.tag_LineIndent = value * (this.m_isOrthographic ? 1 : 0.1);
                                    break;
                                case TMPro.TagUnitType.FontUnits: 
                                    this.tag_LineIndent = value * (this.m_isOrthographic ? 1 : 0.1) * this.m_currentFontSize;
                                    break;
                                case TMPro.TagUnitType.Percentage: 
                                    this.tag_LineIndent = this.m_marginWidth * value / 100;
                                    break;
                            }
                            this.m_xAdvance += this.tag_LineIndent;
                            return true;
                        case -445537194: 
                        case 1897386838:  // </line-indent> // </LINE-INDENT>
                            this.tag_LineIndent = 0;
                            return true;
                        case 2246877: 
                        case 1619421:  // <sprite=x> // <SPRITE>
                            var spriteAssetHashCode = TMPro.TMP_Text.m_xmlAttribute[0].valueHashCode;
                            var tempSpriteAsset = { };
                            this.m_spriteIndex = -1;
                            // CHECK TAG FORMAT
                            if (TMPro.TMP_Text.m_xmlAttribute[0].valueType === TMPro.TagValueType.None || TMPro.TMP_Text.m_xmlAttribute[0].valueType === TMPro.TagValueType.NumericalValue) {
                                // No Sprite Asset is assigned to the text object
                                if (this.m_spriteAsset != null) {
                                    this.m_currentSpriteAsset = this.m_spriteAsset;
                                } else if (this.m_defaultSpriteAsset != null) {
                                    this.m_currentSpriteAsset = this.m_defaultSpriteAsset;
                                } else if (this.m_defaultSpriteAsset == null) {
                                    if (TMPro.TMP_Settings.defaultSpriteAsset != null) {
                                        this.m_defaultSpriteAsset = TMPro.TMP_Settings.defaultSpriteAsset;
                                    } else {
                                        this.m_defaultSpriteAsset = UnityEngine.Resources.Load(TMPro.TMP_SpriteAsset, "Sprite Assets/Default Sprite Asset");
                                    }

                                    this.m_currentSpriteAsset = this.m_defaultSpriteAsset;
                                }

                                // No valid sprite asset available
                                if (this.m_currentSpriteAsset == null) {
                                    return false;
                                }
                            } else {
                                // A Sprite Asset has been specified
                                if (TMPro.MaterialReferenceManager.TryGetSpriteAsset(spriteAssetHashCode, tempSpriteAsset)) {
                                    this.m_currentSpriteAsset = tempSpriteAsset.v;
                                } else {
                                    // Load Sprite Asset
                                    if (tempSpriteAsset.v == null) {
                                        //
                                        tempSpriteAsset.v = !Bridge.staticEquals(TMPro.TMP_Text.OnSpriteAssetRequest, null) ? TMPro.TMP_Text.OnSpriteAssetRequest(spriteAssetHashCode, System.String.fromCharArray(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[0].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[0].valueLength)) : null;

                                        if (tempSpriteAsset.v == null) {
                                            tempSpriteAsset.v = UnityEngine.Resources.Load(TMPro.TMP_SpriteAsset, (TMPro.TMP_Settings.defaultSpriteAssetPath || "") + (System.String.fromCharArray(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[0].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[0].valueLength) || ""));
                                        }
                                    }

                                    if (tempSpriteAsset.v == null) {
                                        return false;
                                    }

                                    //Debug.Log("Loading & assigning new Sprite Asset: " + tempSpriteAsset.name);
                                    TMPro.MaterialReferenceManager.AddSpriteAsset(spriteAssetHashCode, tempSpriteAsset.v);
                                    this.m_currentSpriteAsset = tempSpriteAsset.v;
                                }
                            }
                            // Handling of <sprite=index> legacy tag format.
                            if (TMPro.TMP_Text.m_xmlAttribute[0].valueType === TMPro.TagValueType.NumericalValue) {
                                var index1 = this.ConvertToFloat(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[0].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[0].valueLength);

                                // Reject tag if value is invalid.
                                if (index1 === -32768) {
                                    return false;
                                }

                                // Check to make sure sprite index is valid
                                if (index1 > this.m_currentSpriteAsset.spriteCharacterTable.Count - 1) {
                                    return false;
                                }

                                this.m_spriteIndex = index1;
                            }
                            this.m_spriteColor = TMPro.TMP_Text.s_colorWhite.$clone();
                            this.m_tintSprite = false;
                            // Handle Sprite Tag Attributes
                            for (var i3 = 0; i3 < TMPro.TMP_Text.m_xmlAttribute.length && TMPro.TMP_Text.m_xmlAttribute[i3].nameHashCode !== 0; i3++) {
                                //Debug.Log("Attribute[" + i + "].nameHashCode=" + m_xmlAttribute[i].nameHashCode + "   Value:" + ConvertToFloat(m_htmlTag, m_xmlAttribute[i].valueStartIndex, m_xmlAttribute[i].valueLength));
                                var nameHashCode2 = TMPro.TMP_Text.m_xmlAttribute[i3].nameHashCode;
                                var index2 = { v : 0 };

                                switch (nameHashCode2) {
                                    case 43347: 
                                    case 30547:  // <sprite name=""> // <SPRITE NAME="">
                                        this.m_currentSpriteAsset = TMPro.TMP_SpriteAsset.SearchForSpriteByHashCode(this.m_currentSpriteAsset, TMPro.TMP_Text.m_xmlAttribute[i3].valueHashCode, true, index2);
                                        if (index2.v === -1) {
                                            return false;
                                        }
                                        this.m_spriteIndex = index2.v;
                                        break;
                                    case 295562: 
                                    case 205930:  // <sprite index=> // <SPRITE INDEX=>
                                        index2.v = this.ConvertToFloat(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[1].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[1].valueLength);
                                        // Reject tag if value is invalid.
                                        if (index2.v === -32768) {
                                            return false;
                                        }
                                        // Check to make sure sprite index is valid
                                        if (index2.v > this.m_currentSpriteAsset.spriteCharacterTable.Count - 1) {
                                            return false;
                                        }
                                        this.m_spriteIndex = index2.v;
                                        break;
                                    case 45819: 
                                    case 33019:  // tint // TINT
                                        this.m_tintSprite = this.ConvertToFloat(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[i3].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[i3].valueLength) !== 0;
                                        break;
                                    case 281955: 
                                    case 192323:  // color=#FF00FF80 // COLOR
                                        this.m_spriteColor = this.HexCharsToColor$1(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[i3].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[i3].valueLength);
                                        break;
                                    case 39505: 
                                    case 26705:  // anim="0,16,12"  start, end, fps // ANIM
                                        //Debug.Log("Start: " + m_xmlAttribute[i].valueStartIndex + "  Length: " + m_xmlAttribute[i].valueLength);
                                        var paramCount1 = this.GetAttributeParameters(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[i3].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[i3].valueLength, Bridge.ref(TMPro.TMP_Text, "m_attributeParameterValues"));
                                        if (paramCount1 !== 3) {
                                            return false;
                                        }
                                        this.m_spriteIndex = TMPro.TMP_Text.m_attributeParameterValues[0];
                                        if (this.m_isParsingText) {
                                            // TODO : fix this!
                                            // It is possible for a sprite to get animated when it ends up being truncated.
                                            // Should consider moving the animation of the sprite after text geometry upload.

                                            this.spriteAnimator.DoSpriteAnimation(this.m_characterCount, this.m_currentSpriteAsset, this.m_spriteIndex, TMPro.TMP_Text.m_attributeParameterValues[1], TMPro.TMP_Text.m_attributeParameterValues[2]);
                                        }
                                        break;
                                    default: 
                                        if (nameHashCode2 !== 2246877 && nameHashCode2 !== 1619421) {
                                            return false;
                                        }
                                        break;
                                }
                            }
                            if (this.m_spriteIndex === -1) {
                                return false;
                            }
                            // Material HashCode for the Sprite Asset is the Sprite Asset Hash Code
                            this.m_currentMaterialIndex = TMPro.MaterialReference.AddMaterialReference$1(this.m_currentSpriteAsset.material, this.m_currentSpriteAsset, Bridge.ref(TMPro.TMP_Text, "m_materialReferences"), TMPro.TMP_Text.m_materialReferenceIndexLookup);
                            this.m_textElementType = TMPro.TMP_TextElementType.Sprite;
                            return true;
                        case 730022849: 
                        case 514803617:  // <lowercase> // <LOWERCASE>
                            this.m_FontStyleInternal |= TMPro.FontStyles.LowerCase;
                            this.m_fontStyleStack.Add(TMPro.FontStyles.LowerCase);
                            return true;
                        case -1668324918: 
                        case -1883544150:  // </lowercase> // </LOWERCASE>
                            if ((this.m_fontStyle & TMPro.FontStyles.LowerCase) !== TMPro.FontStyles.LowerCase) {
                                if (this.m_fontStyleStack.Remove(TMPro.FontStyles.LowerCase) === 0) {
                                    this.m_FontStyleInternal &= -9;
                                }
                            }
                            return true;
                        case 13526026: 
                        case 9133802: 
                        case 781906058: 
                        case 566686826:  // <allcaps> // <ALLCAPS> // <uppercase> // <UPPERCASE>
                            this.m_FontStyleInternal |= TMPro.FontStyles.UpperCase;
                            this.m_fontStyleStack.Add(TMPro.FontStyles.UpperCase);
                            return true;
                        case 52232547: 
                        case 47840323: 
                        case -1616441709: 
                        case -1831660941:  // </allcaps> // </ALLCAPS> // </uppercase> // </UPPERCASE>
                            if ((this.m_fontStyle & TMPro.FontStyles.UpperCase) !== TMPro.FontStyles.UpperCase) {
                                if (this.m_fontStyleStack.Remove(TMPro.FontStyles.UpperCase) === 0) {
                                    this.m_FontStyleInternal &= -17;
                                }
                            }
                            return true;
                        case 766244328: 
                        case 551025096:  // <smallcaps> // <SMALLCAPS>
                            this.m_FontStyleInternal |= TMPro.FontStyles.SmallCaps;
                            this.m_fontStyleStack.Add(TMPro.FontStyles.SmallCaps);
                            return true;
                        case -1632103439: 
                        case -1847322671:  // </smallcaps> // </SMALLCAPS>
                            if ((this.m_fontStyle & TMPro.FontStyles.SmallCaps) !== TMPro.FontStyles.SmallCaps) {
                                if (this.m_fontStyleStack.Remove(TMPro.FontStyles.SmallCaps) === 0) {
                                    this.m_FontStyleInternal &= -33;
                                }
                            }
                            return true;
                        case 2109854: 
                        case 1482398:  // <margin=00.0> <margin=00em> <margin=50%> // <MARGIN>
                            // Check value type
                            switch (TMPro.TMP_Text.m_xmlAttribute[0].valueType) {
                                case TMPro.TagValueType.NumericalValue: 
                                    value = this.ConvertToFloat(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[0].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[0].valueLength); // px
                                    // Reject tag if value is invalid.
                                    if (value === -32768) {
                                        return false;
                                    }
                                    // Determine tag unit type
                                    switch (tagUnitType) {
                                        case TMPro.TagUnitType.Pixels: 
                                            this.m_marginLeft = value * (this.m_isOrthographic ? 1 : 0.1);
                                            break;
                                        case TMPro.TagUnitType.FontUnits: 
                                            this.m_marginLeft = value * (this.m_isOrthographic ? 1 : 0.1) * this.m_currentFontSize;
                                            break;
                                        case TMPro.TagUnitType.Percentage: 
                                            this.m_marginLeft = (this.m_marginWidth - (this.m_width !== -1 ? this.m_width : 0)) * value / 100;
                                            break;
                                    }
                                    this.m_marginLeft = this.m_marginLeft >= 0 ? this.m_marginLeft : 0;
                                    this.m_marginRight = this.m_marginLeft;
                                    return true;
                                case TMPro.TagValueType.None: 
                                    for (var i4 = 1; i4 < TMPro.TMP_Text.m_xmlAttribute.length && TMPro.TMP_Text.m_xmlAttribute[i4].nameHashCode !== 0; i4++) {
                                        // Get attribute name
                                        var nameHashCode3 = TMPro.TMP_Text.m_xmlAttribute[i4].nameHashCode;

                                        switch (nameHashCode3) {
                                            case 42823:  // <margin left=value>
                                                value = this.ConvertToFloat(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[i4].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[i4].valueLength); // px
                                                // Reject tag if value is invalid.
                                                if (value === -32768) {
                                                    return false;
                                                }
                                                switch (TMPro.TMP_Text.m_xmlAttribute[i4].unitType) {
                                                    case TMPro.TagUnitType.Pixels: 
                                                        this.m_marginLeft = value * (this.m_isOrthographic ? 1 : 0.1);
                                                        break;
                                                    case TMPro.TagUnitType.FontUnits: 
                                                        this.m_marginLeft = value * (this.m_isOrthographic ? 1 : 0.1) * this.m_currentFontSize;
                                                        break;
                                                    case TMPro.TagUnitType.Percentage: 
                                                        this.m_marginLeft = (this.m_marginWidth - (this.m_width !== -1 ? this.m_width : 0)) * value / 100;
                                                        break;
                                                }
                                                this.m_marginLeft = this.m_marginLeft >= 0 ? this.m_marginLeft : 0;
                                                break;
                                            case 315620:  // <margin right=value>
                                                value = this.ConvertToFloat(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[i4].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[i4].valueLength); // px
                                                // Reject tag if value is invalid.
                                                if (value === -32768) {
                                                    return false;
                                                }
                                                switch (TMPro.TMP_Text.m_xmlAttribute[i4].unitType) {
                                                    case TMPro.TagUnitType.Pixels: 
                                                        this.m_marginRight = value * (this.m_isOrthographic ? 1 : 0.1);
                                                        break;
                                                    case TMPro.TagUnitType.FontUnits: 
                                                        this.m_marginRight = value * (this.m_isOrthographic ? 1 : 0.1) * this.m_currentFontSize;
                                                        break;
                                                    case TMPro.TagUnitType.Percentage: 
                                                        this.m_marginRight = (this.m_marginWidth - (this.m_width !== -1 ? this.m_width : 0)) * value / 100;
                                                        break;
                                                }
                                                this.m_marginRight = this.m_marginRight >= 0 ? this.m_marginRight : 0;
                                                break;
                                        }
                                    }
                                    return true;
                            }
                            return false;
                        case 7639357: 
                        case 7011901:  // </margin> // </MARGIN>
                            this.m_marginLeft = 0;
                            this.m_marginRight = 0;
                            return true;
                        case 1100728678: 
                        case -855002522:  // <margin-left=xx.x> // <MARGIN-LEFT>
                            value = this.ConvertToFloat(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[0].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[0].valueLength); // px
                            // Reject tag if value is invalid.
                            if (value === -32768) {
                                return false;
                            }
                            switch (tagUnitType) {
                                case TMPro.TagUnitType.Pixels: 
                                    this.m_marginLeft = value * (this.m_isOrthographic ? 1 : 0.1);
                                    break;
                                case TMPro.TagUnitType.FontUnits: 
                                    this.m_marginLeft = value * (this.m_isOrthographic ? 1 : 0.1) * this.m_currentFontSize;
                                    break;
                                case TMPro.TagUnitType.Percentage: 
                                    this.m_marginLeft = (this.m_marginWidth - (this.m_width !== -1 ? this.m_width : 0)) * value / 100;
                                    break;
                            }
                            this.m_marginLeft = this.m_marginLeft >= 0 ? this.m_marginLeft : 0;
                            return true;
                        case -884817987: 
                        case -1690034531:  // <margin-right=xx.x> // <MARGIN-RIGHT>
                            value = this.ConvertToFloat(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[0].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[0].valueLength); // px
                            // Reject tag if value is invalid.
                            if (value === -32768) {
                                return false;
                            }
                            switch (tagUnitType) {
                                case TMPro.TagUnitType.Pixels: 
                                    this.m_marginRight = value * (this.m_isOrthographic ? 1 : 0.1);
                                    break;
                                case TMPro.TagUnitType.FontUnits: 
                                    this.m_marginRight = value * (this.m_isOrthographic ? 1 : 0.1) * this.m_currentFontSize;
                                    break;
                                case TMPro.TagUnitType.Percentage: 
                                    this.m_marginRight = (this.m_marginWidth - (this.m_width !== -1 ? this.m_width : 0)) * value / 100;
                                    break;
                            }
                            this.m_marginRight = this.m_marginRight >= 0 ? this.m_marginRight : 0;
                            return true;
                        case 1109349752: 
                        case -842693512:  // <line-height=xx.x> // <LINE-HEIGHT>
                            value = this.ConvertToFloat(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[0].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[0].valueLength);
                            // Reject tag if value is invalid.
                            if (value === -32768) {
                                return false;
                            }
                            switch (tagUnitType) {
                                case TMPro.TagUnitType.Pixels: 
                                    this.m_lineHeight = value * (this.m_isOrthographic ? 1 : 0.1);
                                    break;
                                case TMPro.TagUnitType.FontUnits: 
                                    this.m_lineHeight = value * (this.m_isOrthographic ? 1 : 0.1) * this.m_currentFontSize;
                                    break;
                                case TMPro.TagUnitType.Percentage: 
                                    fontScale = this.m_currentFontSize / this.m_currentFontAsset.faceInfo.pointSize * this.m_currentFontAsset.faceInfo.scale * (this.m_isOrthographic ? 1 : 0.1);
                                    this.m_lineHeight = this.m_fontAsset.faceInfo.lineHeight * value / 100 * fontScale;
                                    break;
                            }
                            return true;
                        case -445573839: 
                        case 1897350193:  // </line-height> // </LINE-HEIGHT>
                            this.m_lineHeight = TMPro.TMP_Math.FLOAT_UNSET;
                            return true;
                        case 15115642: 
                        case 10723418:  // <noparse> // <NOPARSE>
                            this.tag_NoParsing = true;
                            return true;
                        case 1913798: 
                        case 1286342:  // <action> // <ACTION>
                            var actionID = TMPro.TMP_Text.m_xmlAttribute[0].valueHashCode;
                            if (this.m_isParsingText) {
                                this.m_actionStack.Add(actionID);

                                UnityEngine.Debug.Log$1("Action ID: [" + actionID + "] First character index: " + this.m_characterCount);
                            }
                            //if (m_isParsingText)
                            //{
                            // TMP_Action action = TMP_Action.GetAction(m_xmlAttribute[0].valueHashCode);
                            //}
                            return true;
                        case 7443301: 
                        case 6815845:  // </action> // </ACTION>
                            if (this.m_isParsingText) {
                                UnityEngine.Debug.Log$1("Action ID: [" + this.m_actionStack.CurrentItem() + "] Last character index: " + (this.m_characterCount - 1));
                            }
                            this.m_actionStack.Remove();
                            return true;
                        case 315682: 
                        case 226050:  // <scale=xx.x> // <SCALE=xx.x>
                            value = this.ConvertToFloat(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[0].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[0].valueLength);
                            // Reject tag if value is invalid.
                            if (value === -32768) {
                                return false;
                            }
                            this.m_FXMatrix = new pc.Mat4().setTRS( pc.Vec3.ZERO.clone(), pc.Quat.IDENTITY.clone(), new pc.Vec3( value, 1, 1 ) );
                            this.m_isFXMatrixSet = true;
                            return true;
                        case 1105611: 
                        case 1015979:  // </scale> // </SCALE>
                            this.m_isFXMatrixSet = false;
                            return true;
                        case 2227963: 
                        case 1600507:  // <rotate=xx.x> // <ROTATE=xx.x>
                            // TODO: Add ability to use Random Rotation
                            value = this.ConvertToFloat(TMPro.TMP_Text.m_htmlTag, TMPro.TMP_Text.m_xmlAttribute[0].valueStartIndex, TMPro.TMP_Text.m_xmlAttribute[0].valueLength);
                            // Reject tag if value is invalid.
                            if (value === -32768) {
                                return false;
                            }
                            this.m_FXMatrix = new pc.Mat4().setTRS( pc.Vec3.ZERO.clone(), new pc.Quat().setFromEulerAngles_Unity( 0, 0, value ), new pc.Vec3( 1, 1, 1 ) );
                            this.m_isFXMatrixSet = true;
                            return true;
                        case 7757466: 
                        case 7130010:  // </rotate> // </ROTATE>
                            this.m_isFXMatrixSet = false;
                            return true;
                        case 317446: 
                        case 227814:  // <table> // <TABLE>
                            //switch (m_xmlAttribute[1].nameHashCode)
                            //{
                            //    case 327550: // width
                            //        float tableWidth = ConvertToFloat(m_htmlTag, m_xmlAttribute[1].valueStartIndex, m_xmlAttribute[1].valueLength);
                            //        // Reject tag if value is invalid.
                            //        if (tableWidth == Int16.MinValue) return false;
                            //        switch (tagUnitType)
                            //        {
                            //            case TagUnitType.Pixels:
                            //                Debug.Log("Table width = " + tableWidth + "px.");
                            //                break;
                            //            case TagUnitType.FontUnits:
                            //                Debug.Log("Table width = " + tableWidth + "em.");
                            //                break;
                            //            case TagUnitType.Percentage:
                            //                Debug.Log("Table width = " + tableWidth + "%.");
                            //                break;
                            //        }
                            //        break;
                            //}
                            return false;
                        case 1107375: 
                        case 1017743:  // </table> // </TABLE>
                            return true;
                        case 926: 
                        case 670:  // <tr> // <TR>
                            return true;
                        case 3229: 
                        case 2973:  // </tr> // </TR>
                            return true;
                        case 916: 
                        case 660:  // <th> // <TH>
                            // Set style to bold and center alignment
                            return true;
                        case 3219: 
                        case 2963:  // </th> // </TH>
                            return true;
                        case 912: 
                        case 656:  // <td> // <TD>
                            // Style options
                            //for (int i = 1; i < m_xmlAttribute.Length && m_xmlAttribute[i].nameHashCode != 0; i++)
                            //{
                            //    switch (m_xmlAttribute[i].nameHashCode)
                            //    {
                            //        case 327550: // width
                            //            float tableWidth = ConvertToFloat(m_htmlTag, m_xmlAttribute[i].valueStartIndex, m_xmlAttribute[i].valueLength);
                            //            switch (tagUnitType)
                            //            {
                            //                case TagUnitType.Pixels:
                            //                    Debug.Log("Table width = " + tableWidth + "px.");
                            //                    break;
                            //                case TagUnitType.FontUnits:
                            //                    Debug.Log("Table width = " + tableWidth + "em.");
                            //                    break;
                            //                case TagUnitType.Percentage:
                            //                    Debug.Log("Table width = " + tableWidth + "%.");
                            //                    break;
                            //            }
                            //            break;
                            //        case 275917: // align
                            //            switch (m_xmlAttribute[i].valueHashCode)
                            //            {
                            //                case 3774683: // left
                            //                    Debug.Log("TD align=\"left\".");
                            //                    break;
                            //                case 136703040: // right
                            //                    Debug.Log("TD align=\"right\".");
                            //                    break;
                            //                case -458210101: // center
                            //                    Debug.Log("TD align=\"center\".");
                            //                    break;
                            //                case -523808257: // justified
                            //                    Debug.Log("TD align=\"justified\".");
                            //                    break;
                            //            }
                            //            break;
                            //    }
                            //}
                            return false;
                        case 3215: 
                        case 2959:  // </td> // </TD>
                            return false;
                    }
                }


                return false;
            },
            /*TMPro.TMP_Text.ValidateHtmlTag end.*/


        },
        overloads: {
            "SetTextSortingOrder(VertexSortingOrder)": "SetTextSortingOrder$1",
            "GetPaddingForMaterial(Material)": "GetPaddingForMaterial$1",
            "UpdateGeometry(Mesh, int)": "UpdateGeometry$1",
            "UpdateVertexData(TMP_VertexDataUpdateFlags)": "UpdateVertexData$1",
            "PopulateTextBackingArray(string)": "PopulateTextBackingArray$1",
            "PopulateTextBackingArray(string, int, int)": "PopulateTextBackingArray$2",
            "PopulateTextBackingArray(StringBuilder, int, int)": "PopulateTextBackingArray$3",
            "SetText(string, bool)": "SetText$2",
            "SetText(string, float)": "SetText$3",
            "SetText(string, float, float)": "SetText$4",
            "SetText(string, float, float, float)": "SetText$5",
            "SetText(string, float, float, float, float)": "SetText$6",
            "SetText(string, float, float, float, float, float)": "SetText$7",
            "SetText(string, float, float, float, float, float, float)": "SetText$8",
            "SetText(string, float, float, float, float, float, float, float)": "SetText$9",
            "SetText(string, float, float, float, float, float, float, float, float)": "SetText$10",
            "SetText(StringBuilder)": "SetText$11",
            "SetText(StringBuilder, int, int)": "SetText$12",
            "SetText(char[], int, int)": "SetText$1",
            "SetCharArray(char[], int, int)": "SetCharArray$1",
            "ReplaceOpeningStyleTag(TextBackingContainer, int, int, UnicodeChar[], int)": "ReplaceOpeningStyleTag$1",
            "ReplaceClosingStyleTag(TextBackingContainer, int, UnicodeChar[], int)": "ReplaceClosingStyleTag$1",
            "GetMarkupTagHashCode(TextBackingContainer, int)": "GetMarkupTagHashCode$1",
            "GetStyleHashCode(TextBackingContainer, int, int)": "GetStyleHashCode$1",
            "ResizeInternalArray(T[], int)": "ResizeInternalArray$1",
            "GetPreferredValues(float, float)": "GetPreferredValues$1",
            "GetPreferredValues(string)": "GetPreferredValues$2",
            "GetPreferredValues(string, float, float)": "GetPreferredValues$3",
            "GetPreferredWidth(Vector2)": "GetPreferredWidth$1",
            "GetPreferredHeight(Vector2)": "GetPreferredHeight$1",
            "GetRenderedValues(bool)": "GetRenderedValues$1",
            "GetRenderedWidth()": "GetRenderedWidth$1",
            "GetRenderedHeight()": "GetRenderedHeight$1",
            "GetTextBounds(bool)": "GetTextBounds$1",
            "FillCharacterVertexBuffers(int, int, bool)": "FillCharacterVertexBuffers$1",
            "ClearMesh(bool)": "ClearMesh$1",
            "PackUV(float, float, float)": "PackUV$1",
            "GetUTF16(string, int)": "GetUTF16$2",
            "GetUTF16(int[], int)": "GetUTF16$1",
            "GetUTF16(StringBuilder, int)": "GetUTF16$3",
            "GetUTF16(TextBackingContainer, int)": "GetUTF16$4",
            "GetUTF32(string, int)": "GetUTF32$2",
            "GetUTF32(int[], int)": "GetUTF32$1",
            "GetUTF32(StringBuilder, int)": "GetUTF32$3",
            "GetUTF32(TextBackingContainer, int)": "GetUTF32$4",
            "HexCharsToColor(char[], int, int)": "HexCharsToColor$1",
            "ConvertToFloat(char[], int, int, int)": "ConvertToFloat$1"
        }
    });
    /*TMPro.TMP_Text end.*/

    /*TMPro.TextOverflowModes start.*/
    Bridge.define("TMPro.TextOverflowModes", {
        $kind: 6,
        statics: {
            fields: {
                Overflow: 0,
                Ellipsis: 1,
                Masking: 2,
                Truncate: 3,
                ScrollRect: 4,
                Page: 5,
                Linked: 6
            }
        }
    });
    /*TMPro.TextOverflowModes end.*/

    /*TMPro.TextRenderFlags start.*/
    /**
     * Flags controlling what vertex data gets pushed to the mesh.
     *
     * @public
     * @class TMPro.TextRenderFlags
     */
    Bridge.define("TMPro.TextRenderFlags", {
        $kind: 6,
        statics: {
            fields: {
                DontRender: 0,
                Render: 255
            }
        }
    });
    /*TMPro.TextRenderFlags end.*/

    /*TMPro.TextureMappingOptions start.*/
    Bridge.define("TMPro.TextureMappingOptions", {
        $kind: 6,
        statics: {
            fields: {
                Character: 0,
                Line: 1,
                Paragraph: 2,
                MatchAspect: 3
            }
        }
    });
    /*TMPro.TextureMappingOptions end.*/

    /*TMPro.TMP_Asset start.*/
    Bridge.define("TMPro.TMP_Asset", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            m_InstanceID: 0,
            /**
             * HashCode based on the name of the asset.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Asset
             * @type number
             */
            hashCode: 0,
            /**
             * The material used by this asset.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Asset
             * @type UnityEngine.Material
             */
            material: null,
            /**
             * HashCode based on the name of the material assigned to this asset.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Asset
             * @type number
             */
            materialHashCode: 0
        },
        props: {
            /**
             * Instance ID of the TMP Asset
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_Asset
             * @function instanceID
             * @type number
             */
            instanceID: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Asset#instanceID#get", this ); }

                    if (this.m_InstanceID === 0) {
                        this.m_InstanceID = this.GetInstanceID();
                    }

                    return this.m_InstanceID;
                }
            }
        }
    });
    /*TMPro.TMP_Asset end.*/

    /*TMPro.TMP_TextElement start.*/
    /**
     * Base class for all text elements like Character and SpriteCharacter.
     *
     * @public
     * @class TMPro.TMP_TextElement
     */
    Bridge.define("TMPro.TMP_TextElement", {
        fields: {
            m_ElementType: 0,
            m_Unicode: 0,
            m_TextAsset: null,
            m_Glyph: null,
            m_GlyphIndex: 0,
            m_Scale: 0
        },
        props: {
            /**
             * The type of text element which can be a character or sprite.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_TextElement
             * @function elementType
             * @type TMPro.TextElementType
             */
            elementType: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextElement#elementType#get", this ); }

                    return this.m_ElementType;
                }
            },
            /**
             * The unicode value (code point) of the character.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_TextElement
             * @function unicode
             * @type number
             */
            unicode: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextElement#unicode#get", this ); }

                    return this.m_Unicode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextElement#unicode#set", this ); }

                    this.m_Unicode = value;
                }
            },
            /**
             * The Text Asset to which this Text Element belongs.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_TextElement
             * @function textAsset
             * @type TMPro.TMP_Asset
             */
            textAsset: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextElement#textAsset#get", this ); }

                    return this.m_TextAsset;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextElement#textAsset#set", this ); }

                    this.m_TextAsset = value;
                }
            },
            /**
             * The glyph used by this text element.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_TextElement
             * @function glyph
             * @type UnityEngine.TextCore.Glyph
             */
            glyph: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextElement#glyph#get", this ); }

                    return this.m_Glyph;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextElement#glyph#set", this ); }

                    this.m_Glyph = value;
                }
            },
            /**
             * The index of the glyph used by this text element.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_TextElement
             * @function glyphIndex
             * @type number
             */
            glyphIndex: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextElement#glyphIndex#get", this ); }

                    return this.m_GlyphIndex;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextElement#glyphIndex#set", this ); }

                    this.m_GlyphIndex = value;
                }
            },
            /**
             * The relative scale of the character.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_TextElement
             * @function scale
             * @type number
             */
            scale: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextElement#scale#get", this ); }

                    return this.m_Scale;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextElement#scale#set", this ); }

                    this.m_Scale = value;
                }
            }
        }
    });
    /*TMPro.TMP_TextElement end.*/

    /*TMPro.TMP_CharacterInfo start.*/
    /**
     * Structure containing information about individual text elements (character or sprites).
     *
     * @public
     * @class TMPro.TMP_CharacterInfo
     */
    Bridge.define("TMPro.TMP_CharacterInfo", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_CharacterInfo#getDefaultValue", this ); }
 return new TMPro.TMP_CharacterInfo(); }
            }
        },
        fields: {
            character: 0,
            /**
             * Index of the character in the raw string.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_CharacterInfo
             * @type number
             */
            index: 0,
            stringLength: 0,
            elementType: 0,
            textElement: null,
            fontAsset: null,
            spriteAsset: null,
            spriteIndex: 0,
            material: null,
            materialReferenceIndex: 0,
            isUsingAlternateTypeface: false,
            pointSize: 0,
            lineNumber: 0,
            pageNumber: 0,
            vertexIndex: 0,
            vertex_BL: null,
            vertex_TL: null,
            vertex_TR: null,
            vertex_BR: null,
            topLeft: null,
            bottomLeft: null,
            topRight: null,
            bottomRight: null,
            origin: 0,
            xAdvance: 0,
            ascender: 0,
            baseLine: 0,
            descender: 0,
            adjustedAscender: 0,
            adjustedDescender: 0,
            aspectRatio: 0,
            scale: 0,
            color: null,
            underlineColor: null,
            underlineVertexIndex: 0,
            strikethroughColor: null,
            strikethroughVertexIndex: 0,
            highlightColor: null,
            highlightState: null,
            style: 0,
            isVisible: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_CharacterInfo#init", this ); }

                this.vertex_BL = new TMPro.TMP_Vertex();
                this.vertex_TL = new TMPro.TMP_Vertex();
                this.vertex_TR = new TMPro.TMP_Vertex();
                this.vertex_BR = new TMPro.TMP_Vertex();
                this.topLeft = new UnityEngine.Vector3();
                this.bottomLeft = new UnityEngine.Vector3();
                this.topRight = new UnityEngine.Vector3();
                this.bottomRight = new UnityEngine.Vector3();
                this.color = new UnityEngine.Color32();
                this.underlineColor = new UnityEngine.Color32();
                this.strikethroughColor = new UnityEngine.Color32();
                this.highlightColor = new UnityEngine.Color32();
                this.highlightState = new TMPro.HighlightState();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_CharacterInfo#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_CharacterInfo#getHashCode", this ); }

                var h = Bridge.addHash([6938714841, this.character, this.index, this.stringLength, this.elementType, this.textElement, this.fontAsset, this.spriteAsset, this.spriteIndex, this.material, this.materialReferenceIndex, this.isUsingAlternateTypeface, this.pointSize, this.lineNumber, this.pageNumber, this.vertexIndex, this.vertex_BL, this.vertex_TL, this.vertex_TR, this.vertex_BR, this.topLeft, this.bottomLeft, this.topRight, this.bottomRight, this.origin, this.xAdvance, this.ascender, this.baseLine, this.descender, this.adjustedAscender, this.adjustedDescender, this.aspectRatio, this.scale, this.color, this.underlineColor, this.underlineVertexIndex, this.strikethroughColor, this.strikethroughVertexIndex, this.highlightColor, this.highlightState, this.style, this.isVisible]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.TMP_CharacterInfo#equals", this ); }

                if (!Bridge.is(o, TMPro.TMP_CharacterInfo)) {
                    return false;
                }
                return Bridge.equals(this.character, o.character) && Bridge.equals(this.index, o.index) && Bridge.equals(this.stringLength, o.stringLength) && Bridge.equals(this.elementType, o.elementType) && Bridge.equals(this.textElement, o.textElement) && Bridge.equals(this.fontAsset, o.fontAsset) && Bridge.equals(this.spriteAsset, o.spriteAsset) && Bridge.equals(this.spriteIndex, o.spriteIndex) && Bridge.equals(this.material, o.material) && Bridge.equals(this.materialReferenceIndex, o.materialReferenceIndex) && Bridge.equals(this.isUsingAlternateTypeface, o.isUsingAlternateTypeface) && Bridge.equals(this.pointSize, o.pointSize) && Bridge.equals(this.lineNumber, o.lineNumber) && Bridge.equals(this.pageNumber, o.pageNumber) && Bridge.equals(this.vertexIndex, o.vertexIndex) && Bridge.equals(this.vertex_BL, o.vertex_BL) && Bridge.equals(this.vertex_TL, o.vertex_TL) && Bridge.equals(this.vertex_TR, o.vertex_TR) && Bridge.equals(this.vertex_BR, o.vertex_BR) && Bridge.equals(this.topLeft, o.topLeft) && Bridge.equals(this.bottomLeft, o.bottomLeft) && Bridge.equals(this.topRight, o.topRight) && Bridge.equals(this.bottomRight, o.bottomRight) && Bridge.equals(this.origin, o.origin) && Bridge.equals(this.xAdvance, o.xAdvance) && Bridge.equals(this.ascender, o.ascender) && Bridge.equals(this.baseLine, o.baseLine) && Bridge.equals(this.descender, o.descender) && Bridge.equals(this.adjustedAscender, o.adjustedAscender) && Bridge.equals(this.adjustedDescender, o.adjustedDescender) && Bridge.equals(this.aspectRatio, o.aspectRatio) && Bridge.equals(this.scale, o.scale) && Bridge.equals(this.color, o.color) && Bridge.equals(this.underlineColor, o.underlineColor) && Bridge.equals(this.underlineVertexIndex, o.underlineVertexIndex) && Bridge.equals(this.strikethroughColor, o.strikethroughColor) && Bridge.equals(this.strikethroughVertexIndex, o.strikethroughVertexIndex) && Bridge.equals(this.highlightColor, o.highlightColor) && Bridge.equals(this.highlightState, o.highlightState) && Bridge.equals(this.style, o.style) && Bridge.equals(this.isVisible, o.isVisible);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.TMP_CharacterInfo#$clone", this ); }

                var s = to || new TMPro.TMP_CharacterInfo();
                s.character = this.character;
                s.index = this.index;
                s.stringLength = this.stringLength;
                s.elementType = this.elementType;
                s.textElement = this.textElement;
                s.fontAsset = this.fontAsset;
                s.spriteAsset = this.spriteAsset;
                s.spriteIndex = this.spriteIndex;
                s.material = this.material;
                s.materialReferenceIndex = this.materialReferenceIndex;
                s.isUsingAlternateTypeface = this.isUsingAlternateTypeface;
                s.pointSize = this.pointSize;
                s.lineNumber = this.lineNumber;
                s.pageNumber = this.pageNumber;
                s.vertexIndex = this.vertexIndex;
                s.vertex_BL = this.vertex_BL.$clone();
                s.vertex_TL = this.vertex_TL.$clone();
                s.vertex_TR = this.vertex_TR.$clone();
                s.vertex_BR = this.vertex_BR.$clone();
                s.topLeft = this.topLeft.$clone();
                s.bottomLeft = this.bottomLeft.$clone();
                s.topRight = this.topRight.$clone();
                s.bottomRight = this.bottomRight.$clone();
                s.origin = this.origin;
                s.xAdvance = this.xAdvance;
                s.ascender = this.ascender;
                s.baseLine = this.baseLine;
                s.descender = this.descender;
                s.adjustedAscender = this.adjustedAscender;
                s.adjustedDescender = this.adjustedDescender;
                s.aspectRatio = this.aspectRatio;
                s.scale = this.scale;
                s.color = this.color.$clone();
                s.underlineColor = this.underlineColor.$clone();
                s.underlineVertexIndex = this.underlineVertexIndex;
                s.strikethroughColor = this.strikethroughColor.$clone();
                s.strikethroughVertexIndex = this.strikethroughVertexIndex;
                s.highlightColor = this.highlightColor.$clone();
                s.highlightState = this.highlightState.$clone();
                s.style = this.style;
                s.isVisible = this.isVisible;
                return s;
            }
        }
    });
    /*TMPro.TMP_CharacterInfo end.*/

    /*TMPro.TMP_ColorGradient start.*/
    Bridge.define("TMPro.TMP_ColorGradient", {
        inherits: [UnityEngine.ScriptableObject],
        statics: {
            fields: {
                k_DefaultColorMode: 0,
                k_DefaultColor: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_ColorGradient#init", this ); }

                    this.k_DefaultColor = new UnityEngine.Color();
                    this.k_DefaultColorMode = TMPro.ColorMode.FourCornersGradient;
                    this.k_DefaultColor = new pc.Color( 1, 1, 1, 1 );
                }
            }
        },
        fields: {
            colorMode: 0,
            topLeft: null,
            topRight: null,
            bottomLeft: null,
            bottomRight: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_ColorGradient#init", this ); }

                this.topLeft = new UnityEngine.Color();
                this.topRight = new UnityEngine.Color();
                this.bottomLeft = new UnityEngine.Color();
                this.bottomRight = new UnityEngine.Color();
                this.colorMode = TMPro.ColorMode.FourCornersGradient;
            },
            /**
             * Default Constructor which sets each of the colors as white.
             *
             * @instance
             * @public
             * @this TMPro.TMP_ColorGradient
             * @memberof TMPro.TMP_ColorGradient
             * @return  {void}
             */
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_ColorGradient#ctor", this ); }

                this.$initialize();
                UnityEngine.ScriptableObject.ctor.call(this);
                this.colorMode = TMPro.TMP_ColorGradient.k_DefaultColorMode;
                this.topLeft = TMPro.TMP_ColorGradient.k_DefaultColor.$clone();
                this.topRight = TMPro.TMP_ColorGradient.k_DefaultColor.$clone();
                this.bottomLeft = TMPro.TMP_ColorGradient.k_DefaultColor.$clone();
                this.bottomRight = TMPro.TMP_ColorGradient.k_DefaultColor.$clone();
            },
            /**
             * Constructor allowing to set the default color of the Color Gradient.
             *
             * @instance
             * @public
             * @this TMPro.TMP_ColorGradient
             * @memberof TMPro.TMP_ColorGradient
             * @param   {UnityEngine.Color}    color
             * @return  {void}
             */
            $ctor1: function (color) {
if ( TRACE ) { TRACE( "TMPro.TMP_ColorGradient#$ctor1", this ); }

                this.$initialize();
                UnityEngine.ScriptableObject.ctor.call(this);
                this.colorMode = TMPro.TMP_ColorGradient.k_DefaultColorMode;
                this.topLeft = color.$clone();
                this.topRight = color.$clone();
                this.bottomLeft = color.$clone();
                this.bottomRight = color.$clone();
            },
            /**
             * The vertex colors at the corners of the characters.
             *
             * @instance
             * @public
             * @this TMPro.TMP_ColorGradient
             * @memberof TMPro.TMP_ColorGradient
             * @param   {UnityEngine.Color}    color0    Top left color.
             * @param   {UnityEngine.Color}    color1    Top right color.
             * @param   {UnityEngine.Color}    color2    Bottom left color.
             * @param   {UnityEngine.Color}    color3    Bottom right color.
             * @return  {void}
             */
            $ctor2: function (color0, color1, color2, color3) {
if ( TRACE ) { TRACE( "TMPro.TMP_ColorGradient#$ctor2", this ); }

                this.$initialize();
                UnityEngine.ScriptableObject.ctor.call(this);
                this.colorMode = TMPro.TMP_ColorGradient.k_DefaultColorMode;
                this.topLeft = color0.$clone();
                this.topRight = color1.$clone();
                this.bottomLeft = color2.$clone();
                this.bottomRight = color3.$clone();
            }
        }
    });
    /*TMPro.TMP_ColorGradient end.*/

    /*TMPro.TMP_Compatibility start.*/
    Bridge.define("TMPro.TMP_Compatibility", {
        statics: {
            methods: {
                /*TMPro.TMP_Compatibility.ConvertTextAlignmentEnumValues:static start.*/
                /**
                 * Function used to convert text alignment option enumeration format.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_Compatibility
                 * @memberof TMPro.TMP_Compatibility
                 * @param   {TMPro.TextAlignmentOptions}    oldValue
                 * @return  {TMPro.TextAlignmentOptions}
                 */
                ConvertTextAlignmentEnumValues: function (oldValue) {
if ( TRACE ) { TRACE( "TMPro.TMP_Compatibility#ConvertTextAlignmentEnumValues", this ); }

                    switch (oldValue) {
                        case 0: 
                            return TMPro.TextAlignmentOptions.TopLeft;
                        case 1: 
                            return TMPro.TextAlignmentOptions.Top;
                        case 2: 
                            return TMPro.TextAlignmentOptions.TopRight;
                        case 3: 
                            return TMPro.TextAlignmentOptions.TopJustified;
                        case 4: 
                            return TMPro.TextAlignmentOptions.Left;
                        case 5: 
                            return TMPro.TextAlignmentOptions.Center;
                        case 6: 
                            return TMPro.TextAlignmentOptions.Right;
                        case 7: 
                            return TMPro.TextAlignmentOptions.Justified;
                        case 8: 
                            return TMPro.TextAlignmentOptions.BottomLeft;
                        case 9: 
                            return TMPro.TextAlignmentOptions.Bottom;
                        case 10: 
                            return TMPro.TextAlignmentOptions.BottomRight;
                        case 11: 
                            return TMPro.TextAlignmentOptions.BottomJustified;
                        case 12: 
                            return TMPro.TextAlignmentOptions.BaselineLeft;
                        case 13: 
                            return TMPro.TextAlignmentOptions.Baseline;
                        case 14: 
                            return TMPro.TextAlignmentOptions.BaselineRight;
                        case 15: 
                            return TMPro.TextAlignmentOptions.BaselineJustified;
                        case 16: 
                            return TMPro.TextAlignmentOptions.MidlineLeft;
                        case 17: 
                            return TMPro.TextAlignmentOptions.Midline;
                        case 18: 
                            return TMPro.TextAlignmentOptions.MidlineRight;
                        case 19: 
                            return TMPro.TextAlignmentOptions.MidlineJustified;
                        case 20: 
                            return TMPro.TextAlignmentOptions.CaplineLeft;
                        case 21: 
                            return TMPro.TextAlignmentOptions.Capline;
                        case 22: 
                            return TMPro.TextAlignmentOptions.CaplineRight;
                        case 23: 
                            return TMPro.TextAlignmentOptions.CaplineJustified;
                    }

                    return TMPro.TextAlignmentOptions.TopLeft;
                },
                /*TMPro.TMP_Compatibility.ConvertTextAlignmentEnumValues:static end.*/


            }
        }
    });
    /*TMPro.TMP_Compatibility end.*/

    /*TMPro.TMP_Compatibility+AnchorPositions start.*/
    Bridge.define("TMPro.TMP_Compatibility.AnchorPositions", {
        $kind: 1006,
        statics: {
            fields: {
                TopLeft: 0,
                Top: 1,
                TopRight: 2,
                Left: 3,
                Center: 4,
                Right: 5,
                BottomLeft: 6,
                Bottom: 7,
                BottomRight: 8,
                BaseLine: 9,
                None: 10
            }
        }
    });
    /*TMPro.TMP_Compatibility+AnchorPositions end.*/

    /*TMPro.TMP_DefaultControls start.*/
    Bridge.define("TMPro.TMP_DefaultControls", {
        statics: {
            fields: {
                kWidth: 0,
                kThickHeight: 0,
                kThinHeight: 0,
                s_TextElementSize: null,
                s_ThickElementSize: null,
                s_ThinElementSize: null,
                s_DefaultSelectableColor: null,
                s_TextColor: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_DefaultControls#init", this ); }

                    this.s_TextElementSize = new UnityEngine.Vector2();
                    this.s_ThickElementSize = new UnityEngine.Vector2();
                    this.s_ThinElementSize = new UnityEngine.Vector2();
                    this.s_DefaultSelectableColor = new UnityEngine.Color();
                    this.s_TextColor = new UnityEngine.Color();
                    this.kWidth = 160.0;
                    this.kThickHeight = 30.0;
                    this.kThinHeight = 20.0;
                    this.s_TextElementSize = new pc.Vec2( 100.0, 100.0 );
                    this.s_ThickElementSize = new pc.Vec2( TMPro.TMP_DefaultControls.kWidth, TMPro.TMP_DefaultControls.kThickHeight );
                    this.s_ThinElementSize = new pc.Vec2( TMPro.TMP_DefaultControls.kWidth, TMPro.TMP_DefaultControls.kThinHeight );
                    this.s_DefaultSelectableColor = new pc.Color( 1.0, 1.0, 1.0, 1.0 );
                    this.s_TextColor = new pc.Color( 0.196078435, 0.196078435, 0.196078435, 1.0 );
                }
            },
            methods: {
                /*TMPro.TMP_DefaultControls.CreateUIElementRoot:static start.*/
                CreateUIElementRoot: function (name, size) {
if ( TRACE ) { TRACE( "TMPro.TMP_DefaultControls#CreateUIElementRoot", this ); }

                    var child = new UnityEngine.GameObject.$ctor2(name);
                    var rectTransform = child.AddComponent(UnityEngine.RectTransform);
                    rectTransform.sizeDelta = size.$clone();
                    return child;
                },
                /*TMPro.TMP_DefaultControls.CreateUIElementRoot:static end.*/

                /*TMPro.TMP_DefaultControls.CreateUIObject:static start.*/
                CreateUIObject: function (name, parent) {
if ( TRACE ) { TRACE( "TMPro.TMP_DefaultControls#CreateUIObject", this ); }

                    var go = new UnityEngine.GameObject.$ctor2(name);
                    go.AddComponent(UnityEngine.RectTransform);
                    TMPro.TMP_DefaultControls.SetParentAndAlign(go, parent);
                    return go;
                },
                /*TMPro.TMP_DefaultControls.CreateUIObject:static end.*/

                /*TMPro.TMP_DefaultControls.SetDefaultTextValues:static start.*/
                SetDefaultTextValues: function (lbl) {
if ( TRACE ) { TRACE( "TMPro.TMP_DefaultControls#SetDefaultTextValues", this ); }

                    // Set text values we want across UI elements in default controls.
                    // Don't set values which are the same as the default values for the Text component,
                    // since there's no point in that, and it's good to keep them as consistent as possible.
                    lbl.color = TMPro.TMP_DefaultControls.s_TextColor.$clone();
                    lbl.fontSize = 14;
                },
                /*TMPro.TMP_DefaultControls.SetDefaultTextValues:static end.*/

                /*TMPro.TMP_DefaultControls.SetDefaultColorTransitionValues:static start.*/
                SetDefaultColorTransitionValues: function (slider) {
if ( TRACE ) { TRACE( "TMPro.TMP_DefaultControls#SetDefaultColorTransitionValues", this ); }

                    var colors = slider.colors.$clone();
                    colors.highlightedColor = new pc.Color( 0.882, 0.882, 0.882, 1 );
                    colors.pressedColor = new pc.Color( 0.698, 0.698, 0.698, 1 );
                    colors.disabledColor = new pc.Color( 0.521, 0.521, 0.521, 1 );
                },
                /*TMPro.TMP_DefaultControls.SetDefaultColorTransitionValues:static end.*/

                /*TMPro.TMP_DefaultControls.SetParentAndAlign:static start.*/
                SetParentAndAlign: function (child, parent) {
if ( TRACE ) { TRACE( "TMPro.TMP_DefaultControls#SetParentAndAlign", this ); }

                    if (UnityEngine.GameObject.op_Equality(parent, null)) {
                        return;
                    }

                    child.transform.SetParent(parent.transform, false);
                    TMPro.TMP_DefaultControls.SetLayerRecursively(child, parent.layer);
                },
                /*TMPro.TMP_DefaultControls.SetParentAndAlign:static end.*/

                /*TMPro.TMP_DefaultControls.SetLayerRecursively:static start.*/
                SetLayerRecursively: function (go, layer) {
if ( TRACE ) { TRACE( "TMPro.TMP_DefaultControls#SetLayerRecursively", this ); }

                    go.layer = layer;
                    var t = go.transform;
                    for (var i = 0; i < t.childCount; i++) {
                        TMPro.TMP_DefaultControls.SetLayerRecursively(t.GetChild(i).gameObject, layer);
                    }
                },
                /*TMPro.TMP_DefaultControls.SetLayerRecursively:static end.*/

                /*TMPro.TMP_DefaultControls.CreateScrollbar:static start.*/
                CreateScrollbar: function (resources) {
if ( TRACE ) { TRACE( "TMPro.TMP_DefaultControls#CreateScrollbar", this ); }

                    // Create GOs Hierarchy
                    var scrollbarRoot = TMPro.TMP_DefaultControls.CreateUIElementRoot("Scrollbar", TMPro.TMP_DefaultControls.s_ThinElementSize.$clone());

                    var sliderArea = TMPro.TMP_DefaultControls.CreateUIObject("Sliding Area", scrollbarRoot);
                    var handle = TMPro.TMP_DefaultControls.CreateUIObject("Handle", sliderArea);

                    var bgImage = scrollbarRoot.AddComponent(UnityEngine.UI.Image);
                    bgImage.sprite = resources.background;
                    bgImage.type = UnityEngine.UI.Image.Type.Sliced;
                    bgImage.color = TMPro.TMP_DefaultControls.s_DefaultSelectableColor.$clone();

                    var handleImage = handle.AddComponent(UnityEngine.UI.Image);
                    handleImage.sprite = resources.standard;
                    handleImage.type = UnityEngine.UI.Image.Type.Sliced;
                    handleImage.color = TMPro.TMP_DefaultControls.s_DefaultSelectableColor.$clone();

                    var sliderAreaRect = sliderArea.GetComponent(UnityEngine.RectTransform);
                    sliderAreaRect.sizeDelta = new pc.Vec2( -20, -20 );
                    sliderAreaRect.anchorMin = pc.Vec2.ZERO.clone();
                    sliderAreaRect.anchorMax = pc.Vec2.ONE.clone();

                    var handleRect = handle.GetComponent(UnityEngine.RectTransform);
                    handleRect.sizeDelta = new pc.Vec2( 20, 20 );

                    var scrollbar = scrollbarRoot.AddComponent(UnityEngine.UI.Scrollbar);
                    scrollbar.handleRect = handleRect;
                    scrollbar.targetGraphic = handleImage;
                    TMPro.TMP_DefaultControls.SetDefaultColorTransitionValues(scrollbar);

                    return scrollbarRoot;
                },
                /*TMPro.TMP_DefaultControls.CreateScrollbar:static end.*/

                /*TMPro.TMP_DefaultControls.CreateButton:static start.*/
                CreateButton: function (resources) {
if ( TRACE ) { TRACE( "TMPro.TMP_DefaultControls#CreateButton", this ); }

                    var buttonRoot = TMPro.TMP_DefaultControls.CreateUIElementRoot("Button", TMPro.TMP_DefaultControls.s_ThickElementSize.$clone());

                    var childText = new UnityEngine.GameObject.$ctor2("Text (TMP)");
                    childText.AddComponent(UnityEngine.RectTransform);
                    TMPro.TMP_DefaultControls.SetParentAndAlign(childText, buttonRoot);

                    var image = buttonRoot.AddComponent(UnityEngine.UI.Image);
                    image.sprite = resources.standard;
                    image.type = UnityEngine.UI.Image.Type.Sliced;
                    image.color = TMPro.TMP_DefaultControls.s_DefaultSelectableColor.$clone();

                    var bt = buttonRoot.AddComponent(UnityEngine.UI.Button);
                    TMPro.TMP_DefaultControls.SetDefaultColorTransitionValues(bt);

                    var text = childText.AddComponent(TMPro.TextMeshProUGUI);
                    text.text = "Button";
                    text.alignment = TMPro.TextAlignmentOptions.Center;
                    TMPro.TMP_DefaultControls.SetDefaultTextValues(text);

                    var textRectTransform = childText.GetComponent(UnityEngine.RectTransform);
                    textRectTransform.anchorMin = pc.Vec2.ZERO.clone();
                    textRectTransform.anchorMax = pc.Vec2.ONE.clone();
                    textRectTransform.sizeDelta = pc.Vec2.ZERO.clone();

                    return buttonRoot;
                },
                /*TMPro.TMP_DefaultControls.CreateButton:static end.*/

                /*TMPro.TMP_DefaultControls.CreateText:static start.*/
                CreateText: function (resources) {
if ( TRACE ) { TRACE( "TMPro.TMP_DefaultControls#CreateText", this ); }

                    var go = null;

                    go = TMPro.TMP_DefaultControls.CreateUIElementRoot("Text (TMP)", TMPro.TMP_DefaultControls.s_TextElementSize.$clone());
                    go.AddComponent(TMPro.TextMeshProUGUI);

                    return go;
                },
                /*TMPro.TMP_DefaultControls.CreateText:static end.*/

                /*TMPro.TMP_DefaultControls.CreateInputField:static start.*/
                CreateInputField: function (resources) {
if ( TRACE ) { TRACE( "TMPro.TMP_DefaultControls#CreateInputField", this ); }

                    var root = TMPro.TMP_DefaultControls.CreateUIElementRoot("InputField (TMP)", TMPro.TMP_DefaultControls.s_ThickElementSize.$clone());

                    var textArea = TMPro.TMP_DefaultControls.CreateUIObject("Text Area", root);
                    var childPlaceholder = TMPro.TMP_DefaultControls.CreateUIObject("Placeholder", textArea);
                    var childText = TMPro.TMP_DefaultControls.CreateUIObject("Text", textArea);

                    var image = root.AddComponent(UnityEngine.UI.Image);
                    image.sprite = resources.inputField;
                    image.type = UnityEngine.UI.Image.Type.Sliced;
                    image.color = TMPro.TMP_DefaultControls.s_DefaultSelectableColor.$clone();

                    var inputField = root.AddComponent(TMPro.TMP_InputField);
                    TMPro.TMP_DefaultControls.SetDefaultColorTransitionValues(inputField);

                    // Use UI.Mask for Unity 5.0 - 5.1 and 2D RectMask for Unity 5.2 and up
                    var rectMask = textArea.AddComponent(UnityEngine.UI.RectMask2D);

                    var textAreaRectTransform = textArea.GetComponent(UnityEngine.RectTransform);
                    textAreaRectTransform.anchorMin = pc.Vec2.ZERO.clone();
                    textAreaRectTransform.anchorMax = pc.Vec2.ONE.clone();
                    textAreaRectTransform.sizeDelta = pc.Vec2.ZERO.clone();
                    textAreaRectTransform.offsetMin = new pc.Vec2( 10, 6 );
                    textAreaRectTransform.offsetMax = new pc.Vec2( -10, -7 );


                    var text = childText.AddComponent(TMPro.TextMeshProUGUI);
                    text.text = "";
                    text.enableWordWrapping = false;
                    text.extraPadding = true;
                    text.richText = true;
                    TMPro.TMP_DefaultControls.SetDefaultTextValues(text);

                    var placeholder = childPlaceholder.AddComponent(TMPro.TextMeshProUGUI);
                    placeholder.text = "Enter text...";
                    placeholder.fontSize = 14;
                    placeholder.fontStyle = TMPro.FontStyles.Italic;
                    placeholder.enableWordWrapping = false;
                    placeholder.extraPadding = true;

                    // Make placeholder color half as opaque as normal text color.
                    var placeholderColor = text.color.$clone();
                    placeholderColor.a *= 0.5;
                    placeholder.color = placeholderColor.$clone();

                    // Add Layout component to placeholder.
                    placeholder.gameObject.AddComponent(UnityEngine.UI.LayoutElement).ignoreLayout = true;

                    var textRectTransform = childText.GetComponent(UnityEngine.RectTransform);
                    textRectTransform.anchorMin = pc.Vec2.ZERO.clone();
                    textRectTransform.anchorMax = pc.Vec2.ONE.clone();
                    textRectTransform.sizeDelta = pc.Vec2.ZERO.clone();
                    textRectTransform.offsetMin = new pc.Vec2( 0, 0 );
                    textRectTransform.offsetMax = new pc.Vec2( 0, 0 );

                    var placeholderRectTransform = childPlaceholder.GetComponent(UnityEngine.RectTransform);
                    placeholderRectTransform.anchorMin = pc.Vec2.ZERO.clone();
                    placeholderRectTransform.anchorMax = pc.Vec2.ONE.clone();
                    placeholderRectTransform.sizeDelta = pc.Vec2.ZERO.clone();
                    placeholderRectTransform.offsetMin = new pc.Vec2( 0, 0 );
                    placeholderRectTransform.offsetMax = new pc.Vec2( 0, 0 );

                    inputField.textViewport = textAreaRectTransform;
                    inputField.textComponent = text;
                    inputField.placeholder = placeholder;
                    inputField.fontAsset = text.font;

                    return root;
                },
                /*TMPro.TMP_DefaultControls.CreateInputField:static end.*/

                /*TMPro.TMP_DefaultControls.CreateDropdown:static start.*/
                CreateDropdown: function (resources) {
if ( TRACE ) { TRACE( "TMPro.TMP_DefaultControls#CreateDropdown", this ); }

                    var $t;
                    var root = TMPro.TMP_DefaultControls.CreateUIElementRoot("Dropdown", TMPro.TMP_DefaultControls.s_ThickElementSize.$clone());

                    var label = TMPro.TMP_DefaultControls.CreateUIObject("Label", root);
                    var arrow = TMPro.TMP_DefaultControls.CreateUIObject("Arrow", root);
                    var template = TMPro.TMP_DefaultControls.CreateUIObject("Template", root);
                    var viewport = TMPro.TMP_DefaultControls.CreateUIObject("Viewport", template);
                    var content = TMPro.TMP_DefaultControls.CreateUIObject("Content", viewport);
                    var item = TMPro.TMP_DefaultControls.CreateUIObject("Item", content);
                    var itemBackground = TMPro.TMP_DefaultControls.CreateUIObject("Item Background", item);
                    var itemCheckmark = TMPro.TMP_DefaultControls.CreateUIObject("Item Checkmark", item);
                    var itemLabel = TMPro.TMP_DefaultControls.CreateUIObject("Item Label", item);

                    // Sub controls.

                    var scrollbar = TMPro.TMP_DefaultControls.CreateScrollbar(resources.$clone());
                    scrollbar.name = "Scrollbar";
                    TMPro.TMP_DefaultControls.SetParentAndAlign(scrollbar, template);

                    var scrollbarScrollbar = scrollbar.GetComponent(UnityEngine.UI.Scrollbar);
                    scrollbarScrollbar.SetDirection(UnityEngine.UI.Scrollbar.Direction.BottomToTop, true);

                    var vScrollbarRT = scrollbar.GetComponent(UnityEngine.RectTransform);
                    vScrollbarRT.anchorMin = pc.Vec2.RIGHT.clone();
                    vScrollbarRT.anchorMax = pc.Vec2.ONE.clone();
                    vScrollbarRT.pivot = pc.Vec2.ONE.clone();
                    vScrollbarRT.sizeDelta = new pc.Vec2( vScrollbarRT.sizeDelta.x, 0 );

                    // Setup item UI components.

                    var itemLabelText = itemLabel.AddComponent(TMPro.TextMeshProUGUI);
                    TMPro.TMP_DefaultControls.SetDefaultTextValues(itemLabelText);
                    itemLabelText.alignment = TMPro.TextAlignmentOptions.Left;

                    var itemBackgroundImage = itemBackground.AddComponent(UnityEngine.UI.Image);
                    itemBackgroundImage.color = UnityEngine.Color32.op_Implicit(new UnityEngine.Color32.$ctor1(245, 245, 245, 255));

                    var itemCheckmarkImage = itemCheckmark.AddComponent(UnityEngine.UI.Image);
                    itemCheckmarkImage.sprite = resources.checkmark;

                    var itemToggle = item.AddComponent(UnityEngine.UI.Toggle);
                    itemToggle.targetGraphic = itemBackgroundImage;
                    itemToggle.graphic = itemCheckmarkImage;
                    itemToggle.isOn = true;

                    // Setup template UI components.

                    var templateImage = template.AddComponent(UnityEngine.UI.Image);
                    templateImage.sprite = resources.standard;
                    templateImage.type = UnityEngine.UI.Image.Type.Sliced;

                    var templateScrollRect = template.AddComponent(UnityEngine.UI.ScrollRect);
                    templateScrollRect.content = Bridge.cast(content.transform, UnityEngine.RectTransform);
                    templateScrollRect.viewport = Bridge.cast(viewport.transform, UnityEngine.RectTransform);
                    templateScrollRect.horizontal = false;
                    templateScrollRect.movementType = UnityEngine.UI.ScrollRect.MovementType.Clamped;
                    templateScrollRect.verticalScrollbar = scrollbarScrollbar;
                    templateScrollRect.verticalScrollbarVisibility = UnityEngine.UI.ScrollRect.ScrollbarVisibility.AutoHideAndExpandViewport;
                    templateScrollRect.verticalScrollbarSpacing = -3;

                    var scrollRectMask = viewport.AddComponent(UnityEngine.UI.Mask);
                    scrollRectMask.showMaskGraphic = false;

                    var viewportImage = viewport.AddComponent(UnityEngine.UI.Image);
                    viewportImage.sprite = resources.mask;
                    viewportImage.type = UnityEngine.UI.Image.Type.Sliced;

                    // Setup dropdown UI components.

                    var labelText = label.AddComponent(TMPro.TextMeshProUGUI);
                    TMPro.TMP_DefaultControls.SetDefaultTextValues(labelText);
                    labelText.alignment = TMPro.TextAlignmentOptions.Left;

                    var arrowImage = arrow.AddComponent(UnityEngine.UI.Image);
                    arrowImage.sprite = resources.dropdown;

                    var backgroundImage = root.AddComponent(UnityEngine.UI.Image);
                    backgroundImage.sprite = resources.standard;
                    backgroundImage.color = TMPro.TMP_DefaultControls.s_DefaultSelectableColor.$clone();
                    backgroundImage.type = UnityEngine.UI.Image.Type.Sliced;

                    var dropdown = root.AddComponent(TMPro.TMP_Dropdown);
                    dropdown.targetGraphic = backgroundImage;
                    TMPro.TMP_DefaultControls.SetDefaultColorTransitionValues(dropdown);
                    dropdown.template = template.GetComponent(UnityEngine.RectTransform);
                    dropdown.captionText = labelText;
                    dropdown.itemText = itemLabelText;

                    // Setting default Item list.
                    itemLabelText.text = "Option A";
                    dropdown.options.add(($t = new TMPro.TMP_Dropdown.OptionData.ctor(), $t.text = "Option A", $t));
                    dropdown.options.add(($t = new TMPro.TMP_Dropdown.OptionData.ctor(), $t.text = "Option B", $t));
                    dropdown.options.add(($t = new TMPro.TMP_Dropdown.OptionData.ctor(), $t.text = "Option C", $t));
                    dropdown.RefreshShownValue();

                    // Set up RectTransforms.

                    var labelRT = label.GetComponent(UnityEngine.RectTransform);
                    labelRT.anchorMin = pc.Vec2.ZERO.clone();
                    labelRT.anchorMax = pc.Vec2.ONE.clone();
                    labelRT.offsetMin = new pc.Vec2( 10, 6 );
                    labelRT.offsetMax = new pc.Vec2( -25, -7 );

                    var arrowRT = arrow.GetComponent(UnityEngine.RectTransform);
                    arrowRT.anchorMin = new pc.Vec2( 1, 0.5 );
                    arrowRT.anchorMax = new pc.Vec2( 1, 0.5 );
                    arrowRT.sizeDelta = new pc.Vec2( 20, 20 );
                    arrowRT.anchoredPosition = new pc.Vec2( -15, 0 );

                    var templateRT = template.GetComponent(UnityEngine.RectTransform);
                    templateRT.anchorMin = new pc.Vec2( 0, 0 );
                    templateRT.anchorMax = new pc.Vec2( 1, 0 );
                    templateRT.pivot = new pc.Vec2( 0.5, 1 );
                    templateRT.anchoredPosition = new pc.Vec2( 0, 2 );
                    templateRT.sizeDelta = new pc.Vec2( 0, 150 );

                    var viewportRT = viewport.GetComponent(UnityEngine.RectTransform);
                    viewportRT.anchorMin = new pc.Vec2( 0, 0 );
                    viewportRT.anchorMax = new pc.Vec2( 1, 1 );
                    viewportRT.sizeDelta = new pc.Vec2( -18, 0 );
                    viewportRT.pivot = new pc.Vec2( 0, 1 );

                    var contentRT = content.GetComponent(UnityEngine.RectTransform);
                    contentRT.anchorMin = new pc.Vec2( 0.0, 1 );
                    contentRT.anchorMax = new pc.Vec2( 1.0, 1 );
                    contentRT.pivot = new pc.Vec2( 0.5, 1 );
                    contentRT.anchoredPosition = new pc.Vec2( 0, 0 );
                    contentRT.sizeDelta = new pc.Vec2( 0, 28 );

                    var itemRT = item.GetComponent(UnityEngine.RectTransform);
                    itemRT.anchorMin = new pc.Vec2( 0, 0.5 );
                    itemRT.anchorMax = new pc.Vec2( 1, 0.5 );
                    itemRT.sizeDelta = new pc.Vec2( 0, 20 );

                    var itemBackgroundRT = itemBackground.GetComponent(UnityEngine.RectTransform);
                    itemBackgroundRT.anchorMin = pc.Vec2.ZERO.clone();
                    itemBackgroundRT.anchorMax = pc.Vec2.ONE.clone();
                    itemBackgroundRT.sizeDelta = pc.Vec2.ZERO.clone();

                    var itemCheckmarkRT = itemCheckmark.GetComponent(UnityEngine.RectTransform);
                    itemCheckmarkRT.anchorMin = new pc.Vec2( 0, 0.5 );
                    itemCheckmarkRT.anchorMax = new pc.Vec2( 0, 0.5 );
                    itemCheckmarkRT.sizeDelta = new pc.Vec2( 20, 20 );
                    itemCheckmarkRT.anchoredPosition = new pc.Vec2( 10, 0 );

                    var itemLabelRT = itemLabel.GetComponent(UnityEngine.RectTransform);
                    itemLabelRT.anchorMin = pc.Vec2.ZERO.clone();
                    itemLabelRT.anchorMax = pc.Vec2.ONE.clone();
                    itemLabelRT.offsetMin = new pc.Vec2( 20, 1 );
                    itemLabelRT.offsetMax = new pc.Vec2( -10, -2 );

                    template.SetActive(false);

                    return root;
                },
                /*TMPro.TMP_DefaultControls.CreateDropdown:static end.*/


            }
        }
    });
    /*TMPro.TMP_DefaultControls end.*/

    /*TMPro.TMP_DefaultControls+Resources start.*/
    Bridge.define("TMPro.TMP_DefaultControls.Resources", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_DefaultControls.Resources#getDefaultValue", this ); }
 return new TMPro.TMP_DefaultControls.Resources(); }
            }
        },
        fields: {
            standard: null,
            background: null,
            inputField: null,
            knob: null,
            checkmark: null,
            dropdown: null,
            mask: null
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_DefaultControls.Resources#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_DefaultControls.Resources#getHashCode", this ); }

                var h = Bridge.addHash([3570849850, this.standard, this.background, this.inputField, this.knob, this.checkmark, this.dropdown, this.mask]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.TMP_DefaultControls.Resources#equals", this ); }

                if (!Bridge.is(o, TMPro.TMP_DefaultControls.Resources)) {
                    return false;
                }
                return Bridge.equals(this.standard, o.standard) && Bridge.equals(this.background, o.background) && Bridge.equals(this.inputField, o.inputField) && Bridge.equals(this.knob, o.knob) && Bridge.equals(this.checkmark, o.checkmark) && Bridge.equals(this.dropdown, o.dropdown) && Bridge.equals(this.mask, o.mask);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.TMP_DefaultControls.Resources#$clone", this ); }

                var s = to || new TMPro.TMP_DefaultControls.Resources();
                s.standard = this.standard;
                s.background = this.background;
                s.inputField = this.inputField;
                s.knob = this.knob;
                s.checkmark = this.checkmark;
                s.dropdown = this.dropdown;
                s.mask = this.mask;
                return s;
            }
        }
    });
    /*TMPro.TMP_DefaultControls+Resources end.*/

    /*TMPro.TMP_Dropdown start.*/
    /**
     * A standard dropdown that presents a list of options when clicked, of which one can be chosen.
     *
     * @public
     * @class TMPro.TMP_Dropdown
     * @augments UnityEngine.UI.Selectable
     * @implements  UnityEngine.EventSystems.IPointerClickHandler
     * @implements  UnityEngine.EventSystems.ISubmitHandler
     * @implements  UnityEngine.EventSystems.ICancelHandler
     */
    Bridge.define("TMPro.TMP_Dropdown", {
        inherits: [UnityEngine.UI.Selectable,UnityEngine.EventSystems.IPointerClickHandler,UnityEngine.EventSystems.ISubmitHandler,UnityEngine.EventSystems.ICancelHandler],
        statics: {
            fields: {
                s_NoOptionData: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#init", this ); }

                    this.s_NoOptionData = new TMPro.TMP_Dropdown.OptionData.ctor();
                }
            },
            methods: {
                /*TMPro.TMP_Dropdown.GetOrAddComponent:static start.*/
                GetOrAddComponent: function (T, go) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#GetOrAddComponent", this ); }

                    var comp = go.GetComponent(T);
                    if (!comp) {
                        comp = go.AddComponent(T);
                    }

                    return comp;
                },
                /*TMPro.TMP_Dropdown.GetOrAddComponent:static end.*/


            }
        },
        fields: {
            m_Template: null,
            m_CaptionText: null,
            m_CaptionImage: null,
            m_Placeholder: null,
            m_ItemText: null,
            m_ItemImage: null,
            m_Value: 0,
            m_Options: null,
            m_OnValueChanged: null,
            m_AlphaFadeSpeed: 0,
            m_Dropdown: null,
            m_Blocker: null,
            m_Items: null,
            m_AlphaTweenRunner: null,
            validTemplate: false,
            m_Coroutine: null
        },
        props: {
            /**
             * The Rect Transform of the template for the dropdown list.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Dropdown
             * @function template
             * @type UnityEngine.RectTransform
             */
            template: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#template#get", this ); }

                    return this.m_Template;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#template#set", this ); }

                    this.m_Template = value;
                    this.RefreshShownValue();
                }
            },
            /**
             * The Text component to hold the text of the currently selected option.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Dropdown
             * @function captionText
             * @type TMPro.TMP_Text
             */
            captionText: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#captionText#get", this ); }

                    return this.m_CaptionText;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#captionText#set", this ); }

                    this.m_CaptionText = value;
                    this.RefreshShownValue();
                }
            },
            /**
             * The Image component to hold the image of the currently selected option.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Dropdown
             * @function captionImage
             * @type UnityEngine.UI.Image
             */
            captionImage: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#captionImage#get", this ); }

                    return this.m_CaptionImage;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#captionImage#set", this ); }

                    this.m_CaptionImage = value;
                    this.RefreshShownValue();
                }
            },
            /**
             * The placeholder Graphic component. Shown when no option is selected.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Dropdown
             * @function placeholder
             * @type UnityEngine.UI.Graphic
             */
            placeholder: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#placeholder#get", this ); }

                    return this.m_Placeholder;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#placeholder#set", this ); }

                    this.m_Placeholder = value;
                    this.RefreshShownValue();
                }
            },
            /**
             * The Text component to hold the text of the item.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Dropdown
             * @function itemText
             * @type TMPro.TMP_Text
             */
            itemText: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#itemText#get", this ); }

                    return this.m_ItemText;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#itemText#set", this ); }

                    this.m_ItemText = value;
                    this.RefreshShownValue();
                }
            },
            /**
             * The Image component to hold the image of the item
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Dropdown
             * @function itemImage
             * @type UnityEngine.UI.Image
             */
            itemImage: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#itemImage#get", this ); }

                    return this.m_ItemImage;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#itemImage#set", this ); }

                    this.m_ItemImage = value;
                    this.RefreshShownValue();
                }
            },
            
            options: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#options#get", this ); }

                    return this.m_Options.options;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#options#set", this ); }

                    this.m_Options.options = value;
                    this.RefreshShownValue();
                }
            },
            
            onValueChanged: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#onValueChanged#get", this ); }

                    return this.m_OnValueChanged;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#onValueChanged#set", this ); }

                    this.m_OnValueChanged = value;
                }
            },
            /**
             * The time interval at which a drop down will appear and disappear
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Dropdown
             * @function alphaFadeSpeed
             * @type number
             */
            alphaFadeSpeed: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#alphaFadeSpeed#get", this ); }

                    return this.m_AlphaFadeSpeed;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#alphaFadeSpeed#set", this ); }

                    this.m_AlphaFadeSpeed = value;
                }
            },
            
            value: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#value#get", this ); }

                    return this.m_Value;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#value#set", this ); }

                    this.SetValue(value);
                }
            },
            IsExpanded: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#IsExpanded#get", this ); }

                    return UnityEngine.GameObject.op_Inequality(this.m_Dropdown, null);
                }
            }
        },
        alias: [
            "OnPointerClick", "UnityEngine$EventSystems$IPointerClickHandler$OnPointerClick",
            "OnSubmit", "UnityEngine$EventSystems$ISubmitHandler$OnSubmit",
            "OnCancel", "UnityEngine$EventSystems$ICancelHandler$OnCancel"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#init", this ); }

                this.m_Options = new TMPro.TMP_Dropdown.OptionDataList();
                this.m_OnValueChanged = new TMPro.TMP_Dropdown.DropdownEvent();
                this.m_AlphaFadeSpeed = 0.15;
                this.m_Items = new (System.Collections.Generic.List$1(TMPro.TMP_Dropdown.DropdownItem)).ctor();
                this.validTemplate = false;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#ctor", this ); }

                this.$initialize();
                UnityEngine.UI.Selectable.ctor.call(this);
            }
        },
        methods: {
            /*TMPro.TMP_Dropdown.SetValueWithoutNotify start.*/
            /**
             * Set index number of the current selection in the Dropdown without invoking onValueChanged callback.
             *
             * @instance
             * @public
             * @this TMPro.TMP_Dropdown
             * @memberof TMPro.TMP_Dropdown
             * @param   {number}    input    The new index for the current selection.
             * @return  {void}
             */
            SetValueWithoutNotify: function (input) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#SetValueWithoutNotify", this ); }

                this.SetValue(input, false);
            },
            /*TMPro.TMP_Dropdown.SetValueWithoutNotify end.*/

            /*TMPro.TMP_Dropdown.SetValue start.*/
            SetValue: function (value, sendCallback) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#SetValue", this ); }

                if (sendCallback === void 0) { sendCallback = true; }
                if (UnityEngine.Application.isPlaying && (value === this.m_Value || this.options.Count === 0)) {
                    return;
                }

                this.m_Value = Math.max(UnityEngine.Object.op_Implicit(this.m_Placeholder) ? -1 : 0, Math.min(value, this.options.Count - 1));
                this.RefreshShownValue();

                if (sendCallback) {
                    // Notify all listeners
                    this.m_OnValueChanged.Invoke(this.m_Value);
                }
            },
            /*TMPro.TMP_Dropdown.SetValue end.*/

            /*TMPro.TMP_Dropdown.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#Awake", this ); }


                if (UnityEngine.Object.op_Implicit(this.m_CaptionImage)) {
                    this.m_CaptionImage.enabled = this.m_CaptionImage.sprite != null;
                }

                if (UnityEngine.Object.op_Implicit(this.m_Template)) {
                    this.m_Template.gameObject.SetActive(false);
                }
            },
            /*TMPro.TMP_Dropdown.Awake end.*/

            /*TMPro.TMP_Dropdown.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#Start", this ); }

                this.m_AlphaTweenRunner = new (TMPro.TweenRunner$1(TMPro.FloatTween))();
                this.m_AlphaTweenRunner.Init(this);
                UnityEngine.UI.Selectable.prototype.Start.call(this);

                this.RefreshShownValue();
            },
            /*TMPro.TMP_Dropdown.Start end.*/

            /*TMPro.TMP_Dropdown.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#OnDisable", this ); }

                //Destroy dropdown and blocker in case user deactivates the dropdown when they click an option (case 935649)
                this.ImmediateDestroyDropdownList();

                if (UnityEngine.GameObject.op_Inequality(this.m_Blocker, null)) {
                    this.DestroyBlocker(this.m_Blocker);
                }

                this.m_Blocker = null;

                UnityEngine.UI.Selectable.prototype.OnDisable.call(this);
            },
            /*TMPro.TMP_Dropdown.OnDisable end.*/

            /*TMPro.TMP_Dropdown.RefreshShownValue start.*/
            /**
             * Refreshes the text and image (if available) of the currently selected option.
             *
             * @instance
             * @public
             * @this TMPro.TMP_Dropdown
             * @memberof TMPro.TMP_Dropdown
             * @return  {void}
             */
            RefreshShownValue: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#RefreshShownValue", this ); }

                var data = TMPro.TMP_Dropdown.s_NoOptionData;

                if (this.options.Count > 0 && this.m_Value >= 0) {
                    data = this.options.getItem(Math.max(0, Math.min(this.m_Value, this.options.Count - 1)));
                }

                if (UnityEngine.Object.op_Implicit(this.m_CaptionText)) {
                    if (data != null && data.text != null) {
                        this.m_CaptionText.text = data.text;
                    } else {
                        this.m_CaptionText.text = "";
                    }
                }

                if (UnityEngine.Object.op_Implicit(this.m_CaptionImage)) {
                    if (data != null) {
                        this.m_CaptionImage.sprite = data.image;
                    } else {
                        this.m_CaptionImage.sprite = null;
                    }

                    this.m_CaptionImage.enabled = this.m_CaptionImage.sprite != null;
                }

                if (UnityEngine.Object.op_Implicit(this.m_Placeholder)) {
                    this.m_Placeholder.enabled = this.options.Count === 0 || this.m_Value === -1;
                }
            },
            /*TMPro.TMP_Dropdown.RefreshShownValue end.*/

            /*TMPro.TMP_Dropdown.AddOptions$1 start.*/
            
            AddOptions$1: function (options) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#AddOptions$1", this ); }

                this.options.AddRange(options);
                this.RefreshShownValue();
            },
            /*TMPro.TMP_Dropdown.AddOptions$1 end.*/

            /*TMPro.TMP_Dropdown.AddOptions start.*/
            
            AddOptions: function (options) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#AddOptions", this ); }

                for (var i = 0; i < options.Count; i++) {
                    this.options.add(new TMPro.TMP_Dropdown.OptionData.$ctor1(options.getItem(i)));
                }

                this.RefreshShownValue();
            },
            /*TMPro.TMP_Dropdown.AddOptions end.*/

            /*TMPro.TMP_Dropdown.AddOptions$2 start.*/
            
            AddOptions$2: function (options) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#AddOptions$2", this ); }

                for (var i = 0; i < options.Count; i++) {
                    this.options.add(new TMPro.TMP_Dropdown.OptionData.$ctor3(options.getItem(i)));
                }

                this.RefreshShownValue();
            },
            /*TMPro.TMP_Dropdown.AddOptions$2 end.*/

            /*TMPro.TMP_Dropdown.ClearOptions start.*/
            /**
             * Clear the list of options in the Dropdown.
             *
             * @instance
             * @public
             * @this TMPro.TMP_Dropdown
             * @memberof TMPro.TMP_Dropdown
             * @return  {void}
             */
            ClearOptions: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#ClearOptions", this ); }

                this.options.clear();
                this.m_Value = UnityEngine.Object.op_Implicit(this.m_Placeholder) ? -1 : 0;
                this.RefreshShownValue();
            },
            /*TMPro.TMP_Dropdown.ClearOptions end.*/

            /*TMPro.TMP_Dropdown.SetupTemplate start.*/
            SetupTemplate: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#SetupTemplate", this ); }

                this.validTemplate = false;

                if (!UnityEngine.Object.op_Implicit(this.m_Template)) {
                    UnityEngine.Debug.LogError$2("The dropdown template is not assigned. The template needs to be assigned and must have a child GameObject with a Toggle component serving as the item.", this);
                    return;
                }

                var templateGo = this.m_Template.gameObject;
                templateGo.SetActive(true);
                var itemToggle = this.m_Template.GetComponentInChildren(UnityEngine.UI.Toggle);

                this.validTemplate = true;
                if (!UnityEngine.Object.op_Implicit(itemToggle) || UnityEngine.Component.op_Equality(itemToggle.transform, this.template)) {
                    this.validTemplate = false;
                    UnityEngine.Debug.LogError$2("The dropdown template is not valid. The template must have a child GameObject with a Toggle component serving as the item.", this.template);
                } else if (!(Bridge.is(itemToggle.transform.parent, UnityEngine.RectTransform))) {
                    this.validTemplate = false;
                    UnityEngine.Debug.LogError$2("The dropdown template is not valid. The child GameObject with a Toggle component (the item) must have a RectTransform on its parent.", this.template);
                } else if (UnityEngine.MonoBehaviour.op_Inequality(this.itemText, null) && !this.itemText.transform$1.IsChildOf(itemToggle.transform)) {
                    this.validTemplate = false;
                    UnityEngine.Debug.LogError$2("The dropdown template is not valid. The Item Text must be on the item GameObject or children of it.", this.template);
                } else if (UnityEngine.MonoBehaviour.op_Inequality(this.itemImage, null) && !this.itemImage.transform.IsChildOf(itemToggle.transform)) {
                    this.validTemplate = false;
                    UnityEngine.Debug.LogError$2("The dropdown template is not valid. The Item Image must be on the item GameObject or children of it.", this.template);
                }

                if (!this.validTemplate) {
                    templateGo.SetActive(false);
                    return;
                }

                var item = itemToggle.gameObject.AddComponent(TMPro.TMP_Dropdown.DropdownItem);
                item.text = this.m_ItemText;
                item.image = this.m_ItemImage;
                item.toggle = itemToggle;
                item.rectTransform = Bridge.cast(itemToggle.transform, UnityEngine.RectTransform);

                // Find the Canvas that this dropdown is a part of
                var parentCanvas = null;
                var parentTransform = this.m_Template.parent;
                while (UnityEngine.Component.op_Inequality(parentTransform, null)) {
                    parentCanvas = parentTransform.GetComponent(UnityEngine.Canvas);
                    if (UnityEngine.Component.op_Inequality(parentCanvas, null)) {
                        break;
                    }

                    parentTransform = parentTransform.parent;
                }

                var popupCanvas = TMPro.TMP_Dropdown.GetOrAddComponent(UnityEngine.Canvas, templateGo);
                popupCanvas.overrideSorting = true;
                popupCanvas.sortingOrder = 30000;

                // If we have a parent canvas, apply the same raycasters as the parent for consistency.
                if (UnityEngine.Component.op_Inequality(parentCanvas, null)) {
                    var components = parentCanvas.GetComponents(UnityEngine.EventSystems.BaseRaycaster);
                    for (var i = 0; i < components.length; i++) {
                        var raycasterType = Bridge.getType(components[i]);
                        if (UnityEngine.Component.op_Equality(templateGo.GetComponent$1(raycasterType), null)) {
                            templateGo.AddComponent$1(raycasterType);
                        }
                    }
                } else {
                    TMPro.TMP_Dropdown.GetOrAddComponent(UnityEngine.UI.GraphicRaycaster, templateGo);
                }

                TMPro.TMP_Dropdown.GetOrAddComponent(UnityEngine.CanvasGroup, templateGo);
                templateGo.SetActive(false);

                this.validTemplate = true;
            },
            /*TMPro.TMP_Dropdown.SetupTemplate end.*/

            /*TMPro.TMP_Dropdown.OnPointerClick start.*/
            /**
             * Handling for when the dropdown is initially 'clicked'. Typically shows the dropdown
             *
             * @instance
             * @public
             * @this TMPro.TMP_Dropdown
             * @memberof TMPro.TMP_Dropdown
             * @param   {UnityEngine.EventSystems.PointerEventData}    eventData    The associated event data.
             * @return  {void}
             */
            OnPointerClick: function (eventData) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#OnPointerClick", this ); }

                this.Show();
            },
            /*TMPro.TMP_Dropdown.OnPointerClick end.*/

            /*TMPro.TMP_Dropdown.OnSubmit start.*/
            /**
             * Handling for when the dropdown is selected and a submit event is processed. Typically shows the dropdown
             *
             * @instance
             * @public
             * @this TMPro.TMP_Dropdown
             * @memberof TMPro.TMP_Dropdown
             * @param   {UnityEngine.EventSystems.BaseEventData}    eventData    The associated event data.
             * @return  {void}
             */
            OnSubmit: function (eventData) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#OnSubmit", this ); }

                this.Show();
            },
            /*TMPro.TMP_Dropdown.OnSubmit end.*/

            /*TMPro.TMP_Dropdown.OnCancel start.*/
            /**
             * This will hide the dropdown list.
             *
             * @instance
             * @public
             * @this TMPro.TMP_Dropdown
             * @memberof TMPro.TMP_Dropdown
             * @param   {UnityEngine.EventSystems.BaseEventData}    eventData    The associated event data.
             * @return  {void}
             */
            OnCancel: function (eventData) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#OnCancel", this ); }

                this.Hide();
            },
            /*TMPro.TMP_Dropdown.OnCancel end.*/

            /*TMPro.TMP_Dropdown.Show start.*/
            /**
             * Show the dropdown.
             Plan for dropdown scrolling to ensure dropdown is contained within screen.
             We assume the Canvas is the screen that the dropdown must be kept inside.
             This is always valid for screen space canvas modes.
             For world space canvases we don't know how it's used, but it could be e.g. for an in-game monitor.
             We consider it a fair constraint that the canvas must be big enough to contain dropdowns.
             *
             * @instance
             * @public
             * @this TMPro.TMP_Dropdown
             * @memberof TMPro.TMP_Dropdown
             * @return  {void}
             */
            Show: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#Show", this ); }

                if (this.m_Coroutine != null) {
                    this.StopCoroutine$2(this.m_Coroutine);
                    this.ImmediateDestroyDropdownList();
                }

                if (!this.IsActive() || !this.IsInteractable() || UnityEngine.GameObject.op_Inequality(this.m_Dropdown, null)) {
                    return;
                }

                // Get root Canvas.
                var list = TMPro.TMP_ListPool$1(UnityEngine.Canvas).Get();
                this.gameObject.GetComponentsInParent$1(UnityEngine.Canvas, false, list);
                if (list.Count === 0) {
                    return;
                }

                var rootCanvas = list.getItem(list.Count - 1);
                for (var i = 0; i < list.Count; i++) {
                    if (list.getItem(i).isRootCanvas) {
                        rootCanvas = list.getItem(i);
                        break;
                    }
                }

                TMPro.TMP_ListPool$1(UnityEngine.Canvas).Release(list);

                if (!this.validTemplate) {
                    this.SetupTemplate();
                    if (!this.validTemplate) {
                        return;
                    }
                }

                this.m_Template.gameObject.SetActive(true);

                // popupCanvas used to assume the root canvas had the default sorting Layer, next line fixes (case 958281 - [UI] Dropdown list does not copy the parent canvas layer when the panel is opened)
                this.m_Template.GetComponent(UnityEngine.Canvas).sortingLayerID = rootCanvas.sortingLayerID;

                // Instantiate the drop-down template
                this.m_Dropdown = this.CreateDropdownList(this.m_Template.gameObject);
                this.m_Dropdown.name = "Dropdown List";
                this.m_Dropdown.SetActive(true);

                // Make drop-down RectTransform have same values as original.
                var dropdownRectTransform = Bridge.as(this.m_Dropdown.transform, UnityEngine.RectTransform);
                dropdownRectTransform.SetParent(this.m_Template.transform.parent, false);

                // Instantiate the drop-down list items

                // Find the dropdown item and disable it.
                var itemTemplate = this.m_Dropdown.GetComponentInChildren(TMPro.TMP_Dropdown.DropdownItem);

                var content = itemTemplate.rectTransform.parent.gameObject;
                var contentRectTransform = Bridge.as(content.transform, UnityEngine.RectTransform);
                itemTemplate.rectTransform.gameObject.SetActive(true);

                // Get the rects of the dropdown and item
                var dropdownContentRect = contentRectTransform.rect.$clone();
                var itemTemplateRect = itemTemplate.rectTransform.rect.$clone();

                // Calculate the visual offset between the item's edges and the background's edges
                var offsetMin = itemTemplateRect.min.$clone().sub( dropdownContentRect.min ).add( UnityEngine.Vector2.FromVector3(itemTemplate.rectTransform.localPosition) );
                var offsetMax = itemTemplateRect.max.$clone().sub( dropdownContentRect.max ).add( UnityEngine.Vector2.FromVector3(itemTemplate.rectTransform.localPosition) );
                var itemSize = itemTemplateRect.size.$clone();

                this.m_Items.clear();

                var prev = null;
                for (var i1 = 0; i1 < this.options.Count; ++i1) {
                    var data = this.options.getItem(i1);
                    var item = { v : this.AddItem(data, this.value === i1, itemTemplate, this.m_Items) };
                    if (UnityEngine.MonoBehaviour.op_Equality(item.v, null)) {
                        continue;
                    }

                    // Automatically set up a toggle state change listener
                    item.v.toggle.isOn = this.value === i1;
                    item.v.toggle.onValueChanged.AddListener((function ($me, item) {
                        return Bridge.fn.bind($me, function (x) {
                            this.OnSelectItem(item.v.toggle);
                        });
                    })(this, item));

                    // Select current option
                    if (item.v.toggle.isOn) {
                        item.v.toggle.Select();
                    }

                    // Automatically set up explicit navigation
                    if (UnityEngine.MonoBehaviour.op_Inequality(prev, null)) {
                        var prevNav = prev.navigation.$clone();
                        var toggleNav = item.v.toggle.navigation.$clone();
                        prevNav.mode = UnityEngine.UI.Navigation.Mode.Explicit;
                        toggleNav.mode = UnityEngine.UI.Navigation.Mode.Explicit;

                        prevNav.selectOnDown = item.v.toggle;
                        prevNav.selectOnRight = item.v.toggle;
                        toggleNav.selectOnLeft = prev;
                        toggleNav.selectOnUp = prev;

                        prev.navigation = prevNav.$clone();
                        item.v.toggle.navigation = toggleNav.$clone();
                    }

                    prev = item.v.toggle;
                }

                // Reposition all items now that all of them have been added
                var sizeDelta = contentRectTransform.sizeDelta.$clone();
                sizeDelta.y = itemSize.y * this.m_Items.Count + offsetMin.y - offsetMax.y;
                contentRectTransform.sizeDelta = sizeDelta.$clone();

                var extraSpace = dropdownRectTransform.rect.height - contentRectTransform.rect.height;
                if (extraSpace > 0) {
                    dropdownRectTransform.sizeDelta = new pc.Vec2( dropdownRectTransform.sizeDelta.x, dropdownRectTransform.sizeDelta.y - extraSpace );
                }

                // Invert anchoring and position if dropdown is partially or fully outside of canvas rect.
                // Typically this will have the effect of placing the dropdown above the button instead of below,
                // but it works as inversion regardless of initial setup.
                var corners = System.Array.init(4, function (){
                    return new UnityEngine.Vector3();
                }, UnityEngine.Vector3);
                dropdownRectTransform.GetWorldCorners(corners);

                var rootCanvasRectTransform = Bridge.as(rootCanvas.transform, UnityEngine.RectTransform);
                var rootCanvasRect = rootCanvasRectTransform.rect.$clone();
                for (var axis = 0; axis < 2; axis++) {
                    var outside = false;
                    for (var i2 = 0; i2 < 4; i2++) {
                        var corner = rootCanvasRectTransform.InverseTransformPoint(corners[i2]);
                        if (corner.getitem(axis) < rootCanvasRect.min.getitem(axis) && !UnityEngine.Mathf.Approximately(corner.getitem(axis), rootCanvasRect.min.getitem(axis)) || corner.getitem(axis) > rootCanvasRect.max.getitem(axis) && !UnityEngine.Mathf.Approximately(corner.getitem(axis), rootCanvasRect.max.getitem(axis))) {
                            outside = true;
                            break;
                        }
                    }

                    if (outside) {
                        UnityEngine.RectTransformUtility.FlipLayoutOnAxis(dropdownRectTransform, axis, false, false);
                    }
                }

                for (var i3 = 0; i3 < this.m_Items.Count; i3++) {
                    var itemRect = this.m_Items.getItem(i3).rectTransform;
                    itemRect.anchorMin = new pc.Vec2( itemRect.anchorMin.x, 0 );
                    itemRect.anchorMax = new pc.Vec2( itemRect.anchorMax.x, 0 );
                    itemRect.anchoredPosition = new pc.Vec2( itemRect.anchoredPosition.x, offsetMin.y + itemSize.y * (this.m_Items.Count - 1 - i3) + itemSize.y * itemRect.pivot.y );
                    itemRect.sizeDelta = new pc.Vec2( itemRect.sizeDelta.x, itemSize.y );
                }

                // Fade in the popup
                this.AlphaFadeList$1(this.m_AlphaFadeSpeed, 0.0, 1.0);

                // Make drop-down template and item template inactive
                this.m_Template.gameObject.SetActive(false);
                itemTemplate.gameObject.SetActive(false);

                this.m_Blocker = this.CreateBlocker(rootCanvas);
            },
            /*TMPro.TMP_Dropdown.Show end.*/

            /*TMPro.TMP_Dropdown.CreateBlocker start.*/
            /**
             * Create a blocker that blocks clicks to other controls while the dropdown list is open.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Dropdown
             * @memberof TMPro.TMP_Dropdown
             * @param   {UnityEngine.Canvas}        rootCanvas    The root canvas the dropdown is under.
             * @return  {UnityEngine.GameObject}                  The created blocker object
             */
            CreateBlocker: function (rootCanvas) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#CreateBlocker", this ); }

                // Create blocker GameObject.
                var blocker = new UnityEngine.GameObject.$ctor2("Blocker");

                // Setup blocker RectTransform to cover entire root canvas area.
                var blockerRect = blocker.AddComponent(UnityEngine.RectTransform);
                blockerRect.SetParent(rootCanvas.transform, false);
                blockerRect.anchorMin = UnityEngine.Vector2.FromVector3(pc.Vec3.ZERO.clone());
                blockerRect.anchorMax = UnityEngine.Vector2.FromVector3(new pc.Vec3( 1, 1, 1 ));
                blockerRect.sizeDelta = pc.Vec2.ZERO.clone();

                // Make blocker be in separate canvas in same layer as dropdown and in layer just below it.
                var blockerCanvas = blocker.AddComponent(UnityEngine.Canvas);
                blockerCanvas.overrideSorting = true;
                var dropdownCanvas = this.m_Dropdown.GetComponent(UnityEngine.Canvas);
                blockerCanvas.sortingLayerID = dropdownCanvas.sortingLayerID;
                blockerCanvas.sortingOrder = dropdownCanvas.sortingOrder - 1;

                // Find the Canvas that this dropdown is a part of
                var parentCanvas = null;
                var parentTransform = this.m_Template.parent;
                while (UnityEngine.Component.op_Inequality(parentTransform, null)) {
                    parentCanvas = parentTransform.GetComponent(UnityEngine.Canvas);
                    if (UnityEngine.Component.op_Inequality(parentCanvas, null)) {
                        break;
                    }

                    parentTransform = parentTransform.parent;
                }

                // If we have a parent canvas, apply the same raycasters as the parent for consistency.
                if (UnityEngine.Component.op_Inequality(parentCanvas, null)) {
                    var components = parentCanvas.GetComponents(UnityEngine.EventSystems.BaseRaycaster);
                    for (var i = 0; i < components.length; i++) {
                        var raycasterType = Bridge.getType(components[i]);
                        if (UnityEngine.Component.op_Equality(blocker.GetComponent$1(raycasterType), null)) {
                            blocker.AddComponent$1(raycasterType);
                        }
                    }
                } else {
                    // Add raycaster since it's needed to block.
                    TMPro.TMP_Dropdown.GetOrAddComponent(UnityEngine.UI.GraphicRaycaster, blocker);
                }


                // Add image since it's needed to block, but make it clear.
                var blockerImage = blocker.AddComponent(UnityEngine.UI.Image);
                blockerImage.color = new pc.Color( 0, 0, 0, 0 );

                // Add button since it's needed to block, and to close the dropdown when blocking area is clicked.
                var blockerButton = blocker.AddComponent(UnityEngine.UI.Button);
                blockerButton.onClick.AddListener(Bridge.fn.cacheBind(this, this.Hide));

                return blocker;
            },
            /*TMPro.TMP_Dropdown.CreateBlocker end.*/

            /*TMPro.TMP_Dropdown.DestroyBlocker start.*/
            /**
             * Convenience method to explicitly destroy the previously generated blocker object
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Dropdown
             * @memberof TMPro.TMP_Dropdown
             * @param   {UnityEngine.GameObject}    blocker    The blocker object to destroy.
             * @return  {void}
             */
            DestroyBlocker: function (blocker) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#DestroyBlocker", this ); }

                UnityEngine.MonoBehaviour.Destroy(blocker);
            },
            /*TMPro.TMP_Dropdown.DestroyBlocker end.*/

            /*TMPro.TMP_Dropdown.CreateDropdownList start.*/
            /**
             * Create the dropdown list to be shown when the dropdown is clicked. The dropdown list should correspond to the provided template GameObject, equivalent to instantiating a copy of it.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Dropdown
             * @memberof TMPro.TMP_Dropdown
             * @param   {UnityEngine.GameObject}    template    The template to create the dropdown list from.
             * @return  {UnityEngine.GameObject}                The created drop down list gameobject.
             */
            CreateDropdownList: function (template) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#CreateDropdownList", this ); }

                return UnityEngine.Object.Instantiate(UnityEngine.GameObject, template);
            },
            /*TMPro.TMP_Dropdown.CreateDropdownList end.*/

            /*TMPro.TMP_Dropdown.DestroyDropdownList start.*/
            /**
             * Convenience method to explicitly destroy the previously generated dropdown list
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Dropdown
             * @memberof TMPro.TMP_Dropdown
             * @param   {UnityEngine.GameObject}    dropdownList    The dropdown list GameObject to destroy
             * @return  {void}
             */
            DestroyDropdownList: function (dropdownList) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#DestroyDropdownList", this ); }

                UnityEngine.MonoBehaviour.Destroy(dropdownList);
            },
            /*TMPro.TMP_Dropdown.DestroyDropdownList end.*/

            /*TMPro.TMP_Dropdown.CreateItem start.*/
            /**
             * Create a dropdown item based upon the item template.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Dropdown
             * @memberof TMPro.TMP_Dropdown
             * @param   {TMPro.TMP_Dropdown.DropdownItem}    itemTemplate    e template to create the option item from.
             * @return  {TMPro.TMP_Dropdown.DropdownItem}                    The created dropdown item component
             */
            CreateItem: function (itemTemplate) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#CreateItem", this ); }

                return UnityEngine.Object.Instantiate(TMPro.TMP_Dropdown.DropdownItem, itemTemplate);
            },
            /*TMPro.TMP_Dropdown.CreateItem end.*/

            /*TMPro.TMP_Dropdown.DestroyItem start.*/
            /**
             * Convenience method to explicitly destroy the previously generated Items.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_Dropdown
             * @memberof TMPro.TMP_Dropdown
             * @param   {TMPro.TMP_Dropdown.DropdownItem}    item    The Item to destroy.
             * @return  {void}
             */
            DestroyItem: function (item) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#DestroyItem", this ); }
 },
            /*TMPro.TMP_Dropdown.DestroyItem end.*/

            /*TMPro.TMP_Dropdown.AddItem start.*/
            AddItem: function (data, selected, itemTemplate, items) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#AddItem", this ); }

                // Add a new item to the dropdown.
                var item = this.CreateItem(itemTemplate);
                item.rectTransform.SetParent(itemTemplate.rectTransform.parent, false);

                item.gameObject.SetActive(true);
                item.gameObject.name = "Item " + items.Count + ((data.text != null ? ": " + (data.text || "") : "") || "");

                if (UnityEngine.MonoBehaviour.op_Inequality(item.toggle, null)) {
                    item.toggle.isOn = false;
                }

                // Set the item's data
                if (UnityEngine.Object.op_Implicit(item.text)) {
                    item.text.text = data.text;
                }

                if (UnityEngine.Object.op_Implicit(item.image)) {
                    item.image.sprite = data.image;
                    item.image.enabled = item.image.sprite != null;
                }

                items.add(item);
                return item;
            },
            /*TMPro.TMP_Dropdown.AddItem end.*/

            /*TMPro.TMP_Dropdown.AlphaFadeList start.*/
            AlphaFadeList: function (duration, alpha) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#AlphaFadeList", this ); }

                var group = this.m_Dropdown.GetComponent(UnityEngine.CanvasGroup);
                this.AlphaFadeList$1(duration, group.alpha, alpha);
            },
            /*TMPro.TMP_Dropdown.AlphaFadeList end.*/

            /*TMPro.TMP_Dropdown.AlphaFadeList$1 start.*/
            AlphaFadeList$1: function (duration, start, end) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#AlphaFadeList$1", this ); }

                var $t;
                if (end === start) {
                    return;
                }

                var tween = ($t = new TMPro.FloatTween(), $t.duration = duration, $t.startValue = start, $t.targetValue = end, $t);
                tween.AddOnChangedCallback(Bridge.fn.cacheBind(this, this.SetAlpha));
                tween.ignoreTimeScale = true;
                this.m_AlphaTweenRunner.StartTween(tween.$clone());
            },
            /*TMPro.TMP_Dropdown.AlphaFadeList$1 end.*/

            /*TMPro.TMP_Dropdown.SetAlpha start.*/
            SetAlpha: function (alpha) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#SetAlpha", this ); }

                if (!UnityEngine.Object.op_Implicit(this.m_Dropdown)) {
                    return;
                }

                var group = this.m_Dropdown.GetComponent(UnityEngine.CanvasGroup);
                group.alpha = alpha;
            },
            /*TMPro.TMP_Dropdown.SetAlpha end.*/

            /*TMPro.TMP_Dropdown.Hide start.*/
            /**
             * Hide the dropdown list. I.e. close it.
             *
             * @instance
             * @public
             * @this TMPro.TMP_Dropdown
             * @memberof TMPro.TMP_Dropdown
             * @return  {void}
             */
            Hide: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#Hide", this ); }

                if (this.m_Coroutine == null) {
                    if (UnityEngine.GameObject.op_Inequality(this.m_Dropdown, null)) {
                        this.AlphaFadeList(this.m_AlphaFadeSpeed, 0.0);

                        // User could have disabled the dropdown during the OnValueChanged call.
                        if (this.IsActive()) {
                            this.m_Coroutine = this.StartCoroutine$1(this.DelayedDestroyDropdownList(this.m_AlphaFadeSpeed));
                        }
                    }

                    if (UnityEngine.GameObject.op_Inequality(this.m_Blocker, null)) {
                        this.DestroyBlocker(this.m_Blocker);
                    }

                    this.m_Blocker = null;
                    this.Select();
                }
            },
            /*TMPro.TMP_Dropdown.Hide end.*/

            /*TMPro.TMP_Dropdown.DelayedDestroyDropdownList start.*/
            DelayedDestroyDropdownList: function (delay) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#DelayedDestroyDropdownList", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = new UnityEngine.WaitForSecondsRealtime(delay);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    this.ImmediateDestroyDropdownList();

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*TMPro.TMP_Dropdown.DelayedDestroyDropdownList end.*/

            /*TMPro.TMP_Dropdown.ImmediateDestroyDropdownList start.*/
            ImmediateDestroyDropdownList: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#ImmediateDestroyDropdownList", this ); }

                for (var i = 0; i < this.m_Items.Count; i++) {
                    if (UnityEngine.MonoBehaviour.op_Inequality(this.m_Items.getItem(i), null)) {
                        this.DestroyItem(this.m_Items.getItem(i));
                    }
                }

                this.m_Items.clear();

                if (UnityEngine.GameObject.op_Inequality(this.m_Dropdown, null)) {
                    this.DestroyDropdownList(this.m_Dropdown);
                }

                if (this.m_AlphaTweenRunner != null) {
                    this.m_AlphaTweenRunner.StopTween();
                }

                this.m_Dropdown = null;
                this.m_Coroutine = null;
            },
            /*TMPro.TMP_Dropdown.ImmediateDestroyDropdownList end.*/

            /*TMPro.TMP_Dropdown.OnSelectItem start.*/
            OnSelectItem: function (toggle) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown#OnSelectItem", this ); }

                if (!toggle.isOn) {
                    toggle.isOn = true;
                }

                var selectedIndex = -1;
                var tr = toggle.transform;
                var parent = tr.parent;
                for (var i = 0; i < parent.childCount; i++) {
                    if (UnityEngine.Component.op_Equality(parent.GetChild(i), tr)) {
                        // Subtract one to account for template child.
                        selectedIndex = i - 1;
                        break;
                    }
                }

                if (selectedIndex < 0) {
                    return;
                }

                this.value = selectedIndex;
                this.Hide();
            },
            /*TMPro.TMP_Dropdown.OnSelectItem end.*/


        },
        overloads: {
            "AddOptions(List<OptionData>)": "AddOptions$1",
            "AddOptions(List<Sprite>)": "AddOptions$2",
            "AlphaFadeList(float, float, float)": "AlphaFadeList$1"
        }
    });
    /*TMPro.TMP_Dropdown end.*/

    /*TMPro.TMP_Dropdown+DropdownEvent start.*/
    /**
     * UnityEvent callback for when a dropdown current option is changed.
     *
     * @public
     * @class TMPro.TMP_Dropdown.DropdownEvent
     * @augments UnityEngine.Events.UnityEvent$1
     */
    Bridge.define("TMPro.TMP_Dropdown.DropdownEvent", {
        inherits: [UnityEngine.Events.UnityEvent$1(System.Int32)],
        $kind: 1002
    });
    /*TMPro.TMP_Dropdown+DropdownEvent end.*/

    /*TMPro.TMP_Dropdown+DropdownItem start.*/
    Bridge.define("TMPro.TMP_Dropdown.DropdownItem", {
        inherits: [UnityEngine.MonoBehaviour,UnityEngine.EventSystems.IPointerEnterHandler,UnityEngine.EventSystems.ICancelHandler],
        $kind: 1002,
        fields: {
            m_Text: null,
            m_Image: null,
            m_RectTransform: null,
            m_Toggle: null
        },
        props: {
            text: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown.DropdownItem#text#get", this ); }

                    return this.m_Text;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown.DropdownItem#text#set", this ); }

                    this.m_Text = value;
                }
            },
            image: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown.DropdownItem#image#get", this ); }

                    return this.m_Image;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown.DropdownItem#image#set", this ); }

                    this.m_Image = value;
                }
            },
            rectTransform: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown.DropdownItem#rectTransform#get", this ); }

                    return this.m_RectTransform;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown.DropdownItem#rectTransform#set", this ); }

                    this.m_RectTransform = value;
                }
            },
            toggle: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown.DropdownItem#toggle#get", this ); }

                    return this.m_Toggle;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown.DropdownItem#toggle#set", this ); }

                    this.m_Toggle = value;
                }
            }
        },
        alias: [
            "OnPointerEnter", "UnityEngine$EventSystems$IPointerEnterHandler$OnPointerEnter",
            "OnCancel", "UnityEngine$EventSystems$ICancelHandler$OnCancel"
        ],
        methods: {
            /*TMPro.TMP_Dropdown+DropdownItem.OnPointerEnter start.*/
            OnPointerEnter: function (eventData) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown.DropdownItem#OnPointerEnter", this ); }

                UnityEngine.EventSystems.EventSystem.current.SetSelectedGameObject(this.gameObject);
            },
            /*TMPro.TMP_Dropdown+DropdownItem.OnPointerEnter end.*/

            /*TMPro.TMP_Dropdown+DropdownItem.OnCancel start.*/
            OnCancel: function (eventData) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown.DropdownItem#OnCancel", this ); }

                var dropdown = this.GetComponentInParent(TMPro.TMP_Dropdown);
                if (UnityEngine.Object.op_Implicit(dropdown)) {
                    dropdown.Hide();
                }
            },
            /*TMPro.TMP_Dropdown+DropdownItem.OnCancel end.*/


        }
    });
    /*TMPro.TMP_Dropdown+DropdownItem end.*/

    /*TMPro.TMP_Dropdown+OptionData start.*/
    /**
     * Class to store the text and/or image of a single option in the dropdown list.
     *
     * @public
     * @class TMPro.TMP_Dropdown.OptionData
     */
    Bridge.define("TMPro.TMP_Dropdown.OptionData", {
        $kind: 1002,
        fields: {
            m_Text: null,
            m_Image: null
        },
        props: {
            /**
             * The text associated with the option.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Dropdown.OptionData
             * @function text
             * @type string
             */
            text: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown.OptionData#text#get", this ); }

                    return this.m_Text;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown.OptionData#text#set", this ); }

                    this.m_Text = value;
                }
            },
            /**
             * The image associated with the option.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Dropdown.OptionData
             * @function image
             * @type UnityEngine.Sprite
             */
            image: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown.OptionData#image#get", this ); }

                    return this.m_Image;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown.OptionData#image#set", this ); }

                    this.m_Image = value;
                }
            }
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown.OptionData#ctor", this ); }

                this.$initialize();
            },
            $ctor1: function (text) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown.OptionData#$ctor1", this ); }

                this.$initialize();
                this.text = text;
            },
            $ctor3: function (image) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown.OptionData#$ctor3", this ); }

                this.$initialize();
                this.image = image;
            },
            /**
             * Create an object representing a single option for the dropdown list.
             *
             * @instance
             * @public
             * @this TMPro.TMP_Dropdown.OptionData
             * @memberof TMPro.TMP_Dropdown.OptionData
             * @param   {string}                text     Optional text for the option.
             * @param   {UnityEngine.Sprite}    image    Optional image for the option.
             * @return  {void}
             */
            $ctor2: function (text, image) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown.OptionData#$ctor2", this ); }

                this.$initialize();
                this.text = text;
                this.image = image;
            }
        }
    });
    /*TMPro.TMP_Dropdown+OptionData end.*/

    /*TMPro.TMP_Dropdown+OptionDataList start.*/
    /**
     * Class used internally to store the list of options for the dropdown list.
     *
     * @public
     * @class TMPro.TMP_Dropdown.OptionDataList
     */
    Bridge.define("TMPro.TMP_Dropdown.OptionDataList", {
        $kind: 1002,
        fields: {
            m_Options: null
        },
        props: {
            /**
             * The list of options for the dropdown list.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Dropdown.OptionDataList
             * @function options
             * @type System.Collections.Generic.List$1
             */
            options: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown.OptionDataList#options#get", this ); }

                    return this.m_Options;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown.OptionDataList#options#set", this ); }

                    this.m_Options = value;
                }
            }
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Dropdown.OptionDataList#ctor", this ); }

                this.$initialize();
                this.options = new (System.Collections.Generic.List$1(TMPro.TMP_Dropdown.OptionData)).ctor();
            }
        }
    });
    /*TMPro.TMP_Dropdown+OptionDataList end.*/

    /*TMPro.TMP_FontAssetUtilities start.*/
    Bridge.define("TMPro.TMP_FontAssetUtilities", {
        statics: {
            fields: {
                s_Instance: null,
                /**
                 * HashSet containing instance ID of font assets already searched.
                 *
                 * @static
                 * @private
                 * @memberof TMPro.TMP_FontAssetUtilities
                 * @type System.Collections.Generic.HashSet$1
                 */
                k_SearchedAssets: null,
                k_IsFontEngineInitialized: false
            },
            props: {
                /**
                 * Get a singleton instance of the Font Asset Utilities class.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof TMPro.TMP_FontAssetUtilities
                 * @function instance
                 * @type TMPro.TMP_FontAssetUtilities
                 */
                instance: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAssetUtilities#instance#get", this ); }

                        return TMPro.TMP_FontAssetUtilities.s_Instance;
                    }
                }
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAssetUtilities#init", this ); }

                    this.s_Instance = new TMPro.TMP_FontAssetUtilities();
                },
                ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAssetUtilities#ctor", this ); }

                }
            },
            methods: {
                /*TMPro.TMP_FontAssetUtilities.GetCharacterFromFontAsset:static start.*/
                /**
                 * Returns the text element (character) for the given unicode value taking into consideration the requested font style and weight.
                 Function searches the source font asset, its list of font assets assigned as alternative typefaces and potentially its fallbacks.
                 The font asset out parameter contains a reference to the font asset containing the character.
                 The typeface type indicates whether the returned font asset is the source font asset, an alternative typeface or fallback font asset.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_FontAssetUtilities
                 * @memberof TMPro.TMP_FontAssetUtilities
                 * @param   {number}                 unicode                  The unicode value of the requested character
                 * @param   {TMPro.TMP_FontAsset}    sourceFontAsset          The font asset to be searched
                 * @param   {boolean}                includeFallbacks         Include the fallback font assets in the search
                 * @param   {TMPro.FontStyles}       fontStyle                The font style
                 * @param   {TMPro.FontWeight}       fontWeight               The font weight
                 * @param   {System.Boolean}         isAlternativeTypeface    Indicates if the OUT font asset is an alternative typeface or fallback font asset
                 * @return  {TMPro.TMP_Character}
                 */
                GetCharacterFromFontAsset: function (unicode, sourceFontAsset, includeFallbacks, fontStyle, fontWeight, isAlternativeTypeface) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAssetUtilities#GetCharacterFromFontAsset", this ); }

                    if (includeFallbacks) {
                        if (TMPro.TMP_FontAssetUtilities.k_SearchedAssets == null) {
                            TMPro.TMP_FontAssetUtilities.k_SearchedAssets = new (System.Collections.Generic.HashSet$1(System.Int32)).ctor();
                        } else {
                            TMPro.TMP_FontAssetUtilities.k_SearchedAssets.clear();
                        }
                    }

                    return TMPro.TMP_FontAssetUtilities.GetCharacterFromFontAsset_Internal(unicode, sourceFontAsset, includeFallbacks, fontStyle, fontWeight, isAlternativeTypeface);
                },
                /*TMPro.TMP_FontAssetUtilities.GetCharacterFromFontAsset:static end.*/

                /*TMPro.TMP_FontAssetUtilities.GetCharacterFromFontAsset_Internal:static start.*/
                /**
                 * Internal function returning the text element character for the given unicode value taking into consideration the font style and weight.
                 Function searches the source font asset, list of font assets assigned as alternative typefaces and list of fallback font assets.
                 *
                 * @static
                 * @private
                 * @this TMPro.TMP_FontAssetUtilities
                 * @memberof TMPro.TMP_FontAssetUtilities
                 * @param   {number}                 unicode                  
                 * @param   {TMPro.TMP_FontAsset}    sourceFontAsset          
                 * @param   {boolean}                includeFallbacks         
                 * @param   {TMPro.FontStyles}       fontStyle                
                 * @param   {TMPro.FontWeight}       fontWeight               
                 * @param   {System.Boolean}         isAlternativeTypeface
                 * @return  {TMPro.TMP_Character}
                 */
                GetCharacterFromFontAsset_Internal: function (unicode, sourceFontAsset, includeFallbacks, fontStyle, fontWeight, isAlternativeTypeface) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAssetUtilities#GetCharacterFromFontAsset_Internal", this ); }

                    isAlternativeTypeface.v = false;
                    var character = { v : null };


                    // Determine if a font weight or style is used. If so check if an alternative typeface is assigned for the given weight and / or style.
                    var isItalic = (fontStyle & TMPro.FontStyles.Italic) === TMPro.FontStyles.Italic;

                    if (isItalic || fontWeight !== TMPro.FontWeight.Regular) {
                        // Get reference to the font weight pairs of the given font asset.
                        var fontWeights = sourceFontAsset.fontWeightTable;

                        var fontWeightIndex = 4;
                        switch (fontWeight) {
                            case TMPro.FontWeight.Thin: 
                                fontWeightIndex = 1;
                                break;
                            case TMPro.FontWeight.ExtraLight: 
                                fontWeightIndex = 2;
                                break;
                            case TMPro.FontWeight.Light: 
                                fontWeightIndex = 3;
                                break;
                            case TMPro.FontWeight.Regular: 
                                fontWeightIndex = 4;
                                break;
                            case TMPro.FontWeight.Medium: 
                                fontWeightIndex = 5;
                                break;
                            case TMPro.FontWeight.SemiBold: 
                                fontWeightIndex = 6;
                                break;
                            case TMPro.FontWeight.Bold: 
                                fontWeightIndex = 7;
                                break;
                            case TMPro.FontWeight.Heavy: 
                                fontWeightIndex = 8;
                                break;
                            case TMPro.FontWeight.Black: 
                                fontWeightIndex = 9;
                                break;
                        }

                        var temp = isItalic ? fontWeights[fontWeightIndex].italicTypeface : fontWeights[fontWeightIndex].regularTypeface;

                        if (temp != null) {
                            if (temp.characterLookupTable.tryGetValue(unicode, character)) {
                                isAlternativeTypeface.v = true;

                                return character.v;
                            }

                            if (temp.atlasPopulationMode === TMPro.AtlasPopulationMode.Dynamic) {
                                if (temp.TryAddCharacterInternal(unicode, character)) {
                                    isAlternativeTypeface.v = true;

                                    return character.v;
                                }

                                // Check if the source font file contains the requested character.
                                //if (TryGetCharacterFromFontFile(unicode, fontAsset, out characterData))
                                //{
                                //    isAlternativeTypeface = true;

                                //    return characterData;
                                //}

                                // If we find the requested character, we add it to the font asset character table
                                // and return its character data.
                                // We also add this character to the list of characters we will need to add to the font atlas.
                                // We assume the font atlas has room otherwise this font asset should not be marked as dynamic.
                                // Alternatively, we could also add multiple pages of font atlas textures (feature consideration).
                            }

                            // At this point, we were not able to find the requested character in the alternative typeface
                            // so we check the source font asset and its potential fallbacks.
                        }
                    }


                    // Search the source font asset for the requested character.
                    if (sourceFontAsset.characterLookupTable.tryGetValue(unicode, character)) {
                        return character.v;
                    }

                    if (sourceFontAsset.atlasPopulationMode === TMPro.AtlasPopulationMode.Dynamic) {
                        if (sourceFontAsset.TryAddCharacterInternal(unicode, character)) {
                            return character.v;
                        }
                    }

                    // Search fallback font assets if we still don't have a valid character and include fallback is set to true.
                    if (character.v == null && includeFallbacks && sourceFontAsset.fallbackFontAssetTable != null) {
                        // Get reference to the list of fallback font assets.
                        var fallbackFontAssets = sourceFontAsset.fallbackFontAssetTable;
                        var fallbackCount = fallbackFontAssets.Count;

                        if (fallbackCount === 0) {
                            return null;
                        }

                        for (var i = 0; i < fallbackCount; i++) {
                            var temp1 = fallbackFontAssets.getItem(i);

                            if (temp1 == null) {
                                continue;
                            }

                            var id = temp1.instanceID;

                            // Try adding font asset to search list. If already present skip to the next one otherwise check if it contains the requested character.
                            if (TMPro.TMP_FontAssetUtilities.k_SearchedAssets.add(id) === false) {
                                continue;
                            }

                            // Add reference to this search query
                            sourceFontAsset.FallbackSearchQueryLookup.add(id);

                            character.v = TMPro.TMP_FontAssetUtilities.GetCharacterFromFontAsset_Internal(unicode, temp1, true, fontStyle, fontWeight, isAlternativeTypeface);

                            if (character.v != null) {
                                return character.v;
                            }
                        }
                    }

                    return null;
                },
                /*TMPro.TMP_FontAssetUtilities.GetCharacterFromFontAsset_Internal:static end.*/

                /*TMPro.TMP_FontAssetUtilities.GetCharacterFromFontAssets:static start.*/
                /**
                 * Returns the text element (character) for the given unicode value taking into consideration the requested font style and weight.
                 Function searches the provided list of font assets, the list of font assets assigned as alternative typefaces to them as well as their fallbacks.
                 The font asset out parameter contains a reference to the font asset containing the character.
                 The typeface type indicates whether the returned font asset is the source font asset, an alternative typeface or fallback font asset.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_FontAssetUtilities
                 * @memberof TMPro.TMP_FontAssetUtilities
                 * @param   {number}                               unicode                  The unicode value of the requested character
                 * @param   {TMPro.TMP_FontAsset}                  sourceFontAsset          The font asset originating the search query
                 * @param   {System.Collections.Generic.List$1}    fontAssets               The list of font assets to search
                 * @param   {boolean}                              includeFallbacks         Determines if the fallback of each font assets on the list will be searched
                 * @param   {TMPro.FontStyles}                     fontStyle                The font style
                 * @param   {TMPro.FontWeight}                     fontWeight               The font weight
                 * @param   {System.Boolean}                       isAlternativeTypeface    Determines if the OUT font asset is an alternative typeface or fallback font asset
                 * @return  {TMPro.TMP_Character}
                 */
                GetCharacterFromFontAssets: function (unicode, sourceFontAsset, fontAssets, includeFallbacks, fontStyle, fontWeight, isAlternativeTypeface) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAssetUtilities#GetCharacterFromFontAssets", this ); }

                    isAlternativeTypeface.v = false;

                    // Make sure font asset list is valid
                    if (fontAssets == null || fontAssets.Count === 0) {
                        return null;
                    }

                    if (includeFallbacks) {
                        if (TMPro.TMP_FontAssetUtilities.k_SearchedAssets == null) {
                            TMPro.TMP_FontAssetUtilities.k_SearchedAssets = new (System.Collections.Generic.HashSet$1(System.Int32)).ctor();
                        } else {
                            TMPro.TMP_FontAssetUtilities.k_SearchedAssets.clear();
                        }
                    }

                    var fontAssetCount = fontAssets.Count;

                    for (var i = 0; i < fontAssetCount; i++) {
                        var fontAsset = fontAssets.getItem(i);

                        if (fontAsset == null) {
                            continue;
                        }

                        // Add reference to this search query
                        sourceFontAsset.FallbackSearchQueryLookup.add(fontAsset.instanceID);

                        var character = TMPro.TMP_FontAssetUtilities.GetCharacterFromFontAsset_Internal(unicode, fontAsset, includeFallbacks, fontStyle, fontWeight, isAlternativeTypeface);

                        if (character != null) {
                            return character;
                        }
                    }

                    return null;
                },
                /*TMPro.TMP_FontAssetUtilities.GetCharacterFromFontAssets:static end.*/

                /*TMPro.TMP_FontAssetUtilities.GetSpriteCharacterFromSpriteAsset:static start.*/
                /**
                 * @static
                 * @public
                 * @this TMPro.TMP_FontAssetUtilities
                 * @memberof TMPro.TMP_FontAssetUtilities
                 * @param   {number}                       unicode             
                 * @param   {TMPro.TMP_SpriteAsset}        spriteAsset         
                 * @param   {boolean}                      includeFallbacks
                 * @return  {TMPro.TMP_SpriteCharacter}
                 */
                GetSpriteCharacterFromSpriteAsset: function (unicode, spriteAsset, includeFallbacks) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAssetUtilities#GetSpriteCharacterFromSpriteAsset", this ); }

                    // Make sure we have a valid sprite asset to search
                    if (spriteAsset == null) {
                        return null;
                    }

                    var spriteCharacter = { };

                    // Search sprite asset for potential sprite character for the given unicode value
                    if (spriteAsset.spriteCharacterLookupTable.tryGetValue(unicode, spriteCharacter)) {
                        return spriteCharacter.v;
                    }

                    if (includeFallbacks) {
                        // Clear searched assets
                        if (TMPro.TMP_FontAssetUtilities.k_SearchedAssets == null) {
                            TMPro.TMP_FontAssetUtilities.k_SearchedAssets = new (System.Collections.Generic.HashSet$1(System.Int32)).ctor();
                        } else {
                            TMPro.TMP_FontAssetUtilities.k_SearchedAssets.clear();
                        }

                        // Add current sprite asset to already searched assets.
                        TMPro.TMP_FontAssetUtilities.k_SearchedAssets.add(spriteAsset.instanceID);

                        var fallbackSpriteAsset = spriteAsset.fallbackSpriteAssets;

                        if (fallbackSpriteAsset != null && fallbackSpriteAsset.Count > 0) {
                            var fallbackCount = fallbackSpriteAsset.Count;

                            for (var i = 0; i < fallbackCount; i++) {
                                var temp = fallbackSpriteAsset.getItem(i);

                                if (temp == null) {
                                    continue;
                                }

                                var id = temp.instanceID;

                                // Try adding asset to search list. If already present skip to the next one otherwise check if it contains the requested character.
                                if (TMPro.TMP_FontAssetUtilities.k_SearchedAssets.add(id) === false) {
                                    continue;
                                }

                                spriteCharacter.v = TMPro.TMP_FontAssetUtilities.GetSpriteCharacterFromSpriteAsset_Internal(unicode, temp, true);

                                if (spriteCharacter.v != null) {
                                    return spriteCharacter.v;
                                }
                            }
                        }
                    }

                    return null;
                },
                /*TMPro.TMP_FontAssetUtilities.GetSpriteCharacterFromSpriteAsset:static end.*/

                /*TMPro.TMP_FontAssetUtilities.GetSpriteCharacterFromSpriteAsset_Internal:static start.*/
                /**
                 * @static
                 * @private
                 * @this TMPro.TMP_FontAssetUtilities
                 * @memberof TMPro.TMP_FontAssetUtilities
                 * @param   {number}                       unicode             
                 * @param   {TMPro.TMP_SpriteAsset}        spriteAsset         
                 * @param   {boolean}                      includeFallbacks
                 * @return  {TMPro.TMP_SpriteCharacter}
                 */
                GetSpriteCharacterFromSpriteAsset_Internal: function (unicode, spriteAsset, includeFallbacks) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAssetUtilities#GetSpriteCharacterFromSpriteAsset_Internal", this ); }

                    var spriteCharacter = { };

                    // Search sprite asset for potential sprite character for the given unicode value
                    if (spriteAsset.spriteCharacterLookupTable.tryGetValue(unicode, spriteCharacter)) {
                        return spriteCharacter.v;
                    }

                    if (includeFallbacks) {
                        var fallbackSpriteAsset = spriteAsset.fallbackSpriteAssets;

                        if (fallbackSpriteAsset != null && fallbackSpriteAsset.Count > 0) {
                            var fallbackCount = fallbackSpriteAsset.Count;

                            for (var i = 0; i < fallbackCount; i++) {
                                var temp = fallbackSpriteAsset.getItem(i);

                                if (temp == null) {
                                    continue;
                                }

                                var id = temp.instanceID;

                                // Try adding asset to search list. If already present skip to the next one otherwise check if it contains the requested character.
                                if (TMPro.TMP_FontAssetUtilities.k_SearchedAssets.add(id) === false) {
                                    continue;
                                }

                                spriteCharacter.v = TMPro.TMP_FontAssetUtilities.GetSpriteCharacterFromSpriteAsset_Internal(unicode, temp, true);

                                if (spriteCharacter.v != null) {
                                    return spriteCharacter.v;
                                }
                            }
                        }
                    }

                    return null;
                },
                /*TMPro.TMP_FontAssetUtilities.GetSpriteCharacterFromSpriteAsset_Internal:static end.*/


            }
        }
    });
    /*TMPro.TMP_FontAssetUtilities end.*/

    /*TMPro.TMP_FontFeatureTable start.*/
    /**
     * Table that contains the various font features available for the given font asset.
     *
     * @public
     * @class TMPro.TMP_FontFeatureTable
     */
    Bridge.define("TMPro.TMP_FontFeatureTable", {
        fields: {
            m_GlyphPairAdjustmentRecords: null,
            /**
             * @instance
             * @memberof TMPro.TMP_FontFeatureTable
             * @type System.Collections.Generic.Dictionary$2
             */
            m_GlyphPairAdjustmentRecordLookupDictionary: null
        },
        props: {
            /**
             * List that contains the glyph pair adjustment records.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_FontFeatureTable
             * @function glyphPairAdjustmentRecords
             * @type System.Collections.Generic.List$1
             */
            glyphPairAdjustmentRecords: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontFeatureTable#glyphPairAdjustmentRecords#get", this ); }

                    return this.m_GlyphPairAdjustmentRecords;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontFeatureTable#glyphPairAdjustmentRecords#set", this ); }

                    this.m_GlyphPairAdjustmentRecords = value;
                }
            }
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontFeatureTable#ctor", this ); }

                this.$initialize();
                this.m_GlyphPairAdjustmentRecords = new (System.Collections.Generic.List$1(TMPro.TMP_GlyphPairAdjustmentRecord)).ctor();
                this.m_GlyphPairAdjustmentRecordLookupDictionary = new (System.Collections.Generic.Dictionary$2(System.UInt32,TMPro.TMP_GlyphPairAdjustmentRecord)).ctor();
            }
        },
        methods: {
            /*TMPro.TMP_FontFeatureTable.SortGlyphPairAdjustmentRecords start.*/
            /**
             * Sort the glyph pair adjustment records by glyph index.
             *
             * @instance
             * @public
             * @this TMPro.TMP_FontFeatureTable
             * @memberof TMPro.TMP_FontFeatureTable
             * @return  {void}
             */
            SortGlyphPairAdjustmentRecords: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontFeatureTable#SortGlyphPairAdjustmentRecords", this ); }

                // Sort List of Kerning Info
                if (this.m_GlyphPairAdjustmentRecords.Count > 0) {
                    this.m_GlyphPairAdjustmentRecords = System.Linq.Enumerable.from(this.m_GlyphPairAdjustmentRecords, TMPro.TMP_GlyphPairAdjustmentRecord).orderBy(function (s) {
                            return s.firstAdjustmentRecord.glyphIndex;
                        }).thenBy(function (s) {
                        return s.secondAdjustmentRecord.glyphIndex;
                    }).toList(TMPro.TMP_GlyphPairAdjustmentRecord);
                }
            },
            /*TMPro.TMP_FontFeatureTable.SortGlyphPairAdjustmentRecords end.*/


        }
    });
    /*TMPro.TMP_FontFeatureTable end.*/

    /*TMPro.TMP_FontStyleStack start.*/
    /**
     * Structure used to track basic XML tags which are binary (on / off)
     *
     * @public
     * @class TMPro.TMP_FontStyleStack
     */
    Bridge.define("TMPro.TMP_FontStyleStack", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontStyleStack#getDefaultValue", this ); }
 return new TMPro.TMP_FontStyleStack(); }
            }
        },
        fields: {
            bold: 0,
            italic: 0,
            underline: 0,
            strikethrough: 0,
            highlight: 0,
            superscript: 0,
            subscript: 0,
            uppercase: 0,
            lowercase: 0,
            smallcaps: 0
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontStyleStack#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*TMPro.TMP_FontStyleStack.Copy start.*/
            Copy: function (other) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontStyleStack#Copy", this ); }

                this.bold = other.bold;
                this.italic = other.italic;
                this.underline = other.underline;
                this.strikethrough = other.strikethrough;
                this.highlight = other.highlight;
                this.superscript = other.superscript;
                this.subscript = other.subscript;
                this.uppercase = other.uppercase;
                this.lowercase = other.lowercase;
                this.smallcaps = other.smallcaps;
            },
            /*TMPro.TMP_FontStyleStack.Copy end.*/

            /*TMPro.TMP_FontStyleStack.Clear start.*/
            /**
             * Clear the basic XML tag stack.
             *
             * @instance
             * @public
             * @this TMPro.TMP_FontStyleStack
             * @memberof TMPro.TMP_FontStyleStack
             * @return  {void}
             */
            Clear: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontStyleStack#Clear", this ); }

                this.bold = 0;
                this.italic = 0;
                this.underline = 0;
                this.strikethrough = 0;
                this.highlight = 0;
                this.superscript = 0;
                this.subscript = 0;
                this.uppercase = 0;
                this.lowercase = 0;
                this.smallcaps = 0;
            },
            /*TMPro.TMP_FontStyleStack.Clear end.*/

            /*TMPro.TMP_FontStyleStack.Add start.*/
            Add: function (style) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontStyleStack#Add", this ); }

                switch (style) {
                    case TMPro.FontStyles.Bold: 
                        this.bold++;
                        return this.bold;
                    case TMPro.FontStyles.Italic: 
                        this.italic++;
                        return this.italic;
                    case TMPro.FontStyles.Underline: 
                        this.underline++;
                        return this.underline;
                    case TMPro.FontStyles.UpperCase: 
                        this.uppercase++;
                        return this.uppercase;
                    case TMPro.FontStyles.LowerCase: 
                        this.lowercase++;
                        return this.lowercase;
                    case TMPro.FontStyles.Strikethrough: 
                        this.strikethrough++;
                        return this.strikethrough;
                    case TMPro.FontStyles.Superscript: 
                        this.superscript++;
                        return this.superscript;
                    case TMPro.FontStyles.Subscript: 
                        this.subscript++;
                        return this.subscript;
                    case TMPro.FontStyles.Highlight: 
                        this.highlight++;
                        return this.highlight;
                }

                return 0;
            },
            /*TMPro.TMP_FontStyleStack.Add end.*/

            /*TMPro.TMP_FontStyleStack.Remove start.*/
            Remove: function (style) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontStyleStack#Remove", this ); }

                switch (style) {
                    case TMPro.FontStyles.Bold: 
                        if (this.bold > 1) {
                            this.bold--;
                        } else {
                            this.bold = 0;
                        }
                        return this.bold;
                    case TMPro.FontStyles.Italic: 
                        if (this.italic > 1) {
                            this.italic--;
                        } else {
                            this.italic = 0;
                        }
                        return this.italic;
                    case TMPro.FontStyles.Underline: 
                        if (this.underline > 1) {
                            this.underline--;
                        } else {
                            this.underline = 0;
                        }
                        return this.underline;
                    case TMPro.FontStyles.UpperCase: 
                        if (this.uppercase > 1) {
                            this.uppercase--;
                        } else {
                            this.uppercase = 0;
                        }
                        return this.uppercase;
                    case TMPro.FontStyles.LowerCase: 
                        if (this.lowercase > 1) {
                            this.lowercase--;
                        } else {
                            this.lowercase = 0;
                        }
                        return this.lowercase;
                    case TMPro.FontStyles.Strikethrough: 
                        if (this.strikethrough > 1) {
                            this.strikethrough--;
                        } else {
                            this.strikethrough = 0;
                        }
                        return this.strikethrough;
                    case TMPro.FontStyles.Highlight: 
                        if (this.highlight > 1) {
                            this.highlight--;
                        } else {
                            this.highlight = 0;
                        }
                        return this.highlight;
                    case TMPro.FontStyles.Superscript: 
                        if (this.superscript > 1) {
                            this.superscript--;
                        } else {
                            this.superscript = 0;
                        }
                        return this.superscript;
                    case TMPro.FontStyles.Subscript: 
                        if (this.subscript > 1) {
                            this.subscript--;
                        } else {
                            this.subscript = 0;
                        }
                        return this.subscript;
                }

                return 0;
            },
            /*TMPro.TMP_FontStyleStack.Remove end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontStyleStack#getHashCode", this ); }

                var h = Bridge.addHash([7007432629, this.bold, this.italic, this.underline, this.strikethrough, this.highlight, this.superscript, this.subscript, this.uppercase, this.lowercase, this.smallcaps]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontStyleStack#equals", this ); }

                if (!Bridge.is(o, TMPro.TMP_FontStyleStack)) {
                    return false;
                }
                return Bridge.equals(this.bold, o.bold) && Bridge.equals(this.italic, o.italic) && Bridge.equals(this.underline, o.underline) && Bridge.equals(this.strikethrough, o.strikethrough) && Bridge.equals(this.highlight, o.highlight) && Bridge.equals(this.superscript, o.superscript) && Bridge.equals(this.subscript, o.subscript) && Bridge.equals(this.uppercase, o.uppercase) && Bridge.equals(this.lowercase, o.lowercase) && Bridge.equals(this.smallcaps, o.smallcaps);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontStyleStack#$clone", this ); }

                var s = to || new TMPro.TMP_FontStyleStack();
                s.bold = this.bold;
                s.italic = this.italic;
                s.underline = this.underline;
                s.strikethrough = this.strikethrough;
                s.highlight = this.highlight;
                s.superscript = this.superscript;
                s.subscript = this.subscript;
                s.uppercase = this.uppercase;
                s.lowercase = this.lowercase;
                s.smallcaps = this.smallcaps;
                return s;
            }
        }
    });
    /*TMPro.TMP_FontStyleStack end.*/

    /*TMPro.TMP_FontUtilities start.*/
    Bridge.define("TMPro.TMP_FontUtilities", {
        statics: {
            fields: {
                k_searchedFontAssets: null
            },
            methods: {
                /*TMPro.TMP_FontUtilities.SearchForCharacter$1:static start.*/
                /**
                 * Search through the given font and its fallbacks for the specified character.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_FontUtilities
                 * @memberof TMPro.TMP_FontUtilities
                 * @param   {TMPro.TMP_FontAsset}    font         The font asset to search for the given character.
                 * @param   {number}                 unicode      The character to find.
                 * @param   {TMPro.TMP_Character}    character    out parameter containing the glyph for the specified character (if found).
                 * @return  {TMPro.TMP_FontAsset}
                 */
                SearchForCharacter$1: function (font, unicode, character) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontUtilities#SearchForCharacter$1", this ); }

                    if (TMPro.TMP_FontUtilities.k_searchedFontAssets == null) {
                        TMPro.TMP_FontUtilities.k_searchedFontAssets = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                    }

                    TMPro.TMP_FontUtilities.k_searchedFontAssets.clear();

                    return TMPro.TMP_FontUtilities.SearchForCharacterInternal$1(font, unicode, character);
                },
                /*TMPro.TMP_FontUtilities.SearchForCharacter$1:static end.*/

                /*TMPro.TMP_FontUtilities.SearchForCharacter:static start.*/
                /**
                 * Search through the given list of fonts and their possible fallbacks for the specified character.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_FontUtilities
                 * @memberof TMPro.TMP_FontUtilities
                 * @param   {System.Collections.Generic.List$1}    fonts        
                 * @param   {number}                               unicode      
                 * @param   {TMPro.TMP_Character}                  character
                 * @return  {TMPro.TMP_FontAsset}
                 */
                SearchForCharacter: function (fonts, unicode, character) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontUtilities#SearchForCharacter", this ); }

                    return TMPro.TMP_FontUtilities.SearchForCharacterInternal(fonts, unicode, character);
                },
                /*TMPro.TMP_FontUtilities.SearchForCharacter:static end.*/

                /*TMPro.TMP_FontUtilities.SearchForCharacterInternal$1:static start.*/
                SearchForCharacterInternal$1: function (font, unicode, character) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontUtilities#SearchForCharacterInternal$1", this ); }

                    character.v = null;

                    if (font == null) {
                        return null;
                    }

                    if (font.characterLookupTable.tryGetValue(unicode, character)) {
                        return font;
                    } else if (font.fallbackFontAssetTable != null && font.fallbackFontAssetTable.Count > 0) {
                        for (var i = 0; i < font.fallbackFontAssetTable.Count && character.v == null; i++) {
                            var temp = font.fallbackFontAssetTable.getItem(i);
                            if (temp == null) {
                                continue;
                            }

                            var id = temp.GetInstanceID();

                            // Skip over the fallback font asset in the event it is null or if already searched.
                            if (TMPro.TMP_FontUtilities.k_searchedFontAssets.contains(id)) {
                                continue;
                            }

                            // Add to list of font assets already searched.
                            TMPro.TMP_FontUtilities.k_searchedFontAssets.add(id);

                            temp = TMPro.TMP_FontUtilities.SearchForCharacterInternal$1(temp, unicode, character);

                            if (temp != null) {
                                return temp;
                            }
                        }
                    }

                    return null;
                },
                /*TMPro.TMP_FontUtilities.SearchForCharacterInternal$1:static end.*/

                /*TMPro.TMP_FontUtilities.SearchForCharacterInternal:static start.*/
                SearchForCharacterInternal: function (fonts, unicode, character) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontUtilities#SearchForCharacterInternal", this ); }

                    character.v = null;

                    if (fonts != null && fonts.Count > 0) {
                        for (var i = 0; i < fonts.Count; i++) {
                            var fontAsset = TMPro.TMP_FontUtilities.SearchForCharacterInternal$1(fonts.getItem(i), unicode, character);

                            if (fontAsset != null) {
                                return fontAsset;
                            }
                        }
                    }

                    return null;
                },
                /*TMPro.TMP_FontUtilities.SearchForCharacterInternal:static end.*/


            }
        }
    });
    /*TMPro.TMP_FontUtilities end.*/

    /*TMPro.TMP_FontWeightPair start.*/
    /**
     * Contains the font assets for the regular and italic styles associated with a given font weight.
     *
     * @public
     * @class TMPro.TMP_FontWeightPair
     */
    Bridge.define("TMPro.TMP_FontWeightPair", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontWeightPair#getDefaultValue", this ); }
 return new TMPro.TMP_FontWeightPair(); }
            }
        },
        fields: {
            regularTypeface: null,
            italicTypeface: null
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontWeightPair#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontWeightPair#getHashCode", this ); }

                var h = Bridge.addHash([6920145090, this.regularTypeface, this.italicTypeface]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontWeightPair#equals", this ); }

                if (!Bridge.is(o, TMPro.TMP_FontWeightPair)) {
                    return false;
                }
                return Bridge.equals(this.regularTypeface, o.regularTypeface) && Bridge.equals(this.italicTypeface, o.italicTypeface);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontWeightPair#$clone", this ); }

                var s = to || new TMPro.TMP_FontWeightPair();
                s.regularTypeface = this.regularTypeface;
                s.italicTypeface = this.italicTypeface;
                return s;
            }
        }
    });
    /*TMPro.TMP_FontWeightPair end.*/

    /*TMPro.TMP_TextElement_Legacy start.*/
    /**
     * Base class for all text elements like characters (glyphs) and sprites.
     *
     * @public
     * @class TMPro.TMP_TextElement_Legacy
     */
    Bridge.define("TMPro.TMP_TextElement_Legacy", {
        fields: {
            id: 0,
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            xOffset: 0,
            yOffset: 0,
            xAdvance: 0,
            scale: 0
        }
    });
    /*TMPro.TMP_TextElement_Legacy end.*/

    /*TMPro.TMP_GlyphAdjustmentRecord start.*/
    /**
     * The positional adjustment values of a glyph.
     *
     * @public
     * @class TMPro.TMP_GlyphAdjustmentRecord
     */
    Bridge.define("TMPro.TMP_GlyphAdjustmentRecord", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphAdjustmentRecord#getDefaultValue", this ); }
 return new TMPro.TMP_GlyphAdjustmentRecord(); }
            }
        },
        fields: {
            m_GlyphIndex: 0,
            m_GlyphValueRecord: null
        },
        props: {
            /**
             * The index of the glyph in the source font file.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_GlyphAdjustmentRecord
             * @function glyphIndex
             * @type number
             */
            glyphIndex: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphAdjustmentRecord#glyphIndex#get", this ); }

                    return this.m_GlyphIndex;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphAdjustmentRecord#glyphIndex#set", this ); }

                    this.m_GlyphIndex = value;
                }
            },
            /**
             * The GlyphValueRecord contains the positional adjustments of the glyph.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_GlyphAdjustmentRecord
             * @function glyphValueRecord
             * @type TMPro.TMP_GlyphValueRecord
             */
            glyphValueRecord: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphAdjustmentRecord#glyphValueRecord#get", this ); }

                    return this.m_GlyphValueRecord.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphAdjustmentRecord#glyphValueRecord#set", this ); }

                    this.m_GlyphValueRecord = value.$clone();
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphAdjustmentRecord#init", this ); }

                this.m_GlyphValueRecord = new TMPro.TMP_GlyphValueRecord();
            },
            /**
             * Constructor
             *
             * @instance
             * @public
             * @this TMPro.TMP_GlyphAdjustmentRecord
             * @memberof TMPro.TMP_GlyphAdjustmentRecord
             * @param   {number}                        glyphIndex          The index of the glyph in the source font file.
             * @param   {TMPro.TMP_GlyphValueRecord}    glyphValueRecord    The GlyphValueRecord contains the positional adjustments of the glyph.
             * @return  {void}
             */
            $ctor1: function (glyphIndex, glyphValueRecord) {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphAdjustmentRecord#$ctor1", this ); }

                this.$initialize();
                this.m_GlyphIndex = glyphIndex;
                this.m_GlyphValueRecord = glyphValueRecord.$clone();
            },
            $ctor2: function (adjustmentRecord) {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphAdjustmentRecord#$ctor2", this ); }

                this.$initialize();
                this.m_GlyphIndex = adjustmentRecord.glyphIndex;
                this.m_GlyphValueRecord = new TMPro.TMP_GlyphValueRecord.$ctor3(adjustmentRecord.glyphValueRecord.$clone());
            },
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphAdjustmentRecord#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphAdjustmentRecord#getHashCode", this ); }

                var h = Bridge.addHash([10410672294, this.m_GlyphIndex, this.m_GlyphValueRecord]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphAdjustmentRecord#equals", this ); }

                if (!Bridge.is(o, TMPro.TMP_GlyphAdjustmentRecord)) {
                    return false;
                }
                return Bridge.equals(this.m_GlyphIndex, o.m_GlyphIndex) && Bridge.equals(this.m_GlyphValueRecord, o.m_GlyphValueRecord);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphAdjustmentRecord#$clone", this ); }

                var s = to || new TMPro.TMP_GlyphAdjustmentRecord();
                s.m_GlyphIndex = this.m_GlyphIndex;
                s.m_GlyphValueRecord = this.m_GlyphValueRecord.$clone();
                return s;
            }
        }
    });
    /*TMPro.TMP_GlyphAdjustmentRecord end.*/

    /*TMPro.TMP_GlyphPairAdjustmentRecord start.*/
    /**
     * The positional adjustment values for a pair of glyphs.
     *
     * @public
     * @class TMPro.TMP_GlyphPairAdjustmentRecord
     */
    Bridge.define("TMPro.TMP_GlyphPairAdjustmentRecord", {
        fields: {
            m_FirstAdjustmentRecord: null,
            m_SecondAdjustmentRecord: null,
            m_FeatureLookupFlags: 0
        },
        props: {
            /**
             * Contains the positional adjustment values for the first glyph.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_GlyphPairAdjustmentRecord
             * @function firstAdjustmentRecord
             * @type TMPro.TMP_GlyphAdjustmentRecord
             */
            firstAdjustmentRecord: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphPairAdjustmentRecord#firstAdjustmentRecord#get", this ); }

                    return this.m_FirstAdjustmentRecord.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphPairAdjustmentRecord#firstAdjustmentRecord#set", this ); }

                    this.m_FirstAdjustmentRecord = value.$clone();
                }
            },
            /**
             * Contains the positional adjustment values for the second glyph.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_GlyphPairAdjustmentRecord
             * @function secondAdjustmentRecord
             * @type TMPro.TMP_GlyphAdjustmentRecord
             */
            secondAdjustmentRecord: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphPairAdjustmentRecord#secondAdjustmentRecord#get", this ); }

                    return this.m_SecondAdjustmentRecord.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphPairAdjustmentRecord#secondAdjustmentRecord#set", this ); }

                    this.m_SecondAdjustmentRecord = value.$clone();
                }
            },
            /**
             * @instance
             * @public
             * @memberof TMPro.TMP_GlyphPairAdjustmentRecord
             * @function featureLookupFlags
             * @type TMPro.FontFeatureLookupFlags
             */
            featureLookupFlags: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphPairAdjustmentRecord#featureLookupFlags#get", this ); }

                    return this.m_FeatureLookupFlags;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphPairAdjustmentRecord#featureLookupFlags#set", this ); }

                    this.m_FeatureLookupFlags = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphPairAdjustmentRecord#init", this ); }

                this.m_FirstAdjustmentRecord = new TMPro.TMP_GlyphAdjustmentRecord();
                this.m_SecondAdjustmentRecord = new TMPro.TMP_GlyphAdjustmentRecord();
            },
            /**
             * Constructor
             *
             * @instance
             * @public
             * @this TMPro.TMP_GlyphPairAdjustmentRecord
             * @memberof TMPro.TMP_GlyphPairAdjustmentRecord
             * @param   {TMPro.TMP_GlyphAdjustmentRecord}    firstAdjustmentRecord     First glyph adjustment record.
             * @param   {TMPro.TMP_GlyphAdjustmentRecord}    secondAdjustmentRecord    Second glyph adjustment record.
             * @return  {void}
             */
            ctor: function (firstAdjustmentRecord, secondAdjustmentRecord) {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphPairAdjustmentRecord#ctor", this ); }

                this.$initialize();
                this.m_FirstAdjustmentRecord = firstAdjustmentRecord.$clone();
                this.m_SecondAdjustmentRecord = secondAdjustmentRecord.$clone();
                this.m_FeatureLookupFlags = TMPro.FontFeatureLookupFlags.None;
            },
            /**
             * Internal constructor
             *
             * @instance
             * @this TMPro.TMP_GlyphPairAdjustmentRecord
             * @memberof TMPro.TMP_GlyphPairAdjustmentRecord
             * @param   {UnityEngine.TextCore.LowLevel.GlyphPairAdjustmentRecord}    glyphPairAdjustmentRecord
             * @return  {void}
             */
            $ctor1: function (glyphPairAdjustmentRecord) {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphPairAdjustmentRecord#$ctor1", this ); }

                this.$initialize();
                this.m_FirstAdjustmentRecord = new TMPro.TMP_GlyphAdjustmentRecord.$ctor2(glyphPairAdjustmentRecord.firstAdjustmentRecord.$clone());
                this.m_SecondAdjustmentRecord = new TMPro.TMP_GlyphAdjustmentRecord.$ctor2(glyphPairAdjustmentRecord.secondAdjustmentRecord.$clone());
                this.m_FeatureLookupFlags = TMPro.FontFeatureLookupFlags.None;
            }
        }
    });
    /*TMPro.TMP_GlyphPairAdjustmentRecord end.*/

    /*TMPro.TMP_GlyphValueRecord start.*/
    /**
     * The values used to adjust the position of a glyph or set of glyphs.
     *
     * @public
     * @class TMPro.TMP_GlyphValueRecord
     */
    Bridge.define("TMPro.TMP_GlyphValueRecord", {
        $kind: 4,
        statics: {
            methods: {
                op_Addition: function (a, b) {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphValueRecord#op_Addition", this ); }

                    var c = new TMPro.TMP_GlyphValueRecord();
                    c.m_XPlacement = a.xPlacement + b.xPlacement;
                    c.m_YPlacement = a.yPlacement + b.yPlacement;
                    c.m_XAdvance = a.xAdvance + b.xAdvance;
                    c.m_YAdvance = a.yAdvance + b.yAdvance;

                    return c.$clone();
                },
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphValueRecord#getDefaultValue", this ); }
 return new TMPro.TMP_GlyphValueRecord(); }
            }
        },
        fields: {
            m_XPlacement: 0,
            m_YPlacement: 0,
            m_XAdvance: 0,
            m_YAdvance: 0
        },
        props: {
            /**
             * The positional adjustment affecting the horizontal bearing X of the glyph.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_GlyphValueRecord
             * @function xPlacement
             * @type number
             */
            xPlacement: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphValueRecord#xPlacement#get", this ); }

                    return this.m_XPlacement;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphValueRecord#xPlacement#set", this ); }

                    this.m_XPlacement = value;
                }
            },
            /**
             * The positional adjustment affecting the horizontal bearing Y of the glyph.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_GlyphValueRecord
             * @function yPlacement
             * @type number
             */
            yPlacement: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphValueRecord#yPlacement#get", this ); }

                    return this.m_YPlacement;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphValueRecord#yPlacement#set", this ); }

                    this.m_YPlacement = value;
                }
            },
            /**
             * The positional adjustment affecting the horizontal advance of the glyph.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_GlyphValueRecord
             * @function xAdvance
             * @type number
             */
            xAdvance: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphValueRecord#xAdvance#get", this ); }

                    return this.m_XAdvance;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphValueRecord#xAdvance#set", this ); }

                    this.m_XAdvance = value;
                }
            },
            /**
             * The positional adjustment affecting the vertical advance of the glyph.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_GlyphValueRecord
             * @function yAdvance
             * @type number
             */
            yAdvance: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphValueRecord#yAdvance#get", this ); }

                    return this.m_YAdvance;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphValueRecord#yAdvance#set", this ); }

                    this.m_YAdvance = value;
                }
            }
        },
        ctors: {
            /**
             * Constructor
             *
             * @instance
             * @public
             * @this TMPro.TMP_GlyphValueRecord
             * @memberof TMPro.TMP_GlyphValueRecord
             * @param   {number}    xPlacement    The positional adjustment affecting the horizontal bearing X of the glyph.
             * @param   {number}    yPlacement    The positional adjustment affecting the horizontal bearing Y of the glyph.
             * @param   {number}    xAdvance      The positional adjustment affecting the horizontal advance of the glyph.
             * @param   {number}    yAdvance      The positional adjustment affecting the vertical advance of the glyph.
             * @return  {void}
             */
            $ctor1: function (xPlacement, yPlacement, xAdvance, yAdvance) {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphValueRecord#$ctor1", this ); }

                this.$initialize();
                this.m_XPlacement = xPlacement;
                this.m_YPlacement = yPlacement;
                this.m_XAdvance = xAdvance;
                this.m_YAdvance = yAdvance;
            },
            $ctor2: function (valueRecord) {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphValueRecord#$ctor2", this ); }

                this.$initialize();
                this.m_XPlacement = valueRecord.xPlacement;
                this.m_YPlacement = valueRecord.yPlacement;
                this.m_XAdvance = valueRecord.xAdvance;
                this.m_YAdvance = valueRecord.yAdvance;
            },
            $ctor3: function (valueRecord) {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphValueRecord#$ctor3", this ); }

                this.$initialize();
                this.m_XPlacement = valueRecord.xPlacement;
                this.m_YPlacement = valueRecord.yPlacement;
                this.m_XAdvance = valueRecord.xAdvance;
                this.m_YAdvance = valueRecord.yAdvance;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphValueRecord#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphValueRecord#getHashCode", this ); }

                var h = Bridge.addHash([8689542363, this.m_XPlacement, this.m_YPlacement, this.m_XAdvance, this.m_YAdvance]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphValueRecord#equals", this ); }

                if (!Bridge.is(o, TMPro.TMP_GlyphValueRecord)) {
                    return false;
                }
                return Bridge.equals(this.m_XPlacement, o.m_XPlacement) && Bridge.equals(this.m_YPlacement, o.m_YPlacement) && Bridge.equals(this.m_XAdvance, o.m_XAdvance) && Bridge.equals(this.m_YAdvance, o.m_YAdvance);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.TMP_GlyphValueRecord#$clone", this ); }

                var s = to || new TMPro.TMP_GlyphValueRecord();
                s.m_XPlacement = this.m_XPlacement;
                s.m_YPlacement = this.m_YPlacement;
                s.m_XAdvance = this.m_XAdvance;
                s.m_YAdvance = this.m_YAdvance;
                return s;
            }
        }
    });
    /*TMPro.TMP_GlyphValueRecord end.*/
    /**
     * @memberof TMPro
     * @callback TMPro.TMP_InputField.OnValidateInput
     * @param   {string}    text         
     * @param   {number}    charIndex    
     * @param   {number}    addedChar
     * @return  {number}
     */


    /*TMPro.TMP_InputField start.*/
    /**
     * Editable text input field.
     *
     * @public
     * @class TMPro.TMP_InputField
     * @augments UnityEngine.UI.Selectable
     * @implements  UnityEngine.EventSystems.IUpdateSelectedHandler
     * @implements  UnityEngine.EventSystems.IBeginDragHandler
     * @implements  UnityEngine.EventSystems.IDragHandler
     * @implements  UnityEngine.EventSystems.IEndDragHandler
     * @implements  UnityEngine.EventSystems.IPointerClickHandler
     * @implements  UnityEngine.EventSystems.ISubmitHandler
     * @implements  UnityEngine.UI.ICanvasElement
     * @implements  UnityEngine.UI.ILayoutElement
     * @implements  UnityEngine.EventSystems.IScrollHandler
     */
    Bridge.define("TMPro.TMP_InputField", {
        inherits: [UnityEngine.UI.Selectable,UnityEngine.EventSystems.IUpdateSelectedHandler,UnityEngine.EventSystems.IBeginDragHandler,UnityEngine.EventSystems.IDragHandler,UnityEngine.EventSystems.IEndDragHandler,UnityEngine.EventSystems.IPointerClickHandler,UnityEngine.EventSystems.ISubmitHandler,UnityEngine.UI.ICanvasElement,UnityEngine.UI.ILayoutElement,UnityEngine.EventSystems.IScrollHandler],
        statics: {
            fields: {
                kHScrollSpeed: 0,
                kVScrollSpeed: 0,
                kEmailSpecialCharacters: null,
                kSeparators: null
            },
            props: {
                clipboard: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#clipboard#get", this ); }

                        return pc.generateStubProxy( 'UnityEngine.GUIUtility', true ).reportProperty( 'UnityEngine.GUIUtility.systemCopyBuffer', '' );
                    },
                    set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#clipboard#set", this ); }

                        pc.generateStubProxy( 'UnityEngine.GUIUtility', true ).systemCopyBuffer = value;
                    }
                }
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#init", this ); }

                    this.kHScrollSpeed = 0.05;
                    this.kVScrollSpeed = 0.1;
                    this.kEmailSpecialCharacters = "!#$%&'*+-/=?^_`{|}~";
                    this.kSeparators = System.Array.init([
                        32, 
                        46, 
                        44, 
                        9, 
                        13, 
                        10
                    ], System.Char);
                }
            }
        },
        fields: {
            m_SoftKeyboard: null,
            /**
             * Text Text used to display the input's value.
             *
             * @instance
             * @protected
             * @memberof TMPro.TMP_InputField
             * @type UnityEngine.RectTransform
             */
            m_RectTransform: null,
            m_TextViewport: null,
            m_TextComponentRectMask: null,
            m_TextViewportRectMask: null,
            m_CachedViewportRect: null,
            m_TextComponent: null,
            m_TextComponentRectTransform: null,
            m_Placeholder: null,
            m_VerticalScrollbar: null,
            m_VerticalScrollbarEventHandler: null,
            m_IsDrivenByLayoutComponents: false,
            m_LayoutGroup: null,
            m_IScrollHandlerParent: null,
            /**
             * Used to keep track of scroll position
             *
             * @instance
             * @private
             * @memberof TMPro.TMP_InputField
             * @type number
             */
            m_ScrollPosition: 0,
            /**
             * @instance
             * @protected
             * @memberof TMPro.TMP_InputField
             * @default 1.0
             * @type number
             */
            m_ScrollSensitivity: 0,
            m_ContentType: 0,
            /**
             * Type of data expected by the input field.
             *
             * @instance
             * @private
             * @memberof TMPro.TMP_InputField
             * @type number
             */
            m_InputType: 0,
            /**
             * The character used to hide text in password field.
             *
             * @instance
             * @private
             * @memberof TMPro.TMP_InputField
             * @default "*"
             * @type number
             */
            m_AsteriskChar: 0,
            /**
             * Keyboard type applies to mobile keyboards that get shown.
             *
             * @instance
             * @private
             * @memberof TMPro.TMP_InputField
             * @type UnityEngine.TouchScreenKeyboardType
             */
            m_KeyboardType: 0,
            m_LineType: 0,
            /**
             * Should hide mobile input field part of the virtual keyboard.
             *
             * @instance
             * @private
             * @memberof TMPro.TMP_InputField
             * @default false
             * @type boolean
             */
            m_HideMobileInput: false,
            /**
             * Should hide soft / virtual keyboard.
             *
             * @instance
             * @private
             * @memberof TMPro.TMP_InputField
             * @default false
             * @type boolean
             */
            m_HideSoftKeyboard: false,
            /**
             * What kind of validation to use with the input field's data.
             *
             * @instance
             * @private
             * @memberof TMPro.TMP_InputField
             * @type number
             */
            m_CharacterValidation: 0,
            /**
             * The Regex expression used for validating the text input.
             *
             * @instance
             * @private
             * @memberof TMPro.TMP_InputField
             * @default ""
             * @type string
             */
            m_RegexValue: null,
            /**
             * The point sized used by the placeholder and input text object.
             *
             * @instance
             * @private
             * @memberof TMPro.TMP_InputField
             * @default 14
             * @type number
             */
            m_GlobalPointSize: 0,
            /**
             * Maximum number of characters allowed before input no longer works.
             *
             * @instance
             * @private
             * @memberof TMPro.TMP_InputField
             * @default 0
             * @type number
             */
            m_CharacterLimit: 0,
            /**
             * Event delegates triggered when the input field submits its data.
             *
             * @instance
             * @private
             * @memberof TMPro.TMP_InputField
             * @type TMPro.TMP_InputField.SubmitEvent
             */
            m_OnEndEdit: null,
            /**
             * Event delegates triggered when the input field submits its data.
             *
             * @instance
             * @private
             * @memberof TMPro.TMP_InputField
             * @type TMPro.TMP_InputField.SubmitEvent
             */
            m_OnSubmit: null,
            /**
             * Event delegates triggered when the input field is focused.
             *
             * @instance
             * @private
             * @memberof TMPro.TMP_InputField
             * @type TMPro.TMP_InputField.SelectionEvent
             */
            m_OnSelect: null,
            /**
             * Event delegates triggered when the input field focus is lost.
             *
             * @instance
             * @private
             * @memberof TMPro.TMP_InputField
             * @type TMPro.TMP_InputField.SelectionEvent
             */
            m_OnDeselect: null,
            /**
             * Event delegates triggered when the text is selected / highlighted.
             *
             * @instance
             * @private
             * @memberof TMPro.TMP_InputField
             * @type TMPro.TMP_InputField.TextSelectionEvent
             */
            m_OnTextSelection: null,
            /**
             * Event delegates triggered when text is no longer select / highlighted.
             *
             * @instance
             * @private
             * @memberof TMPro.TMP_InputField
             * @type TMPro.TMP_InputField.TextSelectionEvent
             */
            m_OnEndTextSelection: null,
            /**
             * Event delegates triggered when the input field changes its data.
             *
             * @instance
             * @private
             * @memberof TMPro.TMP_InputField
             * @type TMPro.TMP_InputField.OnChangeEvent
             */
            m_OnValueChanged: null,
            /**
             * Event delegates triggered when the status of the TouchScreenKeyboard changes.
             *
             * @instance
             * @private
             * @memberof TMPro.TMP_InputField
             * @type TMPro.TMP_InputField.TouchScreenKeyboardEvent
             */
            m_OnTouchScreenKeyboardStatusChanged: null,
            /**
             * Custom validation callback.
             *
             * @instance
             * @private
             * @memberof TMPro.TMP_InputField
             * @type TMPro.TMP_InputField.OnValidateInput
             */
            m_OnValidateInput: null,
            m_CaretColor: null,
            m_CustomCaretColor: false,
            m_SelectionColor: null,
            /**
             * Input field's value.
             *
             * @instance
             * @protected
             * @memberof TMPro.TMP_InputField
             * @default ""
             * @type string
             */
            m_Text: null,
            m_CaretBlinkRate: 0,
            m_CaretWidth: 0,
            m_ReadOnly: false,
            m_RichText: false,
            m_StringPosition: 0,
            m_StringSelectPosition: 0,
            m_CaretPosition: 0,
            m_CaretSelectPosition: 0,
            caretRectTrans: null,
            m_CursorVerts: null,
            m_CachedInputRenderer: null,
            m_LastPosition: null,
            m_Mesh: null,
            m_AllowInput: false,
            m_ShouldActivateNextUpdate: false,
            m_UpdateDrag: false,
            m_DragPositionOutOfBounds: false,
            m_CaretVisible: false,
            m_BlinkCoroutine: null,
            m_BlinkStartTime: 0,
            m_DragCoroutine: null,
            m_OriginalText: null,
            m_WasCanceled: false,
            m_HasDoneFocusTransition: false,
            m_WaitForSecondsRealtime: null,
            m_PreventCallback: false,
            m_TouchKeyboardAllowsInPlaceEditing: false,
            m_IsTextComponentUpdateRequired: false,
            m_isLastKeyBackspace: false,
            m_PointerDownClickStartTime: 0,
            m_KeyDownStartTime: 0,
            m_DoubleClickDelay: 0,
            m_IsCompositionActive: false,
            m_ShouldUpdateIMEWindowPosition: false,
            m_PreviousIMEInsertionLine: 0,
            m_GlobalFontAsset: null,
            m_OnFocusSelectAll: false,
            m_isSelectAll: false,
            m_ResetOnDeActivation: false,
            m_SelectionStillActive: false,
            m_ReleaseSelection: false,
            m_PreviouslySelectedObject: null,
            m_RestoreOriginalTextOnEscape: false,
            m_isRichTextEditingAllowed: false,
            m_LineLimit: 0,
            m_InputValidator: null,
            m_isSelected: false,
            m_IsStringPositionDirty: false,
            m_IsCaretPositionDirty: false,
            m_forceRectTransformAdjustment: false,
            /**
             * Handle the specified event.
             *
             * @instance
             * @private
             * @memberof TMPro.TMP_InputField
             * @type ( pc.stubProxy.generateConstructorFor( 'UnityEngine.Event' ) )
             */
            m_ProcessingEvent: null
        },
        props: {
            inputSystem: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#inputSystem#get", this ); }

                    if (UnityEngine.Object.op_Implicit(UnityEngine.EventSystems.EventSystem.current) && UnityEngine.Object.op_Implicit(UnityEngine.EventSystems.EventSystem.current.currentInputModule)) {
                        return UnityEngine.EventSystems.EventSystem.current.currentInputModule.input;
                    }

                    return null;
                }
            },
            compositionString: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#compositionString#get", this ); }

                    return UnityEngine.MonoBehaviour.op_Inequality(this.inputSystem, null) ? this.inputSystem.compositionString : UnityEngine.Input.compositionString;
                }
            },
            compositionLength: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#compositionLength#get", this ); }

                    if (this.m_ReadOnly) {
                        return 0;
                    }

                    return this.compositionString.length;
                }
            },
            mesh: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#mesh#get", this ); }

                    if (this.m_Mesh == null) {
                        this.m_Mesh = new UnityEngine.Mesh.ctor();
                    }

                    return this.m_Mesh;
                }
            },
            /**
             * Should the mobile keyboard input be hidden.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_InputField
             * @function shouldHideMobileInput
             * @type boolean
             */
            shouldHideMobileInput: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#shouldHideMobileInput#get", this ); }

                    switch (UnityEngine.Application.platform) {
                        case UnityEngine.RuntimePlatform.Android: 
                        case UnityEngine.RuntimePlatform.IPhonePlayer: 
                        case UnityEngine.RuntimePlatform.tvOS: 
                            return this.m_HideMobileInput;
                        default: 
                            return true;
                    }
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#shouldHideMobileInput#set", this ); }

                    switch (UnityEngine.Application.platform) {
                        case UnityEngine.RuntimePlatform.Android: 
                        case UnityEngine.RuntimePlatform.IPhonePlayer: 
                        case UnityEngine.RuntimePlatform.tvOS: 
                            TMPro.SetPropertyUtility.SetStruct(System.Boolean, Bridge.ref(this, "m_HideMobileInput"), value);
                            break;
                        default: 
                            this.m_HideMobileInput = true;
                            break;
                    }
                }
            },
            shouldHideSoftKeyboard: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#shouldHideSoftKeyboard#get", this ); }

                    switch (UnityEngine.Application.platform) {
                        case UnityEngine.RuntimePlatform.Android: 
                        case UnityEngine.RuntimePlatform.IPhonePlayer: 
                        case UnityEngine.RuntimePlatform.tvOS: 
                        case UnityEngine.RuntimePlatform.WSAPlayerX86: 
                        case UnityEngine.RuntimePlatform.WSAPlayerX64: 
                        case UnityEngine.RuntimePlatform.WSAPlayerARM: 
                        default: 
                            return true;
                    }
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#shouldHideSoftKeyboard#set", this ); }

                    switch (UnityEngine.Application.platform) {
                        case UnityEngine.RuntimePlatform.Android: 
                        case UnityEngine.RuntimePlatform.IPhonePlayer: 
                        case UnityEngine.RuntimePlatform.tvOS: 
                        case UnityEngine.RuntimePlatform.WSAPlayerX86: 
                        case UnityEngine.RuntimePlatform.WSAPlayerX64: 
                        case UnityEngine.RuntimePlatform.WSAPlayerARM: 
                        default: 
                            this.m_HideSoftKeyboard = true;
                            break;
                    }

                    if (this.m_HideSoftKeyboard === true && this.m_SoftKeyboard != null && UnityEngine.TouchScreenKeyboard.isSupported && this.m_SoftKeyboard.active) {
                        this.m_SoftKeyboard.active = false;
                        this.m_SoftKeyboard = null;
                    }
                }
            },
            /**
             * Input field's current text value. This is not necessarily the same as what is visible on screen.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_InputField
             * @function text
             * @type string
             * @example
             *
             * using UnityEngine;
             * using System.Collections;
             * using UnityEngine.UI; // Required when Using UI elements.
             * public class Example : MonoBehaviour
             * {
             *     public InputField mainInputField;
             *     public void Start()
             *     {
             *         mainInputField.text = "Enter Text Here...";
             *     }
             * }
             * 
             *
             *
             */
            text: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#text#get", this ); }

                    return this.m_Text;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#text#set", this ); }

                    this.SetText(value);
                }
            },
            isFocused: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#isFocused#get", this ); }

                    return this.m_AllowInput;
                }
            },
            caretBlinkRate: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#caretBlinkRate#get", this ); }

                    return this.m_CaretBlinkRate;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#caretBlinkRate#set", this ); }

                    if (TMPro.SetPropertyUtility.SetStruct(System.Single, Bridge.ref(this, "m_CaretBlinkRate"), value)) {
                        if (this.m_AllowInput) {
                            this.SetCaretActive();
                        }
                    }
                }
            },
            caretWidth: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#caretWidth#get", this ); }

                    return this.m_CaretWidth;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#caretWidth#set", this ); }

                    if (TMPro.SetPropertyUtility.SetStruct(System.Int32, Bridge.ref(this, "m_CaretWidth"), value)) {
                        this.MarkGeometryAsDirty();
                    }
                }
            },
            textViewport: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#textViewport#get", this ); }

                    return this.m_TextViewport;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#textViewport#set", this ); }

                    TMPro.SetPropertyUtility.SetClass(UnityEngine.RectTransform, Bridge.ref(this, "m_TextViewport"), value);
                }
            },
            textComponent: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#textComponent#get", this ); }

                    return this.m_TextComponent;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#textComponent#set", this ); }

                    if (TMPro.SetPropertyUtility.SetClass(TMPro.TMP_Text, Bridge.ref(this, "m_TextComponent"), value)) {
                        this.SetTextComponentWrapMode();
                    }
                }
            },
            placeholder: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#placeholder#get", this ); }

                    return this.m_Placeholder;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#placeholder#set", this ); }

                    TMPro.SetPropertyUtility.SetClass(UnityEngine.UI.Graphic, Bridge.ref(this, "m_Placeholder"), value);
                }
            },
            verticalScrollbar: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#verticalScrollbar#get", this ); }

                    return this.m_VerticalScrollbar;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#verticalScrollbar#set", this ); }

                    if (UnityEngine.MonoBehaviour.op_Inequality(this.m_VerticalScrollbar, null)) {
                        this.m_VerticalScrollbar.onValueChanged.RemoveListener(Bridge.fn.cacheBind(this, this.OnScrollbarValueChange));
                    }

                    TMPro.SetPropertyUtility.SetClass(UnityEngine.UI.Scrollbar, Bridge.ref(this, "m_VerticalScrollbar"), value);
                    if (UnityEngine.Object.op_Implicit(this.m_VerticalScrollbar)) {
                        this.m_VerticalScrollbar.onValueChanged.AddListener(Bridge.fn.cacheBind(this, this.OnScrollbarValueChange));
                    }
                }
            },
            scrollSensitivity: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#scrollSensitivity#get", this ); }

                    return this.m_ScrollSensitivity;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#scrollSensitivity#set", this ); }

                    if (TMPro.SetPropertyUtility.SetStruct(System.Single, Bridge.ref(this, "m_ScrollSensitivity"), value)) {
                        this.MarkGeometryAsDirty();
                    }
                }
            },
            caretColor: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#caretColor#get", this ); }

                    return this.customCaretColor ? this.m_CaretColor.$clone() : this.textComponent.color.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#caretColor#set", this ); }

                    if (TMPro.SetPropertyUtility.SetColor(Bridge.ref(this, "m_CaretColor"), value.$clone())) {
                        this.MarkGeometryAsDirty();
                    }
                }
            },
            customCaretColor: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#customCaretColor#get", this ); }

                    return this.m_CustomCaretColor;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#customCaretColor#set", this ); }

                    if (this.m_CustomCaretColor !== value) {
                        this.m_CustomCaretColor = value;
                        this.MarkGeometryAsDirty();
                    }
                }
            },
            selectionColor: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#selectionColor#get", this ); }

                    return this.m_SelectionColor.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#selectionColor#set", this ); }

                    if (TMPro.SetPropertyUtility.SetColor(Bridge.ref(this, "m_SelectionColor"), value.$clone())) {
                        this.MarkGeometryAsDirty();
                    }
                }
            },
            onEndEdit: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#onEndEdit#get", this ); }

                    return this.m_OnEndEdit;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#onEndEdit#set", this ); }

                    TMPro.SetPropertyUtility.SetClass(TMPro.TMP_InputField.SubmitEvent, Bridge.ref(this, "m_OnEndEdit"), value);
                }
            },
            onSubmit: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#onSubmit#get", this ); }

                    return this.m_OnSubmit;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#onSubmit#set", this ); }

                    TMPro.SetPropertyUtility.SetClass(TMPro.TMP_InputField.SubmitEvent, Bridge.ref(this, "m_OnSubmit"), value);
                }
            },
            onSelect: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#onSelect#get", this ); }

                    return this.m_OnSelect;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#onSelect#set", this ); }

                    TMPro.SetPropertyUtility.SetClass(TMPro.TMP_InputField.SelectionEvent, Bridge.ref(this, "m_OnSelect"), value);
                }
            },
            onDeselect: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#onDeselect#get", this ); }

                    return this.m_OnDeselect;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#onDeselect#set", this ); }

                    TMPro.SetPropertyUtility.SetClass(TMPro.TMP_InputField.SelectionEvent, Bridge.ref(this, "m_OnDeselect"), value);
                }
            },
            onTextSelection: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#onTextSelection#get", this ); }

                    return this.m_OnTextSelection;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#onTextSelection#set", this ); }

                    TMPro.SetPropertyUtility.SetClass(TMPro.TMP_InputField.TextSelectionEvent, Bridge.ref(this, "m_OnTextSelection"), value);
                }
            },
            onEndTextSelection: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#onEndTextSelection#get", this ); }

                    return this.m_OnEndTextSelection;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#onEndTextSelection#set", this ); }

                    TMPro.SetPropertyUtility.SetClass(TMPro.TMP_InputField.TextSelectionEvent, Bridge.ref(this, "m_OnEndTextSelection"), value);
                }
            },
            onValueChanged: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#onValueChanged#get", this ); }

                    return this.m_OnValueChanged;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#onValueChanged#set", this ); }

                    TMPro.SetPropertyUtility.SetClass(TMPro.TMP_InputField.OnChangeEvent, Bridge.ref(this, "m_OnValueChanged"), value);
                }
            },
            onTouchScreenKeyboardStatusChanged: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#onTouchScreenKeyboardStatusChanged#get", this ); }

                    return this.m_OnTouchScreenKeyboardStatusChanged;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#onTouchScreenKeyboardStatusChanged#set", this ); }

                    TMPro.SetPropertyUtility.SetClass(TMPro.TMP_InputField.TouchScreenKeyboardEvent, Bridge.ref(this, "m_OnTouchScreenKeyboardStatusChanged"), value);
                }
            },
            onValidateInput: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#onValidateInput#get", this ); }

                    return this.m_OnValidateInput;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#onValidateInput#set", this ); }

                    TMPro.SetPropertyUtility.SetClass(Function, Bridge.ref(this, "m_OnValidateInput"), value);
                }
            },
            characterLimit: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#characterLimit#get", this ); }

                    return this.m_CharacterLimit;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#characterLimit#set", this ); }

                    if (TMPro.SetPropertyUtility.SetStruct(System.Int32, Bridge.ref(this, "m_CharacterLimit"), Math.max(0, value))) {
                        this.UpdateLabel();
                        if (this.m_SoftKeyboard != null) {
                            this.m_SoftKeyboard.characterLimit = value;
                        }
                    }
                }
            },
            /**
             * Set the point size on both Placeholder and Input text object.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_InputField
             * @function pointSize
             * @type number
             */
            pointSize: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#pointSize#get", this ); }

                    return this.m_GlobalPointSize;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#pointSize#set", this ); }

                    if (TMPro.SetPropertyUtility.SetStruct(System.Single, Bridge.ref(this, "m_GlobalPointSize"), Math.max(0, value))) {
                        this.SetGlobalPointSize(this.m_GlobalPointSize);
                        this.UpdateLabel();
                    }
                }
            },
            /**
             * Sets the Font Asset on both Placeholder and Input child objects.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_InputField
             * @function fontAsset
             * @type TMPro.TMP_FontAsset
             */
            fontAsset: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#fontAsset#get", this ); }

                    return this.m_GlobalFontAsset;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#fontAsset#set", this ); }

                    if (TMPro.SetPropertyUtility.SetClass(TMPro.TMP_FontAsset, Bridge.ref(this, "m_GlobalFontAsset"), value)) {
                        this.SetGlobalFontAsset(this.m_GlobalFontAsset);
                        this.UpdateLabel();
                    }
                }
            },
            /**
             * Determines if the whole text will be selected when focused.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_InputField
             * @function onFocusSelectAll
             * @type boolean
             */
            onFocusSelectAll: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#onFocusSelectAll#get", this ); }

                    return this.m_OnFocusSelectAll;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#onFocusSelectAll#set", this ); }

                    this.m_OnFocusSelectAll = value;
                }
            },
            /**
             * Determines if the text and caret position as well as selection will be reset when the input field is deactivated.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_InputField
             * @function resetOnDeActivation
             * @type boolean
             */
            resetOnDeActivation: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#resetOnDeActivation#get", this ); }

                    return this.m_ResetOnDeActivation;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#resetOnDeActivation#set", this ); }

                    this.m_ResetOnDeActivation = value;
                }
            },
            /**
             * Controls whether the original text is restored when pressing "ESC".
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_InputField
             * @function restoreOriginalTextOnEscape
             * @type boolean
             */
            restoreOriginalTextOnEscape: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#restoreOriginalTextOnEscape#get", this ); }

                    return this.m_RestoreOriginalTextOnEscape;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#restoreOriginalTextOnEscape#set", this ); }

                    this.m_RestoreOriginalTextOnEscape = value;
                }
            },
            /**
             * Is Rich Text editing allowed?
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_InputField
             * @function isRichTextEditingAllowed
             * @type boolean
             */
            isRichTextEditingAllowed: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#isRichTextEditingAllowed#get", this ); }

                    return this.m_isRichTextEditingAllowed;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#isRichTextEditingAllowed#set", this ); }

                    this.m_isRichTextEditingAllowed = value;
                }
            },
            contentType: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#contentType#get", this ); }

                    return this.m_ContentType;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#contentType#set", this ); }

                    if (TMPro.SetPropertyUtility.SetStruct(TMPro.TMP_InputField.ContentType, Bridge.ref(this, "m_ContentType"), value)) {
                        this.EnforceContentType();
                    }
                }
            },
            lineType: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#lineType#get", this ); }

                    return this.m_LineType;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#lineType#set", this ); }

                    if (TMPro.SetPropertyUtility.SetStruct(TMPro.TMP_InputField.LineType, Bridge.ref(this, "m_LineType"), value)) {
                        this.SetToCustomIfContentTypeIsNot([TMPro.TMP_InputField.ContentType.Standard, TMPro.TMP_InputField.ContentType.Autocorrected]);
                        this.SetTextComponentWrapMode();
                    }
                }
            },
            /**
             * Limits the number of lines of text in the Input Field.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_InputField
             * @function lineLimit
             * @type number
             */
            lineLimit: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#lineLimit#get", this ); }

                    return this.m_LineLimit;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#lineLimit#set", this ); }

                    if (this.m_LineType === TMPro.TMP_InputField.LineType.SingleLine) {
                        this.m_LineLimit = 1;
                    } else {
                        TMPro.SetPropertyUtility.SetStruct(System.Int32, Bridge.ref(this, "m_LineLimit"), value);
                    }
                }
            },
            inputType: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#inputType#get", this ); }

                    return this.m_InputType;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#inputType#set", this ); }

                    if (TMPro.SetPropertyUtility.SetStruct(TMPro.TMP_InputField.InputType, Bridge.ref(this, "m_InputType"), value)) {
                        this.SetToCustom();
                    }
                }
            },
            keyboardType: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#keyboardType#get", this ); }

                    return this.m_KeyboardType;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#keyboardType#set", this ); }

                    if (TMPro.SetPropertyUtility.SetStruct(UnityEngine.TouchScreenKeyboardType, Bridge.ref(this, "m_KeyboardType"), value)) {
                        this.SetToCustom();
                    }
                }
            },
            characterValidation: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#characterValidation#get", this ); }

                    return this.m_CharacterValidation;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#characterValidation#set", this ); }

                    if (TMPro.SetPropertyUtility.SetStruct(TMPro.TMP_InputField.CharacterValidation, Bridge.ref(this, "m_CharacterValidation"), value)) {
                        this.SetToCustom();
                    }
                }
            },
            /**
             * Sets the Input Validation to use a Custom Input Validation script.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_InputField
             * @function inputValidator
             * @type TMPro.TMP_InputValidator
             */
            inputValidator: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#inputValidator#get", this ); }

                    return this.m_InputValidator;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#inputValidator#set", this ); }

                    if (TMPro.SetPropertyUtility.SetClass(TMPro.TMP_InputValidator, Bridge.ref(this, "m_InputValidator"), value)) {
                        this.SetToCustom$1(TMPro.TMP_InputField.CharacterValidation.CustomValidator);
                    }
                }
            },
            readOnly: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#readOnly#get", this ); }

                    return this.m_ReadOnly;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#readOnly#set", this ); }

                    this.m_ReadOnly = value;
                }
            },
            richText: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#richText#get", this ); }

                    return this.m_RichText;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#richText#set", this ); }

                    this.m_RichText = value;
                    this.SetTextComponentRichTextMode();
                }
            },
            multiLine: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#multiLine#get", this ); }

                    return this.m_LineType === TMPro.TMP_InputField.LineType.MultiLineNewline || this.lineType === TMPro.TMP_InputField.LineType.MultiLineSubmit;
                }
            },
            asteriskChar: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#asteriskChar#get", this ); }

                    return this.m_AsteriskChar;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#asteriskChar#set", this ); }

                    if (TMPro.SetPropertyUtility.SetStruct(System.Char, Bridge.ref(this, "m_AsteriskChar"), value)) {
                        this.UpdateLabel();
                    }
                }
            },
            wasCanceled: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#wasCanceled#get", this ); }

                    return this.m_WasCanceled;
                }
            },
            /**
             * Current position of the cursor.
             Getters are public Setters are protected
             *
             * @instance
             * @protected
             * @memberof TMPro.TMP_InputField
             * @function caretPositionInternal
             * @type number
             */
            caretPositionInternal: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#caretPositionInternal#get", this ); }

                    return this.m_CaretPosition + this.compositionLength;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#caretPositionInternal#set", this ); }

                    this.m_CaretPosition = value;
                    this.ClampCaretPos(Bridge.ref(this, "m_CaretPosition"));
                }
            },
            stringPositionInternal: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#stringPositionInternal#get", this ); }

                    return this.m_StringPosition + this.compositionLength;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#stringPositionInternal#set", this ); }

                    this.m_StringPosition = value;
                    this.ClampStringPos(Bridge.ref(this, "m_StringPosition"));
                }
            },
            caretSelectPositionInternal: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#caretSelectPositionInternal#get", this ); }

                    return this.m_CaretSelectPosition + this.compositionLength;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#caretSelectPositionInternal#set", this ); }

                    this.m_CaretSelectPosition = value;
                    this.ClampCaretPos(Bridge.ref(this, "m_CaretSelectPosition"));
                }
            },
            stringSelectPositionInternal: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#stringSelectPositionInternal#get", this ); }

                    return this.m_StringSelectPosition + this.compositionLength;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#stringSelectPositionInternal#set", this ); }

                    this.m_StringSelectPosition = value;
                    this.ClampStringPos(Bridge.ref(this, "m_StringSelectPosition"));
                }
            },
            hasSelection$1: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#hasSelection$1#get", this ); }

                    return this.stringPositionInternal !== this.stringSelectPositionInternal;
                }
            },
            /**
             * Get: Returns the focus position as thats the position that moves around even during selection.
             Set: Set both the anchor and focus position such that a selection doesn't happen
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_InputField
             * @function caretPosition
             * @type number
             */
            caretPosition: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#caretPosition#get", this ); }

                    return this.caretSelectPositionInternal;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#caretPosition#set", this ); }

                    this.selectionAnchorPosition = value;
                    this.selectionFocusPosition = value;
                    this.m_IsStringPositionDirty = true;
                }
            },
            /**
             * Get: Returns the fixed position of selection
             Set: If compositionString is 0 set the fixed position
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_InputField
             * @function selectionAnchorPosition
             * @type number
             */
            selectionAnchorPosition: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#selectionAnchorPosition#get", this ); }

                    return this.caretPositionInternal;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#selectionAnchorPosition#set", this ); }

                    if (this.compositionLength !== 0) {
                        return;
                    }

                    this.caretPositionInternal = value;
                    this.m_IsStringPositionDirty = true;
                }
            },
            /**
             * Get: Returns the variable position of selection
             Set: If compositionString is 0 set the variable position
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_InputField
             * @function selectionFocusPosition
             * @type number
             */
            selectionFocusPosition: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#selectionFocusPosition#get", this ); }

                    return this.caretSelectPositionInternal;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#selectionFocusPosition#set", this ); }

                    if (this.compositionLength !== 0) {
                        return;
                    }

                    this.caretSelectPositionInternal = value;
                    this.m_IsStringPositionDirty = true;
                }
            },
            /**
             * @instance
             * @public
             * @memberof TMPro.TMP_InputField
             * @function stringPosition
             * @type number
             */
            stringPosition: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#stringPosition#get", this ); }

                    return this.stringSelectPositionInternal;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#stringPosition#set", this ); }

                    this.selectionStringAnchorPosition = value;
                    this.selectionStringFocusPosition = value;
                    this.m_IsCaretPositionDirty = true;
                }
            },
            /**
             * The fixed position of the selection in the raw string which may contains rich text.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_InputField
             * @function selectionStringAnchorPosition
             * @type number
             */
            selectionStringAnchorPosition: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#selectionStringAnchorPosition#get", this ); }

                    return this.stringPositionInternal;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#selectionStringAnchorPosition#set", this ); }

                    if (this.compositionLength !== 0) {
                        return;
                    }

                    this.stringPositionInternal = value;
                    this.m_IsCaretPositionDirty = true;
                }
            },
            /**
             * The variable position of the selection in the raw string which may contains rich text.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_InputField
             * @function selectionStringFocusPosition
             * @type number
             */
            selectionStringFocusPosition: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#selectionStringFocusPosition#get", this ); }

                    return this.stringSelectPositionInternal;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#selectionStringFocusPosition#set", this ); }

                    if (this.compositionLength !== 0) {
                        return;
                    }

                    this.stringSelectPositionInternal = value;
                    this.m_IsCaretPositionDirty = true;
                }
            },
            /**
             * See ILayoutElement.minWidth.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_InputField
             * @function minWidth
             * @type number
             */
            minWidth: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#minWidth#get", this ); }

                    return 0;
                }
            },
            /**
             * Get the displayed with of all input characters.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_InputField
             * @function preferredWidth
             * @type number
             */
            preferredWidth: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#preferredWidth#get", this ); }

                    if (UnityEngine.MonoBehaviour.op_Equality(this.textComponent, null)) {
                        return 0;
                    }

                    var horizontalPadding = 0;

                    if (UnityEngine.MonoBehaviour.op_Inequality(this.m_LayoutGroup, null)) {
                        horizontalPadding = this.m_LayoutGroup.padding.horizontal;
                    }

                    if (UnityEngine.Component.op_Inequality(this.m_TextViewport, null)) {
                        horizontalPadding += this.m_TextViewport.offsetMin.x - this.m_TextViewport.offsetMax.x;
                    }

                    return this.m_TextComponent.preferredWidth + horizontalPadding; // Should add some extra padding for caret
                }
            },
            /**
             * See ILayoutElement.flexibleWidth.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_InputField
             * @function flexibleWidth
             * @type number
             */
            flexibleWidth: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#flexibleWidth#get", this ); }

                    return -1;
                }
            },
            /**
             * See ILayoutElement.minHeight.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_InputField
             * @function minHeight
             * @type number
             */
            minHeight: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#minHeight#get", this ); }

                    return 0;
                }
            },
            /**
             * Get the height of all the text if constrained to the height of the RectTransform.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_InputField
             * @function preferredHeight
             * @type number
             */
            preferredHeight: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#preferredHeight#get", this ); }

                    if (UnityEngine.MonoBehaviour.op_Equality(this.textComponent, null)) {
                        return 0;
                    }

                    var verticalPadding = 0;

                    if (UnityEngine.MonoBehaviour.op_Inequality(this.m_LayoutGroup, null)) {
                        verticalPadding = this.m_LayoutGroup.padding.vertical;
                    }

                    if (UnityEngine.Component.op_Inequality(this.m_TextViewport, null)) {
                        verticalPadding += this.m_TextViewport.offsetMin.y - this.m_TextViewport.offsetMax.y;
                    }

                    return this.m_TextComponent.preferredHeight + verticalPadding;
                }
            },
            /**
             * See ILayoutElement.flexibleHeight.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_InputField
             * @function flexibleHeight
             * @type number
             */
            flexibleHeight: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#flexibleHeight#get", this ); }

                    return -1;
                }
            },
            /**
             * See ILayoutElement.layoutPriority.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_InputField
             * @function layoutPriority
             * @type number
             */
            layoutPriority: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#layoutPriority#get", this ); }

                    return 1;
                }
            }
        },
        alias: [
            "OnBeginDrag", "UnityEngine$EventSystems$IBeginDragHandler$OnBeginDrag",
            "OnDrag", "UnityEngine$EventSystems$IDragHandler$OnDrag",
            "OnEndDrag", "UnityEngine$EventSystems$IEndDragHandler$OnEndDrag",
            "OnPointerDown", "UnityEngine$EventSystems$IPointerDownHandler$OnPointerDown",
            "OnUpdateSelected", "UnityEngine$EventSystems$IUpdateSelectedHandler$OnUpdateSelected",
            "OnScroll", "UnityEngine$EventSystems$IScrollHandler$OnScroll",
            "Rebuild", "UnityEngine$UI$ICanvasElement$Rebuild",
            "LayoutComplete", "UnityEngine$UI$ICanvasElement$LayoutComplete",
            "GraphicUpdateComplete", "UnityEngine$UI$ICanvasElement$GraphicUpdateComplete",
            "OnSelect", "UnityEngine$EventSystems$ISelectHandler$OnSelect",
            "OnPointerClick", "UnityEngine$EventSystems$IPointerClickHandler$OnPointerClick",
            "OnDeselect", "UnityEngine$EventSystems$IDeselectHandler$OnDeselect",
            "OnSubmit", "UnityEngine$EventSystems$ISubmitHandler$OnSubmit",
            "CalculateLayoutInputHorizontal", "UnityEngine$UI$ILayoutElement$CalculateLayoutInputHorizontal",
            "CalculateLayoutInputVertical", "UnityEngine$UI$ILayoutElement$CalculateLayoutInputVertical",
            "minWidth", "UnityEngine$UI$ILayoutElement$minWidth",
            "preferredWidth", "UnityEngine$UI$ILayoutElement$preferredWidth",
            "flexibleWidth", "UnityEngine$UI$ILayoutElement$flexibleWidth",
            "minHeight", "UnityEngine$UI$ILayoutElement$minHeight",
            "preferredHeight", "UnityEngine$UI$ILayoutElement$preferredHeight",
            "flexibleHeight", "UnityEngine$UI$ILayoutElement$flexibleHeight",
            "layoutPriority", "UnityEngine$UI$ILayoutElement$layoutPriority",
            "IsDestroyed", "UnityEngine$UI$ICanvasElement$IsDestroyed",
            "transform", "UnityEngine$UI$ICanvasElement$transform"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#init", this ); }

                this.m_CachedViewportRect = new UnityEngine.Rect();
                this.m_CaretColor = new UnityEngine.Color();
                this.m_SelectionColor = new UnityEngine.Color();
                this.m_LastPosition = new UnityEngine.Vector2();
                this.m_IsDrivenByLayoutComponents = false;
                this.m_ScrollSensitivity = 1.0;
                this.m_ContentType = TMPro.TMP_InputField.ContentType.Standard;
                this.m_InputType = TMPro.TMP_InputField.InputType.Standard;
                this.m_AsteriskChar = 42;
                this.m_KeyboardType = UnityEngine.TouchScreenKeyboardType.Default;
                this.m_LineType = TMPro.TMP_InputField.LineType.SingleLine;
                this.m_HideMobileInput = false;
                this.m_HideSoftKeyboard = false;
                this.m_CharacterValidation = TMPro.TMP_InputField.CharacterValidation.None;
                this.m_RegexValue = "";
                this.m_GlobalPointSize = 14;
                this.m_CharacterLimit = 0;
                this.m_OnEndEdit = new TMPro.TMP_InputField.SubmitEvent();
                this.m_OnSubmit = new TMPro.TMP_InputField.SubmitEvent();
                this.m_OnSelect = new TMPro.TMP_InputField.SelectionEvent();
                this.m_OnDeselect = new TMPro.TMP_InputField.SelectionEvent();
                this.m_OnTextSelection = new TMPro.TMP_InputField.TextSelectionEvent();
                this.m_OnEndTextSelection = new TMPro.TMP_InputField.TextSelectionEvent();
                this.m_OnValueChanged = new TMPro.TMP_InputField.OnChangeEvent();
                this.m_OnTouchScreenKeyboardStatusChanged = new TMPro.TMP_InputField.TouchScreenKeyboardEvent();
                this.m_CaretColor = new pc.Color( 0.196078435, 0.196078435, 0.196078435, 1.0 );
                this.m_CustomCaretColor = false;
                this.m_SelectionColor = new pc.Color( 0.65882355, 0.807843149, 1.0, 0.7529412 );
                this.m_Text = "";
                this.m_CaretBlinkRate = 0.85;
                this.m_CaretWidth = 1;
                this.m_ReadOnly = false;
                this.m_RichText = true;
                this.m_StringPosition = 0;
                this.m_StringSelectPosition = 0;
                this.m_CaretPosition = 0;
                this.m_CaretSelectPosition = 0;
                this.m_AllowInput = false;
                this.m_ShouldActivateNextUpdate = false;
                this.m_UpdateDrag = false;
                this.m_DragPositionOutOfBounds = false;
                this.m_BlinkStartTime = 0.0;
                this.m_OriginalText = "";
                this.m_WasCanceled = false;
                this.m_HasDoneFocusTransition = false;
                this.m_PreventCallback = false;
                this.m_TouchKeyboardAllowsInPlaceEditing = false;
                this.m_IsTextComponentUpdateRequired = false;
                this.m_isLastKeyBackspace = false;
                this.m_DoubleClickDelay = 0.5;
                this.m_IsCompositionActive = false;
                this.m_ShouldUpdateIMEWindowPosition = false;
                this.m_PreviousIMEInsertionLine = 0;
                this.m_OnFocusSelectAll = true;
                this.m_ResetOnDeActivation = true;
                this.m_SelectionStillActive = false;
                this.m_ReleaseSelection = false;
                this.m_RestoreOriginalTextOnEscape = true;
                this.m_isRichTextEditingAllowed = false;
                this.m_LineLimit = 0;
                this.m_ProcessingEvent = ( pc.generateStubProxy( 'UnityEngine.Event' ) );
            },
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#ctor", this ); }

                this.$initialize();
                UnityEngine.UI.Selectable.ctor.call(this);
                this.SetTextComponentWrapMode();
            }
        },
        methods: {
            /*TMPro.TMP_InputField.isKeyboardUsingEvents start.*/
            isKeyboardUsingEvents: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#isKeyboardUsingEvents", this ); }

                switch (UnityEngine.Application.platform) {
                    case UnityEngine.RuntimePlatform.Android: 
                    case UnityEngine.RuntimePlatform.IPhonePlayer: 
                    case UnityEngine.RuntimePlatform.tvOS: 
                    default: 
                        return true;
                }
            },
            /*TMPro.TMP_InputField.isKeyboardUsingEvents end.*/

            /*TMPro.TMP_InputField.SetTextWithoutNotify start.*/
            /**
             * Set Input field's current text value without invoke onValueChanged. This is not necessarily the same as what is visible on screen.
             *
             * @instance
             * @public
             * @this TMPro.TMP_InputField
             * @memberof TMPro.TMP_InputField
             * @param   {string}    input
             * @return  {void}
             */
            SetTextWithoutNotify: function (input) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#SetTextWithoutNotify", this ); }

                this.SetText(input, false);
            },
            /*TMPro.TMP_InputField.SetTextWithoutNotify end.*/

            /*TMPro.TMP_InputField.SetText start.*/
            SetText: function (value, sendCallback) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#SetText", this ); }

                if (sendCallback === void 0) { sendCallback = true; }
                if (Bridge.referenceEquals(this.text, value)) {
                    return;
                }

                if (value == null) {
                    value = "";
                }

                value = System.String.replaceAll(value, "\u0000", ""); // remove embedded nulls

                this.m_Text = value;

                /* 
                if (m_LineType == LineType.SingleLine)
                   value = value.Replace("\n", "").Replace("\t", "");

                // If we have an input validator, validate the input and apply the character limit at the same time.
                if (onValidateInput != null || characterValidation != CharacterValidation.None)
                {
                   m_Text = "";
                   OnValidateInput validatorMethod = onValidateInput ?? Validate;
                   m_CaretPosition = m_CaretSelectPosition = value.Length;
                   int charactersToCheck = characterLimit > 0 ? Math.Min(characterLimit, value.Length) : value.Length;
                   for (int i = 0; i < charactersToCheck; ++i)
                   {
                       char c = validatorMethod(m_Text, m_Text.Length, value[i]);
                       if (c != 0)
                           m_Text += c;
                   }
                }
                else
                {
                   m_Text = characterLimit > 0 && value.Length > characterLimit ? value.Substring(0, characterLimit) : value;
                }
                */


                if (this.m_SoftKeyboard != null) {
                    this.m_SoftKeyboard.text = this.m_Text;
                }

                if (this.m_StringPosition > this.m_Text.length) {
                    this.m_StringPosition = (this.m_StringSelectPosition = this.m_Text.length);
                } else if (this.m_StringSelectPosition > this.m_Text.length) {
                    this.m_StringSelectPosition = this.m_Text.length;
                }

                this.m_forceRectTransformAdjustment = true;

                this.m_IsTextComponentUpdateRequired = true;
                this.UpdateLabel();

                if (sendCallback) {
                    this.SendOnValueChanged();
                }
            },
            /*TMPro.TMP_InputField.SetText end.*/

            /*TMPro.TMP_InputField.ClampStringPos start.*/
            ClampStringPos: function (pos) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#ClampStringPos", this ); }

                if (pos.v < 0) {
                    pos.v = 0;
                } else if (pos.v > this.text.length) {
                    pos.v = this.text.length;
                }
            },
            /*TMPro.TMP_InputField.ClampStringPos end.*/

            /*TMPro.TMP_InputField.ClampCaretPos start.*/
            ClampCaretPos: function (pos) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#ClampCaretPos", this ); }

                if (pos.v < 0) {
                    pos.v = 0;
                } else if (pos.v > this.m_TextComponent.textInfo.characterCount - 1) {
                    pos.v = this.m_TextComponent.textInfo.characterCount - 1;
                }
            },
            /*TMPro.TMP_InputField.ClampCaretPos end.*/

            /*TMPro.TMP_InputField.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#OnEnable", this ); }

                //Debug.Log("*** OnEnable() *** - " + this.name);

                UnityEngine.UI.Selectable.prototype.OnEnable.call(this);

                if (this.m_Text == null) {
                    this.m_Text = "";
                }

                // Check if Input Field is driven by any layout components
                var layoutController = this.GetComponent(UnityEngine.UI.ILayoutController);

                if (layoutController != null) {
                    this.m_IsDrivenByLayoutComponents = true;
                    this.m_LayoutGroup = this.GetComponent(UnityEngine.UI.LayoutGroup);
                } else {
                    this.m_IsDrivenByLayoutComponents = false;
                }

                if (UnityEngine.Application.isPlaying) {
                    if (UnityEngine.Component.op_Equality(this.m_CachedInputRenderer, null) && UnityEngine.MonoBehaviour.op_Inequality(this.m_TextComponent, null)) {
                        var go = new UnityEngine.GameObject.$ctor3("Caret", TMPro.TMP_SelectionCaret);

                        go.hideFlags = UnityEngine.HideFlags.DontSave;
                        go.transform.SetParent(this.m_TextComponent.transform$1.parent);
                        go.transform.SetAsFirstSibling();
                        go.layer = this.gameObject.layer;

                        this.caretRectTrans = go.GetComponent(UnityEngine.RectTransform);
                        this.m_CachedInputRenderer = go.GetComponent(UnityEngine.CanvasRenderer);
                        this.m_CachedInputRenderer.SetMaterial$1(UnityEngine.UI.Graphic.defaultGraphicMaterial, UnityEngine.Texture2D.whiteTexture);

                        // Needed as if any layout is present we want the caret to always be the same as the text area.
                        go.AddComponent(UnityEngine.UI.LayoutElement).ignoreLayout = true;

                        this.AssignPositioningIfNeeded();
                    }
                }

                this.m_RectTransform = this.GetComponent(UnityEngine.RectTransform);

                // Check if parent component has IScrollHandler
                var scrollHandlers = this.GetComponentsInParent(UnityEngine.EventSystems.IScrollHandler);
                if (scrollHandlers.length > 1) {
                    this.m_IScrollHandlerParent = Bridge.as(scrollHandlers[1], UnityEngine.UI.ScrollRect);
                }

                // Get a reference to the RectMask 2D on the Viewport Text Area object.
                if (UnityEngine.Component.op_Inequality(this.m_TextViewport, null)) {
                    this.m_TextViewportRectMask = this.m_TextViewport.GetComponent(UnityEngine.UI.RectMask2D);

                    this.UpdateMaskRegions();
                }

                // If we have a cached renderer then we had OnDisable called so just restore the material.
                if (UnityEngine.Component.op_Inequality(this.m_CachedInputRenderer, null)) {
                    this.m_CachedInputRenderer.SetMaterial$1(UnityEngine.UI.Graphic.defaultGraphicMaterial, UnityEngine.Texture2D.whiteTexture);
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.m_TextComponent, null)) {
                    this.m_TextComponent.RegisterDirtyVerticesCallback(Bridge.fn.cacheBind(this, this.MarkGeometryAsDirty));
                    this.m_TextComponent.RegisterDirtyVerticesCallback(Bridge.fn.cacheBind(this, this.UpdateLabel));

                    // Cache reference to Vertical Scrollbar RectTransform and add listener.
                    if (UnityEngine.MonoBehaviour.op_Inequality(this.m_VerticalScrollbar, null)) {
                        this.m_VerticalScrollbar.onValueChanged.AddListener(Bridge.fn.cacheBind(this, this.OnScrollbarValueChange));
                    }

                    this.UpdateLabel();
                }

                // Subscribe to event fired when text object has been regenerated.
                TMPro.TMPro_EventManager.TEXT_CHANGED_EVENT.Add(Bridge.fn.cacheBind(this, this.ON_TEXT_CHANGED));
            },
            /*TMPro.TMP_InputField.OnEnable end.*/

            /*TMPro.TMP_InputField.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#OnDisable", this ); }

                // the coroutine will be terminated, so this will ensure it restarts when we are next activated
                this.m_BlinkCoroutine = null;

                this.DeactivateInputField();
                if (UnityEngine.MonoBehaviour.op_Inequality(this.m_TextComponent, null)) {
                    this.m_TextComponent.UnregisterDirtyVerticesCallback(Bridge.fn.cacheBind(this, this.MarkGeometryAsDirty));
                    this.m_TextComponent.UnregisterDirtyVerticesCallback(Bridge.fn.cacheBind(this, this.UpdateLabel));

                    if (UnityEngine.MonoBehaviour.op_Inequality(this.m_VerticalScrollbar, null)) {
                        this.m_VerticalScrollbar.onValueChanged.RemoveListener(Bridge.fn.cacheBind(this, this.OnScrollbarValueChange));
                    }
                }

                UnityEngine.UI.CanvasUpdateRegistry.UnRegisterCanvasElementForRebuild(this);

                // Clear needs to be called otherwise sync never happens as the object is disabled.
                if (UnityEngine.Component.op_Inequality(this.m_CachedInputRenderer, null)) {
                    this.m_CachedInputRenderer.Clear();
                }

                if (this.m_Mesh != null) {
                    UnityEngine.Object.DestroyImmediate(this.m_Mesh);
                }

                this.m_Mesh = null;

                // Unsubscribe to event triggered when text object has been regenerated
                TMPro.TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(Bridge.fn.cacheBind(this, this.ON_TEXT_CHANGED));

                UnityEngine.UI.Selectable.prototype.OnDisable.call(this);
            },
            /*TMPro.TMP_InputField.OnDisable end.*/

            /*TMPro.TMP_InputField.ON_TEXT_CHANGED start.*/
            /**
             * Method used to update the tracking of the caret position when the text object has been regenerated.
             *
             * @instance
             * @private
             * @this TMPro.TMP_InputField
             * @memberof TMPro.TMP_InputField
             * @param   {UnityEngine.Object}    obj
             * @return  {void}
             */
            ON_TEXT_CHANGED: function (obj) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#ON_TEXT_CHANGED", this ); }

                var isThisObject = Bridge.referenceEquals(obj, this.m_TextComponent);

                if (isThisObject) {
                    if (UnityEngine.Application.isPlaying && this.compositionLength === 0) {
                        this.caretPositionInternal = this.GetCaretPositionFromStringIndex(this.stringPositionInternal);
                        this.caretSelectPositionInternal = this.GetCaretPositionFromStringIndex(this.stringSelectPositionInternal);

                    }

                    if (UnityEngine.Object.op_Implicit(this.m_VerticalScrollbar)) {
                        this.UpdateScrollbar();
                    }
                }
            },
            /*TMPro.TMP_InputField.ON_TEXT_CHANGED end.*/

            /*TMPro.TMP_InputField.CaretBlink start.*/
            CaretBlink: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#CaretBlink", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    blinkPeriod,
                    blinkState,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    // Always ensure caret is initially visible since it can otherwise be confusing for a moment.
                                        this.m_CaretVisible = true;
                                        $enumerator.current = null;
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    if ( (this.isFocused || this.m_SelectionStillActive) && this.m_CaretBlinkRate > 0 ) {
                                            $step = 2;
                                            continue;
                                        } 
                                        $step = 4;
                                        continue;
                                }
                                case 2: {
                                    // the blink rate is expressed as a frequency
                                        blinkPeriod = 1.0 / this.m_CaretBlinkRate;

                                        // the caret should be ON if we are in the first half of the blink period
                                        blinkState = (UnityEngine.Time.unscaledTime - this.m_BlinkStartTime) % blinkPeriod < blinkPeriod / 2;
                                        if (this.m_CaretVisible !== blinkState) {
                                            this.m_CaretVisible = blinkState;
                                            if (!this.hasSelection$1) {
                                                this.MarkGeometryAsDirty();
                                            }
                                        }

                                        // Then wait again.
                                        $enumerator.current = null;
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    
                                        $step = 1;
                                        continue;
                                }
                                case 4: {
                                    this.m_BlinkCoroutine = null;

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*TMPro.TMP_InputField.CaretBlink end.*/

            /*TMPro.TMP_InputField.SetCaretVisible start.*/
            SetCaretVisible: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#SetCaretVisible", this ); }

                if (!this.m_AllowInput) {
                    return;
                }

                this.m_CaretVisible = true;
                this.m_BlinkStartTime = UnityEngine.Time.unscaledTime;
                this.SetCaretActive();
            },
            /*TMPro.TMP_InputField.SetCaretVisible end.*/

            /*TMPro.TMP_InputField.SetCaretActive start.*/
            SetCaretActive: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#SetCaretActive", this ); }

                if (!this.m_AllowInput) {
                    return;
                }

                if (this.m_CaretBlinkRate > 0.0) {
                    if (this.m_BlinkCoroutine == null) {
                        this.m_BlinkCoroutine = this.StartCoroutine$1(this.CaretBlink());
                    }
                } else {
                    this.m_CaretVisible = true;
                }
            },
            /*TMPro.TMP_InputField.SetCaretActive end.*/

            /*TMPro.TMP_InputField.OnFocus start.*/
            OnFocus: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#OnFocus", this ); }

                if (this.m_OnFocusSelectAll) {
                    this.SelectAll();
                }
            },
            /*TMPro.TMP_InputField.OnFocus end.*/

            /*TMPro.TMP_InputField.SelectAll start.*/
            SelectAll: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#SelectAll", this ); }

                this.m_isSelectAll = true;
                this.stringPositionInternal = this.text.length;
                this.stringSelectPositionInternal = 0;
            },
            /*TMPro.TMP_InputField.SelectAll end.*/

            /*TMPro.TMP_InputField.MoveTextEnd start.*/
            /**
             * Move to the end of the text.
             *
             * @instance
             * @public
             * @this TMPro.TMP_InputField
             * @memberof TMPro.TMP_InputField
             * @param   {boolean}    shift
             * @return  {void}
             */
            MoveTextEnd: function (shift) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#MoveTextEnd", this ); }

                var $t;
                if (this.m_isRichTextEditingAllowed) {
                    var position = this.text.length;

                    if (shift) {
                        this.stringSelectPositionInternal = position;
                    } else {
                        this.stringPositionInternal = position;
                        this.stringSelectPositionInternal = this.stringPositionInternal;
                    }
                } else {
                    var position1 = this.m_TextComponent.textInfo.characterCount - 1;

                    if (shift) {
                        this.caretSelectPositionInternal = position1;
                        this.stringSelectPositionInternal = this.GetStringIndexFromCaretPosition(position1);
                    } else {
                        this.caretPositionInternal = (this.caretSelectPositionInternal = position1, position1);
                        this.stringSelectPositionInternal = ($t = this.GetStringIndexFromCaretPosition(position1), this.stringPositionInternal = $t, $t);
                    }
                }

                this.UpdateLabel();
            },
            /*TMPro.TMP_InputField.MoveTextEnd end.*/

            /*TMPro.TMP_InputField.MoveTextStart start.*/
            /**
             * Move to the start of the text.
             *
             * @instance
             * @public
             * @this TMPro.TMP_InputField
             * @memberof TMPro.TMP_InputField
             * @param   {boolean}    shift
             * @return  {void}
             */
            MoveTextStart: function (shift) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#MoveTextStart", this ); }

                var $t;
                if (this.m_isRichTextEditingAllowed) {
                    var position = 0;

                    if (shift) {
                        this.stringSelectPositionInternal = position;
                    } else {
                        this.stringPositionInternal = position;
                        this.stringSelectPositionInternal = this.stringPositionInternal;
                    }
                } else {
                    var position1 = 0;

                    if (shift) {
                        this.caretSelectPositionInternal = position1;
                        this.stringSelectPositionInternal = this.GetStringIndexFromCaretPosition(position1);
                    } else {
                        this.caretPositionInternal = (this.caretSelectPositionInternal = position1, position1);
                        this.stringSelectPositionInternal = ($t = this.GetStringIndexFromCaretPosition(position1), this.stringPositionInternal = $t, $t);
                    }
                }

                this.UpdateLabel();
            },
            /*TMPro.TMP_InputField.MoveTextStart end.*/

            /*TMPro.TMP_InputField.MoveToEndOfLine start.*/
            /**
             * Move to the end of the current line of text.
             *
             * @instance
             * @public
             * @this TMPro.TMP_InputField
             * @memberof TMPro.TMP_InputField
             * @param   {boolean}    shift    
             * @param   {boolean}    ctrl
             * @return  {void}
             */
            MoveToEndOfLine: function (shift, ctrl) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#MoveToEndOfLine", this ); }

                var $t, $t1, $t2;
                // Get the line the caret is currently located on.
                var currentLine = ($t = this.m_TextComponent.textInfo.characterInfo)[this.caretPositionInternal].lineNumber;

                // Get the last character of the given line.
                var characterIndex = ctrl === true ? this.m_TextComponent.textInfo.characterCount - 1 : ($t1 = this.m_TextComponent.textInfo.lineInfo)[currentLine].lastCharacterIndex;

                var position = ($t2 = this.m_TextComponent.textInfo.characterInfo)[characterIndex].index;

                if (shift) {
                    this.stringSelectPositionInternal = position;

                    this.caretSelectPositionInternal = characterIndex;
                } else {
                    this.stringPositionInternal = position;
                    this.stringSelectPositionInternal = this.stringPositionInternal;

                    this.caretSelectPositionInternal = (this.caretPositionInternal = characterIndex, characterIndex);
                }

                this.UpdateLabel();
            },
            /*TMPro.TMP_InputField.MoveToEndOfLine end.*/

            /*TMPro.TMP_InputField.MoveToStartOfLine start.*/
            /**
             * Move to the start of the current line of text.
             *
             * @instance
             * @public
             * @this TMPro.TMP_InputField
             * @memberof TMPro.TMP_InputField
             * @param   {boolean}    shift    
             * @param   {boolean}    ctrl
             * @return  {void}
             */
            MoveToStartOfLine: function (shift, ctrl) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#MoveToStartOfLine", this ); }

                var $t, $t1, $t2, $t3;
                // Get the line the caret is currently located on.
                var currentLine = ($t = this.m_TextComponent.textInfo.characterInfo)[this.caretPositionInternal].lineNumber;

                // Get the first character of the given line.
                var characterIndex = ctrl === true ? 0 : ($t1 = this.m_TextComponent.textInfo.lineInfo)[currentLine].firstCharacterIndex;

                var position = 0;
                if (characterIndex > 0) {
                    position = ($t2 = this.m_TextComponent.textInfo.characterInfo)[characterIndex - 1].index + ($t3 = this.m_TextComponent.textInfo.characterInfo)[characterIndex - 1].stringLength;
                }

                if (shift) {
                    this.stringSelectPositionInternal = position;

                    this.caretSelectPositionInternal = characterIndex;
                } else {
                    this.stringPositionInternal = position;
                    this.stringSelectPositionInternal = this.stringPositionInternal;

                    this.caretSelectPositionInternal = (this.caretPositionInternal = characterIndex, characterIndex);
                }

                this.UpdateLabel();
            },
            /*TMPro.TMP_InputField.MoveToStartOfLine end.*/

            /*TMPro.TMP_InputField.InPlaceEditing start.*/
            InPlaceEditing: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#InPlaceEditing", this ); }

                if (UnityEngine.Application.platform === UnityEngine.RuntimePlatform.WSAPlayerX86 || UnityEngine.Application.platform === UnityEngine.RuntimePlatform.WSAPlayerX64 || UnityEngine.Application.platform === UnityEngine.RuntimePlatform.WSAPlayerARM) {
                    return !UnityEngine.TouchScreenKeyboard.isSupported || this.m_TouchKeyboardAllowsInPlaceEditing;
                }

                if (UnityEngine.TouchScreenKeyboard.isSupported && this.shouldHideSoftKeyboard) {
                    return true;
                }

                if (UnityEngine.TouchScreenKeyboard.isSupported && this.shouldHideSoftKeyboard === false && this.shouldHideMobileInput === false) {
                    return false;
                }

                return true;
            },
            /*TMPro.TMP_InputField.InPlaceEditing end.*/

            /*TMPro.TMP_InputField.UpdateStringPositionFromKeyboard start.*/
            UpdateStringPositionFromKeyboard: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#UpdateStringPositionFromKeyboard", this ); }

                // TODO: Might want to add null check here.
                var selectionRange = this.m_SoftKeyboard.selection.$clone();

                //if (selectionRange.start == 0 && selectionRange.length == 0)
                //    return;

                var selectionStart = selectionRange.start;
                var selectionEnd = selectionRange.end;

                var stringPositionChanged = false;

                if (this.stringPositionInternal !== selectionStart) {
                    stringPositionChanged = true;
                    this.stringPositionInternal = selectionStart;

                    this.caretPositionInternal = this.GetCaretPositionFromStringIndex(this.stringPositionInternal);
                }

                if (this.stringSelectPositionInternal !== selectionEnd) {
                    this.stringSelectPositionInternal = selectionEnd;
                    stringPositionChanged = true;

                    this.caretSelectPositionInternal = this.GetCaretPositionFromStringIndex(this.stringSelectPositionInternal);
                }

                if (stringPositionChanged) {
                    this.m_BlinkStartTime = UnityEngine.Time.unscaledTime;

                    this.UpdateLabel();
                }
            },
            /*TMPro.TMP_InputField.UpdateStringPositionFromKeyboard end.*/

            /*TMPro.TMP_InputField.LateUpdate start.*/
            /**
             * Update the text based on input.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_InputField
             * @memberof TMPro.TMP_InputField
             * @return  {void}
             */
            LateUpdate: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#LateUpdate", this ); }

                // Only activate if we are not already activated.
                if (this.m_ShouldActivateNextUpdate) {
                    if (!this.isFocused) {
                        this.ActivateInputFieldInternal();
                        this.m_ShouldActivateNextUpdate = false;
                        return;
                    }

                    // Reset as we are already activated.
                    this.m_ShouldActivateNextUpdate = false;
                }

                // Handle double click to reset / deselect Input Field when ResetOnActivation is false.
                if (!this.isFocused && this.m_SelectionStillActive) {
                    var selectedObject = UnityEngine.MonoBehaviour.op_Inequality(UnityEngine.EventSystems.EventSystem.current, null) ? UnityEngine.EventSystems.EventSystem.current.currentSelectedGameObject : null;

                    if (UnityEngine.GameObject.op_Equality(selectedObject, null) && this.m_ResetOnDeActivation) {
                        this.ReleaseSelection();
                        return;
                    }

                    if (UnityEngine.GameObject.op_Inequality(selectedObject, null) && UnityEngine.GameObject.op_Inequality(selectedObject, this.gameObject)) {
                        if (UnityEngine.GameObject.op_Equality(selectedObject, this.m_PreviouslySelectedObject)) {
                            return;
                        }

                        this.m_PreviouslySelectedObject = selectedObject;

                        // Special handling for Vertical Scrollbar
                        if (UnityEngine.Object.op_Implicit(this.m_VerticalScrollbar) && UnityEngine.GameObject.op_Equality(selectedObject, this.m_VerticalScrollbar.gameObject)) {
                            // Do not release selection
                            return;
                        }

                        // Release selection for all objects when ResetOnDeActivation is true
                        if (this.m_ResetOnDeActivation) {
                            this.ReleaseSelection();
                            return;
                        }

                        // Release current selection of selected object is another Input Field
                        if (UnityEngine.MonoBehaviour.op_Inequality(selectedObject.GetComponent(TMPro.TMP_InputField), null)) {
                            this.ReleaseSelection();
                        }

                        return;
                    }

                    if (UnityEngine.Input.GetKeyDown(UnityEngine.KeyCode.Mouse0)) {
                        // Check for Double Click
                        var isDoubleClick = false;
                        var timeStamp = UnityEngine.Time.unscaledTime;

                        if (this.m_KeyDownStartTime + this.m_DoubleClickDelay > timeStamp) {
                            isDoubleClick = true;
                        }

                        this.m_KeyDownStartTime = timeStamp;

                        if (isDoubleClick) {
                            //m_StringPosition = m_StringSelectPosition = 0;
                            //m_CaretPosition = m_CaretSelectPosition = 0;
                            //m_TextComponent.rectTransform.localPosition = m_DefaultTransformPosition;

                            //if (caretRectTrans != null)
                            //    caretRectTrans.localPosition = Vector3.zero;

                            this.ReleaseSelection();

                            return;
                        }
                    }
                }

                this.UpdateMaskRegions();

                if (this.InPlaceEditing() && this.isKeyboardUsingEvents() || !this.isFocused) {
                    return;
                }

                this.AssignPositioningIfNeeded();

                if (this.m_SoftKeyboard == null || this.m_SoftKeyboard.status !== UnityEngine.TouchScreenKeyboard.Status.Visible) {
                    if (this.m_SoftKeyboard != null) {
                        if (!this.m_ReadOnly) {
                            this.text = this.m_SoftKeyboard.text;
                        }

                        if (this.m_SoftKeyboard.status === UnityEngine.TouchScreenKeyboard.Status.LostFocus) {
                            this.SendTouchScreenKeyboardStatusChanged();
                        }

                        if (this.m_SoftKeyboard.status === UnityEngine.TouchScreenKeyboard.Status.Canceled) {
                            this.m_ReleaseSelection = true;
                            this.m_WasCanceled = true;
                            this.SendTouchScreenKeyboardStatusChanged();
                        }

                        if (this.m_SoftKeyboard.status === UnityEngine.TouchScreenKeyboard.Status.Done) {
                            this.m_ReleaseSelection = true;
                            this.OnSubmit(null);
                            this.SendTouchScreenKeyboardStatusChanged();
                        }
                    }

                    this.OnDeselect(null);
                    return;
                }

                var val = this.m_SoftKeyboard.text;

                if (!Bridge.referenceEquals(this.m_Text, val)) {
                    if (this.m_ReadOnly) {
                        this.m_SoftKeyboard.text = this.m_Text;
                    } else {
                        this.m_Text = "";

                        for (var i = 0; i < val.length; ++i) {
                            var c = val.charCodeAt(i);

                            if (c === 13 || c === 3) {
                                c = 10;
                            }

                            if (!Bridge.staticEquals(this.onValidateInput, null)) {
                                c = this.onValidateInput(this.m_Text, this.m_Text.length, c);
                            } else if (this.characterValidation !== TMPro.TMP_InputField.CharacterValidation.None) {
                                c = this.Validate(this.m_Text, this.m_Text.length, c);
                            }

                            if (this.lineType === TMPro.TMP_InputField.LineType.MultiLineSubmit && c === 10) {
                                this.m_SoftKeyboard.text = this.m_Text;

                                this.OnSubmit(null);
                                this.OnDeselect(null);
                                return;
                            }

                            if (c !== 0) {
                                this.m_Text = (this.m_Text || "") + String.fromCharCode(c);
                            }
                        }

                        if (this.characterLimit > 0 && this.m_Text.length > this.characterLimit) {
                            this.m_Text = this.m_Text.substr(0, this.characterLimit);
                        }

                        this.UpdateStringPositionFromKeyboard();

                        // Set keyboard text before updating label, as we might have changed it with validation
                        // and update label will take the old value from keyboard if we don't change it here
                        if (!Bridge.referenceEquals(this.m_Text, val)) {
                            this.m_SoftKeyboard.text = this.m_Text;
                        }

                        this.SendOnValueChangedAndUpdateLabel();
                    }
                } else if (this.m_HideMobileInput && UnityEngine.Application.platform === UnityEngine.RuntimePlatform.Android) {
                    this.UpdateStringPositionFromKeyboard();
                }

                //else if (m_HideMobileInput) // m_Keyboard.canSetSelection
                //{
                //    int length = stringPositionInternal < stringSelectPositionInternal ? stringSelectPositionInternal - stringPositionInternal : stringPositionInternal - stringSelectPositionInternal;
                //    m_SoftKeyboard.selection = new RangeInt(stringPositionInternal < stringSelectPositionInternal ? stringPositionInternal : stringSelectPositionInternal, length);
                //}
                //else if (!m_HideMobileInput) // m_Keyboard.canGetSelection)
                //{
                //    UpdateStringPositionFromKeyboard();
                //}

                if (this.m_SoftKeyboard != null && this.m_SoftKeyboard.status !== UnityEngine.TouchScreenKeyboard.Status.Visible) {
                    if (this.m_SoftKeyboard.status === UnityEngine.TouchScreenKeyboard.Status.Canceled) {
                        this.m_WasCanceled = true;
                    }

                    this.OnDeselect(null);
                }
            },
            /*TMPro.TMP_InputField.LateUpdate end.*/

            /*TMPro.TMP_InputField.MayDrag start.*/
            MayDrag: function (eventData) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#MayDrag", this ); }

                return this.IsActive() && this.IsInteractable() && eventData.button === UnityEngine.EventSystems.PointerEventData.InputButton.Left && UnityEngine.MonoBehaviour.op_Inequality(this.m_TextComponent, null) && (this.m_SoftKeyboard == null || this.shouldHideSoftKeyboard || this.shouldHideMobileInput);
            },
            /*TMPro.TMP_InputField.MayDrag end.*/

            /*TMPro.TMP_InputField.OnBeginDrag start.*/
            OnBeginDrag: function (eventData) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#OnBeginDrag", this ); }

                if (!this.MayDrag(eventData)) {
                    return;
                }

                this.m_UpdateDrag = true;
            },
            /*TMPro.TMP_InputField.OnBeginDrag end.*/

            /*TMPro.TMP_InputField.OnDrag start.*/
            OnDrag: function (eventData) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#OnDrag", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7;
                if (!this.MayDrag(eventData)) {
                    return;
                }

                var insertionSide = { v : new TMPro.CaretPosition() };

                var insertionIndex = TMPro.TMP_TextUtilities.GetCursorIndexFromPosition$1(this.m_TextComponent, UnityEngine.Vector3.FromVector2(eventData.position.$clone()), eventData.pressEventCamera, insertionSide);

                if (this.m_isRichTextEditingAllowed) {
                    if (insertionSide.v === TMPro.CaretPosition.Left) {
                        this.stringSelectPositionInternal = ($t = this.m_TextComponent.textInfo.characterInfo)[insertionIndex].index;
                    } else if (insertionSide.v === TMPro.CaretPosition.Right) {
                        this.stringSelectPositionInternal = ($t1 = this.m_TextComponent.textInfo.characterInfo)[insertionIndex].index + ($t2 = this.m_TextComponent.textInfo.characterInfo)[insertionIndex].stringLength;
                    }
                } else {
                    if (insertionSide.v === TMPro.CaretPosition.Left) {
                        this.stringSelectPositionInternal = insertionIndex === 0 ? ($t3 = this.m_TextComponent.textInfo.characterInfo)[0].index : ($t4 = this.m_TextComponent.textInfo.characterInfo)[insertionIndex - 1].index + ($t5 = this.m_TextComponent.textInfo.characterInfo)[insertionIndex - 1].stringLength;
                    } else if (insertionSide.v === TMPro.CaretPosition.Right) {
                        this.stringSelectPositionInternal = ($t6 = this.m_TextComponent.textInfo.characterInfo)[insertionIndex].index + ($t7 = this.m_TextComponent.textInfo.characterInfo)[insertionIndex].stringLength;
                    }
                }

                this.caretSelectPositionInternal = this.GetCaretPositionFromStringIndex(this.stringSelectPositionInternal);

                this.MarkGeometryAsDirty();

                this.m_DragPositionOutOfBounds = !UnityEngine.RectTransformUtility.RectangleContainsScreenPoint$1(this.textViewport, eventData.position, eventData.pressEventCamera);
                if (this.m_DragPositionOutOfBounds && this.m_DragCoroutine == null) {
                    this.m_DragCoroutine = this.StartCoroutine$1(this.MouseDragOutsideRect(eventData));
                }

                eventData.Use();

            },
            /*TMPro.TMP_InputField.OnDrag end.*/

            /*TMPro.TMP_InputField.MouseDragOutsideRect start.*/
            MouseDragOutsideRect: function (eventData) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#MouseDragOutsideRect", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    localMousePos,
                    rect,
                    delay,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if ( this.m_UpdateDrag && this.m_DragPositionOutOfBounds ) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 3;
                                        continue;
                                }
                                case 1: {
                                    localMousePos = { v : new UnityEngine.Vector2() };

                                        UnityEngine.RectTransformUtility.ScreenPointToLocalPointInRectangle(this.textViewport, eventData.position, eventData.pressEventCamera, localMousePos);

                                        rect = this.textViewport.rect.$clone();

                                        if (this.multiLine) {
                                            if (localMousePos.v.y > rect.yMax) {
                                                this.MoveUp$1(true, true);
                                            } else if (localMousePos.v.y < rect.yMin) {
                                                this.MoveDown$1(true, true);
                                            }
                                        } else {
                                            if (localMousePos.v.x < rect.xMin) {
                                                this.MoveLeft(true, false);
                                            } else if (localMousePos.v.x > rect.xMax) {
                                                this.MoveRight(true, false);
                                            }
                                        }

                                        this.UpdateLabel();

                                        delay = this.multiLine ? TMPro.TMP_InputField.kVScrollSpeed : TMPro.TMP_InputField.kHScrollSpeed;

                                        if (this.m_WaitForSecondsRealtime == null) {
                                            this.m_WaitForSecondsRealtime = new UnityEngine.WaitForSecondsRealtime(delay);
                                        } else {
                                            this.m_WaitForSecondsRealtime.waitTime = delay;
                                        }

                                        $enumerator.current = this.m_WaitForSecondsRealtime;
                                        $step = 2;
                                        return true;
                                }
                                case 2: {
                                    
                                        $step = 0;
                                        continue;
                                }
                                case 3: {
                                    this.m_DragCoroutine = null;

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*TMPro.TMP_InputField.MouseDragOutsideRect end.*/

            /*TMPro.TMP_InputField.OnEndDrag start.*/
            OnEndDrag: function (eventData) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#OnEndDrag", this ); }

                if (!this.MayDrag(eventData)) {
                    return;
                }

                this.m_UpdateDrag = false;
            },
            /*TMPro.TMP_InputField.OnEndDrag end.*/

            /*TMPro.TMP_InputField.OnPointerDown start.*/
            OnPointerDown: function (eventData) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#OnPointerDown", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20, $t21, $t22, $t23, $t24, $t25, $t26, $t27;
                if (!this.MayDrag(eventData)) {
                    return;
                }

                UnityEngine.EventSystems.EventSystem.current.SetSelectedGameObject$1(this.gameObject, eventData);

                var hadFocusBefore = this.m_AllowInput;
                UnityEngine.UI.Selectable.prototype.OnPointerDown.call(this, eventData);

                if (this.InPlaceEditing() === false) {
                    if (this.m_SoftKeyboard == null || !this.m_SoftKeyboard.active) {
                        this.OnSelect(eventData);
                        return;
                    }
                }

                var shift = UnityEngine.Input.GetKey(UnityEngine.KeyCode.LeftShift) || UnityEngine.Input.GetKey(UnityEngine.KeyCode.RightShift);

                // Check for Double Click
                var isDoubleClick = false;
                var timeStamp = UnityEngine.Time.unscaledTime;

                if (this.m_PointerDownClickStartTime + this.m_DoubleClickDelay > timeStamp) {
                    isDoubleClick = true;
                }

                this.m_PointerDownClickStartTime = timeStamp;

                // Only set caret position if we didn't just get focus now.
                // Otherwise it will overwrite the select all on focus.
                if (hadFocusBefore || !this.m_OnFocusSelectAll) {
                    var insertionSide = { v : new TMPro.CaretPosition() };

                    var insertionIndex = TMPro.TMP_TextUtilities.GetCursorIndexFromPosition$1(this.m_TextComponent, UnityEngine.Vector3.FromVector2(eventData.position.$clone()), eventData.pressEventCamera, insertionSide);

                    if (shift) {
                        if (this.m_isRichTextEditingAllowed) {
                            if (insertionSide.v === TMPro.CaretPosition.Left) {
                                this.stringSelectPositionInternal = ($t = this.m_TextComponent.textInfo.characterInfo)[insertionIndex].index;
                            } else if (insertionSide.v === TMPro.CaretPosition.Right) {
                                this.stringSelectPositionInternal = ($t1 = this.m_TextComponent.textInfo.characterInfo)[insertionIndex].index + ($t2 = this.m_TextComponent.textInfo.characterInfo)[insertionIndex].stringLength;
                            }
                        } else {
                            if (insertionSide.v === TMPro.CaretPosition.Left) {
                                this.stringSelectPositionInternal = insertionIndex === 0 ? ($t3 = this.m_TextComponent.textInfo.characterInfo)[0].index : ($t4 = this.m_TextComponent.textInfo.characterInfo)[insertionIndex - 1].index + ($t5 = this.m_TextComponent.textInfo.characterInfo)[insertionIndex - 1].stringLength;
                            } else if (insertionSide.v === TMPro.CaretPosition.Right) {
                                this.stringSelectPositionInternal = ($t6 = this.m_TextComponent.textInfo.characterInfo)[insertionIndex].index + ($t7 = this.m_TextComponent.textInfo.characterInfo)[insertionIndex].stringLength;
                            }
                        }
                    } else {
                        if (this.m_isRichTextEditingAllowed) {
                            if (insertionSide.v === TMPro.CaretPosition.Left) {
                                this.stringPositionInternal = ($t8 = ($t9 = this.m_TextComponent.textInfo.characterInfo)[insertionIndex].index, this.stringSelectPositionInternal = $t8, $t8);
                            } else if (insertionSide.v === TMPro.CaretPosition.Right) {
                                this.stringPositionInternal = ($t10 = ($t11 = this.m_TextComponent.textInfo.characterInfo)[insertionIndex].index + ($t12 = this.m_TextComponent.textInfo.characterInfo)[insertionIndex].stringLength, this.stringSelectPositionInternal = $t10, $t10);
                            }
                        } else {
                            if (insertionSide.v === TMPro.CaretPosition.Left) {
                                this.stringPositionInternal = ($t13 = insertionIndex === 0 ? ($t14 = this.m_TextComponent.textInfo.characterInfo)[0].index : ($t15 = this.m_TextComponent.textInfo.characterInfo)[insertionIndex - 1].index + ($t16 = this.m_TextComponent.textInfo.characterInfo)[insertionIndex - 1].stringLength, this.stringSelectPositionInternal = $t13, $t13);
                            } else if (insertionSide.v === TMPro.CaretPosition.Right) {
                                this.stringPositionInternal = ($t17 = ($t18 = this.m_TextComponent.textInfo.characterInfo)[insertionIndex].index + ($t19 = this.m_TextComponent.textInfo.characterInfo)[insertionIndex].stringLength, this.stringSelectPositionInternal = $t17, $t17);
                            }
                        }
                    }


                    if (isDoubleClick) {
                        var wordIndex = TMPro.TMP_TextUtilities.FindIntersectingWord(this.m_TextComponent, UnityEngine.Vector3.FromVector2(eventData.position.$clone()), eventData.pressEventCamera);

                        if (wordIndex !== -1) {
                            // TODO: Should behavior be different if rich text editing is enabled or not?

                            // Select current word
                            this.caretPositionInternal = ($t20 = this.m_TextComponent.textInfo.wordInfo)[wordIndex].firstCharacterIndex;
                            this.caretSelectPositionInternal = ($t21 = this.m_TextComponent.textInfo.wordInfo)[wordIndex].lastCharacterIndex + 1;

                            this.stringPositionInternal = ($t22 = this.m_TextComponent.textInfo.characterInfo)[this.caretPositionInternal].index;
                            this.stringSelectPositionInternal = ($t23 = this.m_TextComponent.textInfo.characterInfo)[this.caretSelectPositionInternal - 1].index + ($t24 = this.m_TextComponent.textInfo.characterInfo)[this.caretSelectPositionInternal - 1].stringLength;
                        } else {
                            // Select current character
                            this.caretPositionInternal = insertionIndex;
                            this.caretSelectPositionInternal = this.caretPositionInternal + 1;

                            this.stringPositionInternal = ($t25 = this.m_TextComponent.textInfo.characterInfo)[insertionIndex].index;
                            this.stringSelectPositionInternal = this.stringPositionInternal + ($t26 = this.m_TextComponent.textInfo.characterInfo)[insertionIndex].stringLength;
                        }
                    } else {
                        this.caretPositionInternal = ($t27 = this.GetCaretPositionFromStringIndex(this.stringPositionInternal), this.caretSelectPositionInternal = $t27, $t27);
                    }

                    this.m_isSelectAll = false;
                }

                this.UpdateLabel();
                eventData.Use();

            },
            /*TMPro.TMP_InputField.OnPointerDown end.*/

            /*TMPro.TMP_InputField.KeyPressed start.*/
            KeyPressed: function (evt) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#KeyPressed", this ); }

                var currentEventModifiers = evt.reportProperty( 'UnityEngine.Event.modifiers', 0 );
                var ctrl = UnityEngine.SystemInfo.operatingSystemFamily === UnityEngine.OperatingSystemFamily.MacOSX ? (currentEventModifiers & UnityEngine.EventModifiers.Command) !== 0 : (currentEventModifiers & UnityEngine.EventModifiers.Control) !== 0;
                var shift = (currentEventModifiers & UnityEngine.EventModifiers.Shift) !== 0;
                var alt = (currentEventModifiers & UnityEngine.EventModifiers.Alt) !== 0;
                var ctrlOnly = ctrl && !alt && !shift;

                switch (evt.reportProperty( 'UnityEngine.Event.keyCode', 0 )) {
                    case UnityEngine.KeyCode.Backspace: 
                        {
                            this.Backspace();
                            return TMPro.TMP_InputField.EditState.Continue;
                        }
                    case UnityEngine.KeyCode.Delete: 
                        {
                            this.DeleteKey();
                            return TMPro.TMP_InputField.EditState.Continue;
                        }
                    case UnityEngine.KeyCode.Home: 
                        {
                            this.MoveToStartOfLine(shift, ctrl);
                            return TMPro.TMP_InputField.EditState.Continue;
                        }
                    case UnityEngine.KeyCode.End: 
                        {
                            this.MoveToEndOfLine(shift, ctrl);
                            return TMPro.TMP_InputField.EditState.Continue;
                        }
                    case UnityEngine.KeyCode.A: 
                        {
                            if (ctrlOnly) {
                                this.SelectAll();
                                return TMPro.TMP_InputField.EditState.Continue;
                            }

                            break;
                        }
                    case UnityEngine.KeyCode.C: 
                        {
                            if (ctrlOnly) {
                                if (this.inputType !== TMPro.TMP_InputField.InputType.Password) {
                                    TMPro.TMP_InputField.clipboard = this.GetSelectedString();
                                } else {
                                    TMPro.TMP_InputField.clipboard = "";
                                }

                                return TMPro.TMP_InputField.EditState.Continue;
                            }

                            break;
                        }
                    case UnityEngine.KeyCode.V: 
                        {
                            if (ctrlOnly) {
                                this.Append$1(TMPro.TMP_InputField.clipboard);
                                return TMPro.TMP_InputField.EditState.Continue;
                            }

                            break;
                        }
                    case UnityEngine.KeyCode.X: 
                        {
                            if (ctrlOnly) {
                                if (this.inputType !== TMPro.TMP_InputField.InputType.Password) {
                                    TMPro.TMP_InputField.clipboard = this.GetSelectedString();
                                } else {
                                    TMPro.TMP_InputField.clipboard = "";
                                }

                                this.Delete();
                                this.UpdateTouchKeyboardFromEditChanges();
                                this.SendOnValueChangedAndUpdateLabel();
                                return TMPro.TMP_InputField.EditState.Continue;
                            }

                            break;
                        }
                    case UnityEngine.KeyCode.LeftArrow: 
                        {
                            this.MoveLeft(shift, ctrl);
                            return TMPro.TMP_InputField.EditState.Continue;
                        }
                    case UnityEngine.KeyCode.RightArrow: 
                        {
                            this.MoveRight(shift, ctrl);
                            return TMPro.TMP_InputField.EditState.Continue;
                        }
                    case UnityEngine.KeyCode.UpArrow: 
                        {
                            this.MoveUp(shift);
                            return TMPro.TMP_InputField.EditState.Continue;
                        }
                    case UnityEngine.KeyCode.DownArrow: 
                        {
                            this.MoveDown(shift);
                            return TMPro.TMP_InputField.EditState.Continue;
                        }
                    case UnityEngine.KeyCode.PageUp: 
                        {
                            this.MovePageUp(shift);
                            return TMPro.TMP_InputField.EditState.Continue;
                        }
                    case UnityEngine.KeyCode.PageDown: 
                        {
                            this.MovePageDown(shift);
                            return TMPro.TMP_InputField.EditState.Continue;
                        }
                    case UnityEngine.KeyCode.Return: 
                    case UnityEngine.KeyCode.KeypadEnter: 
                        {
                            if (this.lineType !== TMPro.TMP_InputField.LineType.MultiLineNewline) {
                                this.m_ReleaseSelection = true;
                                return TMPro.TMP_InputField.EditState.Finish;
                            }

                            break;
                        }
                    case UnityEngine.KeyCode.Escape: 
                        {
                            this.m_ReleaseSelection = true;
                            this.m_WasCanceled = true;
                            return TMPro.TMP_InputField.EditState.Finish;
                        }
                }

                var c = evt.reportProperty( 'UnityEngine.Event.character', null );

                // Don't allow return chars or tabulator key to be entered into single line fields.
                if (!this.multiLine && (c === 9 || c === 13 || c === 10)) {
                    return TMPro.TMP_InputField.EditState.Continue;
                }

                // Convert carriage return and end-of-text characters to newline.
                if (c === 13 || c === 3) {
                    c = 10;
                }

                // Convert Shift Enter to Vertical tab
                if (shift && c === 10) {
                    c = 11;
                }

                if (this.IsValidChar(c)) {
                    this.Append(c);
                }

                if (c === 0) {
                    if (this.compositionLength > 0) {
                        this.UpdateLabel();
                    }
                }

                return TMPro.TMP_InputField.EditState.Continue;
            },
            /*TMPro.TMP_InputField.KeyPressed end.*/

            /*TMPro.TMP_InputField.IsValidChar start.*/
            IsValidChar: function (c) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#IsValidChar", this ); }

                // Null character
                if (c === 0) {
                    return false;
                }

                // Delete key on mac
                if (c === 127) {
                    return false;
                }

                // Accept newline and tab
                if (c === 9 || c === 10) {
                    return true;
                }

                return true;

                // With the addition of Dynamic support, I think this will best be handled by the text component.
                //return m_TextComponent.font.HasCharacter(c, true);
            },
            /*TMPro.TMP_InputField.IsValidChar end.*/

            /*TMPro.TMP_InputField.ProcessEvent start.*/
            ProcessEvent: function (e) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#ProcessEvent", this ); }

                this.KeyPressed(e);
            },
            /*TMPro.TMP_InputField.ProcessEvent end.*/

            /*TMPro.TMP_InputField.OnUpdateSelected start.*/
            /**
             * @instance
             * @public
             * @this TMPro.TMP_InputField
             * @memberof TMPro.TMP_InputField
             * @param   {UnityEngine.EventSystems.BaseEventData}    eventData
             * @return  {void}
             */
            OnUpdateSelected: function (eventData) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#OnUpdateSelected", this ); }

                if (!this.isFocused) {
                    return;
                }

                var consumedEvent = false;
                var shouldContinue = new TMPro.TMP_InputField.EditState();

                while (pc.stubProxy.reportMethod( 'UnityEngine.Event.PopEvent', false )) {
                    //Debug.Log("Event: " + m_ProcessingEvent.ToString() + "  IsCompositionActive= " + m_IsCompositionActive + "  Composition Length: " + compositionLength);

                    switch (this.m_ProcessingEvent.reportProperty( 'UnityEngine.Event.rawType', 0 )) {
                        case UnityEngine.EventType.KeyUp: 
                            // TODO: Figure out way to handle navigation during IME Composition.
                            break;
                        case UnityEngine.EventType.KeyDown: 
                            consumedEvent = true;
                            // Special handling on OSX which produces more events which need to be suppressed.
                            if (this.m_IsCompositionActive && this.compositionLength === 0) {
                                //if (m_ProcessingEvent.keyCode == KeyCode.Backspace && m_ProcessingEvent.modifiers == EventModifiers.None)
                                //{
                                //    int eventCount = Event.GetEventCount();

                                //    // Suppress all subsequent events
                                //    for (int i = 0; i < eventCount; i++)
                                //        Event.PopEvent(m_ProcessingEvent);

                                //    break;
                                //}

                                // Suppress other events related to navigation or termination of composition sequence.
                                if (this.m_ProcessingEvent.reportProperty( 'UnityEngine.Event.character', null ) === 0 && this.m_ProcessingEvent.reportProperty( 'UnityEngine.Event.modifiers', 0 ) === UnityEngine.EventModifiers.None) {
                                    break;
                                }
                            }
                            shouldContinue = this.KeyPressed(this.m_ProcessingEvent);
                            if (shouldContinue === TMPro.TMP_InputField.EditState.Finish) {
                                if (!this.m_WasCanceled) {
                                    this.SendOnSubmit();
                                }

                                this.DeactivateInputField();
                                break;
                            }
                            this.m_IsTextComponentUpdateRequired = true;
                            this.UpdateLabel();
                            break;
                        case UnityEngine.EventType.ValidateCommand: 
                        case UnityEngine.EventType.ExecuteCommand: 
                            switch (this.m_ProcessingEvent.reportProperty( 'UnityEngine.Event.commandName', '' )) {
                                case "SelectAll": 
                                    this.SelectAll();
                                    consumedEvent = true;
                                    break;
                            }
                            break;
                    }
                }

                if (consumedEvent) {
                    this.UpdateLabel();
                }

                eventData.Use();
            },
            /*TMPro.TMP_InputField.OnUpdateSelected end.*/

            /*TMPro.TMP_InputField.OnScroll start.*/
            /**
             * @instance
             * @public
             * @this TMPro.TMP_InputField
             * @memberof TMPro.TMP_InputField
             * @param   {UnityEngine.EventSystems.PointerEventData}    eventData
             * @return  {void}
             */
            OnScroll: function (eventData) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#OnScroll", this ); }

                // Return if Single Line
                if (this.m_LineType === TMPro.TMP_InputField.LineType.SingleLine) {
                    if (this.m_IScrollHandlerParent != null) {
                        this.m_IScrollHandlerParent.UnityEngine$EventSystems$IScrollHandler$OnScroll(eventData);
                    }

                    return;
                }

                if (this.m_TextComponent.preferredHeight < this.m_TextViewport.rect.height) {
                    return;
                }

                var scrollDirection = -eventData.scrollDelta.y;

                // Determine the current scroll position of the text within the viewport
                this.m_ScrollPosition = this.GetScrollPositionRelativeToViewport();

                this.m_ScrollPosition += 1.0 / this.m_TextComponent.textInfo.lineCount * scrollDirection * this.m_ScrollSensitivity;

                this.m_ScrollPosition = Math.max(0, Math.min(1, this.m_ScrollPosition));

                this.AdjustTextPositionRelativeToViewport(this.m_ScrollPosition);

                if (UnityEngine.Object.op_Implicit(this.m_VerticalScrollbar)) {
                    this.m_VerticalScrollbar.value = this.m_ScrollPosition;
                }

                //Debug.Log(GetInstanceID() + "- Scroll Position:" + m_ScrollPosition);
            },
            /*TMPro.TMP_InputField.OnScroll end.*/

            /*TMPro.TMP_InputField.GetScrollPositionRelativeToViewport start.*/
            GetScrollPositionRelativeToViewport: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#GetScrollPositionRelativeToViewport", this ); }

                var $t;
                // Determine the current scroll position of the text within the viewport
                var viewportRect = this.m_TextViewport.rect.$clone();

                var scrollPosition = (($t = this.m_TextComponent.textInfo.lineInfo)[0].ascender - viewportRect.yMax + this.m_TextComponent.rectTransform$1.anchoredPosition.y) / (this.m_TextComponent.preferredHeight - viewportRect.height);

                scrollPosition = (scrollPosition * 1000 + 0.5) / 1000.0;

                return scrollPosition;
            },
            /*TMPro.TMP_InputField.GetScrollPositionRelativeToViewport end.*/

            /*TMPro.TMP_InputField.GetSelectedString start.*/
            GetSelectedString: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#GetSelectedString", this ); }

                if (!this.hasSelection$1) {
                    return "";
                }

                var startPos = this.stringPositionInternal;
                var endPos = this.stringSelectPositionInternal;

                // Ensure pos is always less then selPos to make the code simpler
                if (startPos > endPos) {
                    var temp = startPos;
                    startPos = endPos;
                    endPos = temp;
                }

                //for (int i = m_CaretPosition; i < m_CaretSelectPosition; i++)
                //{
                //    Debug.Log("Character [" + m_TextComponent.textInfo.characterInfo[i].character + "] using Style [" + m_TextComponent.textInfo.characterInfo[i].style + "] has been selected.");
                //}


                return this.text.substr(startPos, endPos - startPos);
            },
            /*TMPro.TMP_InputField.GetSelectedString end.*/

            /*TMPro.TMP_InputField.FindNextWordBegin start.*/
            FindNextWordBegin: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#FindNextWordBegin", this ); }

                if (this.stringSelectPositionInternal + 1 >= this.text.length) {
                    return this.text.length;
                }

                var spaceLoc = System.String.indexOfAny(this.text, TMPro.TMP_InputField.kSeparators, this.stringSelectPositionInternal + 1);

                if (spaceLoc === -1) {
                    spaceLoc = this.text.length;
                } else {
                    spaceLoc++;
                }

                return spaceLoc;
            },
            /*TMPro.TMP_InputField.FindNextWordBegin end.*/

            /*TMPro.TMP_InputField.MoveRight start.*/
            MoveRight: function (shift, ctrl) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#MoveRight", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5, $t6;
                if (this.hasSelection$1 && !shift) {
                    // By convention, if we have a selection and move right without holding shift,
                    // we just place the cursor at the end.
                    this.stringPositionInternal = ($t = UnityEngine.Mathf.Max(this.stringPositionInternal, this.stringSelectPositionInternal), this.stringSelectPositionInternal = $t, $t);
                    this.caretPositionInternal = ($t1 = this.GetCaretPositionFromStringIndex(this.stringSelectPositionInternal), this.caretSelectPositionInternal = $t1, $t1);

                    return;
                }

                var position;
                if (ctrl) {
                    position = this.FindNextWordBegin();
                } else {
                    if (this.m_isRichTextEditingAllowed) {
                        // Special handling for Surrogate pairs and Diacritical marks.
                        if (this.stringSelectPositionInternal < this.text.length && System.Char.isHighSurrogate(this.text.charCodeAt(this.stringSelectPositionInternal))) {
                            position = this.stringSelectPositionInternal + 2;
                        } else {
                            position = this.stringSelectPositionInternal + 1;
                        }
                    } else {
                        position = ($t2 = this.m_TextComponent.textInfo.characterInfo)[this.caretSelectPositionInternal].index + ($t3 = this.m_TextComponent.textInfo.characterInfo)[this.caretSelectPositionInternal].stringLength;
                    }
                }

                if (shift) {
                    this.stringSelectPositionInternal = position;
                    this.caretSelectPositionInternal = this.GetCaretPositionFromStringIndex(this.stringSelectPositionInternal);
                } else {
                    this.stringSelectPositionInternal = (this.stringPositionInternal = position, position);

                    // Only increase caret position as we cross character boundary.
                    if (this.stringPositionInternal >= ($t4 = this.m_TextComponent.textInfo.characterInfo)[this.caretPositionInternal].index + ($t5 = this.m_TextComponent.textInfo.characterInfo)[this.caretPositionInternal].stringLength) {
                        this.caretSelectPositionInternal = ($t6 = this.GetCaretPositionFromStringIndex(this.stringSelectPositionInternal), this.caretPositionInternal = $t6, $t6);
                    }
                }

            },
            /*TMPro.TMP_InputField.MoveRight end.*/

            /*TMPro.TMP_InputField.FindPrevWordBegin start.*/
            FindPrevWordBegin: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#FindPrevWordBegin", this ); }

                if (this.stringSelectPositionInternal - 2 < 0) {
                    return 0;
                }

                var spaceLoc = System.String.lastIndexOfAny(this.text, TMPro.TMP_InputField.kSeparators, this.stringSelectPositionInternal - 2);

                if (spaceLoc === -1) {
                    spaceLoc = 0;
                } else {
                    spaceLoc++;
                }

                return spaceLoc;
            },
            /*TMPro.TMP_InputField.FindPrevWordBegin end.*/

            /*TMPro.TMP_InputField.MoveLeft start.*/
            MoveLeft: function (shift, ctrl) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#MoveLeft", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5;
                if (this.hasSelection$1 && !shift) {
                    // By convention, if we have a selection and move left without holding shift,
                    // we just place the cursor at the start.
                    this.stringPositionInternal = ($t = UnityEngine.Mathf.Min(this.stringPositionInternal, this.stringSelectPositionInternal), this.stringSelectPositionInternal = $t, $t);
                    this.caretPositionInternal = ($t1 = this.GetCaretPositionFromStringIndex(this.stringSelectPositionInternal), this.caretSelectPositionInternal = $t1, $t1);

                    return;
                }

                var position;
                if (ctrl) {
                    position = this.FindPrevWordBegin();
                } else {
                    if (this.m_isRichTextEditingAllowed) {
                        // Special handling for Surrogate pairs and Diacritical marks.
                        if (this.stringSelectPositionInternal > 0 && System.Char.isLowSurrogate(this.text.charCodeAt(this.stringSelectPositionInternal - 1))) {
                            position = this.stringSelectPositionInternal - 2;
                        } else {
                            position = this.stringSelectPositionInternal - 1;
                        }
                    } else {
                        position = this.caretSelectPositionInternal < 1 ? ($t2 = this.m_TextComponent.textInfo.characterInfo)[0].index : ($t3 = this.m_TextComponent.textInfo.characterInfo)[this.caretSelectPositionInternal - 1].index;
                    }
                }

                if (shift) {
                    this.stringSelectPositionInternal = position;
                    this.caretSelectPositionInternal = this.GetCaretPositionFromStringIndex(this.stringSelectPositionInternal);
                } else {
                    this.stringSelectPositionInternal = (this.stringPositionInternal = position, position);

                    // Only decrease caret position as we cross character boundary.
                    if (this.caretPositionInternal > 0 && this.stringPositionInternal <= ($t4 = this.m_TextComponent.textInfo.characterInfo)[this.caretPositionInternal - 1].index) {
                        this.caretSelectPositionInternal = ($t5 = this.GetCaretPositionFromStringIndex(this.stringSelectPositionInternal), this.caretPositionInternal = $t5, $t5);
                    }
                }

            },
            /*TMPro.TMP_InputField.MoveLeft end.*/

            /*TMPro.TMP_InputField.LineUpCharacterPosition start.*/
            LineUpCharacterPosition: function (originalPos, goToFirstChar) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#LineUpCharacterPosition", this ); }

                var $t, $t1, $t2, $t3;
                if (originalPos >= this.m_TextComponent.textInfo.characterCount) {
                    originalPos -= 1;
                }

                var originChar = ($t = this.m_TextComponent.textInfo.characterInfo)[originalPos].$clone();
                var originLine = originChar.lineNumber;

                // We are on the first line return first character
                if (originLine - 1 < 0) {
                    return goToFirstChar ? 0 : originalPos;
                }

                var endCharIdx = ($t1 = this.m_TextComponent.textInfo.lineInfo)[originLine].firstCharacterIndex - 1;

                var closest = -1;
                var distance = TMPro.TMP_Math.FLOAT_MAX;
                var range = 0;

                for (var i = ($t2 = this.m_TextComponent.textInfo.lineInfo)[originLine - 1].firstCharacterIndex; i < endCharIdx; ++i) {
                    var currentChar = ($t3 = this.m_TextComponent.textInfo.characterInfo)[i].$clone();

                    var d = originChar.origin - currentChar.origin;
                    var r = d / (currentChar.xAdvance - currentChar.origin);

                    if (r >= 0 && r <= 1) {
                        if (r < 0.5) {
                            return i;
                        } else {
                            return i + 1;
                        }
                    }

                    d = Math.abs(d);

                    if (d < distance) {
                        closest = i;
                        distance = d;
                        range = r;
                    }
                }

                if (closest === -1) {
                    return endCharIdx;
                }

                //Debug.Log("Returning nearest character with Range = " + range);

                if (range < 0.5) {
                    return closest;
                } else {
                    return closest + 1;
                }
            },
            /*TMPro.TMP_InputField.LineUpCharacterPosition end.*/

            /*TMPro.TMP_InputField.LineDownCharacterPosition start.*/
            LineDownCharacterPosition: function (originalPos, goToLastChar) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#LineDownCharacterPosition", this ); }

                var $t, $t1, $t2, $t3;
                if (originalPos >= this.m_TextComponent.textInfo.characterCount) {
                    return this.m_TextComponent.textInfo.characterCount - 1; // text.Length;
                }

                var originChar = ($t = this.m_TextComponent.textInfo.characterInfo)[originalPos].$clone();
                var originLine = originChar.lineNumber;

                if (originLine + 1 >= this.m_TextComponent.textInfo.lineCount) {
                    return goToLastChar ? this.m_TextComponent.textInfo.characterCount - 1 : originalPos;
                }

                // Need to determine end line for next line.
                var endCharIdx = ($t1 = this.m_TextComponent.textInfo.lineInfo)[originLine + 1].lastCharacterIndex;

                var closest = -1;
                var distance = TMPro.TMP_Math.FLOAT_MAX;
                var range = 0;

                for (var i = ($t2 = this.m_TextComponent.textInfo.lineInfo)[originLine + 1].firstCharacterIndex; i < endCharIdx; ++i) {
                    var currentChar = ($t3 = this.m_TextComponent.textInfo.characterInfo)[i].$clone();

                    var d = originChar.origin - currentChar.origin;
                    var r = d / (currentChar.xAdvance - currentChar.origin);

                    if (r >= 0 && r <= 1) {
                        if (r < 0.5) {
                            return i;
                        } else {
                            return i + 1;
                        }
                    }

                    d = Math.abs(d);

                    if (d < distance) {
                        closest = i;
                        distance = d;
                        range = r;
                    }
                }

                if (closest === -1) {
                    return endCharIdx;
                }

                //Debug.Log("Returning nearest character with Range = " + range);

                if (range < 0.5) {
                    return closest;
                } else {
                    return closest + 1;
                }
            },
            /*TMPro.TMP_InputField.LineDownCharacterPosition end.*/

            /*TMPro.TMP_InputField.PageUpCharacterPosition start.*/
            PageUpCharacterPosition: function (originalPos, goToFirstChar) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#PageUpCharacterPosition", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5;
                if (originalPos >= this.m_TextComponent.textInfo.characterCount) {
                    originalPos -= 1;
                }

                var originChar = ($t = this.m_TextComponent.textInfo.characterInfo)[originalPos].$clone();
                var originLine = originChar.lineNumber;

                // We are on the first line return first character
                if (originLine - 1 < 0) {
                    return goToFirstChar ? 0 : originalPos;
                }

                var viewportHeight = this.m_TextViewport.rect.height;

                var newLine = originLine - 1;
                // Iterate through each subsequent line to find the first baseline that is not visible in the viewport.
                for (; newLine > 0; newLine--) {
                    if (($t1 = this.m_TextComponent.textInfo.lineInfo)[newLine].baseline > ($t2 = this.m_TextComponent.textInfo.lineInfo)[originLine].baseline + viewportHeight) {
                        break;
                    }
                }

                var endCharIdx = ($t3 = this.m_TextComponent.textInfo.lineInfo)[newLine].lastCharacterIndex;

                var closest = -1;
                var distance = TMPro.TMP_Math.FLOAT_MAX;
                var range = 0;

                for (var i = ($t4 = this.m_TextComponent.textInfo.lineInfo)[newLine].firstCharacterIndex; i < endCharIdx; ++i) {
                    var currentChar = ($t5 = this.m_TextComponent.textInfo.characterInfo)[i].$clone();

                    var d = originChar.origin - currentChar.origin;
                    var r = d / (currentChar.xAdvance - currentChar.origin);

                    if (r >= 0 && r <= 1) {
                        if (r < 0.5) {
                            return i;
                        } else {
                            return i + 1;
                        }
                    }

                    d = Math.abs(d);

                    if (d < distance) {
                        closest = i;
                        distance = d;
                        range = r;
                    }
                }

                if (closest === -1) {
                    return endCharIdx;
                }

                //Debug.Log("Returning nearest character with Range = " + range);

                if (range < 0.5) {
                    return closest;
                } else {
                    return closest + 1;
                }
            },
            /*TMPro.TMP_InputField.PageUpCharacterPosition end.*/

            /*TMPro.TMP_InputField.PageDownCharacterPosition start.*/
            PageDownCharacterPosition: function (originalPos, goToLastChar) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#PageDownCharacterPosition", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5;
                if (originalPos >= this.m_TextComponent.textInfo.characterCount) {
                    return this.m_TextComponent.textInfo.characterCount - 1;
                }

                var originChar = ($t = this.m_TextComponent.textInfo.characterInfo)[originalPos].$clone();
                var originLine = originChar.lineNumber;

                // We are on the last line return last character
                if (originLine + 1 >= this.m_TextComponent.textInfo.lineCount) {
                    return goToLastChar ? this.m_TextComponent.textInfo.characterCount - 1 : originalPos;
                }

                var viewportHeight = this.m_TextViewport.rect.height;

                var newLine = originLine + 1;
                // Iterate through each subsequent line to find the first baseline that is not visible in the viewport.
                for (; newLine < this.m_TextComponent.textInfo.lineCount - 1; newLine++) {
                    if (($t1 = this.m_TextComponent.textInfo.lineInfo)[newLine].baseline < ($t2 = this.m_TextComponent.textInfo.lineInfo)[originLine].baseline - viewportHeight) {
                        break;
                    }
                }

                // Need to determine end line for next line.
                var endCharIdx = ($t3 = this.m_TextComponent.textInfo.lineInfo)[newLine].lastCharacterIndex;

                var closest = -1;
                var distance = TMPro.TMP_Math.FLOAT_MAX;
                var range = 0;

                for (var i = ($t4 = this.m_TextComponent.textInfo.lineInfo)[newLine].firstCharacterIndex; i < endCharIdx; ++i) {
                    var currentChar = ($t5 = this.m_TextComponent.textInfo.characterInfo)[i].$clone();

                    var d = originChar.origin - currentChar.origin;
                    var r = d / (currentChar.xAdvance - currentChar.origin);

                    if (r >= 0 && r <= 1) {
                        if (r < 0.5) {
                            return i;
                        } else {
                            return i + 1;
                        }
                    }

                    d = Math.abs(d);

                    if (d < distance) {
                        closest = i;
                        distance = d;
                        range = r;
                    }
                }

                if (closest === -1) {
                    return endCharIdx;
                }

                if (range < 0.5) {
                    return closest;
                } else {
                    return closest + 1;
                }
            },
            /*TMPro.TMP_InputField.PageDownCharacterPosition end.*/

            /*TMPro.TMP_InputField.MoveDown start.*/
            MoveDown: function (shift) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#MoveDown", this ); }

                this.MoveDown$1(shift, true);
            },
            /*TMPro.TMP_InputField.MoveDown end.*/

            /*TMPro.TMP_InputField.MoveDown$1 start.*/
            MoveDown$1: function (shift, goToLastChar) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#MoveDown$1", this ); }

                var $t, $t1;
                if (this.hasSelection$1 && !shift) {
                    // If we have a selection and press down without shift,
                    // set caret to end of selection before we move it down.
                    this.caretPositionInternal = ($t = UnityEngine.Mathf.Max(this.caretPositionInternal, this.caretSelectPositionInternal), this.caretSelectPositionInternal = $t, $t);
                }

                var position = this.multiLine ? this.LineDownCharacterPosition(this.caretSelectPositionInternal, goToLastChar) : this.m_TextComponent.textInfo.characterCount - 1; // text.Length;

                if (shift) {
                    this.caretSelectPositionInternal = position;
                    this.stringSelectPositionInternal = this.GetStringIndexFromCaretPosition(this.caretSelectPositionInternal);
                } else {
                    this.caretSelectPositionInternal = (this.caretPositionInternal = position, position);
                    this.stringSelectPositionInternal = ($t1 = this.GetStringIndexFromCaretPosition(this.caretSelectPositionInternal), this.stringPositionInternal = $t1, $t1);
                }

            },
            /*TMPro.TMP_InputField.MoveDown$1 end.*/

            /*TMPro.TMP_InputField.MoveUp start.*/
            MoveUp: function (shift) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#MoveUp", this ); }

                this.MoveUp$1(shift, true);
            },
            /*TMPro.TMP_InputField.MoveUp end.*/

            /*TMPro.TMP_InputField.MoveUp$1 start.*/
            MoveUp$1: function (shift, goToFirstChar) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#MoveUp$1", this ); }

                var $t, $t1;
                if (this.hasSelection$1 && !shift) {
                    // If we have a selection and press up without shift,
                    // set caret position to start of selection before we move it up.
                    this.caretPositionInternal = ($t = UnityEngine.Mathf.Min(this.caretPositionInternal, this.caretSelectPositionInternal), this.caretSelectPositionInternal = $t, $t);
                }

                var position = this.multiLine ? this.LineUpCharacterPosition(this.caretSelectPositionInternal, goToFirstChar) : 0;

                if (shift) {
                    this.caretSelectPositionInternal = position;
                    this.stringSelectPositionInternal = this.GetStringIndexFromCaretPosition(this.caretSelectPositionInternal);
                } else {
                    this.caretSelectPositionInternal = (this.caretPositionInternal = position, position);
                    this.stringSelectPositionInternal = ($t1 = this.GetStringIndexFromCaretPosition(this.caretSelectPositionInternal), this.stringPositionInternal = $t1, $t1);
                }

            },
            /*TMPro.TMP_InputField.MoveUp$1 end.*/

            /*TMPro.TMP_InputField.MovePageUp start.*/
            MovePageUp: function (shift) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#MovePageUp", this ); }

                this.MovePageUp$1(shift, true);
            },
            /*TMPro.TMP_InputField.MovePageUp end.*/

            /*TMPro.TMP_InputField.MovePageUp$1 start.*/
            MovePageUp$1: function (shift, goToFirstChar) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#MovePageUp$1", this ); }

                var $t, $t1;
                if (this.hasSelection$1 && !shift) {
                    // If we have a selection and press up without shift,
                    // set caret position to start of selection before we move it up.
                    this.caretPositionInternal = ($t = UnityEngine.Mathf.Min(this.caretPositionInternal, this.caretSelectPositionInternal), this.caretSelectPositionInternal = $t, $t);
                }

                var position = this.multiLine ? this.PageUpCharacterPosition(this.caretSelectPositionInternal, goToFirstChar) : 0;

                if (shift) {
                    this.caretSelectPositionInternal = position;
                    this.stringSelectPositionInternal = this.GetStringIndexFromCaretPosition(this.caretSelectPositionInternal);
                } else {
                    this.caretSelectPositionInternal = (this.caretPositionInternal = position, position);
                    this.stringSelectPositionInternal = ($t1 = this.GetStringIndexFromCaretPosition(this.caretSelectPositionInternal), this.stringPositionInternal = $t1, $t1);
                }


                // Scroll to top of viewport
                //int currentLine = m_TextComponent.textInfo.characterInfo[position].lineNumber;
                //float lineAscender = m_TextComponent.textInfo.lineInfo[currentLine].ascender;

                // Adjust text area up or down if not in single line mode.
                if (this.m_LineType !== TMPro.TMP_InputField.LineType.SingleLine) {
                    var offset = this.m_TextViewport.rect.height; // m_TextViewport.rect.yMax - (m_TextComponent.rectTransform.anchoredPosition.y + lineAscender);

                    var topTextBounds = this.m_TextComponent.rectTransform$1.position.y + this.m_TextComponent.textBounds.max.y;
                    var topViewportBounds = this.m_TextViewport.position.y + this.m_TextViewport.rect.yMax;

                    offset = topViewportBounds > topTextBounds + offset ? offset : topViewportBounds - topTextBounds;

                    this.m_TextComponent.rectTransform$1.anchoredPosition = this.m_TextComponent.rectTransform$1.anchoredPosition.$clone().add( new pc.Vec2( 0, offset ) );
                    this.AssignPositioningIfNeeded();
                }

            },
            /*TMPro.TMP_InputField.MovePageUp$1 end.*/

            /*TMPro.TMP_InputField.MovePageDown start.*/
            MovePageDown: function (shift) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#MovePageDown", this ); }

                this.MovePageDown$1(shift, true);
            },
            /*TMPro.TMP_InputField.MovePageDown end.*/

            /*TMPro.TMP_InputField.MovePageDown$1 start.*/
            MovePageDown$1: function (shift, goToLastChar) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#MovePageDown$1", this ); }

                var $t, $t1;
                if (this.hasSelection$1 && !shift) {
                    // If we have a selection and press down without shift,
                    // set caret to end of selection before we move it down.
                    this.caretPositionInternal = ($t = UnityEngine.Mathf.Max(this.caretPositionInternal, this.caretSelectPositionInternal), this.caretSelectPositionInternal = $t, $t);
                }

                var position = this.multiLine ? this.PageDownCharacterPosition(this.caretSelectPositionInternal, goToLastChar) : this.m_TextComponent.textInfo.characterCount - 1;

                if (shift) {
                    this.caretSelectPositionInternal = position;
                    this.stringSelectPositionInternal = this.GetStringIndexFromCaretPosition(this.caretSelectPositionInternal);
                } else {
                    this.caretSelectPositionInternal = (this.caretPositionInternal = position, position);
                    this.stringSelectPositionInternal = ($t1 = this.GetStringIndexFromCaretPosition(this.caretSelectPositionInternal), this.stringPositionInternal = $t1, $t1);
                }

                // Scroll to top of viewport
                //int currentLine = m_TextComponent.textInfo.characterInfo[position].lineNumber;
                //float lineAscender = m_TextComponent.textInfo.lineInfo[currentLine].ascender;

                // Adjust text area up or down if not in single line mode.
                if (this.m_LineType !== TMPro.TMP_InputField.LineType.SingleLine) {
                    var offset = this.m_TextViewport.rect.height; // m_TextViewport.rect.yMax - (m_TextComponent.rectTransform.anchoredPosition.y + lineAscender);

                    var bottomTextBounds = this.m_TextComponent.rectTransform$1.position.y + this.m_TextComponent.textBounds.min.y;
                    var bottomViewportBounds = this.m_TextViewport.position.y + this.m_TextViewport.rect.yMin;

                    offset = bottomViewportBounds > bottomTextBounds + offset ? offset : bottomViewportBounds - bottomTextBounds;

                    this.m_TextComponent.rectTransform$1.anchoredPosition = this.m_TextComponent.rectTransform$1.anchoredPosition.$clone().add( new pc.Vec2( 0, offset ) );
                    this.AssignPositioningIfNeeded();
                }

            },
            /*TMPro.TMP_InputField.MovePageDown$1 end.*/

            /*TMPro.TMP_InputField.Delete start.*/
            Delete: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#Delete", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5;
                if (this.m_ReadOnly) {
                    return;
                }

                if (this.m_StringPosition === this.m_StringSelectPosition) {
                    return;
                }

                if (this.m_isRichTextEditingAllowed || this.m_isSelectAll) {
                    // Handling of Delete when Rich Text is allowed.
                    if (this.m_StringPosition < this.m_StringSelectPosition) {
                        this.m_Text = System.String.remove(this.text, this.m_StringPosition, this.m_StringSelectPosition - this.m_StringPosition);
                        this.m_StringSelectPosition = this.m_StringPosition;
                    } else {
                        this.m_Text = System.String.remove(this.text, this.m_StringSelectPosition, this.m_StringPosition - this.m_StringSelectPosition);
                        this.m_StringPosition = this.m_StringSelectPosition;
                    }

                    if (this.m_isSelectAll) {
                        this.m_CaretPosition = (this.m_CaretSelectPosition = 0);
                        this.m_isSelectAll = false;
                    }
                } else {
                    if (this.m_CaretPosition < this.m_CaretSelectPosition) {
                        this.m_StringPosition = ($t = this.m_TextComponent.textInfo.characterInfo)[this.m_CaretPosition].index;
                        this.m_StringSelectPosition = ($t1 = this.m_TextComponent.textInfo.characterInfo)[this.m_CaretSelectPosition - 1].index + ($t2 = this.m_TextComponent.textInfo.characterInfo)[this.m_CaretSelectPosition - 1].stringLength;

                        this.m_Text = System.String.remove(this.text, this.m_StringPosition, this.m_StringSelectPosition - this.m_StringPosition);

                        this.m_StringSelectPosition = this.m_StringPosition;
                        this.m_CaretSelectPosition = this.m_CaretPosition;
                    } else {
                        this.m_StringPosition = ($t3 = this.m_TextComponent.textInfo.characterInfo)[this.m_CaretPosition - 1].index + ($t4 = this.m_TextComponent.textInfo.characterInfo)[this.m_CaretPosition - 1].stringLength;
                        this.m_StringSelectPosition = ($t5 = this.m_TextComponent.textInfo.characterInfo)[this.m_CaretSelectPosition].index;

                        this.m_Text = System.String.remove(this.text, this.m_StringSelectPosition, this.m_StringPosition - this.m_StringSelectPosition);

                        this.m_StringPosition = this.m_StringSelectPosition;
                        this.m_CaretPosition = this.m_CaretSelectPosition;
                    }
                }

            },
            /*TMPro.TMP_InputField.Delete end.*/

            /*TMPro.TMP_InputField.DeleteKey start.*/
            /**
             * Handling of DEL key
             *
             * @instance
             * @private
             * @this TMPro.TMP_InputField
             * @memberof TMPro.TMP_InputField
             * @return  {void}
             */
            DeleteKey: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#DeleteKey", this ); }

                var $t, $t1;
                if (this.m_ReadOnly) {
                    return;
                }

                if (this.hasSelection$1) {
                    this.m_isLastKeyBackspace = true;

                    this.Delete();
                    this.UpdateTouchKeyboardFromEditChanges();
                    this.SendOnValueChangedAndUpdateLabel();
                } else {
                    if (this.m_isRichTextEditingAllowed) {
                        if (this.stringPositionInternal < this.text.length) {
                            // Special handling for Surrogate Pairs
                            if (System.Char.isHighSurrogate(this.text.charCodeAt(this.stringPositionInternal))) {
                                this.m_Text = System.String.remove(this.text, this.stringPositionInternal, 2);
                            } else {
                                this.m_Text = System.String.remove(this.text, this.stringPositionInternal, 1);
                            }

                            this.m_isLastKeyBackspace = true;

                            this.UpdateTouchKeyboardFromEditChanges();
                            this.SendOnValueChangedAndUpdateLabel();
                        }
                    } else {
                        if (this.caretPositionInternal < this.m_TextComponent.textInfo.characterCount - 1) {
                            var numberOfCharactersToRemove = ($t = this.m_TextComponent.textInfo.characterInfo)[this.caretPositionInternal].stringLength;

                            // Adjust string position to skip any potential rich text tags.
                            var nextCharacterStringPosition = ($t1 = this.m_TextComponent.textInfo.characterInfo)[this.caretPositionInternal].index;

                            this.m_Text = System.String.remove(this.text, nextCharacterStringPosition, numberOfCharactersToRemove);

                            this.m_isLastKeyBackspace = true;

                            this.SendOnValueChangedAndUpdateLabel();
                        }
                    }
                }

            },
            /*TMPro.TMP_InputField.DeleteKey end.*/

            /*TMPro.TMP_InputField.Backspace start.*/
            /**
             * Handling of Backspace key
             *
             * @instance
             * @private
             * @this TMPro.TMP_InputField
             * @memberof TMPro.TMP_InputField
             * @return  {void}
             */
            Backspace: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#Backspace", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7;
                if (this.m_ReadOnly) {
                    return;
                }

                if (this.hasSelection$1) {
                    this.m_isLastKeyBackspace = true;

                    this.Delete();
                    this.UpdateTouchKeyboardFromEditChanges();
                    this.SendOnValueChangedAndUpdateLabel();
                } else {
                    if (this.m_isRichTextEditingAllowed) {
                        if (this.stringPositionInternal > 0) {
                            var numberOfCharactersToRemove = 1;

                            // Special handling for Surrogate pairs and Diacritical marks
                            if (System.Char.isLowSurrogate(this.text.charCodeAt(this.stringPositionInternal - 1))) {
                                numberOfCharactersToRemove = 2;
                            }

                            this.stringSelectPositionInternal = ($t = this.stringPositionInternal - numberOfCharactersToRemove, this.stringPositionInternal = $t, $t);

                            this.m_Text = System.String.remove(this.text, this.stringPositionInternal, numberOfCharactersToRemove);

                            this.caretSelectPositionInternal = ($t1 = this.caretPositionInternal - 1, this.caretPositionInternal = $t1, $t1);

                            this.m_isLastKeyBackspace = true;

                            this.UpdateTouchKeyboardFromEditChanges();
                            this.SendOnValueChangedAndUpdateLabel();
                        }
                    } else {
                        if (this.caretPositionInternal > 0) {
                            var numberOfCharactersToRemove1 = ($t2 = this.m_TextComponent.textInfo.characterInfo)[this.caretPositionInternal - 1].stringLength;

                            // Delete the previous character
                            this.m_Text = System.String.remove(this.text, ($t3 = this.m_TextComponent.textInfo.characterInfo)[this.caretPositionInternal - 1].index, numberOfCharactersToRemove1);

                            // Get new adjusted string position
                            this.stringSelectPositionInternal = ($t4 = this.caretPositionInternal < 1 ? ($t5 = this.m_TextComponent.textInfo.characterInfo)[0].index : ($t6 = this.m_TextComponent.textInfo.characterInfo)[this.caretPositionInternal - 1].index, this.stringPositionInternal = $t4, $t4);

                            this.caretSelectPositionInternal = ($t7 = this.caretPositionInternal - 1, this.caretPositionInternal = $t7, $t7);
                        }

                        this.m_isLastKeyBackspace = true;

                        this.UpdateTouchKeyboardFromEditChanges();
                        this.SendOnValueChangedAndUpdateLabel();
                    }
                }

            },
            /*TMPro.TMP_InputField.Backspace end.*/

            /*TMPro.TMP_InputField.Append$1 start.*/
            /**
             * Append the specified text to the end of the current.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_InputField
             * @memberof TMPro.TMP_InputField
             * @param   {string}    input
             * @return  {void}
             */
            Append$1: function (input) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#Append$1", this ); }

                if (this.m_ReadOnly) {
                    return;
                }

                if (this.InPlaceEditing() === false) {
                    return;
                }

                for (var i = 0, imax = input.length; i < imax; ++i) {
                    var c = input.charCodeAt(i);

                    if (c >= 32 || c === 9 || c === 13 || c === 10 || c === 10) {
                        this.Append(c);
                    }
                }
            },
            /*TMPro.TMP_InputField.Append$1 end.*/

            /*TMPro.TMP_InputField.Append start.*/
            Append: function (input) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#Append", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5;
                if (this.m_ReadOnly) {
                    return;
                }

                if (this.InPlaceEditing() === false) {
                    return;
                }

                // If we have an input validator, validate the input first
                var insertionPosition = UnityEngine.Mathf.Min(this.stringPositionInternal, this.stringSelectPositionInternal);

                //Get the text based on selection for validation instead of whole text(case 1253193).
                var validateText = this.text;

                if (this.selectionFocusPosition !== this.selectionAnchorPosition) {
                    if (this.m_isRichTextEditingAllowed || this.m_isSelectAll) {
                        // Handling of Delete when Rich Text is allowed.
                        if (this.m_StringPosition < this.m_StringSelectPosition) {
                            validateText = System.String.remove(this.text, this.m_StringPosition, this.m_StringSelectPosition - this.m_StringPosition);
                        } else {
                            validateText = System.String.remove(this.text, this.m_StringSelectPosition, this.m_StringPosition - this.m_StringSelectPosition);
                        }
                    } else {
                        if (this.m_CaretPosition < this.m_CaretSelectPosition) {
                            this.m_StringPosition = ($t = this.m_TextComponent.textInfo.characterInfo)[this.m_CaretPosition].index;
                            this.m_StringSelectPosition = ($t1 = this.m_TextComponent.textInfo.characterInfo)[this.m_CaretSelectPosition - 1].index + ($t2 = this.m_TextComponent.textInfo.characterInfo)[this.m_CaretSelectPosition - 1].stringLength;

                            validateText = System.String.remove(this.text, this.m_StringPosition, this.m_StringSelectPosition - this.m_StringPosition);
                        } else {
                            this.m_StringPosition = ($t3 = this.m_TextComponent.textInfo.characterInfo)[this.m_CaretPosition - 1].index + ($t4 = this.m_TextComponent.textInfo.characterInfo)[this.m_CaretPosition - 1].stringLength;
                            this.m_StringSelectPosition = ($t5 = this.m_TextComponent.textInfo.characterInfo)[this.m_CaretSelectPosition].index;

                            validateText = System.String.remove(this.text, this.m_StringSelectPosition, this.m_StringPosition - this.m_StringSelectPosition);
                        }
                    }
                }

                if (!Bridge.staticEquals(this.onValidateInput, null)) {
                    input = this.onValidateInput(validateText, insertionPosition, input);
                } else if (this.characterValidation === TMPro.TMP_InputField.CharacterValidation.CustomValidator) {
                    input = this.Validate(validateText, insertionPosition, input);

                    if (input === 0) {
                        return;
                    }

                    this.SendOnValueChanged();
                    this.UpdateLabel();

                    return;
                } else if (this.characterValidation !== TMPro.TMP_InputField.CharacterValidation.None) {
                    input = this.Validate(validateText, insertionPosition, input);
                }

                // If the input is invalid, skip it
                if (input === 0) {
                    return;
                }

                // Append the character and update the label
                this.Insert(input);
            },
            /*TMPro.TMP_InputField.Append end.*/

            /*TMPro.TMP_InputField.Insert start.*/
            Insert: function (c) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#Insert", this ); }

                if (this.m_ReadOnly) {
                    return;
                }

                //Debug.Log("Inserting character " + m_IsCompositionActive);

                var replaceString = String.fromCharCode(c);
                this.Delete();

                // Can't go past the character limit
                if (this.characterLimit > 0 && this.text.length >= this.characterLimit) {
                    return;
                }

                this.m_Text = System.String.insert(this.m_StringPosition, this.text, replaceString);

                if (!System.Char.isHighSurrogate(c)) {
                    this.m_CaretSelectPosition = (this.m_CaretPosition = this.m_CaretPosition + 1);
                }

                this.m_StringSelectPosition = (this.m_StringPosition = this.m_StringPosition + 1);

                this.UpdateTouchKeyboardFromEditChanges();
                this.SendOnValueChanged();

            },
            /*TMPro.TMP_InputField.Insert end.*/

            /*TMPro.TMP_InputField.UpdateTouchKeyboardFromEditChanges start.*/
            UpdateTouchKeyboardFromEditChanges: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#UpdateTouchKeyboardFromEditChanges", this ); }

                // Update the TouchKeyboard's text from edit changes
                // if in-place editing is allowed
                if (this.m_SoftKeyboard != null && this.InPlaceEditing()) {
                    this.m_SoftKeyboard.text = this.m_Text;
                }
            },
            /*TMPro.TMP_InputField.UpdateTouchKeyboardFromEditChanges end.*/

            /*TMPro.TMP_InputField.SendOnValueChangedAndUpdateLabel start.*/
            SendOnValueChangedAndUpdateLabel: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#SendOnValueChangedAndUpdateLabel", this ); }

                this.UpdateLabel();
                this.SendOnValueChanged();
            },
            /*TMPro.TMP_InputField.SendOnValueChangedAndUpdateLabel end.*/

            /*TMPro.TMP_InputField.SendOnValueChanged start.*/
            SendOnValueChanged: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#SendOnValueChanged", this ); }

                if (this.onValueChanged != null) {
                    this.onValueChanged.Invoke(this.text);
                }
            },
            /*TMPro.TMP_InputField.SendOnValueChanged end.*/

            /*TMPro.TMP_InputField.SendOnEndEdit start.*/
            /**
             * Submit the input field's text.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_InputField
             * @memberof TMPro.TMP_InputField
             * @return  {void}
             */
            SendOnEndEdit: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#SendOnEndEdit", this ); }

                if (this.onEndEdit != null) {
                    this.onEndEdit.Invoke(this.m_Text);
                }
            },
            /*TMPro.TMP_InputField.SendOnEndEdit end.*/

            /*TMPro.TMP_InputField.SendOnSubmit start.*/
            SendOnSubmit: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#SendOnSubmit", this ); }

                if (this.onSubmit != null) {
                    this.onSubmit.Invoke(this.m_Text);
                }
            },
            /*TMPro.TMP_InputField.SendOnSubmit end.*/

            /*TMPro.TMP_InputField.SendOnFocus start.*/
            SendOnFocus: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#SendOnFocus", this ); }

                if (this.onSelect != null) {
                    this.onSelect.Invoke(this.m_Text);
                }
            },
            /*TMPro.TMP_InputField.SendOnFocus end.*/

            /*TMPro.TMP_InputField.SendOnFocusLost start.*/
            SendOnFocusLost: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#SendOnFocusLost", this ); }

                if (this.onDeselect != null) {
                    this.onDeselect.Invoke(this.m_Text);
                }
            },
            /*TMPro.TMP_InputField.SendOnFocusLost end.*/

            /*TMPro.TMP_InputField.SendOnTextSelection start.*/
            SendOnTextSelection: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#SendOnTextSelection", this ); }

                this.m_isSelected = true;

                if (this.onTextSelection != null) {
                    this.onTextSelection.Invoke(this.m_Text, this.stringPositionInternal, this.stringSelectPositionInternal);
                }
            },
            /*TMPro.TMP_InputField.SendOnTextSelection end.*/

            /*TMPro.TMP_InputField.SendOnEndTextSelection start.*/
            SendOnEndTextSelection: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#SendOnEndTextSelection", this ); }

                if (!this.m_isSelected) {
                    return;
                }

                if (this.onEndTextSelection != null) {
                    this.onEndTextSelection.Invoke(this.m_Text, this.stringPositionInternal, this.stringSelectPositionInternal);
                }

                this.m_isSelected = false;
            },
            /*TMPro.TMP_InputField.SendOnEndTextSelection end.*/

            /*TMPro.TMP_InputField.SendTouchScreenKeyboardStatusChanged start.*/
            SendTouchScreenKeyboardStatusChanged: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#SendTouchScreenKeyboardStatusChanged", this ); }

                if (this.onTouchScreenKeyboardStatusChanged != null) {
                    this.onTouchScreenKeyboardStatusChanged.Invoke(this.m_SoftKeyboard.status);
                }
            },
            /*TMPro.TMP_InputField.SendTouchScreenKeyboardStatusChanged end.*/

            /*TMPro.TMP_InputField.UpdateLabel start.*/
            /**
             * Update the visual text Text.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_InputField
             * @memberof TMPro.TMP_InputField
             * @return  {void}
             */
            UpdateLabel: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#UpdateLabel", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.m_TextComponent, null) && this.m_TextComponent.font != null && this.m_PreventCallback === false) {
                    // Prevent callback from the text component as we assign new text. This is to prevent a recursive call.
                    this.m_PreventCallback = true;

                    var fullText;
                    if (this.compositionLength > 0 && this.m_ReadOnly === false) {
                        //Input.imeCompositionMode = IMECompositionMode.On;

                        // Handle selections
                        this.Delete();

                        if (this.m_RichText) {
                            fullText = (this.text.substr(0, this.m_StringPosition) || "") + "<u>" + (this.compositionString || "") + "</u>" + (this.text.substr(this.m_StringPosition) || "");
                        } else {
                            fullText = (this.text.substr(0, this.m_StringPosition) || "") + (this.compositionString || "") + (this.text.substr(this.m_StringPosition) || "");
                        }

                        this.m_IsCompositionActive = true;

                        //Debug.Log("[" + Time.frameCount + "] Handling IME Input");
                    } else {
                        fullText = this.text;
                        this.m_IsCompositionActive = false;
                        this.m_ShouldUpdateIMEWindowPosition = true;
                    }

                    //Debug.Log("Handling IME Input... [" + compositionString + "] of length [" + compositionLength + "] at StringPosition [" + m_StringPosition + "]  IsActive [" + m_IsCompositionActive + "]");

                    var processed;
                    if (this.inputType === TMPro.TMP_InputField.InputType.Password) {
                        processed = System.String.fromCharCount(this.asteriskChar, fullText.length);
                    } else {
                        processed = fullText;
                    }

                    var isEmpty = System.String.isNullOrEmpty(fullText);

                    if (UnityEngine.MonoBehaviour.op_Inequality(this.m_Placeholder, null)) {
                        this.m_Placeholder.enabled = isEmpty;
                    }

                    if (!isEmpty && this.m_ReadOnly === false) {
                        this.SetCaretVisible();
                    }

                    this.m_TextComponent.text = (processed || "") + "\u200b"; // Extra space is added for Caret tracking.

                    // Rebuild layout if using Layout components.
                    if (this.m_IsDrivenByLayoutComponents) {
                        UnityEngine.UI.LayoutRebuilder.MarkLayoutForRebuild(this.m_RectTransform);
                    }

                    // Special handling to limit the number of lines of text in the Input Field.
                    if (this.m_LineLimit > 0) {
                        this.m_TextComponent.ForceMeshUpdate();

                        var textInfo = this.m_TextComponent.textInfo;

                        // Check if text exceeds maximum number of lines.
                        if (textInfo != null && textInfo.lineCount > this.m_LineLimit) {
                            var lastValidCharacterIndex = textInfo.lineInfo[this.m_LineLimit - 1].lastCharacterIndex;
                            var characterStringIndex = textInfo.characterInfo[lastValidCharacterIndex].index + textInfo.characterInfo[lastValidCharacterIndex].stringLength;
                            this.text = System.String.remove(processed, characterStringIndex, processed.length - characterStringIndex);
                            this.m_TextComponent.text = (this.text || "") + "\u200b";
                        }
                    }

                    if (this.m_IsTextComponentUpdateRequired || UnityEngine.Object.op_Implicit(this.m_VerticalScrollbar)) {
                        this.m_IsTextComponentUpdateRequired = false;
                        this.m_TextComponent.ForceMeshUpdate();
                    }

                    this.MarkGeometryAsDirty();

                    this.m_PreventCallback = false;
                }
            },
            /*TMPro.TMP_InputField.UpdateLabel end.*/

            /*TMPro.TMP_InputField.UpdateScrollbar start.*/
            UpdateScrollbar: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#UpdateScrollbar", this ); }

                // Update Scrollbar
                if (UnityEngine.Object.op_Implicit(this.m_VerticalScrollbar)) {
                    var viewportRect = this.m_TextViewport.rect.$clone();

                    var size = viewportRect.height / this.m_TextComponent.preferredHeight;

                    this.m_VerticalScrollbar.size = size;

                    this.m_VerticalScrollbar.value = this.GetScrollPositionRelativeToViewport();

                    //Debug.Log(GetInstanceID() + "- UpdateScrollbar() - Updating Scrollbar... Value: " + m_VerticalScrollbar.value);
                }
            },
            /*TMPro.TMP_InputField.UpdateScrollbar end.*/

            /*TMPro.TMP_InputField.OnScrollbarValueChange start.*/
            /**
             * Function to update the vertical position of the text container when OnValueChanged event is received from the Scrollbar.
             *
             * @instance
             * @private
             * @this TMPro.TMP_InputField
             * @memberof TMPro.TMP_InputField
             * @param   {number}    value
             * @return  {void}
             */
            OnScrollbarValueChange: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#OnScrollbarValueChange", this ); }

                //if (m_IsUpdatingScrollbarValues)
                //{
                //    m_IsUpdatingScrollbarValues = false;
                //    return;
                //}

                if (value < 0 || value > 1) {
                    return;
                }

                this.AdjustTextPositionRelativeToViewport(value);

                this.m_ScrollPosition = value;

                //Debug.Log(GetInstanceID() + "- OnScrollbarValueChange() - Scrollbar value is: " + value + "  Transform POS: " + m_TextComponent.rectTransform.anchoredPosition);
            },
            /*TMPro.TMP_InputField.OnScrollbarValueChange end.*/

            /*TMPro.TMP_InputField.UpdateMaskRegions start.*/
            UpdateMaskRegions: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#UpdateMaskRegions", this ); }

                // TODO: Figure out a better way to handle adding an offset to the masking region
                // This region is defined by the RectTransform of the GameObject that contains the RectMask2D component.
                /* 
                // Update Masking Region
                if (m_TextViewportRectMask != null)
                {
                   Rect viewportRect = m_TextViewportRectMask.canvasRect;

                   if (viewportRect != m_CachedViewportRect)
                   {
                       m_CachedViewportRect = viewportRect;

                       viewportRect.min -= m_TextViewport.offsetMin * 0.5f;
                       viewportRect.max -= m_TextViewport.offsetMax * 0.5f;

                       if (m_CachedInputRenderer != null)
                           m_CachedInputRenderer.EnableRectClipping(viewportRect);

                       if (m_TextComponent.canvasRenderer != null)
                           m_TextComponent.canvasRenderer.EnableRectClipping(viewportRect);

                       if (m_Placeholder != null && m_Placeholder.enabled)
                           m_Placeholder.canvasRenderer.EnableRectClipping(viewportRect);
                   }
                }
                */
            },
            /*TMPro.TMP_InputField.UpdateMaskRegions end.*/

            /*TMPro.TMP_InputField.AdjustTextPositionRelativeToViewport start.*/
            /**
             * Adjusts the relative position of the body of the text relative to the viewport.
             *
             * @instance
             * @private
             * @this TMPro.TMP_InputField
             * @memberof TMPro.TMP_InputField
             * @param   {number}    relativePosition
             * @return  {void}
             */
            AdjustTextPositionRelativeToViewport: function (relativePosition) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#AdjustTextPositionRelativeToViewport", this ); }

                if (UnityEngine.Component.op_Equality(this.m_TextViewport, null)) {
                    return;
                }

                var textInfo = this.m_TextComponent.textInfo;

                // Check to make sure we have valid data and lines to query.
                if (textInfo == null || textInfo.lineInfo == null || textInfo.lineCount === 0 || textInfo.lineCount > textInfo.lineInfo.length) {
                    return;
                }

                var verticalAlignmentOffset = 0;
                var textHeight = this.m_TextComponent.preferredHeight;

                switch (this.m_TextComponent.verticalAlignment) {
                    case TMPro.VerticalAlignmentOptions.Top: 
                        verticalAlignmentOffset = 0;
                        break;
                    case TMPro.VerticalAlignmentOptions.Middle: 
                        verticalAlignmentOffset = 0.5;
                        break;
                    case TMPro.VerticalAlignmentOptions.Bottom: 
                        verticalAlignmentOffset = 1.0;
                        break;
                    case TMPro.VerticalAlignmentOptions.Baseline: 
                        break;
                    case TMPro.VerticalAlignmentOptions.Geometry: 
                        verticalAlignmentOffset = 0.5;
                        textHeight = this.m_TextComponent.bounds.halfExtents.$clone().scale( 2 ).y;
                        break;
                    case TMPro.VerticalAlignmentOptions.Capline: 
                        verticalAlignmentOffset = 0.5;
                        break;
                }

                this.m_TextComponent.rectTransform$1.anchoredPosition = new pc.Vec2( this.m_TextComponent.rectTransform$1.anchoredPosition.x, (textHeight - this.m_TextViewport.rect.height) * (relativePosition - verticalAlignmentOffset) );

                this.AssignPositioningIfNeeded();

                //Debug.Log("Text height: " + m_TextComponent.preferredHeight + "  Viewport height: " + m_TextViewport.rect.height + "  Adjusted RectTransform anchordedPosition:" + m_TextComponent.rectTransform.anchoredPosition + "  Text Bounds: " + m_TextComponent.bounds.ToString("f3"));
            },
            /*TMPro.TMP_InputField.AdjustTextPositionRelativeToViewport end.*/

            /*TMPro.TMP_InputField.GetCaretPositionFromStringIndex start.*/
            GetCaretPositionFromStringIndex: function (stringIndex) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#GetCaretPositionFromStringIndex", this ); }

                var $t;
                var count = this.m_TextComponent.textInfo.characterCount;

                for (var i = 0; i < count; i++) {
                    if (($t = this.m_TextComponent.textInfo.characterInfo)[i].index >= stringIndex) {
                        return i;
                    }
                }

                return count;
            },
            /*TMPro.TMP_InputField.GetCaretPositionFromStringIndex end.*/

            /*TMPro.TMP_InputField.GetMinCaretPositionFromStringIndex start.*/
            /**
             * Returns / places the caret before the given character at the string index.
             *
             * @instance
             * @private
             * @this TMPro.TMP_InputField
             * @memberof TMPro.TMP_InputField
             * @param   {number}    stringIndex
             * @return  {number}
             */
            GetMinCaretPositionFromStringIndex: function (stringIndex) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#GetMinCaretPositionFromStringIndex", this ); }

                var $t, $t1;
                var count = this.m_TextComponent.textInfo.characterCount;

                for (var i = 0; i < count; i++) {
                    if (stringIndex < ($t = this.m_TextComponent.textInfo.characterInfo)[i].index + ($t1 = this.m_TextComponent.textInfo.characterInfo)[i].stringLength) {
                        return i;
                    }
                }

                return count;
            },
            /*TMPro.TMP_InputField.GetMinCaretPositionFromStringIndex end.*/

            /*TMPro.TMP_InputField.GetMaxCaretPositionFromStringIndex start.*/
            /**
             * Returns / places the caret after the given character at the string index.
             *
             * @instance
             * @private
             * @this TMPro.TMP_InputField
             * @memberof TMPro.TMP_InputField
             * @param   {number}    stringIndex
             * @return  {number}
             */
            GetMaxCaretPositionFromStringIndex: function (stringIndex) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#GetMaxCaretPositionFromStringIndex", this ); }

                var $t;
                var count = this.m_TextComponent.textInfo.characterCount;

                for (var i = 0; i < count; i++) {
                    if (($t = this.m_TextComponent.textInfo.characterInfo)[i].index >= stringIndex) {
                        return i;
                    }
                }

                return count;
            },
            /*TMPro.TMP_InputField.GetMaxCaretPositionFromStringIndex end.*/

            /*TMPro.TMP_InputField.GetStringIndexFromCaretPosition start.*/
            GetStringIndexFromCaretPosition: function (caretPosition) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#GetStringIndexFromCaretPosition", this ); }

                var $t;
                caretPosition = {v:caretPosition};
                // Clamp values between 0 and character count.
                this.ClampCaretPos(caretPosition);

                return ($t = this.m_TextComponent.textInfo.characterInfo)[caretPosition.v].index;
            },
            /*TMPro.TMP_InputField.GetStringIndexFromCaretPosition end.*/

            /*TMPro.TMP_InputField.ForceLabelUpdate start.*/
            ForceLabelUpdate: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#ForceLabelUpdate", this ); }

                this.UpdateLabel();
            },
            /*TMPro.TMP_InputField.ForceLabelUpdate end.*/

            /*TMPro.TMP_InputField.MarkGeometryAsDirty start.*/
            MarkGeometryAsDirty: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#MarkGeometryAsDirty", this ); }


                UnityEngine.UI.CanvasUpdateRegistry.RegisterCanvasElementForGraphicRebuild(this);
            },
            /*TMPro.TMP_InputField.MarkGeometryAsDirty end.*/

            /*TMPro.TMP_InputField.Rebuild start.*/
            Rebuild: function (update) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#Rebuild", this ); }

                switch (update) {
                    case UnityEngine.UI.CanvasUpdate.LatePreRender: 
                        this.UpdateGeometry();
                        break;
                }
            },
            /*TMPro.TMP_InputField.Rebuild end.*/

            /*TMPro.TMP_InputField.LayoutComplete start.*/
            LayoutComplete: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#LayoutComplete", this ); }
 },
            /*TMPro.TMP_InputField.LayoutComplete end.*/

            /*TMPro.TMP_InputField.GraphicUpdateComplete start.*/
            GraphicUpdateComplete: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#GraphicUpdateComplete", this ); }
 },
            /*TMPro.TMP_InputField.GraphicUpdateComplete end.*/

            /*TMPro.TMP_InputField.UpdateGeometry start.*/
            UpdateGeometry: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#UpdateGeometry", this ); }


                // No need to draw a cursor on mobile as its handled by the devices keyboard.
                if (this.InPlaceEditing() === false) {
                    return;
                }

                if (UnityEngine.Component.op_Equality(this.m_CachedInputRenderer, null)) {
                    return;
                }

                this.OnFillVBO(this.mesh);

                this.m_CachedInputRenderer.SetMesh(this.mesh);
            },
            /*TMPro.TMP_InputField.UpdateGeometry end.*/

            /*TMPro.TMP_InputField.AssignPositioningIfNeeded start.*/
            /**
             * Method to keep the Caret RectTransform properties in sync with the text object's RectTransform
             *
             * @instance
             * @private
             * @this TMPro.TMP_InputField
             * @memberof TMPro.TMP_InputField
             * @return  {void}
             */
            AssignPositioningIfNeeded: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#AssignPositioningIfNeeded", this ); }

                var $t, $t1;
                if (UnityEngine.MonoBehaviour.op_Inequality(this.m_TextComponent, null) && UnityEngine.Component.op_Inequality(this.caretRectTrans, null) && (!pc.Vec3.equals( this.caretRectTrans.localPosition, this.m_TextComponent.rectTransform$1.localPosition ) || ($t = this.caretRectTrans.localRotation, $t1 = this.m_TextComponent.rectTransform$1.localRotation, ( $t == null && $t1 != null ) || ( $t != null && $t1 == null ) || ( $t != null && !$t.equals( $t1 ) )) || !pc.Vec3.equals( this.caretRectTrans.localScale, this.m_TextComponent.rectTransform$1.localScale ) || !pc.Vec2.equals( this.caretRectTrans.anchorMin, this.m_TextComponent.rectTransform$1.anchorMin ) || !pc.Vec2.equals( this.caretRectTrans.anchorMax, this.m_TextComponent.rectTransform$1.anchorMax ) || !pc.Vec2.equals( this.caretRectTrans.anchoredPosition, this.m_TextComponent.rectTransform$1.anchoredPosition ) || !pc.Vec2.equals( this.caretRectTrans.sizeDelta, this.m_TextComponent.rectTransform$1.sizeDelta ) || !pc.Vec2.equals( this.caretRectTrans.pivot, this.m_TextComponent.rectTransform$1.pivot ))) {
                    this.caretRectTrans.localPosition = this.m_TextComponent.rectTransform$1.localPosition.$clone();
                    this.caretRectTrans.localRotation = this.m_TextComponent.rectTransform$1.localRotation.$clone();
                    this.caretRectTrans.localScale = this.m_TextComponent.rectTransform$1.localScale.$clone();
                    this.caretRectTrans.anchorMin = this.m_TextComponent.rectTransform$1.anchorMin.$clone();
                    this.caretRectTrans.anchorMax = this.m_TextComponent.rectTransform$1.anchorMax.$clone();
                    this.caretRectTrans.anchoredPosition = this.m_TextComponent.rectTransform$1.anchoredPosition.$clone();
                    this.caretRectTrans.sizeDelta = this.m_TextComponent.rectTransform$1.sizeDelta.$clone();
                    this.caretRectTrans.pivot = this.m_TextComponent.rectTransform$1.pivot.$clone();
                }
            },
            /*TMPro.TMP_InputField.AssignPositioningIfNeeded end.*/

            /*TMPro.TMP_InputField.OnFillVBO start.*/
            OnFillVBO: function (vbo) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#OnFillVBO", this ); }

                var helper = new UnityEngine.UI.VertexHelper.ctor();
                try {
                    if (!this.isFocused && !this.m_SelectionStillActive) {
                        helper.FillMesh(vbo);
                        return;
                    }

                    if (this.m_IsStringPositionDirty) {
                        this.stringPositionInternal = this.GetStringIndexFromCaretPosition(this.m_CaretPosition);
                        this.stringSelectPositionInternal = this.GetStringIndexFromCaretPosition(this.m_CaretSelectPosition);
                        this.m_IsStringPositionDirty = false;
                    }

                    if (this.m_IsCaretPositionDirty) {
                        this.caretPositionInternal = this.GetCaretPositionFromStringIndex(this.stringPositionInternal);
                        this.caretSelectPositionInternal = this.GetCaretPositionFromStringIndex(this.stringSelectPositionInternal);
                        this.m_IsCaretPositionDirty = false;
                    }

                    if (!this.hasSelection$1) {
                        this.GenerateCaret(helper, pc.Vec2.ZERO.clone());
                        this.SendOnEndTextSelection();
                    } else {
                        this.GenerateHightlight(helper, pc.Vec2.ZERO.clone());
                        this.SendOnTextSelection();
                    }

                    helper.FillMesh(vbo);
                }
                finally {
                    if (Bridge.hasValue(helper)) {
                        helper.System$IDisposable$Dispose();
                    }
                }
            },
            /*TMPro.TMP_InputField.OnFillVBO end.*/

            /*TMPro.TMP_InputField.GenerateCaret start.*/
            GenerateCaret: function (vbo, roundingOffset) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#GenerateCaret", this ); }

                var $t, $t1, $t2, $t3;
                if (this.m_CaretVisible === false || UnityEngine.Component.op_Equality(this.m_TextComponent.canvas, null) || this.m_ReadOnly) {
                    return;
                }

                if (this.m_CursorVerts == null) {
                    this.CreateCursorVerts();
                }

                var width = this.m_CaretWidth;

                // TODO: Optimize to only update the caret position when needed.

                var startPosition = pc.Vec2.ZERO.clone();
                var height = 0;
                var currentCharacter = new TMPro.TMP_CharacterInfo();

                // Make sure caret position does not exceed characterInfo array size.
                if (this.caretPositionInternal >= this.m_TextComponent.textInfo.characterInfo.length) {
                    return;
                }

                var currentLine = ($t = this.m_TextComponent.textInfo.characterInfo)[this.caretPositionInternal].lineNumber;

                // Caret is positioned at the origin for the first character of each lines and at the advance for subsequent characters.
                if (this.caretPositionInternal === ($t1 = this.m_TextComponent.textInfo.lineInfo)[currentLine].firstCharacterIndex) {
                    currentCharacter = ($t2 = this.m_TextComponent.textInfo.characterInfo)[this.caretPositionInternal].$clone();
                    height = currentCharacter.ascender - currentCharacter.descender;

                    if (this.m_TextComponent.verticalAlignment === TMPro.VerticalAlignmentOptions.Geometry) {
                        startPosition = new pc.Vec2( currentCharacter.origin, 0 - height / 2 );
                    } else {
                        startPosition = new pc.Vec2( currentCharacter.origin, currentCharacter.descender );
                    }
                } else {
                    currentCharacter = ($t3 = this.m_TextComponent.textInfo.characterInfo)[this.caretPositionInternal - 1].$clone();
                    height = currentCharacter.ascender - currentCharacter.descender;

                    if (this.m_TextComponent.verticalAlignment === TMPro.VerticalAlignmentOptions.Geometry) {
                        startPosition = new pc.Vec2( currentCharacter.xAdvance, 0 - height / 2 );
                    } else {
                        startPosition = new pc.Vec2( currentCharacter.xAdvance, currentCharacter.descender );
                    }
                }

                if (this.m_SoftKeyboard != null) {
                    var selectionStart = this.m_StringPosition;
                    var softKeyboardStringLength = this.m_SoftKeyboard.text == null ? 0 : this.m_SoftKeyboard.text.length;

                    if (selectionStart < 0) {
                        selectionStart = 0;
                    }

                    if (selectionStart > softKeyboardStringLength) {
                        selectionStart = softKeyboardStringLength;
                    }

                    this.m_SoftKeyboard.selection = new UnityEngine.RangeInt.$ctor1(selectionStart, 0);
                }

                // Adjust the position of the RectTransform based on the caret position in the viewport (only if we have focus).
                if (this.isFocused && !pc.Vec2.equals( startPosition, this.m_LastPosition ) || this.m_forceRectTransformAdjustment || this.m_isLastKeyBackspace) {
                    this.AdjustRectTransformRelativeToViewport(startPosition.$clone(), height, currentCharacter.isVisible);
                }

                this.m_LastPosition = startPosition.$clone();

                // Clamp Caret height
                var top = startPosition.y + height;
                var bottom = top - height;

                // Minor tweak to address caret potentially being too thin based on canvas scaler values.
                var scale = this.m_TextComponent.canvas.scaleFactor;

                this.m_CursorVerts[0].position = new pc.Vec3( startPosition.x, bottom, 0.0 );
                this.m_CursorVerts[1].position = new pc.Vec3( startPosition.x, top, 0.0 );
                this.m_CursorVerts[2].position = new pc.Vec3( startPosition.x + width, top, 0.0 );
                this.m_CursorVerts[3].position = new pc.Vec3( startPosition.x + width, bottom, 0.0 );

                // Set Vertex Color for the caret color.
                this.m_CursorVerts[0].color = UnityEngine.Color32.op_Implicit$1(this.caretColor.$clone());
                this.m_CursorVerts[1].color = UnityEngine.Color32.op_Implicit$1(this.caretColor.$clone());
                this.m_CursorVerts[2].color = UnityEngine.Color32.op_Implicit$1(this.caretColor.$clone());
                this.m_CursorVerts[3].color = UnityEngine.Color32.op_Implicit$1(this.caretColor.$clone());

                vbo.AddUIVertexQuad(this.m_CursorVerts);

                // Update position of IME window when necessary.
                if (this.m_ShouldUpdateIMEWindowPosition || currentLine !== this.m_PreviousIMEInsertionLine) {
                    this.m_ShouldUpdateIMEWindowPosition = false;
                    this.m_PreviousIMEInsertionLine = currentLine;

                    // Calculate position of IME Window in screen space.
                    var cameraRef;
                    if (this.m_TextComponent.canvas.renderMode === UnityEngine.RenderMode.ScreenSpaceOverlay) {
                        cameraRef = null;
                    } else {
                        cameraRef = this.m_TextComponent.canvas.worldCamera;

                        if (UnityEngine.Component.op_Equality(cameraRef, null)) {
                            cameraRef = UnityEngine.Camera.current;
                        }
                    }

                    var cursorPosition = this.m_CachedInputRenderer.gameObject.transform.TransformPoint$1(this.m_CursorVerts[0].position);
                    var screenPosition = UnityEngine.RectTransformUtility.WorldToScreenPoint(cameraRef, cursorPosition.$clone());
                    screenPosition.y = UnityEngine.Screen.height - screenPosition.y;

                    UnityEngine.Input.compositionCursorPos = screenPosition.$clone();

                    //Debug.Log("[" + Time.frameCount + "] Updating IME Window position  Cursor Pos: (" + cursorPosition + ")  Screen Pos: (" + screenPosition + ") with Composition Length: " + compositionLength);
                }

                //#if TMP_DEBUG_MODE
                //Debug.Log("Caret position updated at frame: " + Time.frameCount);
                //#endif
            },
            /*TMPro.TMP_InputField.GenerateCaret end.*/

            /*TMPro.TMP_InputField.CreateCursorVerts start.*/
            CreateCursorVerts: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#CreateCursorVerts", this ); }

                this.m_CursorVerts = System.Array.init(4, function (){
                    return new UnityEngine.UIVertex();
                }, UnityEngine.UIVertex);

                for (var i = 0; i < this.m_CursorVerts.length; i++) {
                    this.m_CursorVerts[i] = UnityEngine.UIVertex.simpleVert.$clone();
                    this.m_CursorVerts[i].uv0 = pc.Vec2.ZERO.clone();
                }
            },
            /*TMPro.TMP_InputField.CreateCursorVerts end.*/

            /*TMPro.TMP_InputField.GenerateHightlight start.*/
            GenerateHightlight: function (vbo, roundingOffset) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#GenerateHightlight", this ); }

                // Update Masking Region
                this.UpdateMaskRegions();

                // Make sure caret position does not exceed characterInfo array size.
                //if (caretSelectPositionInternal >= m_TextComponent.textInfo.characterInfo.Length)
                //    return;

                var textInfo = this.m_TextComponent.textInfo;

                this.m_CaretPosition = this.GetCaretPositionFromStringIndex(this.stringPositionInternal);
                this.m_CaretSelectPosition = this.GetCaretPositionFromStringIndex(this.stringSelectPositionInternal);

                if (this.m_SoftKeyboard != null) {
                    var stringPosition = this.m_CaretPosition < this.m_CaretSelectPosition ? textInfo.characterInfo[this.m_CaretPosition].index : textInfo.characterInfo[this.m_CaretSelectPosition].index;
                    var length = this.m_CaretPosition < this.m_CaretSelectPosition ? this.stringSelectPositionInternal - stringPosition : this.stringPositionInternal - stringPosition;
                    this.m_SoftKeyboard.selection = new UnityEngine.RangeInt.$ctor1(stringPosition, length);
                }

                // Adjust text RectTranform position to make sure it is visible in viewport.
                var caretPosition = new UnityEngine.Vector2();
                var height = 0;
                if (this.m_CaretSelectPosition < textInfo.characterCount) {
                    caretPosition = new pc.Vec2( textInfo.characterInfo[this.m_CaretSelectPosition].origin, textInfo.characterInfo[this.m_CaretSelectPosition].descender );
                    height = textInfo.characterInfo[this.m_CaretSelectPosition].ascender - textInfo.characterInfo[this.m_CaretSelectPosition].descender;
                } else {
                    caretPosition = new pc.Vec2( textInfo.characterInfo[this.m_CaretSelectPosition - 1].xAdvance, textInfo.characterInfo[this.m_CaretSelectPosition - 1].descender );
                    height = textInfo.characterInfo[this.m_CaretSelectPosition - 1].ascender - textInfo.characterInfo[this.m_CaretSelectPosition - 1].descender;
                }

                // TODO: Don't adjust the position of the RectTransform if Reset On Deactivation is disabled
                // and we just selected the Input Field again.
                this.AdjustRectTransformRelativeToViewport(caretPosition.$clone(), height, true);

                var startChar = UnityEngine.Mathf.Max(0, this.m_CaretPosition);
                var endChar = UnityEngine.Mathf.Max(0, this.m_CaretSelectPosition);

                // Ensure pos is always less then selPos to make the code simpler
                if (startChar > endChar) {
                    var temp = startChar;
                    startChar = endChar;
                    endChar = temp;
                }

                endChar -= 1;

                //Debug.Log("Updating Highlight... Caret Position: " + startChar + " Caret Select POS: " + endChar);


                var currentLineIndex = textInfo.characterInfo[startChar].lineNumber;
                var nextLineStartIdx = textInfo.lineInfo[currentLineIndex].lastCharacterIndex;

                var vert = UnityEngine.UIVertex.simpleVert.$clone();
                vert.uv0 = pc.Vec2.ZERO.clone();
                vert.color = UnityEngine.Color32.op_Implicit$1(this.selectionColor.$clone());

                var currentChar = startChar;
                while (currentChar <= endChar && currentChar < textInfo.characterCount) {
                    if (currentChar === nextLineStartIdx || currentChar === endChar) {
                        var startCharInfo = textInfo.characterInfo[startChar].$clone();
                        var endCharInfo = textInfo.characterInfo[currentChar].$clone();

                        // Extra check to handle Carriage Return
                        if (currentChar > 0 && endCharInfo.character === 10 && textInfo.characterInfo[currentChar - 1].character === 13) {
                            endCharInfo = textInfo.characterInfo[currentChar - 1].$clone();
                        }

                        var startPosition = new pc.Vec2( startCharInfo.origin, textInfo.lineInfo[currentLineIndex].ascender );
                        var endPosition = new pc.Vec2( endCharInfo.xAdvance, textInfo.lineInfo[currentLineIndex].descender );

                        var startIndex = vbo.currentVertCount;
                        vert.position = new pc.Vec3( startPosition.x, endPosition.y, 0.0 );
                        vbo.AddVert(vert.$clone());

                        vert.position = new pc.Vec3( endPosition.x, endPosition.y, 0.0 );
                        vbo.AddVert(vert.$clone());

                        vert.position = new pc.Vec3( endPosition.x, startPosition.y, 0.0 );
                        vbo.AddVert(vert.$clone());

                        vert.position = new pc.Vec3( startPosition.x, startPosition.y, 0.0 );
                        vbo.AddVert(vert.$clone());

                        vbo.AddTriangle(startIndex, startIndex + 1, startIndex + 2);
                        vbo.AddTriangle(startIndex + 2, startIndex + 3, startIndex + 0);

                        startChar = currentChar + 1;
                        currentLineIndex++;

                        if (currentLineIndex < textInfo.lineCount) {
                            nextLineStartIdx = textInfo.lineInfo[currentLineIndex].lastCharacterIndex;
                        }
                    }

                    currentChar++;
                }

                //#if TMP_DEBUG_MODE
                //    Debug.Log("Text selection updated at frame: " + Time.frameCount);
                //#endif
            },
            /*TMPro.TMP_InputField.GenerateHightlight end.*/

            /*TMPro.TMP_InputField.AdjustRectTransformRelativeToViewport start.*/
            /**
             * @instance
             * @private
             * @this TMPro.TMP_InputField
             * @memberof TMPro.TMP_InputField
             * @param   {UnityEngine.Vector2}    startPosition    
             * @param   {number}                 height           
             * @param   {boolean}                isCharVisible
             * @return  {void}
             */
            AdjustRectTransformRelativeToViewport: function (startPosition, height, isCharVisible) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#AdjustRectTransformRelativeToViewport", this ); }

                var $t, $t1;
                //Debug.Log("Adjusting transform position relative to viewport.");

                if (UnityEngine.Component.op_Equality(this.m_TextViewport, null)) {
                    return;
                }

                var localPosition = this.transform.localPosition.$clone();
                var textComponentLocalPosition = this.m_TextComponent.rectTransform$1.localPosition.$clone();
                var textViewportLocalPosition = this.m_TextViewport.localPosition.$clone();
                var textViewportRect = this.m_TextViewport.rect.$clone();

                var caretPosition = new pc.Vec2( startPosition.x + textComponentLocalPosition.x + textViewportLocalPosition.x + localPosition.x, startPosition.y + textComponentLocalPosition.y + textViewportLocalPosition.y + localPosition.y );
                var viewportWSRect = new UnityEngine.Rect.$ctor1(localPosition.x + textViewportLocalPosition.x + textViewportRect.x, localPosition.y + textViewportLocalPosition.y + textViewportRect.y, textViewportRect.width, textViewportRect.height);

                // Adjust the position of the RectTransform based on the caret position in the viewport.
                var rightOffset = viewportWSRect.xMax - (caretPosition.x + this.m_TextComponent.margin.z + this.m_CaretWidth);
                if (rightOffset < 0.0) {
                    if (!this.multiLine || this.multiLine && isCharVisible) {
                        //Debug.Log("Shifting text to the LEFT by " + rightOffset.ToString("f3"));
                        this.m_TextComponent.rectTransform$1.anchoredPosition = this.m_TextComponent.rectTransform$1.anchoredPosition.$clone().add( new pc.Vec2( rightOffset, 0 ) );

                        this.AssignPositioningIfNeeded();
                    }
                }

                var leftOffset = caretPosition.x - this.m_TextComponent.margin.x - viewportWSRect.xMin;
                if (leftOffset < 0.0) {
                    //Debug.Log("Shifting text to the RIGHT by " + leftOffset.ToString("f3"));
                    this.m_TextComponent.rectTransform$1.anchoredPosition = this.m_TextComponent.rectTransform$1.anchoredPosition.$clone().add( new pc.Vec2( -leftOffset, 0 ) );
                    this.AssignPositioningIfNeeded();
                }

                // Adjust text area up or down if not in single line mode.
                if (this.m_LineType !== TMPro.TMP_InputField.LineType.SingleLine) {
                    var topOffset = viewportWSRect.yMax - (caretPosition.y + height);
                    if (topOffset < -0.0001) {
                        //Debug.Log("Shifting text to Up " + topOffset.ToString("f3"));
                        this.m_TextComponent.rectTransform$1.anchoredPosition = this.m_TextComponent.rectTransform$1.anchoredPosition.$clone().add( new pc.Vec2( 0, topOffset ) );
                        this.AssignPositioningIfNeeded();
                    }

                    var bottomOffset = caretPosition.y - viewportWSRect.yMin;
                    if (bottomOffset < 0.0) {
                        //Debug.Log("Shifting text to Down " + bottomOffset.ToString("f3"));
                        this.m_TextComponent.rectTransform$1.anchoredPosition = this.m_TextComponent.rectTransform$1.anchoredPosition.$clone().sub( new pc.Vec2( 0, bottomOffset ) );
                        this.AssignPositioningIfNeeded();
                    }
                }

                // Special handling of backspace
                if (this.m_isLastKeyBackspace) {
                    var anchoredPositionX = this.m_TextComponent.rectTransform$1.anchoredPosition.x;

                    var firstCharPosition = localPosition.x + textViewportLocalPosition.x + textComponentLocalPosition.x + ($t = this.m_TextComponent.textInfo.characterInfo)[0].origin - this.m_TextComponent.margin.x;
                    var lastCharPosition = localPosition.x + textViewportLocalPosition.x + textComponentLocalPosition.x + ($t1 = this.m_TextComponent.textInfo.characterInfo)[this.m_TextComponent.textInfo.characterCount - 1].origin + this.m_TextComponent.margin.z + this.m_CaretWidth;

                    if (anchoredPositionX > 0.0001 && firstCharPosition > viewportWSRect.xMin) {
                        var offset = viewportWSRect.xMin - firstCharPosition;

                        if (anchoredPositionX < -offset) {
                            offset = -anchoredPositionX;
                        }

                        this.m_TextComponent.rectTransform$1.anchoredPosition = this.m_TextComponent.rectTransform$1.anchoredPosition.$clone().add( new pc.Vec2( offset, 0 ) );
                        this.AssignPositioningIfNeeded();
                    } else if (anchoredPositionX < -0.0001 && lastCharPosition < viewportWSRect.xMax) {
                        var offset1 = viewportWSRect.xMax - lastCharPosition;

                        if (-anchoredPositionX < offset1) {
                            offset1 = -anchoredPositionX;
                        }

                        this.m_TextComponent.rectTransform$1.anchoredPosition = this.m_TextComponent.rectTransform$1.anchoredPosition.$clone().add( new pc.Vec2( offset1, 0 ) );
                        this.AssignPositioningIfNeeded();
                    }

                    this.m_isLastKeyBackspace = false;
                }

                this.m_forceRectTransformAdjustment = false;
            },
            /*TMPro.TMP_InputField.AdjustRectTransformRelativeToViewport end.*/

            /*TMPro.TMP_InputField.Validate start.*/
            /**
             * Validate the specified input.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_InputField
             * @memberof TMPro.TMP_InputField
             * @param   {string}    text    
             * @param   {number}    pos     
             * @param   {number}    ch
             * @return  {number}
             */
            Validate: function (text, pos, ch) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#Validate", this ); }

                text = {v:text};
                pos = {v:pos};
                // Validation is disabled
                if (this.characterValidation === TMPro.TMP_InputField.CharacterValidation.None || !this.enabled) {
                    return ch;
                }

                if (this.characterValidation === TMPro.TMP_InputField.CharacterValidation.Integer || this.characterValidation === TMPro.TMP_InputField.CharacterValidation.Decimal) {
                    // Integer and decimal
                    var cursorBeforeDash = pos.v === 0 && text.v.length > 0 && text.v.charCodeAt(0) === 45;
                    var selectionAtStart = this.stringPositionInternal === 0 || this.stringSelectPositionInternal === 0;
                    if (!cursorBeforeDash) {
                        if (ch >= 48 && ch <= 57) {
                            return ch;
                        }

                        if (ch === 45 && (pos.v === 0 || selectionAtStart)) {
                            return ch;
                        }

                        var separator = System.Globalization.CultureInfo.getCurrentCulture().numberFormat.numberDecimalSeparator;
                        if (ch === System.Convert.toChar(separator, null, 18) && this.characterValidation === TMPro.TMP_InputField.CharacterValidation.Decimal && !System.String.contains(text.v,separator)) {
                            return ch;
                        }
                    }
                } else if (this.characterValidation === TMPro.TMP_InputField.CharacterValidation.Digit) {
                    if (ch >= 48 && ch <= 57) {
                        return ch;
                    }
                } else if (this.characterValidation === TMPro.TMP_InputField.CharacterValidation.Alphanumeric) {
                    // All alphanumeric characters
                    if (ch >= 65 && ch <= 90) {
                        return ch;
                    }

                    if (ch >= 97 && ch <= 122) {
                        return ch;
                    }

                    if (ch >= 48 && ch <= 57) {
                        return ch;
                    }
                } else if (this.characterValidation === TMPro.TMP_InputField.CharacterValidation.Name) {
                    var prevChar = text.v.length > 0 ? text.v.charCodeAt(Math.max(0, Math.min(pos.v - 1, text.v.length - 1))) : 32;
                    var lastChar = text.v.length > 0 ? text.v.charCodeAt(Math.max(0, Math.min(pos.v, text.v.length - 1))) : 32;
                    var nextChar = text.v.length > 0 ? text.v.charCodeAt(Math.max(0, Math.min(pos.v + 1, text.v.length - 1))) : 10;

                    if (System.Char.isLetter(ch)) {
                        // First letter is always capitalized
                        if (Bridge.isLower(ch) && pos.v === 0) {
                            return String.fromCharCode(ch).toUpperCase().charCodeAt(0);
                        }

                        // Letter following a space or hyphen is always capitalized
                        if (Bridge.isLower(ch) && (prevChar === 32 || prevChar === 45)) {
                            return String.fromCharCode(ch).toUpperCase().charCodeAt(0);
                        }

                        // Uppercase letters are only allowed after spaces, apostrophes, hyphens or lowercase letter
                        if (Bridge.isUpper(ch) && pos.v > 0 && prevChar !== 32 && prevChar !== 39 && prevChar !== 45 && !Bridge.isLower(prevChar)) {
                            return String.fromCharCode(ch).toLowerCase().charCodeAt(0);
                        }

                        // Do not allow uppercase characters to be inserted before another uppercase character
                        if (Bridge.isUpper(ch) && Bridge.isUpper(lastChar)) {
                            return 0;
                        }

                        // If character was already in correct case, return it as-is.
                        // Also, letters that are neither upper nor lower case are always allowed.
                        return ch;
                    } else if (ch === 39) {
                        // Don't allow more than one apostrophe
                        if (lastChar !== 32 && lastChar !== 39 && nextChar !== 39 && !System.String.contains(text.v,"'")) {
                            return ch;
                        }
                    }

                    // Allow inserting a hyphen after a character
                    if (System.Char.isLetter(prevChar) && ch === 45 && lastChar !== 45) {
                        return ch;
                    }

                    if ((ch === 32 || ch === 45) && pos.v !== 0) {
                        // Don't allow more than one space in a row
                        if (prevChar !== 32 && prevChar !== 39 && prevChar !== 45 && lastChar !== 32 && lastChar !== 39 && lastChar !== 45 && nextChar !== 32 && nextChar !== 39 && nextChar !== 45) {
                            return ch;
                        }
                    }
                } else if (this.characterValidation === TMPro.TMP_InputField.CharacterValidation.EmailAddress) {
                    // From StackOverflow about allowed characters in email addresses:
                    // Uppercase and lowercase English letters (a-z, A-Z)
                    // Digits 0 to 9
                    // Characters ! # $ % & ' * + - / = ? ^ _ ` { | } ~
                    // Character . (dot, period, full stop) provided that it is not the first or last character,
                    // and provided also that it does not appear two or more times consecutively.

                    if (ch >= 65 && ch <= 90) {
                        return ch;
                    }

                    if (ch >= 97 && ch <= 122) {
                        return ch;
                    }

                    if (ch >= 48 && ch <= 57) {
                        return ch;
                    }

                    if (ch === 64 && System.String.indexOf(text.v, String.fromCharCode(64)) === -1) {
                        return ch;
                    }

                    if (System.String.indexOf(TMPro.TMP_InputField.kEmailSpecialCharacters, String.fromCharCode(ch)) !== -1) {
                        return ch;
                    }

                    if (ch === 46) {
                        var lastChar1 = text.v.length > 0 ? text.v.charCodeAt(Math.max(0, Math.min(pos.v, text.v.length - 1))) : 32;
                        var nextChar1 = text.v.length > 0 ? text.v.charCodeAt(Math.max(0, Math.min(pos.v + 1, text.v.length - 1))) : 10;
                        if (lastChar1 !== 46 && nextChar1 !== 46) {
                            return ch;
                        }
                    }
                } else if (this.characterValidation === TMPro.TMP_InputField.CharacterValidation.Regex) {
                    // Regex expression
                    if (System.Text.RegularExpressions.Regex.isMatch(String.fromCharCode(ch), this.m_RegexValue)) {
                        return ch;
                    }
                } else if (this.characterValidation === TMPro.TMP_InputField.CharacterValidation.CustomValidator) {
                    if (this.m_InputValidator != null) {
                        var c = this.m_InputValidator.Validate(text, pos, ch);
                        this.m_Text = text.v;
                        this.stringSelectPositionInternal = (this.stringPositionInternal = pos.v, pos.v);
                        return c;
                    }
                }

                return 0;
            },
            /*TMPro.TMP_InputField.Validate end.*/

            /*TMPro.TMP_InputField.ActivateInputField start.*/
            ActivateInputField: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#ActivateInputField", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.m_TextComponent, null) || this.m_TextComponent.font == null || !this.IsActive() || !this.IsInteractable()) {
                    return;
                }

                if (this.isFocused) {
                    if (this.m_SoftKeyboard != null && !this.m_SoftKeyboard.active) {
                        this.m_SoftKeyboard.active = true;
                        this.m_SoftKeyboard.text = this.m_Text;
                    }
                }

                this.m_ShouldActivateNextUpdate = true;
            },
            /*TMPro.TMP_InputField.ActivateInputField end.*/

            /*TMPro.TMP_InputField.ActivateInputFieldInternal start.*/
            ActivateInputFieldInternal: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#ActivateInputFieldInternal", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(UnityEngine.EventSystems.EventSystem.current, null)) {
                    return;
                }

                if (UnityEngine.GameObject.op_Inequality(UnityEngine.EventSystems.EventSystem.current.currentSelectedGameObject, this.gameObject)) {
                    UnityEngine.EventSystems.EventSystem.current.SetSelectedGameObject(this.gameObject);
                }

                if (UnityEngine.TouchScreenKeyboard.isSupported && this.shouldHideSoftKeyboard === false) {
                    if (UnityEngine.MonoBehaviour.op_Inequality(this.inputSystem, null) && this.inputSystem.touchSupported) {
                        UnityEngine.TouchScreenKeyboard.hideInput = this.shouldHideMobileInput;
                    }

                    if (this.shouldHideSoftKeyboard === false && this.m_ReadOnly === false) {
                        this.m_SoftKeyboard = this.inputType === TMPro.TMP_InputField.InputType.Password ? UnityEngine.TouchScreenKeyboard.Open$7(this.m_Text, this.keyboardType, false, this.multiLine, true, false, "", this.characterLimit) : UnityEngine.TouchScreenKeyboard.Open$7(this.m_Text, this.keyboardType, this.inputType === TMPro.TMP_InputField.InputType.AutoCorrect, this.multiLine, false, false, "", this.characterLimit);

                        this.OnFocus();

                        // Opening the soft keyboard sets its selection to the end of the text.
                        // As such, we set the selection to match the Input Field's internal selection.
                        if (this.m_SoftKeyboard != null) {
                            var length = this.stringPositionInternal < this.stringSelectPositionInternal ? this.stringSelectPositionInternal - this.stringPositionInternal : this.stringPositionInternal - this.stringSelectPositionInternal;
                            this.m_SoftKeyboard.selection = new UnityEngine.RangeInt.$ctor1(this.stringPositionInternal < this.stringSelectPositionInternal ? this.stringPositionInternal : this.stringSelectPositionInternal, length);
                        }
                        //}
                    }

                    // Cache the value of isInPlaceEditingAllowed, because on UWP this involves calling into native code
                    // The value only needs to be updated once when the TouchKeyboard is opened.

                } else {
                    if (!UnityEngine.TouchScreenKeyboard.isSupported && this.m_ReadOnly === false && UnityEngine.MonoBehaviour.op_Inequality(this.inputSystem, null)) {
                        this.inputSystem.imeCompositionMode = UnityEngine.IMECompositionMode.On;
                    }

                    this.OnFocus();
                }

                this.m_AllowInput = true;
                this.m_OriginalText = this.text;
                this.m_WasCanceled = false;
                this.SetCaretVisible();
                this.UpdateLabel();
            },
            /*TMPro.TMP_InputField.ActivateInputFieldInternal end.*/

            /*TMPro.TMP_InputField.OnSelect start.*/
            OnSelect: function (eventData) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#OnSelect", this ); }

                //Debug.Log("OnSelect()");

                UnityEngine.UI.Selectable.prototype.OnSelect.call(this, eventData);
                this.SendOnFocus();

                this.ActivateInputField();
            },
            /*TMPro.TMP_InputField.OnSelect end.*/

            /*TMPro.TMP_InputField.OnPointerClick start.*/
            OnPointerClick: function (eventData) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#OnPointerClick", this ); }

                //Debug.Log("Pointer Click Event...");

                if (eventData.button !== UnityEngine.EventSystems.PointerEventData.InputButton.Left) {
                    return;
                }

                this.ActivateInputField();
            },
            /*TMPro.TMP_InputField.OnPointerClick end.*/

            /*TMPro.TMP_InputField.OnControlClick start.*/
            OnControlClick: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#OnControlClick", this ); }

                //Debug.Log("Input Field control click...");
            },
            /*TMPro.TMP_InputField.OnControlClick end.*/

            /*TMPro.TMP_InputField.ReleaseSelection start.*/
            ReleaseSelection: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#ReleaseSelection", this ); }

                this.m_SelectionStillActive = false;
                this.m_ReleaseSelection = false;
                this.m_PreviouslySelectedObject = null;

                this.MarkGeometryAsDirty();

                this.SendOnEndEdit();
                this.SendOnEndTextSelection();
            },
            /*TMPro.TMP_InputField.ReleaseSelection end.*/

            /*TMPro.TMP_InputField.DeactivateInputField start.*/
            DeactivateInputField: function (clearSelection) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#DeactivateInputField", this ); }

                if (clearSelection === void 0) { clearSelection = false; }
                //Debug.Log("Deactivate Input Field...");

                // Not activated do nothing.
                if (!this.m_AllowInput) {
                    return;
                }

                this.m_HasDoneFocusTransition = false;
                this.m_AllowInput = false;

                if (UnityEngine.MonoBehaviour.op_Inequality(this.m_Placeholder, null)) {
                    this.m_Placeholder.enabled = System.String.isNullOrEmpty(this.m_Text);
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.m_TextComponent, null) && this.IsInteractable()) {
                    if (this.m_WasCanceled && this.m_RestoreOriginalTextOnEscape) {
                        this.text = this.m_OriginalText;
                    }

                    if (this.m_SoftKeyboard != null) {
                        this.m_SoftKeyboard.active = false;
                        this.m_SoftKeyboard = null;
                    }

                    this.m_SelectionStillActive = true;

                    if (this.m_ResetOnDeActivation || this.m_ReleaseSelection) {
                        //m_StringPosition = m_StringSelectPosition = 0;
                        //m_CaretPosition = m_CaretSelectPosition = 0;
                        //m_TextComponent.rectTransform.localPosition = m_DefaultTransformPosition;

                        if (UnityEngine.MonoBehaviour.op_Equality(this.m_VerticalScrollbar, null)) {
                            this.ReleaseSelection();
                        }
                    }

                    if (UnityEngine.MonoBehaviour.op_Inequality(this.inputSystem, null)) {
                        this.inputSystem.imeCompositionMode = UnityEngine.IMECompositionMode.Auto;
                    }
                }

                this.MarkGeometryAsDirty();
            },
            /*TMPro.TMP_InputField.DeactivateInputField end.*/

            /*TMPro.TMP_InputField.OnDeselect start.*/
            OnDeselect: function (eventData) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#OnDeselect", this ); }

                this.DeactivateInputField();

                UnityEngine.UI.Selectable.prototype.OnDeselect.call(this, eventData);
                this.SendOnFocusLost();
            },
            /*TMPro.TMP_InputField.OnDeselect end.*/

            /*TMPro.TMP_InputField.OnSubmit start.*/
            OnSubmit: function (eventData) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#OnSubmit", this ); }

                //Debug.Log("OnSubmit()");

                if (!this.IsActive() || !this.IsInteractable()) {
                    return;
                }

                if (!this.isFocused) {
                    this.m_ShouldActivateNextUpdate = true;
                }

                this.SendOnSubmit();
            },
            /*TMPro.TMP_InputField.OnSubmit end.*/

            /*TMPro.TMP_InputField.EnforceContentType start.*/
            EnforceContentType: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#EnforceContentType", this ); }

                switch (this.contentType) {
                    case TMPro.TMP_InputField.ContentType.Standard: 
                        {
                            // Don't enforce line type for this content type.
                            this.m_InputType = TMPro.TMP_InputField.InputType.Standard;
                            this.m_KeyboardType = UnityEngine.TouchScreenKeyboardType.Default;
                            this.m_CharacterValidation = TMPro.TMP_InputField.CharacterValidation.None;
                            break;
                        }
                    case TMPro.TMP_InputField.ContentType.Autocorrected: 
                        {
                            // Don't enforce line type for this content type.
                            this.m_InputType = TMPro.TMP_InputField.InputType.AutoCorrect;
                            this.m_KeyboardType = UnityEngine.TouchScreenKeyboardType.Default;
                            this.m_CharacterValidation = TMPro.TMP_InputField.CharacterValidation.None;
                            break;
                        }
                    case TMPro.TMP_InputField.ContentType.IntegerNumber: 
                        {
                            this.m_LineType = TMPro.TMP_InputField.LineType.SingleLine;
                            this.m_InputType = TMPro.TMP_InputField.InputType.Standard;
                            this.m_KeyboardType = UnityEngine.TouchScreenKeyboardType.NumberPad;
                            this.m_CharacterValidation = TMPro.TMP_InputField.CharacterValidation.Integer;
                            break;
                        }
                    case TMPro.TMP_InputField.ContentType.DecimalNumber: 
                        {
                            this.m_LineType = TMPro.TMP_InputField.LineType.SingleLine;
                            this.m_InputType = TMPro.TMP_InputField.InputType.Standard;
                            this.m_KeyboardType = UnityEngine.TouchScreenKeyboardType.NumbersAndPunctuation;
                            this.m_CharacterValidation = TMPro.TMP_InputField.CharacterValidation.Decimal;
                            break;
                        }
                    case TMPro.TMP_InputField.ContentType.Alphanumeric: 
                        {
                            this.m_LineType = TMPro.TMP_InputField.LineType.SingleLine;
                            this.m_InputType = TMPro.TMP_InputField.InputType.Standard;
                            this.m_KeyboardType = UnityEngine.TouchScreenKeyboardType.ASCIICapable;
                            this.m_CharacterValidation = TMPro.TMP_InputField.CharacterValidation.Alphanumeric;
                            break;
                        }
                    case TMPro.TMP_InputField.ContentType.Name: 
                        {
                            this.m_LineType = TMPro.TMP_InputField.LineType.SingleLine;
                            this.m_InputType = TMPro.TMP_InputField.InputType.Standard;
                            this.m_KeyboardType = UnityEngine.TouchScreenKeyboardType.Default;
                            this.m_CharacterValidation = TMPro.TMP_InputField.CharacterValidation.Name;
                            break;
                        }
                    case TMPro.TMP_InputField.ContentType.EmailAddress: 
                        {
                            this.m_LineType = TMPro.TMP_InputField.LineType.SingleLine;
                            this.m_InputType = TMPro.TMP_InputField.InputType.Standard;
                            this.m_KeyboardType = UnityEngine.TouchScreenKeyboardType.EmailAddress;
                            this.m_CharacterValidation = TMPro.TMP_InputField.CharacterValidation.EmailAddress;
                            break;
                        }
                    case TMPro.TMP_InputField.ContentType.Password: 
                        {
                            this.m_LineType = TMPro.TMP_InputField.LineType.SingleLine;
                            this.m_InputType = TMPro.TMP_InputField.InputType.Password;
                            this.m_KeyboardType = UnityEngine.TouchScreenKeyboardType.Default;
                            this.m_CharacterValidation = TMPro.TMP_InputField.CharacterValidation.None;
                            break;
                        }
                    case TMPro.TMP_InputField.ContentType.Pin: 
                        {
                            this.m_LineType = TMPro.TMP_InputField.LineType.SingleLine;
                            this.m_InputType = TMPro.TMP_InputField.InputType.Password;
                            this.m_KeyboardType = UnityEngine.TouchScreenKeyboardType.NumberPad;
                            this.m_CharacterValidation = TMPro.TMP_InputField.CharacterValidation.Digit;
                            break;
                        }
                    default: 
                        {
                            // Includes Custom type. Nothing should be enforced.
                            break;
                        }
                }

                this.SetTextComponentWrapMode();
            },
            /*TMPro.TMP_InputField.EnforceContentType end.*/

            /*TMPro.TMP_InputField.SetTextComponentWrapMode start.*/
            SetTextComponentWrapMode: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#SetTextComponentWrapMode", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.m_TextComponent, null)) {
                    return;
                }

                if (this.multiLine) {
                    this.m_TextComponent.enableWordWrapping = true;
                } else {
                    this.m_TextComponent.enableWordWrapping = false;
                }
            },
            /*TMPro.TMP_InputField.SetTextComponentWrapMode end.*/

            /*TMPro.TMP_InputField.SetTextComponentRichTextMode start.*/
            SetTextComponentRichTextMode: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#SetTextComponentRichTextMode", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.m_TextComponent, null)) {
                    return;
                }

                this.m_TextComponent.richText = this.m_RichText;
            },
            /*TMPro.TMP_InputField.SetTextComponentRichTextMode end.*/

            /*TMPro.TMP_InputField.SetToCustomIfContentTypeIsNot start.*/
            SetToCustomIfContentTypeIsNot: function (allowedContentTypes) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#SetToCustomIfContentTypeIsNot", this ); }

                if (allowedContentTypes === void 0) { allowedContentTypes = []; }
                if (this.contentType === TMPro.TMP_InputField.ContentType.Custom) {
                    return;
                }

                for (var i = 0; i < allowedContentTypes.length; i++) {
                    if (this.contentType === allowedContentTypes[i]) {
                        return;
                    }
                }

                this.contentType = TMPro.TMP_InputField.ContentType.Custom;
            },
            /*TMPro.TMP_InputField.SetToCustomIfContentTypeIsNot end.*/

            /*TMPro.TMP_InputField.SetToCustom start.*/
            SetToCustom: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#SetToCustom", this ); }

                if (this.contentType === TMPro.TMP_InputField.ContentType.Custom) {
                    return;
                }

                this.contentType = TMPro.TMP_InputField.ContentType.Custom;
            },
            /*TMPro.TMP_InputField.SetToCustom end.*/

            /*TMPro.TMP_InputField.SetToCustom$1 start.*/
            SetToCustom$1: function (characterValidation) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#SetToCustom$1", this ); }

                if (this.contentType === TMPro.TMP_InputField.ContentType.Custom) {
                    characterValidation = TMPro.TMP_InputField.CharacterValidation.CustomValidator;
                    return;
                }

                this.contentType = TMPro.TMP_InputField.ContentType.Custom;
                characterValidation = TMPro.TMP_InputField.CharacterValidation.CustomValidator;
            },
            /*TMPro.TMP_InputField.SetToCustom$1 end.*/

            /*TMPro.TMP_InputField.DoStateTransition start.*/
            DoStateTransition: function (state, instant) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#DoStateTransition", this ); }

                if (this.m_HasDoneFocusTransition) {
                    state = UnityEngine.UI.Selectable.SelectionState.Selected;
                } else if (state === UnityEngine.UI.Selectable.SelectionState.Pressed) {
                    this.m_HasDoneFocusTransition = true;
                }

                UnityEngine.UI.Selectable.prototype.DoStateTransition.call(this, state, instant);
            },
            /*TMPro.TMP_InputField.DoStateTransition end.*/

            /*TMPro.TMP_InputField.CalculateLayoutInputHorizontal start.*/
            /**
             * See ILayoutElement.CalculateLayoutInputHorizontal.
             *
             * @instance
             * @public
             * @this TMPro.TMP_InputField
             * @memberof TMPro.TMP_InputField
             * @return  {void}
             */
            CalculateLayoutInputHorizontal: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#CalculateLayoutInputHorizontal", this ); }
 },
            /*TMPro.TMP_InputField.CalculateLayoutInputHorizontal end.*/

            /*TMPro.TMP_InputField.CalculateLayoutInputVertical start.*/
            /**
             * See ILayoutElement.CalculateLayoutInputVertical.
             *
             * @instance
             * @public
             * @this TMPro.TMP_InputField
             * @memberof TMPro.TMP_InputField
             * @return  {void}
             */
            CalculateLayoutInputVertical: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#CalculateLayoutInputVertical", this ); }
 },
            /*TMPro.TMP_InputField.CalculateLayoutInputVertical end.*/

            /*TMPro.TMP_InputField.SetGlobalPointSize start.*/
            /**
             * Function to conveniently set the point size of both Placeholder and Input Field text object.
             *
             * @instance
             * @public
             * @this TMPro.TMP_InputField
             * @memberof TMPro.TMP_InputField
             * @param   {number}    pointSize
             * @return  {void}
             */
            SetGlobalPointSize: function (pointSize) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#SetGlobalPointSize", this ); }

                var placeholderTextComponent = Bridge.as(this.m_Placeholder, TMPro.TMP_Text);

                if (UnityEngine.MonoBehaviour.op_Inequality(placeholderTextComponent, null)) {
                    placeholderTextComponent.fontSize = pointSize;
                }

                this.textComponent.fontSize = pointSize;
            },
            /*TMPro.TMP_InputField.SetGlobalPointSize end.*/

            /*TMPro.TMP_InputField.SetGlobalFontAsset start.*/
            /**
             * Function to conveniently set the Font Asset of both Placeholder and Input Field text object.
             *
             * @instance
             * @public
             * @this TMPro.TMP_InputField
             * @memberof TMPro.TMP_InputField
             * @param   {TMPro.TMP_FontAsset}    fontAsset
             * @return  {void}
             */
            SetGlobalFontAsset: function (fontAsset) {
if ( TRACE ) { TRACE( "TMPro.TMP_InputField#SetGlobalFontAsset", this ); }

                var placeholderTextComponent = Bridge.as(this.m_Placeholder, TMPro.TMP_Text);

                if (UnityEngine.MonoBehaviour.op_Inequality(placeholderTextComponent, null)) {
                    placeholderTextComponent.font = fontAsset;
                }

                this.textComponent.font = fontAsset;
            },
            /*TMPro.TMP_InputField.SetGlobalFontAsset end.*/


        },
        overloads: {
            "MoveDown(bool, bool)": "MoveDown$1",
            "MoveUp(bool, bool)": "MoveUp$1",
            "MovePageUp(bool, bool)": "MovePageUp$1",
            "MovePageDown(bool, bool)": "MovePageDown$1",
            "Append(string)": "Append$1",
            "SetToCustom(CharacterValidation)": "SetToCustom$1"
        }
    });
    /*TMPro.TMP_InputField end.*/

    /*TMPro.TMP_InputField+CharacterValidation start.*/
    Bridge.define("TMPro.TMP_InputField.CharacterValidation", {
        $kind: 1006,
        statics: {
            fields: {
                None: 0,
                Digit: 1,
                Integer: 2,
                Decimal: 3,
                Alphanumeric: 4,
                Name: 5,
                Regex: 6,
                EmailAddress: 7,
                CustomValidator: 8
            }
        }
    });
    /*TMPro.TMP_InputField+CharacterValidation end.*/

    /*TMPro.TMP_InputField+ContentType start.*/
    Bridge.define("TMPro.TMP_InputField.ContentType", {
        $kind: 1006,
        statics: {
            fields: {
                Standard: 0,
                Autocorrected: 1,
                IntegerNumber: 2,
                DecimalNumber: 3,
                Alphanumeric: 4,
                Name: 5,
                EmailAddress: 6,
                Password: 7,
                Pin: 8,
                Custom: 9
            }
        }
    });
    /*TMPro.TMP_InputField+ContentType end.*/

    /*TMPro.TMP_InputField+EditState start.*/
    Bridge.define("TMPro.TMP_InputField.EditState", {
        $kind: 1006,
        statics: {
            fields: {
                Continue: 0,
                Finish: 1
            }
        }
    });
    /*TMPro.TMP_InputField+EditState end.*/

    /*TMPro.TMP_InputField+InputType start.*/
    Bridge.define("TMPro.TMP_InputField.InputType", {
        $kind: 1006,
        statics: {
            fields: {
                Standard: 0,
                AutoCorrect: 1,
                Password: 2
            }
        }
    });
    /*TMPro.TMP_InputField+InputType end.*/

    /*TMPro.TMP_InputField+LineType start.*/
    Bridge.define("TMPro.TMP_InputField.LineType", {
        $kind: 1006,
        statics: {
            fields: {
                SingleLine: 0,
                MultiLineSubmit: 1,
                MultiLineNewline: 2
            }
        }
    });
    /*TMPro.TMP_InputField+LineType end.*/

    /*TMPro.TMP_InputField+OnChangeEvent start.*/
    Bridge.define("TMPro.TMP_InputField.OnChangeEvent", {
        inherits: [UnityEngine.Events.UnityEvent$1(System.String)],
        $kind: 1002
    });
    /*TMPro.TMP_InputField+OnChangeEvent end.*/

    /*TMPro.TMP_InputField+SelectionEvent start.*/
    Bridge.define("TMPro.TMP_InputField.SelectionEvent", {
        inherits: [UnityEngine.Events.UnityEvent$1(System.String)],
        $kind: 1002
    });
    /*TMPro.TMP_InputField+SelectionEvent end.*/

    /*TMPro.TMP_InputField+SubmitEvent start.*/
    Bridge.define("TMPro.TMP_InputField.SubmitEvent", {
        inherits: [UnityEngine.Events.UnityEvent$1(System.String)],
        $kind: 1002
    });
    /*TMPro.TMP_InputField+SubmitEvent end.*/

    /*TMPro.TMP_InputField+TextSelectionEvent start.*/
    Bridge.define("TMPro.TMP_InputField.TextSelectionEvent", {
        inherits: [UnityEngine.Events.UnityEvent$3(System.String,System.Int32,System.Int32)],
        $kind: 1002
    });
    /*TMPro.TMP_InputField+TextSelectionEvent end.*/

    /*TMPro.TMP_InputField+TouchScreenKeyboardEvent start.*/
    Bridge.define("TMPro.TMP_InputField.TouchScreenKeyboardEvent", {
        inherits: [UnityEngine.Events.UnityEvent$1(UnityEngine.TouchScreenKeyboard.Status)],
        $kind: 1002
    });
    /*TMPro.TMP_InputField+TouchScreenKeyboardEvent end.*/

    /*TMPro.TMP_InputValidator start.*/
    /**
     * Custom text input validator where user can implement their own custom character validation.
     *
     * @abstract
     * @public
     * @class TMPro.TMP_InputValidator
     * @augments UnityEngine.ScriptableObject
     */
    Bridge.define("TMPro.TMP_InputValidator", {
        inherits: [UnityEngine.ScriptableObject]
    });
    /*TMPro.TMP_InputValidator end.*/

    /*TMPro.TMP_LineInfo start.*/
    /**
     * Structure which contains information about the individual lines of text.
     * Function returning the current line of text.
     *
     * @public
     * @class TMPro.TMP_LineInfo
     * @return  {[type]}
     */
    Bridge.define("TMPro.TMP_LineInfo", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_LineInfo#getDefaultValue", this ); }
 return new TMPro.TMP_LineInfo(); }
            }
        },
        fields: {
            controlCharacterCount: 0,
            characterCount: 0,
            visibleCharacterCount: 0,
            spaceCount: 0,
            wordCount: 0,
            firstCharacterIndex: 0,
            firstVisibleCharacterIndex: 0,
            lastCharacterIndex: 0,
            lastVisibleCharacterIndex: 0,
            length: 0,
            lineHeight: 0,
            ascender: 0,
            baseline: 0,
            descender: 0,
            maxAdvance: 0,
            width: 0,
            marginLeft: 0,
            marginRight: 0,
            alignment: 0,
            lineExtents: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_LineInfo#init", this ); }

                this.lineExtents = new TMPro.Extents();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_LineInfo#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_LineInfo#getHashCode", this ); }

                var h = Bridge.addHash([5169816809, this.controlCharacterCount, this.characterCount, this.visibleCharacterCount, this.spaceCount, this.wordCount, this.firstCharacterIndex, this.firstVisibleCharacterIndex, this.lastCharacterIndex, this.lastVisibleCharacterIndex, this.length, this.lineHeight, this.ascender, this.baseline, this.descender, this.maxAdvance, this.width, this.marginLeft, this.marginRight, this.alignment, this.lineExtents]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.TMP_LineInfo#equals", this ); }

                if (!Bridge.is(o, TMPro.TMP_LineInfo)) {
                    return false;
                }
                return Bridge.equals(this.controlCharacterCount, o.controlCharacterCount) && Bridge.equals(this.characterCount, o.characterCount) && Bridge.equals(this.visibleCharacterCount, o.visibleCharacterCount) && Bridge.equals(this.spaceCount, o.spaceCount) && Bridge.equals(this.wordCount, o.wordCount) && Bridge.equals(this.firstCharacterIndex, o.firstCharacterIndex) && Bridge.equals(this.firstVisibleCharacterIndex, o.firstVisibleCharacterIndex) && Bridge.equals(this.lastCharacterIndex, o.lastCharacterIndex) && Bridge.equals(this.lastVisibleCharacterIndex, o.lastVisibleCharacterIndex) && Bridge.equals(this.length, o.length) && Bridge.equals(this.lineHeight, o.lineHeight) && Bridge.equals(this.ascender, o.ascender) && Bridge.equals(this.baseline, o.baseline) && Bridge.equals(this.descender, o.descender) && Bridge.equals(this.maxAdvance, o.maxAdvance) && Bridge.equals(this.width, o.width) && Bridge.equals(this.marginLeft, o.marginLeft) && Bridge.equals(this.marginRight, o.marginRight) && Bridge.equals(this.alignment, o.alignment) && Bridge.equals(this.lineExtents, o.lineExtents);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.TMP_LineInfo#$clone", this ); }

                var s = to || new TMPro.TMP_LineInfo();
                s.controlCharacterCount = this.controlCharacterCount;
                s.characterCount = this.characterCount;
                s.visibleCharacterCount = this.visibleCharacterCount;
                s.spaceCount = this.spaceCount;
                s.wordCount = this.wordCount;
                s.firstCharacterIndex = this.firstCharacterIndex;
                s.firstVisibleCharacterIndex = this.firstVisibleCharacterIndex;
                s.lastCharacterIndex = this.lastCharacterIndex;
                s.lastVisibleCharacterIndex = this.lastVisibleCharacterIndex;
                s.length = this.length;
                s.lineHeight = this.lineHeight;
                s.ascender = this.ascender;
                s.baseline = this.baseline;
                s.descender = this.descender;
                s.maxAdvance = this.maxAdvance;
                s.width = this.width;
                s.marginLeft = this.marginLeft;
                s.marginRight = this.marginRight;
                s.alignment = this.alignment;
                s.lineExtents = this.lineExtents.$clone();
                return s;
            }
        }
    });
    /*TMPro.TMP_LineInfo end.*/

    /*TMPro.TMP_LinkInfo start.*/
    /**
     * Structure containing information about individual links contained in the text object.
     *
     * @public
     * @class TMPro.TMP_LinkInfo
     */
    Bridge.define("TMPro.TMP_LinkInfo", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_LinkInfo#getDefaultValue", this ); }
 return new TMPro.TMP_LinkInfo(); }
            }
        },
        fields: {
            textComponent: null,
            hashCode: 0,
            linkIdFirstCharacterIndex: 0,
            linkIdLength: 0,
            linkTextfirstCharacterIndex: 0,
            linkTextLength: 0,
            linkID: null
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_LinkInfo#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*TMPro.TMP_LinkInfo.SetLinkID start.*/
            SetLinkID: function (text, startIndex, length) {
if ( TRACE ) { TRACE( "TMPro.TMP_LinkInfo#SetLinkID", this ); }

                if (this.linkID == null || this.linkID.length < length) {
                    this.linkID = System.Array.init(length, 0, System.Char);
                }

                for (var i = 0; i < length; i++) {
                    this.linkID[i] = text[startIndex + i];
                }
            },
            /*TMPro.TMP_LinkInfo.SetLinkID end.*/

            /*TMPro.TMP_LinkInfo.GetLinkText start.*/
            /**
             * Function which returns the text contained in a link.
             *
             * @instance
             * @public
             * @this TMPro.TMP_LinkInfo
             * @memberof TMPro.TMP_LinkInfo
             * @return  {string}
             */
            GetLinkText: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_LinkInfo#GetLinkText", this ); }

                var text = "";
                var textInfo = this.textComponent.textInfo;

                for (var i = this.linkTextfirstCharacterIndex; i < this.linkTextfirstCharacterIndex + this.linkTextLength; i++) {
                    text = (text || "") + String.fromCharCode(textInfo.characterInfo[i].character);
                }

                return text;
            },
            /*TMPro.TMP_LinkInfo.GetLinkText end.*/

            /*TMPro.TMP_LinkInfo.GetLinkID start.*/
            /**
             * Function which returns the link ID as a string.
             *
             * @instance
             * @public
             * @this TMPro.TMP_LinkInfo
             * @memberof TMPro.TMP_LinkInfo
             * @return  {string}
             */
            GetLinkID: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_LinkInfo#GetLinkID", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.textComponent, null)) {
                    return "";
                }

                return System.String.fromCharArray(this.linkID, 0, this.linkIdLength);
                //return textComponent.text.Substring(linkIdFirstCharacterIndex, linkIdLength);
            },
            /*TMPro.TMP_LinkInfo.GetLinkID end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_LinkInfo#getHashCode", this ); }

                var h = Bridge.addHash([5270480105, this.textComponent, this.hashCode, this.linkIdFirstCharacterIndex, this.linkIdLength, this.linkTextfirstCharacterIndex, this.linkTextLength, this.linkID]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.TMP_LinkInfo#equals", this ); }

                if (!Bridge.is(o, TMPro.TMP_LinkInfo)) {
                    return false;
                }
                return Bridge.equals(this.textComponent, o.textComponent) && Bridge.equals(this.hashCode, o.hashCode) && Bridge.equals(this.linkIdFirstCharacterIndex, o.linkIdFirstCharacterIndex) && Bridge.equals(this.linkIdLength, o.linkIdLength) && Bridge.equals(this.linkTextfirstCharacterIndex, o.linkTextfirstCharacterIndex) && Bridge.equals(this.linkTextLength, o.linkTextLength) && Bridge.equals(this.linkID, o.linkID);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.TMP_LinkInfo#$clone", this ); }

                var s = to || new TMPro.TMP_LinkInfo();
                s.textComponent = this.textComponent;
                s.hashCode = this.hashCode;
                s.linkIdFirstCharacterIndex = this.linkIdFirstCharacterIndex;
                s.linkIdLength = this.linkIdLength;
                s.linkTextfirstCharacterIndex = this.linkTextfirstCharacterIndex;
                s.linkTextLength = this.linkTextLength;
                s.linkID = this.linkID;
                return s;
            }
        }
    });
    /*TMPro.TMP_LinkInfo end.*/

    /*TMPro.TMP_ListPool$1 start.*/
    Bridge.define("TMPro.TMP_ListPool$1", function (T) { return {
        statics: {
            fields: {
                s_ListPool: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_ListPool$1#init", this ); }

                    this.s_ListPool = new (TMPro.TMP_ObjectPool$1(System.Collections.Generic.List$1(T)))(null, function (l) {
                        l.clear();
                    });
                }
            },
            methods: {
                /*TMPro.TMP_ListPool$1.Get:static start.*/
                Get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_ListPool$1#Get", this ); }

                    return TMPro.TMP_ListPool$1(T).s_ListPool.Get();
                },
                /*TMPro.TMP_ListPool$1.Get:static end.*/

                /*TMPro.TMP_ListPool$1.Release:static start.*/
                Release: function (toRelease) {
if ( TRACE ) { TRACE( "TMPro.TMP_ListPool$1#Release", this ); }

                    TMPro.TMP_ListPool$1(T).s_ListPool.Release(toRelease);
                },
                /*TMPro.TMP_ListPool$1.Release:static end.*/


            }
        }
    }; });
    /*TMPro.TMP_ListPool$1 end.*/

    /*TMPro.TMP_MaterialManager start.*/
    Bridge.define("TMPro.TMP_MaterialManager", {
        statics: {
            fields: {
                m_materialList: null,
                m_fallbackMaterials: null,
                m_fallbackMaterialLookup: null,
                m_fallbackCleanupList: null,
                isFallbackListDirty: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_MaterialManager#init", this ); }

                    this.m_materialList = new (System.Collections.Generic.List$1(TMPro.TMP_MaterialManager.MaskingMaterial)).ctor();
                    this.m_fallbackMaterials = new (System.Collections.Generic.Dictionary$2(System.Int64,TMPro.TMP_MaterialManager.FallbackMaterial)).ctor();
                    this.m_fallbackMaterialLookup = new (System.Collections.Generic.Dictionary$2(System.Int32,System.Int64)).ctor();
                    this.m_fallbackCleanupList = new (System.Collections.Generic.List$1(TMPro.TMP_MaterialManager.FallbackMaterial)).ctor();
                },
                ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_MaterialManager#ctor", this ); }

                    UnityEngine.Canvas.addwillRenderCanvases(TMPro.TMP_MaterialManager.OnPreRender);
                }
            },
            methods: {
                /*TMPro.TMP_MaterialManager.OnPreRender:static start.*/
                OnPreRender: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_MaterialManager#OnPreRender", this ); }

                    if (TMPro.TMP_MaterialManager.isFallbackListDirty) {
                        //Debug.Log("2 - Cleaning up Fallback Materials.");
                        TMPro.TMP_MaterialManager.CleanupFallbackMaterials();
                        TMPro.TMP_MaterialManager.isFallbackListDirty = false;
                    }
                },
                /*TMPro.TMP_MaterialManager.OnPreRender:static end.*/

                /*TMPro.TMP_MaterialManager.GetStencilMaterial:static start.*/
                /**
                 * Create a Masking Material Instance for the given ID
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_MaterialManager
                 * @memberof TMPro.TMP_MaterialManager
                 * @param   {UnityEngine.Material}    baseMaterial    
                 * @param   {number}                  stencilID
                 * @return  {UnityEngine.Material}
                 */
                GetStencilMaterial: function (baseMaterial, stencilID) {
if ( TRACE ) { TRACE( "TMPro.TMP_MaterialManager#GetStencilMaterial", this ); }

                    // Check if Material supports masking
                    if (!baseMaterial.HasProperty(TMPro.ShaderUtilities.ID_StencilID)) {
                        UnityEngine.Debug.LogWarning$1("Selected Shader does not support Stencil Masking. Please select the Distance Field or Mobile Distance Field Shader.");
                        return baseMaterial;
                    }

                    var baseMaterialID = baseMaterial.GetInstanceID();

                    // If baseMaterial already has a corresponding masking material, return it.
                    for (var i = 0; i < TMPro.TMP_MaterialManager.m_materialList.Count; i++) {
                        if (TMPro.TMP_MaterialManager.m_materialList.getItem(i).baseMaterial.GetInstanceID() === baseMaterialID && TMPro.TMP_MaterialManager.m_materialList.getItem(i).stencilID === stencilID) {
                            TMPro.TMP_MaterialManager.m_materialList.getItem(i).count += 1;


                            return TMPro.TMP_MaterialManager.m_materialList.getItem(i).stencilMaterial;
                        }
                    }

                    // No matching masking material found. Create and return a new one.

                    var stencilMaterial;

                    //Create new Masking Material Instance for this Base Material
                    stencilMaterial = new UnityEngine.Material.$ctor1(baseMaterial);
                    stencilMaterial.hideFlags = UnityEngine.HideFlags.HideAndDontSave;


                    stencilMaterial.shaderKeywords = baseMaterial.shaderKeywords;

                    // Set Stencil Properties
                    TMPro.ShaderUtilities.GetShaderPropertyIDs();
                    stencilMaterial.SetFloat(TMPro.ShaderUtilities.ID_StencilID, stencilID);
                    //stencilMaterial.SetFloat(ShaderUtilities.ID_StencilOp, 0);
                    stencilMaterial.SetFloat(TMPro.ShaderUtilities.ID_StencilComp, 4);
                    //stencilMaterial.SetFloat(ShaderUtilities.ID_StencilReadMask, stencilID);
                    //stencilMaterial.SetFloat(ShaderUtilities.ID_StencilWriteMask, 0);

                    var temp = new TMPro.TMP_MaterialManager.MaskingMaterial();
                    temp.baseMaterial = baseMaterial;
                    temp.stencilMaterial = stencilMaterial;
                    temp.stencilID = stencilID;
                    temp.count = 1;

                    TMPro.TMP_MaterialManager.m_materialList.add(temp);


                    return stencilMaterial;
                },
                /*TMPro.TMP_MaterialManager.GetStencilMaterial:static end.*/

                /*TMPro.TMP_MaterialManager.ReleaseStencilMaterial:static start.*/
                /**
                 * Function to release the stencil material.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_MaterialManager
                 * @memberof TMPro.TMP_MaterialManager
                 * @param   {UnityEngine.Material}    stencilMaterial
                 * @return  {void}
                 */
                ReleaseStencilMaterial: function (stencilMaterial) {
if ( TRACE ) { TRACE( "TMPro.TMP_MaterialManager#ReleaseStencilMaterial", this ); }

                    var stencilMaterialID = stencilMaterial.GetInstanceID();

                    for (var i = 0; i < TMPro.TMP_MaterialManager.m_materialList.Count; i++) {
                        if (TMPro.TMP_MaterialManager.m_materialList.getItem(i).stencilMaterial.GetInstanceID() === stencilMaterialID) {
                            if (TMPro.TMP_MaterialManager.m_materialList.getItem(i).count > 1) {
                                TMPro.TMP_MaterialManager.m_materialList.getItem(i).count -= 1;
                            } else {
                                UnityEngine.Object.DestroyImmediate(TMPro.TMP_MaterialManager.m_materialList.getItem(i).stencilMaterial);
                                TMPro.TMP_MaterialManager.m_materialList.removeAt(i);
                                stencilMaterial = null;
                            }

                            break;
                        }
                    }


                },
                /*TMPro.TMP_MaterialManager.ReleaseStencilMaterial:static end.*/

                /*TMPro.TMP_MaterialManager.GetBaseMaterial:static start.*/
                GetBaseMaterial: function (stencilMaterial) {
if ( TRACE ) { TRACE( "TMPro.TMP_MaterialManager#GetBaseMaterial", this ); }

                    // Check if maskingMaterial already has a base material associated with it.
                    var index = TMPro.TMP_MaterialManager.m_materialList.FindIndex$2(function (item) {
                        return Bridge.referenceEquals(item.stencilMaterial, stencilMaterial);
                    });

                    if (index === -1) {
                        return null;
                    } else {
                        return TMPro.TMP_MaterialManager.m_materialList.getItem(index).baseMaterial;
                    }
                },
                /*TMPro.TMP_MaterialManager.GetBaseMaterial:static end.*/

                /*TMPro.TMP_MaterialManager.SetStencil:static start.*/
                /**
                 * Function to set the Material Stencil ID
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_MaterialManager
                 * @memberof TMPro.TMP_MaterialManager
                 * @param   {UnityEngine.Material}    material     
                 * @param   {number}                  stencilID
                 * @return  {UnityEngine.Material}
                 */
                SetStencil: function (material, stencilID) {
if ( TRACE ) { TRACE( "TMPro.TMP_MaterialManager#SetStencil", this ); }

                    material.SetFloat(TMPro.ShaderUtilities.ID_StencilID, stencilID);

                    if (stencilID === 0) {
                        material.SetFloat(TMPro.ShaderUtilities.ID_StencilComp, 8);
                    } else {
                        material.SetFloat(TMPro.ShaderUtilities.ID_StencilComp, 4);
                    }

                    return material;
                },
                /*TMPro.TMP_MaterialManager.SetStencil:static end.*/

                /*TMPro.TMP_MaterialManager.AddMaskingMaterial:static start.*/
                AddMaskingMaterial: function (baseMaterial, stencilMaterial, stencilID) {
if ( TRACE ) { TRACE( "TMPro.TMP_MaterialManager#AddMaskingMaterial", this ); }

                    // Check if maskingMaterial already has a base material associated with it.
                    var index = TMPro.TMP_MaterialManager.m_materialList.FindIndex$2(function (item) {
                        return Bridge.referenceEquals(item.stencilMaterial, stencilMaterial);
                    });

                    if (index === -1) {
                        var temp = new TMPro.TMP_MaterialManager.MaskingMaterial();
                        temp.baseMaterial = baseMaterial;
                        temp.stencilMaterial = stencilMaterial;
                        temp.stencilID = stencilID;
                        temp.count = 1;

                        TMPro.TMP_MaterialManager.m_materialList.add(temp);
                    } else {
                        stencilMaterial = TMPro.TMP_MaterialManager.m_materialList.getItem(index).stencilMaterial;
                        TMPro.TMP_MaterialManager.m_materialList.getItem(index).count += 1;
                    }
                },
                /*TMPro.TMP_MaterialManager.AddMaskingMaterial:static end.*/

                /*TMPro.TMP_MaterialManager.RemoveStencilMaterial:static start.*/
                RemoveStencilMaterial: function (stencilMaterial) {
if ( TRACE ) { TRACE( "TMPro.TMP_MaterialManager#RemoveStencilMaterial", this ); }

                    // Check if maskingMaterial is already on the list.
                    var index = TMPro.TMP_MaterialManager.m_materialList.FindIndex$2(function (item) {
                        return Bridge.referenceEquals(item.stencilMaterial, stencilMaterial);
                    });

                    if (index !== -1) {
                        TMPro.TMP_MaterialManager.m_materialList.removeAt(index);
                    }

                },
                /*TMPro.TMP_MaterialManager.RemoveStencilMaterial:static end.*/

                /*TMPro.TMP_MaterialManager.ReleaseBaseMaterial:static start.*/
                ReleaseBaseMaterial: function (baseMaterial) {
if ( TRACE ) { TRACE( "TMPro.TMP_MaterialManager#ReleaseBaseMaterial", this ); }

                    // Check if baseMaterial already has a masking material associated with it.
                    var index = TMPro.TMP_MaterialManager.m_materialList.FindIndex$2(function (item) {
                        return Bridge.referenceEquals(item.baseMaterial, baseMaterial);
                    });

                    if (index === -1) {
                        UnityEngine.Debug.Log$1("No Masking Material exists for " + (baseMaterial.name || ""));
                    } else {
                        if (TMPro.TMP_MaterialManager.m_materialList.getItem(index).count > 1) {
                            TMPro.TMP_MaterialManager.m_materialList.getItem(index).count -= 1;
                            UnityEngine.Debug.Log$1("Removed (1) reference to " + (TMPro.TMP_MaterialManager.m_materialList.getItem(index).stencilMaterial.name || "") + ". There are " + TMPro.TMP_MaterialManager.m_materialList.getItem(index).count + " references left.");
                        } else {
                            UnityEngine.Debug.Log$1("Removed last reference to " + (TMPro.TMP_MaterialManager.m_materialList.getItem(index).stencilMaterial.name || "") + " with ID " + TMPro.TMP_MaterialManager.m_materialList.getItem(index).stencilMaterial.GetInstanceID());
                            UnityEngine.Object.DestroyImmediate(TMPro.TMP_MaterialManager.m_materialList.getItem(index).stencilMaterial);
                            TMPro.TMP_MaterialManager.m_materialList.removeAt(index);
                        }
                    }

                },
                /*TMPro.TMP_MaterialManager.ReleaseBaseMaterial:static end.*/

                /*TMPro.TMP_MaterialManager.ClearMaterials:static start.*/
                ClearMaterials: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_MaterialManager#ClearMaterials", this ); }

                    if (TMPro.TMP_MaterialManager.m_materialList.Count === 0) {
                        UnityEngine.Debug.Log$1("Material List has already been cleared.");
                        return;
                    }

                    for (var i = 0; i < TMPro.TMP_MaterialManager.m_materialList.Count; i++) {
                        //Material baseMaterial = m_materialList[i].baseMaterial;
                        var stencilMaterial = TMPro.TMP_MaterialManager.m_materialList.getItem(i).stencilMaterial;

                        UnityEngine.Object.DestroyImmediate(stencilMaterial);
                    }

                    TMPro.TMP_MaterialManager.m_materialList.clear();
                },
                /*TMPro.TMP_MaterialManager.ClearMaterials:static end.*/

                /*TMPro.TMP_MaterialManager.GetStencilID:static start.*/
                /**
                 * Function to get the Stencil ID
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_MaterialManager
                 * @memberof TMPro.TMP_MaterialManager
                 * @param   {UnityEngine.GameObject}    obj
                 * @return  {number}
                 */
                GetStencilID: function (obj) {
if ( TRACE ) { TRACE( "TMPro.TMP_MaterialManager#GetStencilID", this ); }

                    // Implementation is almost copied from Unity UI

                    var count = 0;

                    var transform = obj.transform;
                    var stopAfter = TMPro.TMP_MaterialManager.FindRootSortOverrideCanvas(transform);
                    if (UnityEngine.Component.op_Equality(transform, stopAfter)) {
                        return count;
                    }

                    var t = transform.parent;
                    var components = TMPro.TMP_ListPool$1(UnityEngine.UI.Mask).Get();
                    while (UnityEngine.Component.op_Inequality(t, null)) {
                        t.GetComponents$2(UnityEngine.UI.Mask, components);
                        for (var i = 0; i < components.Count; ++i) {
                            var mask = components.getItem(i);
                            if (UnityEngine.MonoBehaviour.op_Inequality(mask, null) && mask.MaskEnabled() && mask.graphic.IsActive()) {
                                ++count;
                                break;
                            }
                        }

                        if (UnityEngine.Component.op_Equality(t, stopAfter)) {
                            break;
                        }

                        t = t.parent;
                    }

                    TMPro.TMP_ListPool$1(UnityEngine.UI.Mask).Release(components);

                    return UnityEngine.Mathf.Min((1 << count) - 1, 255);
                },
                /*TMPro.TMP_MaterialManager.GetStencilID:static end.*/

                /*TMPro.TMP_MaterialManager.GetMaterialForRendering:static start.*/
                GetMaterialForRendering: function (graphic, baseMaterial) {
if ( TRACE ) { TRACE( "TMPro.TMP_MaterialManager#GetMaterialForRendering", this ); }

                    if (baseMaterial == null) {
                        return null;
                    }

                    var modifiers = TMPro.TMP_ListPool$1(UnityEngine.UI.IMaterialModifier).Get();
                    graphic.GetComponents$2(UnityEngine.UI.IMaterialModifier, modifiers);

                    var result = baseMaterial;
                    for (var i = 0; i < modifiers.Count; i++) {
                        result = modifiers.getItem(i).UnityEngine$UI$IMaterialModifier$GetModifiedMaterial(result);
                    }

                    TMPro.TMP_ListPool$1(UnityEngine.UI.IMaterialModifier).Release(modifiers);

                    return result;
                },
                /*TMPro.TMP_MaterialManager.GetMaterialForRendering:static end.*/

                /*TMPro.TMP_MaterialManager.FindRootSortOverrideCanvas:static start.*/
                FindRootSortOverrideCanvas: function (start) {
if ( TRACE ) { TRACE( "TMPro.TMP_MaterialManager#FindRootSortOverrideCanvas", this ); }

                    // Implementation is copied from Unity UI

                    var canvasList = TMPro.TMP_ListPool$1(UnityEngine.Canvas).Get();
                    start.GetComponentsInParent$2(UnityEngine.Canvas, false, canvasList);
                    var canvas = null;

                    for (var i = 0; i < canvasList.Count; ++i) {
                        canvas = canvasList.getItem(i);

                        // We found the canvas we want to use break
                        if (canvas.overrideSorting) {
                            break;
                        }
                    }

                    TMPro.TMP_ListPool$1(UnityEngine.Canvas).Release(canvasList);

                    return UnityEngine.Component.op_Inequality(canvas, null) ? canvas.transform : null;
                },
                /*TMPro.TMP_MaterialManager.FindRootSortOverrideCanvas:static end.*/

                /*TMPro.TMP_MaterialManager.GetFallbackMaterial$1:static start.*/
                GetFallbackMaterial$1: function (fontAsset, sourceMaterial, atlasIndex) {
if ( TRACE ) { TRACE( "TMPro.TMP_MaterialManager#GetFallbackMaterial$1", this ); }

                    var $t;
                    var sourceMaterialID = sourceMaterial.GetInstanceID();
                    var tex = ($t = fontAsset.atlasTextures)[atlasIndex];
                    var texID = tex.GetInstanceID();
                    var key = (System.Int64(sourceMaterialID).shl(32)).or(System.Int64(texID));
                    var fallback = { };

                    if (TMPro.TMP_MaterialManager.m_fallbackMaterials.tryGetValue(key, fallback)) {
                        // Check if source material properties have changed.
                        var sourceMaterialCRC = sourceMaterial.ComputeCRC();
                        if (sourceMaterialCRC === fallback.v.sourceMaterialCRC) {
                            return fallback.v.fallbackMaterial;
                        }

                        TMPro.TMP_MaterialManager.CopyMaterialPresetProperties(sourceMaterial, fallback.v.fallbackMaterial);
                        fallback.v.sourceMaterialCRC = sourceMaterialCRC;
                        return fallback.v.fallbackMaterial;
                    }

                    // Create new material from the source material and assign relevant atlas texture
                    var fallbackMaterial = new UnityEngine.Material.$ctor1(sourceMaterial);
                    fallbackMaterial.SetTexture(TMPro.ShaderUtilities.ID_MainTex, tex);

                    fallbackMaterial.hideFlags = UnityEngine.HideFlags.HideAndDontSave;


                    fallback.v = new TMPro.TMP_MaterialManager.FallbackMaterial();
                    fallback.v.fallbackID = key;
                    fallback.v.sourceMaterial = fontAsset.material;
                    fallback.v.sourceMaterialCRC = sourceMaterial.ComputeCRC();
                    fallback.v.fallbackMaterial = fallbackMaterial;
                    fallback.v.count = 0;

                    TMPro.TMP_MaterialManager.m_fallbackMaterials.add(key, fallback.v);
                    TMPro.TMP_MaterialManager.m_fallbackMaterialLookup.add(fallbackMaterial.GetInstanceID(), key);


                    return fallbackMaterial;
                },
                /*TMPro.TMP_MaterialManager.GetFallbackMaterial$1:static end.*/

                /*TMPro.TMP_MaterialManager.GetFallbackMaterial:static start.*/
                /**
                 * This function returns a material instance using the material properties of a previous material but using the font atlas texture of the new font asset.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_MaterialManager
                 * @memberof TMPro.TMP_MaterialManager
                 * @param   {UnityEngine.Material}    sourceMaterial    The material containing the source material properties to be copied to the new material.
                 * @param   {UnityEngine.Material}    targetMaterial    The font atlas texture that should be assigned to the new material.
                 * @return  {UnityEngine.Material}
                 */
                GetFallbackMaterial: function (sourceMaterial, targetMaterial) {
if ( TRACE ) { TRACE( "TMPro.TMP_MaterialManager#GetFallbackMaterial", this ); }

                    var sourceID = sourceMaterial.GetInstanceID();
                    var tex = targetMaterial.GetTexture(TMPro.ShaderUtilities.ID_MainTex);
                    var texID = tex.GetInstanceID();
                    var key = (System.Int64(sourceID).shl(32)).or(System.Int64(texID));
                    var fallback = { };

                    if (TMPro.TMP_MaterialManager.m_fallbackMaterials.tryGetValue(key, fallback)) {
                        // Check if source material properties have changed.
                        var sourceMaterialCRC = sourceMaterial.ComputeCRC();
                        if (sourceMaterialCRC === fallback.v.sourceMaterialCRC) {
                            return fallback.v.fallbackMaterial;
                        }

                        TMPro.TMP_MaterialManager.CopyMaterialPresetProperties(sourceMaterial, fallback.v.fallbackMaterial);
                        fallback.v.sourceMaterialCRC = sourceMaterialCRC;
                        return fallback.v.fallbackMaterial;
                    }

                    // Create new material from the source material and copy properties if using distance field shaders.
                    var fallbackMaterial;
                    if (sourceMaterial.HasProperty(TMPro.ShaderUtilities.ID_GradientScale) && targetMaterial.HasProperty(TMPro.ShaderUtilities.ID_GradientScale)) {
                        fallbackMaterial = new UnityEngine.Material.$ctor1(sourceMaterial);
                        fallbackMaterial.hideFlags = UnityEngine.HideFlags.HideAndDontSave;


                        fallbackMaterial.SetTexture(TMPro.ShaderUtilities.ID_MainTex, tex);
                        // Retain material properties unique to target material.
                        fallbackMaterial.SetFloat(TMPro.ShaderUtilities.ID_GradientScale, targetMaterial.GetFloat(TMPro.ShaderUtilities.ID_GradientScale));
                        fallbackMaterial.SetFloat(TMPro.ShaderUtilities.ID_TextureWidth, targetMaterial.GetFloat(TMPro.ShaderUtilities.ID_TextureWidth));
                        fallbackMaterial.SetFloat(TMPro.ShaderUtilities.ID_TextureHeight, targetMaterial.GetFloat(TMPro.ShaderUtilities.ID_TextureHeight));
                        fallbackMaterial.SetFloat(TMPro.ShaderUtilities.ID_WeightNormal, targetMaterial.GetFloat(TMPro.ShaderUtilities.ID_WeightNormal));
                        fallbackMaterial.SetFloat(TMPro.ShaderUtilities.ID_WeightBold, targetMaterial.GetFloat(TMPro.ShaderUtilities.ID_WeightBold));
                    } else {
                        fallbackMaterial = new UnityEngine.Material.$ctor1(targetMaterial);
                    }

                    fallback.v = new TMPro.TMP_MaterialManager.FallbackMaterial();
                    fallback.v.fallbackID = key;
                    fallback.v.sourceMaterial = sourceMaterial;
                    fallback.v.sourceMaterialCRC = sourceMaterial.ComputeCRC();
                    fallback.v.fallbackMaterial = fallbackMaterial;
                    fallback.v.count = 0;

                    TMPro.TMP_MaterialManager.m_fallbackMaterials.add(key, fallback.v);
                    TMPro.TMP_MaterialManager.m_fallbackMaterialLookup.add(fallbackMaterial.GetInstanceID(), key);


                    return fallbackMaterial;
                },
                /*TMPro.TMP_MaterialManager.GetFallbackMaterial:static end.*/

                /*TMPro.TMP_MaterialManager.AddFallbackMaterialReference:static start.*/
                /**
                 * @static
                 * @public
                 * @this TMPro.TMP_MaterialManager
                 * @memberof TMPro.TMP_MaterialManager
                 * @param   {UnityEngine.Material}    targetMaterial
                 * @return  {void}
                 */
                AddFallbackMaterialReference: function (targetMaterial) {
if ( TRACE ) { TRACE( "TMPro.TMP_MaterialManager#AddFallbackMaterialReference", this ); }

                    if (targetMaterial == null) {
                        return;
                    }

                    var sourceID = targetMaterial.GetInstanceID();
                    var key = { };

                    // Lookup key to retrieve
                    if (TMPro.TMP_MaterialManager.m_fallbackMaterialLookup.tryGetValue(sourceID, key)) {
                        var fallback = { };
                        if (TMPro.TMP_MaterialManager.m_fallbackMaterials.tryGetValue(key.v, fallback)) {
                            //Debug.Log("Adding Fallback material " + fallback.fallbackMaterial.name + " with reference count of " + (fallback.count + 1));
                            fallback.v.count += 1;
                        }
                    }
                },
                /*TMPro.TMP_MaterialManager.AddFallbackMaterialReference:static end.*/

                /*TMPro.TMP_MaterialManager.RemoveFallbackMaterialReference:static start.*/
                /**
                 * @static
                 * @public
                 * @this TMPro.TMP_MaterialManager
                 * @memberof TMPro.TMP_MaterialManager
                 * @param   {UnityEngine.Material}    targetMaterial
                 * @return  {void}
                 */
                RemoveFallbackMaterialReference: function (targetMaterial) {
if ( TRACE ) { TRACE( "TMPro.TMP_MaterialManager#RemoveFallbackMaterialReference", this ); }

                    if (targetMaterial == null) {
                        return;
                    }

                    var sourceID = targetMaterial.GetInstanceID();
                    var key = { };

                    // Lookup key to retrieve
                    if (TMPro.TMP_MaterialManager.m_fallbackMaterialLookup.tryGetValue(sourceID, key)) {
                        var fallback = { };
                        if (TMPro.TMP_MaterialManager.m_fallbackMaterials.tryGetValue(key.v, fallback)) {
                            fallback.v.count -= 1;

                            if (fallback.v.count < 1) {
                                TMPro.TMP_MaterialManager.m_fallbackCleanupList.add(fallback.v);
                            }
                        }
                    }
                },
                /*TMPro.TMP_MaterialManager.RemoveFallbackMaterialReference:static end.*/

                /*TMPro.TMP_MaterialManager.CleanupFallbackMaterials:static start.*/
                /**
                 * @static
                 * @public
                 * @this TMPro.TMP_MaterialManager
                 * @memberof TMPro.TMP_MaterialManager
                 * @return  {void}
                 */
                CleanupFallbackMaterials: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_MaterialManager#CleanupFallbackMaterials", this ); }

                    // Return if the list is empty.
                    if (TMPro.TMP_MaterialManager.m_fallbackCleanupList.Count === 0) {
                        return;
                    }

                    for (var i = 0; i < TMPro.TMP_MaterialManager.m_fallbackCleanupList.Count; i++) {
                        var fallback = TMPro.TMP_MaterialManager.m_fallbackCleanupList.getItem(i);

                        if (fallback.count < 1) {
                            //Debug.Log("Cleaning up " + fallback.fallbackMaterial.name);

                            var mat = fallback.fallbackMaterial;
                            TMPro.TMP_MaterialManager.m_fallbackMaterials.remove(fallback.fallbackID);
                            TMPro.TMP_MaterialManager.m_fallbackMaterialLookup.remove(mat.GetInstanceID());
                            UnityEngine.Object.DestroyImmediate(mat);
                            mat = null;
                        }
                    }

                    TMPro.TMP_MaterialManager.m_fallbackCleanupList.clear();
                },
                /*TMPro.TMP_MaterialManager.CleanupFallbackMaterials:static end.*/

                /*TMPro.TMP_MaterialManager.ReleaseFallbackMaterial:static start.*/
                /**
                 * Function to release the fallback material.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_MaterialManager
                 * @memberof TMPro.TMP_MaterialManager
                 * @param   {UnityEngine.Material}    fallbackMaterial    Material to be released.
                 * @return  {void}
                 */
                ReleaseFallbackMaterial: function (fallbackMaterial) {
if ( TRACE ) { TRACE( "TMPro.TMP_MaterialManager#ReleaseFallbackMaterial", this ); }

                    if (fallbackMaterial == null) {
                        return;
                    }

                    var materialID = fallbackMaterial.GetInstanceID();
                    var key = { };

                    if (TMPro.TMP_MaterialManager.m_fallbackMaterialLookup.tryGetValue(materialID, key)) {
                        var fallback = { };
                        if (TMPro.TMP_MaterialManager.m_fallbackMaterials.tryGetValue(key.v, fallback)) {
                            //Debug.Log("Releasing Fallback material " + fallback.fallbackMaterial.name + " with remaining reference count of " + (fallback.count - 1));

                            fallback.v.count -= 1;

                            if (fallback.v.count < 1) {
                                TMPro.TMP_MaterialManager.m_fallbackCleanupList.add(fallback.v);
                            }
                        }
                    }

                    TMPro.TMP_MaterialManager.isFallbackListDirty = true;

                },
                /*TMPro.TMP_MaterialManager.ReleaseFallbackMaterial:static end.*/

                /*TMPro.TMP_MaterialManager.CopyMaterialPresetProperties:static start.*/
                /**
                 * Function to copy the properties of a source material preset to another while preserving the unique font asset properties of the destination material.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_MaterialManager
                 * @memberof TMPro.TMP_MaterialManager
                 * @param   {UnityEngine.Material}    source         
                 * @param   {UnityEngine.Material}    destination
                 * @return  {void}
                 */
                CopyMaterialPresetProperties: function (source, destination) {
if ( TRACE ) { TRACE( "TMPro.TMP_MaterialManager#CopyMaterialPresetProperties", this ); }

                    if (!source.HasProperty(TMPro.ShaderUtilities.ID_GradientScale) || !destination.HasProperty(TMPro.ShaderUtilities.ID_GradientScale)) {
                        return;
                    }

                    // Save unique material properties
                    var dst_texture = destination.GetTexture(TMPro.ShaderUtilities.ID_MainTex);
                    var dst_gradientScale = destination.GetFloat(TMPro.ShaderUtilities.ID_GradientScale);
                    var dst_texWidth = destination.GetFloat(TMPro.ShaderUtilities.ID_TextureWidth);
                    var dst_texHeight = destination.GetFloat(TMPro.ShaderUtilities.ID_TextureHeight);
                    var dst_weightNormal = destination.GetFloat(TMPro.ShaderUtilities.ID_WeightNormal);
                    var dst_weightBold = destination.GetFloat(TMPro.ShaderUtilities.ID_WeightBold);

                    // Copy all material properties
                    destination.CopyPropertiesFromMaterial(source);

                    // Copy shader keywords
                    destination.shaderKeywords = source.shaderKeywords;

                    // Restore unique material properties
                    destination.SetTexture(TMPro.ShaderUtilities.ID_MainTex, dst_texture);
                    destination.SetFloat(TMPro.ShaderUtilities.ID_GradientScale, dst_gradientScale);
                    destination.SetFloat(TMPro.ShaderUtilities.ID_TextureWidth, dst_texWidth);
                    destination.SetFloat(TMPro.ShaderUtilities.ID_TextureHeight, dst_texHeight);
                    destination.SetFloat(TMPro.ShaderUtilities.ID_WeightNormal, dst_weightNormal);
                    destination.SetFloat(TMPro.ShaderUtilities.ID_WeightBold, dst_weightBold);
                },
                /*TMPro.TMP_MaterialManager.CopyMaterialPresetProperties:static end.*/


            }
        }
    });
    /*TMPro.TMP_MaterialManager end.*/

    /*TMPro.TMP_MaterialManager+FallbackMaterial start.*/
    Bridge.define("TMPro.TMP_MaterialManager.FallbackMaterial", {
        $kind: 1002,
        fields: {
            fallbackID: System.Int64(0),
            sourceMaterial: null,
            sourceMaterialCRC: 0,
            fallbackMaterial: null,
            count: 0
        }
    });
    /*TMPro.TMP_MaterialManager+FallbackMaterial end.*/

    /*TMPro.TMP_MaterialManager+MaskingMaterial start.*/
    Bridge.define("TMPro.TMP_MaterialManager.MaskingMaterial", {
        $kind: 1002,
        fields: {
            baseMaterial: null,
            stencilMaterial: null,
            count: 0,
            stencilID: 0
        }
    });
    /*TMPro.TMP_MaterialManager+MaskingMaterial end.*/

    /*TMPro.TMP_MaterialReference start.*/
    Bridge.define("TMPro.TMP_MaterialReference", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_MaterialReference#getDefaultValue", this ); }
 return new TMPro.TMP_MaterialReference(); }
            }
        },
        fields: {
            material: null,
            referenceCount: 0
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_MaterialReference#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_MaterialReference#getHashCode", this ); }

                var h = Bridge.addHash([8488936252, this.material, this.referenceCount]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.TMP_MaterialReference#equals", this ); }

                if (!Bridge.is(o, TMPro.TMP_MaterialReference)) {
                    return false;
                }
                return Bridge.equals(this.material, o.material) && Bridge.equals(this.referenceCount, o.referenceCount);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.TMP_MaterialReference#$clone", this ); }

                var s = to || new TMPro.TMP_MaterialReference();
                s.material = this.material;
                s.referenceCount = this.referenceCount;
                return s;
            }
        }
    });
    /*TMPro.TMP_MaterialReference end.*/

    /*TMPro.TMP_Math start.*/
    Bridge.define("TMPro.TMP_Math", {
        statics: {
            fields: {
                FLOAT_MAX: 0,
                FLOAT_MIN: 0,
                INT_MAX: 0,
                INT_MIN: 0,
                FLOAT_UNSET: 0,
                INT_UNSET: 0,
                MAX_16BIT: null,
                MIN_16BIT: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Math#init", this ); }

                    this.MAX_16BIT = new UnityEngine.Vector2();
                    this.MIN_16BIT = new UnityEngine.Vector2();
                    this.FLOAT_MAX = 32767;
                    this.FLOAT_MIN = -32767;
                    this.INT_MAX = 2147483647;
                    this.INT_MIN = -2147483647;
                    this.FLOAT_UNSET = -32767;
                    this.INT_UNSET = -32767;
                    this.MAX_16BIT = new pc.Vec2( TMPro.TMP_Math.FLOAT_MAX, TMPro.TMP_Math.FLOAT_MAX );
                    this.MIN_16BIT = new pc.Vec2( TMPro.TMP_Math.FLOAT_MIN, TMPro.TMP_Math.FLOAT_MIN );
                }
            },
            methods: {
                /*TMPro.TMP_Math.Approximately:static start.*/
                Approximately: function (a, b) {
if ( TRACE ) { TRACE( "TMPro.TMP_Math#Approximately", this ); }

                    return b - 0.0001 < a && a < b + 0.0001;
                },
                /*TMPro.TMP_Math.Approximately:static end.*/

                /*TMPro.TMP_Math.Mod:static start.*/
                Mod: function (a, b) {
if ( TRACE ) { TRACE( "TMPro.TMP_Math#Mod", this ); }

                    var r = a % b;
                    return r < 0 ? r + b : r;
                },
                /*TMPro.TMP_Math.Mod:static end.*/


            }
        }
    });
    /*TMPro.TMP_Math end.*/

    /*TMPro.TMP_MeshInfo start.*/
    /**
     * Structure which contains the vertex attributes (geometry) of the text object.
     *
     * @public
     * @class TMPro.TMP_MeshInfo
     */
    Bridge.define("TMPro.TMP_MeshInfo", {
        $kind: 4,
        statics: {
            fields: {
                s_DefaultColor: null,
                s_DefaultNormal: null,
                s_DefaultTangent: null,
                s_DefaultBounds: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_MeshInfo#init", this ); }

                    this.s_DefaultColor = new UnityEngine.Color32();
                    this.s_DefaultNormal = new UnityEngine.Vector3();
                    this.s_DefaultTangent = new UnityEngine.Vector4();
                    this.s_DefaultBounds = new UnityEngine.Bounds();
                    this.s_DefaultColor = new UnityEngine.Color32.$ctor1(255, 255, 255, 255);
                    this.s_DefaultNormal = new pc.Vec3( 0.0, 0.0, -1.0 );
                    this.s_DefaultTangent = new pc.Vec4( -1.0, 0.0, 0.0, 1.0 );
                }
            },
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_MeshInfo#getDefaultValue", this ); }
 return new TMPro.TMP_MeshInfo(); }
            }
        },
        fields: {
            mesh: null,
            vertexCount: 0,
            vertices: null,
            normals: null,
            tangents: null,
            uvs0: null,
            uvs2: null,
            colors32: null,
            triangles: null,
            material: null
        },
        ctors: {
            /**
             * Function to pre-allocate vertex attributes for a mesh of size X.
             *
             * @instance
             * @public
             * @this TMPro.TMP_MeshInfo
             * @memberof TMPro.TMP_MeshInfo
             * @param   {UnityEngine.Mesh}    mesh    
             * @param   {number}              size
             * @return  {void}
             */
            $ctor1: function (mesh, size) {
if ( TRACE ) { TRACE( "TMPro.TMP_MeshInfo#$ctor1", this ); }

                this.$initialize();
                // Reference to the TMP Text Component.
                //this.textComponent = null;

                // Clear existing mesh data
                if (mesh == null) {
                    mesh = new UnityEngine.Mesh.ctor();
                } else {
                    mesh.Clear();
                }

                this.mesh = mesh;

                // Limit the mesh to less than 65535 vertices which is the limit for Unity's Mesh.
                size = UnityEngine.Mathf.Min(size, 16383);

                var sizeX4 = size * 4;
                var sizeX6 = size * 6;

                this.vertexCount = 0;

                this.vertices = System.Array.init(sizeX4, function (){
                    return new UnityEngine.Vector3();
                }, UnityEngine.Vector3);
                this.uvs0 = System.Array.init(sizeX4, function (){
                    return new UnityEngine.Vector2();
                }, UnityEngine.Vector2);
                this.uvs2 = System.Array.init(sizeX4, function (){
                    return new UnityEngine.Vector2();
                }, UnityEngine.Vector2);
                //this.uvs4 = new Vector2[sizeX4]; // SDF scale data
                this.colors32 = System.Array.init(sizeX4, function (){
                    return new UnityEngine.Color32();
                }, UnityEngine.Color32);

                this.normals = System.Array.init(sizeX4, function (){
                    return new UnityEngine.Vector3();
                }, UnityEngine.Vector3);
                this.tangents = System.Array.init(sizeX4, function (){
                    return new UnityEngine.Vector4();
                }, UnityEngine.Vector4);

                this.triangles = System.Array.init(sizeX6, 0, System.Int32);

                var index_X6 = 0;
                var index_X4 = 0;
                while (index_X4 / 4 < size) {
                    for (var i = 0; i < 4; i++) {
                        this.vertices[index_X4 + i] = pc.Vec3.ZERO.clone();
                        this.uvs0[index_X4 + i] = pc.Vec2.ZERO.clone();
                        this.uvs2[index_X4 + i] = pc.Vec2.ZERO.clone();
                        //this.uvs4[index_X4 + i] = Vector2.zero;
                        this.colors32[index_X4 + i] = TMPro.TMP_MeshInfo.s_DefaultColor.$clone();
                        this.normals[index_X4 + i] = TMPro.TMP_MeshInfo.s_DefaultNormal.$clone();
                        this.tangents[index_X4 + i] = TMPro.TMP_MeshInfo.s_DefaultTangent.$clone();
                    }

                    this.triangles[index_X6 + 0] = index_X4 + 0;
                    this.triangles[index_X6 + 1] = index_X4 + 1;
                    this.triangles[index_X6 + 2] = index_X4 + 2;
                    this.triangles[index_X6 + 3] = index_X4 + 2;
                    this.triangles[index_X6 + 4] = index_X4 + 3;
                    this.triangles[index_X6 + 5] = index_X4 + 0;

                    index_X4 += 4;
                    index_X6 += 6;
                }

                // Pre-assign base vertex attributes.
                this.mesh.vertices = this.vertices;
                this.mesh.normals = this.normals;
                this.mesh.tangents = this.tangents;
                this.mesh.triangles = this.triangles;
                this.mesh.bounds = TMPro.TMP_MeshInfo.s_DefaultBounds;
                this.material = null;
            },
            /**
             * Function to pre-allocate vertex attributes for a mesh of size X.
             *
             * @instance
             * @public
             * @this TMPro.TMP_MeshInfo
             * @memberof TMPro.TMP_MeshInfo
             * @param   {UnityEngine.Mesh}    mesh            
             * @param   {number}              size            
             * @param   {boolean}             isVolumetric
             * @return  {void}
             */
            $ctor2: function (mesh, size, isVolumetric) {
if ( TRACE ) { TRACE( "TMPro.TMP_MeshInfo#$ctor2", this ); }

                this.$initialize();
                // Reference to the TMP Text Component.
                //this.textComponent = null;

                // Clear existing mesh data
                if (mesh == null) {
                    mesh = new UnityEngine.Mesh.ctor();
                } else {
                    mesh.Clear();
                }

                this.mesh = mesh;

                var s0 = !isVolumetric ? 4 : 8;
                var s1 = !isVolumetric ? 6 : 36;

                // Limit the mesh to less than 65535 vertices which is the limit for Unity's Mesh.
                size = UnityEngine.Mathf.Min(size, 65532 / s0);

                var size_x_s0 = size * s0;
                var size_x_s1 = size * s1;

                this.vertexCount = 0;

                this.vertices = System.Array.init(size_x_s0, function (){
                    return new UnityEngine.Vector3();
                }, UnityEngine.Vector3);
                this.uvs0 = System.Array.init(size_x_s0, function (){
                    return new UnityEngine.Vector2();
                }, UnityEngine.Vector2);
                this.uvs2 = System.Array.init(size_x_s0, function (){
                    return new UnityEngine.Vector2();
                }, UnityEngine.Vector2);
                //this.uvs4 = new Vector2[sizeX8]; // SDF scale data
                this.colors32 = System.Array.init(size_x_s0, function (){
                    return new UnityEngine.Color32();
                }, UnityEngine.Color32);

                this.normals = System.Array.init(size_x_s0, function (){
                    return new UnityEngine.Vector3();
                }, UnityEngine.Vector3);
                this.tangents = System.Array.init(size_x_s0, function (){
                    return new UnityEngine.Vector4();
                }, UnityEngine.Vector4);

                this.triangles = System.Array.init(size_x_s1, 0, System.Int32);

                var index_x_s0 = 0;
                var index_x_s1 = 0;
                while (index_x_s0 / s0 < size) {
                    for (var i = 0; i < s0; i++) {
                        this.vertices[index_x_s0 + i] = pc.Vec3.ZERO.clone();
                        this.uvs0[index_x_s0 + i] = pc.Vec2.ZERO.clone();
                        this.uvs2[index_x_s0 + i] = pc.Vec2.ZERO.clone();
                        //this.uvs4[index_X4 + i] = Vector2.zero;
                        this.colors32[index_x_s0 + i] = TMPro.TMP_MeshInfo.s_DefaultColor.$clone();
                        this.normals[index_x_s0 + i] = TMPro.TMP_MeshInfo.s_DefaultNormal.$clone();
                        this.tangents[index_x_s0 + i] = TMPro.TMP_MeshInfo.s_DefaultTangent.$clone();
                    }

                    // Front Face
                    this.triangles[index_x_s1 + 0] = index_x_s0 + 0;
                    this.triangles[index_x_s1 + 1] = index_x_s0 + 1;
                    this.triangles[index_x_s1 + 2] = index_x_s0 + 2;
                    this.triangles[index_x_s1 + 3] = index_x_s0 + 2;
                    this.triangles[index_x_s1 + 4] = index_x_s0 + 3;
                    this.triangles[index_x_s1 + 5] = index_x_s0 + 0;

                    if (isVolumetric) {
                        // Left Face
                        this.triangles[index_x_s1 + 6] = index_x_s0 + 4;
                        this.triangles[index_x_s1 + 7] = index_x_s0 + 5;
                        this.triangles[index_x_s1 + 8] = index_x_s0 + 1;
                        this.triangles[index_x_s1 + 9] = index_x_s0 + 1;
                        this.triangles[index_x_s1 + 10] = index_x_s0 + 0;
                        this.triangles[index_x_s1 + 11] = index_x_s0 + 4;

                        // Right Face
                        this.triangles[index_x_s1 + 12] = index_x_s0 + 3;
                        this.triangles[index_x_s1 + 13] = index_x_s0 + 2;
                        this.triangles[index_x_s1 + 14] = index_x_s0 + 6;
                        this.triangles[index_x_s1 + 15] = index_x_s0 + 6;
                        this.triangles[index_x_s1 + 16] = index_x_s0 + 7;
                        this.triangles[index_x_s1 + 17] = index_x_s0 + 3;

                        // Top Face
                        this.triangles[index_x_s1 + 18] = index_x_s0 + 1;
                        this.triangles[index_x_s1 + 19] = index_x_s0 + 5;
                        this.triangles[index_x_s1 + 20] = index_x_s0 + 6;
                        this.triangles[index_x_s1 + 21] = index_x_s0 + 6;
                        this.triangles[index_x_s1 + 22] = index_x_s0 + 2;
                        this.triangles[index_x_s1 + 23] = index_x_s0 + 1;

                        // Bottom Face
                        this.triangles[index_x_s1 + 24] = index_x_s0 + 4;
                        this.triangles[index_x_s1 + 25] = index_x_s0 + 0;
                        this.triangles[index_x_s1 + 26] = index_x_s0 + 3;
                        this.triangles[index_x_s1 + 27] = index_x_s0 + 3;
                        this.triangles[index_x_s1 + 28] = index_x_s0 + 7;
                        this.triangles[index_x_s1 + 29] = index_x_s0 + 4;

                        // Back Face
                        this.triangles[index_x_s1 + 30] = index_x_s0 + 7;
                        this.triangles[index_x_s1 + 31] = index_x_s0 + 6;
                        this.triangles[index_x_s1 + 32] = index_x_s0 + 5;
                        this.triangles[index_x_s1 + 33] = index_x_s0 + 5;
                        this.triangles[index_x_s1 + 34] = index_x_s0 + 4;
                        this.triangles[index_x_s1 + 35] = index_x_s0 + 7;
                    }

                    index_x_s0 += s0;
                    index_x_s1 += s1;
                }

                // Pre-assign base vertex attributes.
                this.mesh.vertices = this.vertices;
                this.mesh.normals = this.normals;
                this.mesh.tangents = this.tangents;
                this.mesh.triangles = this.triangles;
                this.mesh.bounds = TMPro.TMP_MeshInfo.s_DefaultBounds;
                this.material = null;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_MeshInfo#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*TMPro.TMP_MeshInfo.ResizeMeshInfo start.*/
            /**
             * Function to resized the content of MeshData and re-assign normals, tangents and triangles.
             *
             * @instance
             * @public
             * @this TMPro.TMP_MeshInfo
             * @memberof TMPro.TMP_MeshInfo
             * @param   {number}    size
             * @return  {void}
             */
            ResizeMeshInfo: function (size) {
if ( TRACE ) { TRACE( "TMPro.TMP_MeshInfo#ResizeMeshInfo", this ); }

                // If the requested size will exceed the 16 bit mesh limit, switch mesh to use 32 bit.
                //if (size > 16383 && this.mesh.indexFormat == IndexFormat.UInt16)
                //    this.mesh.indexFormat = IndexFormat.UInt32;
                size = UnityEngine.Mathf.Min(size, 16383);

                var size_X4 = size * 4;
                var size_X6 = size * 6;

                var previousSize = this.vertices.length / 4;

                System.Array.resize(Bridge.ref(this, "vertices"), size_X4, function () {
                    return Bridge.getDefaultValue(UnityEngine.Vector3);
                }, UnityEngine.Vector3);
                System.Array.resize(Bridge.ref(this, "normals"), size_X4, function () {
                    return Bridge.getDefaultValue(UnityEngine.Vector3);
                }, UnityEngine.Vector3);
                System.Array.resize(Bridge.ref(this, "tangents"), size_X4, function () {
                    return Bridge.getDefaultValue(UnityEngine.Vector4);
                }, UnityEngine.Vector4);

                System.Array.resize(Bridge.ref(this, "uvs0"), size_X4, function () {
                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                }, UnityEngine.Vector2);
                System.Array.resize(Bridge.ref(this, "uvs2"), size_X4, function () {
                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                }, UnityEngine.Vector2);
                //Array.Resize(ref this.uvs4, size_X4);

                System.Array.resize(Bridge.ref(this, "colors32"), size_X4, function () {
                    return Bridge.getDefaultValue(UnityEngine.Color32);
                }, UnityEngine.Color32);

                System.Array.resize(Bridge.ref(this, "triangles"), size_X6, 0, System.Int32);


                // Re-assign Normals, Tangents and Triangles
                if (size <= previousSize) {
                    this.mesh.triangles = this.triangles;
                    this.mesh.vertices = this.vertices;
                    this.mesh.normals = this.normals;
                    this.mesh.tangents = this.tangents;

                    return;
                }

                for (var i = previousSize; i < size; i++) {
                    var index_X4 = i * 4;
                    var index_X6 = i * 6;

                    this.normals[0 + index_X4] = TMPro.TMP_MeshInfo.s_DefaultNormal.$clone();
                    this.normals[1 + index_X4] = TMPro.TMP_MeshInfo.s_DefaultNormal.$clone();
                    this.normals[2 + index_X4] = TMPro.TMP_MeshInfo.s_DefaultNormal.$clone();
                    this.normals[3 + index_X4] = TMPro.TMP_MeshInfo.s_DefaultNormal.$clone();

                    this.tangents[0 + index_X4] = TMPro.TMP_MeshInfo.s_DefaultTangent.$clone();
                    this.tangents[1 + index_X4] = TMPro.TMP_MeshInfo.s_DefaultTangent.$clone();
                    this.tangents[2 + index_X4] = TMPro.TMP_MeshInfo.s_DefaultTangent.$clone();
                    this.tangents[3 + index_X4] = TMPro.TMP_MeshInfo.s_DefaultTangent.$clone();

                    // Setup Triangles
                    this.triangles[0 + index_X6] = 0 + index_X4;
                    this.triangles[1 + index_X6] = 1 + index_X4;
                    this.triangles[2 + index_X6] = 2 + index_X4;
                    this.triangles[3 + index_X6] = 2 + index_X4;
                    this.triangles[4 + index_X6] = 3 + index_X4;
                    this.triangles[5 + index_X6] = 0 + index_X4;
                }

                this.mesh.vertices = this.vertices;
                this.mesh.normals = this.normals;
                this.mesh.tangents = this.tangents;
                this.mesh.triangles = this.triangles;
            },
            /*TMPro.TMP_MeshInfo.ResizeMeshInfo end.*/

            /*TMPro.TMP_MeshInfo.ResizeMeshInfo$1 start.*/
            /**
             * Function to resized the content of MeshData and re-assign normals, tangents and triangles.
             *
             * @instance
             * @public
             * @this TMPro.TMP_MeshInfo
             * @memberof TMPro.TMP_MeshInfo
             * @param   {number}     size            
             * @param   {boolean}    isVolumetric
             * @return  {void}
             */
            ResizeMeshInfo$1: function (size, isVolumetric) {
if ( TRACE ) { TRACE( "TMPro.TMP_MeshInfo#ResizeMeshInfo$1", this ); }

                var s0 = !isVolumetric ? 4 : 8;
                var s1 = !isVolumetric ? 6 : 36;

                // Limit the mesh to less than 65535 vertices which is the limit for Unity's Mesh.
                size = UnityEngine.Mathf.Min(size, 65532 / s0);

                var size_X4 = size * s0;
                var size_X6 = size * s1;

                var previousSize = this.vertices.length / s0;

                System.Array.resize(Bridge.ref(this, "vertices"), size_X4, function () {
                    return Bridge.getDefaultValue(UnityEngine.Vector3);
                }, UnityEngine.Vector3);
                System.Array.resize(Bridge.ref(this, "normals"), size_X4, function () {
                    return Bridge.getDefaultValue(UnityEngine.Vector3);
                }, UnityEngine.Vector3);
                System.Array.resize(Bridge.ref(this, "tangents"), size_X4, function () {
                    return Bridge.getDefaultValue(UnityEngine.Vector4);
                }, UnityEngine.Vector4);

                System.Array.resize(Bridge.ref(this, "uvs0"), size_X4, function () {
                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                }, UnityEngine.Vector2);
                System.Array.resize(Bridge.ref(this, "uvs2"), size_X4, function () {
                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                }, UnityEngine.Vector2);
                //Array.Resize(ref this.uvs4, size_X4);

                System.Array.resize(Bridge.ref(this, "colors32"), size_X4, function () {
                    return Bridge.getDefaultValue(UnityEngine.Color32);
                }, UnityEngine.Color32);

                System.Array.resize(Bridge.ref(this, "triangles"), size_X6, 0, System.Int32);


                // Re-assign Normals, Tangents and Triangles
                if (size <= previousSize) {
                    this.mesh.triangles = this.triangles;
                    this.mesh.vertices = this.vertices;
                    this.mesh.normals = this.normals;
                    this.mesh.tangents = this.tangents;

                    return;
                }

                for (var i = previousSize; i < size; i++) {
                    var index_X4 = i * s0;
                    var index_X6 = i * s1;

                    this.normals[0 + index_X4] = TMPro.TMP_MeshInfo.s_DefaultNormal.$clone();
                    this.normals[1 + index_X4] = TMPro.TMP_MeshInfo.s_DefaultNormal.$clone();
                    this.normals[2 + index_X4] = TMPro.TMP_MeshInfo.s_DefaultNormal.$clone();
                    this.normals[3 + index_X4] = TMPro.TMP_MeshInfo.s_DefaultNormal.$clone();

                    this.tangents[0 + index_X4] = TMPro.TMP_MeshInfo.s_DefaultTangent.$clone();
                    this.tangents[1 + index_X4] = TMPro.TMP_MeshInfo.s_DefaultTangent.$clone();
                    this.tangents[2 + index_X4] = TMPro.TMP_MeshInfo.s_DefaultTangent.$clone();
                    this.tangents[3 + index_X4] = TMPro.TMP_MeshInfo.s_DefaultTangent.$clone();

                    if (isVolumetric) {
                        this.normals[4 + index_X4] = TMPro.TMP_MeshInfo.s_DefaultNormal.$clone();
                        this.normals[5 + index_X4] = TMPro.TMP_MeshInfo.s_DefaultNormal.$clone();
                        this.normals[6 + index_X4] = TMPro.TMP_MeshInfo.s_DefaultNormal.$clone();
                        this.normals[7 + index_X4] = TMPro.TMP_MeshInfo.s_DefaultNormal.$clone();

                        this.tangents[4 + index_X4] = TMPro.TMP_MeshInfo.s_DefaultTangent.$clone();
                        this.tangents[5 + index_X4] = TMPro.TMP_MeshInfo.s_DefaultTangent.$clone();
                        this.tangents[6 + index_X4] = TMPro.TMP_MeshInfo.s_DefaultTangent.$clone();
                        this.tangents[7 + index_X4] = TMPro.TMP_MeshInfo.s_DefaultTangent.$clone();
                    }

                    // Setup Triangles
                    this.triangles[0 + index_X6] = 0 + index_X4;
                    this.triangles[1 + index_X6] = 1 + index_X4;
                    this.triangles[2 + index_X6] = 2 + index_X4;
                    this.triangles[3 + index_X6] = 2 + index_X4;
                    this.triangles[4 + index_X6] = 3 + index_X4;
                    this.triangles[5 + index_X6] = 0 + index_X4;

                    if (isVolumetric) {
                        // Left Face
                        this.triangles[index_X6 + 6] = index_X4 + 4;
                        this.triangles[index_X6 + 7] = index_X4 + 5;
                        this.triangles[index_X6 + 8] = index_X4 + 1;
                        this.triangles[index_X6 + 9] = index_X4 + 1;
                        this.triangles[index_X6 + 10] = index_X4 + 0;
                        this.triangles[index_X6 + 11] = index_X4 + 4;

                        // Right Face
                        this.triangles[index_X6 + 12] = index_X4 + 3;
                        this.triangles[index_X6 + 13] = index_X4 + 2;
                        this.triangles[index_X6 + 14] = index_X4 + 6;
                        this.triangles[index_X6 + 15] = index_X4 + 6;
                        this.triangles[index_X6 + 16] = index_X4 + 7;
                        this.triangles[index_X6 + 17] = index_X4 + 3;

                        // Top Face
                        this.triangles[index_X6 + 18] = index_X4 + 1;
                        this.triangles[index_X6 + 19] = index_X4 + 5;
                        this.triangles[index_X6 + 20] = index_X4 + 6;
                        this.triangles[index_X6 + 21] = index_X4 + 6;
                        this.triangles[index_X6 + 22] = index_X4 + 2;
                        this.triangles[index_X6 + 23] = index_X4 + 1;

                        // Bottom Face
                        this.triangles[index_X6 + 24] = index_X4 + 4;
                        this.triangles[index_X6 + 25] = index_X4 + 0;
                        this.triangles[index_X6 + 26] = index_X4 + 3;
                        this.triangles[index_X6 + 27] = index_X4 + 3;
                        this.triangles[index_X6 + 28] = index_X4 + 7;
                        this.triangles[index_X6 + 29] = index_X4 + 4;

                        // Back Face
                        this.triangles[index_X6 + 30] = index_X4 + 7;
                        this.triangles[index_X6 + 31] = index_X4 + 6;
                        this.triangles[index_X6 + 32] = index_X4 + 5;
                        this.triangles[index_X6 + 33] = index_X4 + 5;
                        this.triangles[index_X6 + 34] = index_X4 + 4;
                        this.triangles[index_X6 + 35] = index_X4 + 7;
                    }
                }

                this.mesh.vertices = this.vertices;
                this.mesh.normals = this.normals;
                this.mesh.tangents = this.tangents;
                this.mesh.triangles = this.triangles;
            },
            /*TMPro.TMP_MeshInfo.ResizeMeshInfo$1 end.*/

            /*TMPro.TMP_MeshInfo.Clear start.*/
            /**
             * Function to clear the vertices while preserving the Triangles, Normals and Tangents.
             *
             * @instance
             * @public
             * @this TMPro.TMP_MeshInfo
             * @memberof TMPro.TMP_MeshInfo
             * @return  {void}
             */
            Clear: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_MeshInfo#Clear", this ); }

                if (this.vertices == null) {
                    return;
                }

                System.Array.fill(this.vertices, function () {
                    return Bridge.getDefaultValue(UnityEngine.Vector3);
                }, 0, this.vertices.length);
                this.vertexCount = 0;

                if (this.mesh != null) {
                    this.mesh.vertices = this.vertices;
                }
            },
            /*TMPro.TMP_MeshInfo.Clear end.*/

            /*TMPro.TMP_MeshInfo.Clear$1 start.*/
            /**
             * Function to clear the vertices while preserving the Triangles, Normals and Tangents.
             *
             * @instance
             * @public
             * @this TMPro.TMP_MeshInfo
             * @memberof TMPro.TMP_MeshInfo
             * @param   {boolean}    uploadChanges
             * @return  {void}
             */
            Clear$1: function (uploadChanges) {
if ( TRACE ) { TRACE( "TMPro.TMP_MeshInfo#Clear$1", this ); }

                if (this.vertices == null) {
                    return;
                }

                System.Array.fill(this.vertices, function () {
                    return Bridge.getDefaultValue(UnityEngine.Vector3);
                }, 0, this.vertices.length);
                this.vertexCount = 0;

                if (uploadChanges && this.mesh != null) {
                    this.mesh.vertices = this.vertices;
                }

                if (this.mesh != null) {
                    this.mesh.bounds = TMPro.TMP_MeshInfo.s_DefaultBounds;
                }
            },
            /*TMPro.TMP_MeshInfo.Clear$1 end.*/

            /*TMPro.TMP_MeshInfo.ClearUnusedVertices start.*/
            /**
             * Function to clear the vertices while preserving the Triangles, Normals and Tangents.
             *
             * @instance
             * @public
             * @this TMPro.TMP_MeshInfo
             * @memberof TMPro.TMP_MeshInfo
             * @return  {void}
             */
            ClearUnusedVertices: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_MeshInfo#ClearUnusedVertices", this ); }

                var length = this.vertices.length - this.vertexCount;

                if (length > 0) {
                    System.Array.fill(this.vertices, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector3);
                    }, this.vertexCount, length);
                }
            },
            /*TMPro.TMP_MeshInfo.ClearUnusedVertices end.*/

            /*TMPro.TMP_MeshInfo.ClearUnusedVertices$1 start.*/
            /**
             * Function used to mark unused vertices as degenerate.
             *
             * @instance
             * @public
             * @this TMPro.TMP_MeshInfo
             * @memberof TMPro.TMP_MeshInfo
             * @param   {number}    startIndex
             * @return  {void}
             */
            ClearUnusedVertices$1: function (startIndex) {
if ( TRACE ) { TRACE( "TMPro.TMP_MeshInfo#ClearUnusedVertices$1", this ); }

                var length = this.vertices.length - startIndex;

                if (length > 0) {
                    System.Array.fill(this.vertices, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector3);
                    }, startIndex, length);
                }
            },
            /*TMPro.TMP_MeshInfo.ClearUnusedVertices$1 end.*/

            /*TMPro.TMP_MeshInfo.ClearUnusedVertices$2 start.*/
            /**
             * Function used to mark unused vertices as degenerate an upload resulting data to the mesh.
             *
             * @instance
             * @public
             * @this TMPro.TMP_MeshInfo
             * @memberof TMPro.TMP_MeshInfo
             * @param   {number}     startIndex    
             * @param   {boolean}    updateMesh
             * @return  {void}
             */
            ClearUnusedVertices$2: function (startIndex, updateMesh) {
if ( TRACE ) { TRACE( "TMPro.TMP_MeshInfo#ClearUnusedVertices$2", this ); }

                var length = this.vertices.length - startIndex;

                if (length > 0) {
                    System.Array.fill(this.vertices, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector3);
                    }, startIndex, length);
                }

                if (updateMesh && this.mesh != null) {
                    this.mesh.vertices = this.vertices;
                }
            },
            /*TMPro.TMP_MeshInfo.ClearUnusedVertices$2 end.*/

            /*TMPro.TMP_MeshInfo.SortGeometry$1 start.*/
            SortGeometry$1: function (order) {
if ( TRACE ) { TRACE( "TMPro.TMP_MeshInfo#SortGeometry$1", this ); }

                switch (order) {
                    case TMPro.VertexSortingOrder.Normal: 
                        // Do nothing
                        break;
                    case TMPro.VertexSortingOrder.Reverse: 
                        var size = this.vertexCount / 4;
                        for (var i = 0; i < size; i++) {
                            var src = i * 4;
                            var dst = (size - i - 1) * 4;

                            if (src < dst) {
                                this.SwapVertexData(src, dst);
                            }
                        }
                        break;
                }
            },
            /*TMPro.TMP_MeshInfo.SortGeometry$1 end.*/

            /*TMPro.TMP_MeshInfo.SortGeometry start.*/
            /**
             * Function to rearrange the quads of the text object to change their rendering order.
             *
             * @instance
             * @public
             * @this TMPro.TMP_MeshInfo
             * @memberof TMPro.TMP_MeshInfo
             * @param   {System.Collections.Generic.IList$1}    sortingOrder
             * @return  {void}
             */
            SortGeometry: function (sortingOrder) {
if ( TRACE ) { TRACE( "TMPro.TMP_MeshInfo#SortGeometry", this ); }

                // Make sure the sorting order array is not larger than the vertices array.
                var indexCount = System.Array.getCount(sortingOrder, System.Int32);

                if (indexCount * 4 > this.vertices.length) {
                    return;
                }

                var src_index;

                for (var dst_index = 0; dst_index < indexCount; dst_index++) {
                    src_index = System.Array.getItem(sortingOrder, dst_index, System.Int32);

                    while (src_index < dst_index) {
                        src_index = System.Array.getItem(sortingOrder, src_index, System.Int32);
                    }

                    // Swap items
                    if (src_index !== dst_index) {
                        this.SwapVertexData(src_index * 4, dst_index * 4);
                    }

                    //Debug.Log("Swap element [" + dst_index + "] with [" + src_index + "]. Vertex[" + dst_index + "] is " + vertices[dst_index * 4].z);
                }
            },
            /*TMPro.TMP_MeshInfo.SortGeometry end.*/

            /*TMPro.TMP_MeshInfo.SwapVertexData start.*/
            /**
             * Method to swap the vertex attributes between src and dst quads.
             *
             * @instance
             * @public
             * @this TMPro.TMP_MeshInfo
             * @memberof TMPro.TMP_MeshInfo
             * @param   {number}    src    Index of the first vertex attribute of the source character / quad.
             * @param   {number}    dst    Index of the first vertex attribute of the destination character / quad.
             * @return  {void}
             */
            SwapVertexData: function (src, dst) {
if ( TRACE ) { TRACE( "TMPro.TMP_MeshInfo#SwapVertexData", this ); }

                var src_Index = src; //  * 4;
                var dst_Index = dst; // * 4;

                // Swap vertices
                var vertex = new UnityEngine.Vector3();
                vertex = this.vertices[dst_Index + 0].$clone();
                this.vertices[dst_Index + 0] = this.vertices[src_Index + 0].$clone();
                this.vertices[src_Index + 0] = vertex.$clone();

                vertex = this.vertices[dst_Index + 1].$clone();
                this.vertices[dst_Index + 1] = this.vertices[src_Index + 1].$clone();
                this.vertices[src_Index + 1] = vertex.$clone();

                vertex = this.vertices[dst_Index + 2].$clone();
                this.vertices[dst_Index + 2] = this.vertices[src_Index + 2].$clone();
                this.vertices[src_Index + 2] = vertex.$clone();

                vertex = this.vertices[dst_Index + 3].$clone();
                this.vertices[dst_Index + 3] = this.vertices[src_Index + 3].$clone();
                this.vertices[src_Index + 3] = vertex.$clone();


                //Swap UVs0
                var uvs = new UnityEngine.Vector2();
                uvs = this.uvs0[dst_Index + 0].$clone();
                this.uvs0[dst_Index + 0] = this.uvs0[src_Index + 0].$clone();
                this.uvs0[src_Index + 0] = uvs.$clone();

                uvs = this.uvs0[dst_Index + 1].$clone();
                this.uvs0[dst_Index + 1] = this.uvs0[src_Index + 1].$clone();
                this.uvs0[src_Index + 1] = uvs.$clone();

                uvs = this.uvs0[dst_Index + 2].$clone();
                this.uvs0[dst_Index + 2] = this.uvs0[src_Index + 2].$clone();
                this.uvs0[src_Index + 2] = uvs.$clone();

                uvs = this.uvs0[dst_Index + 3].$clone();
                this.uvs0[dst_Index + 3] = this.uvs0[src_Index + 3].$clone();
                this.uvs0[src_Index + 3] = uvs.$clone();

                // Swap UVs2
                uvs = this.uvs2[dst_Index + 0].$clone();
                this.uvs2[dst_Index + 0] = this.uvs2[src_Index + 0].$clone();
                this.uvs2[src_Index + 0] = uvs.$clone();

                uvs = this.uvs2[dst_Index + 1].$clone();
                this.uvs2[dst_Index + 1] = this.uvs2[src_Index + 1].$clone();
                this.uvs2[src_Index + 1] = uvs.$clone();

                uvs = this.uvs2[dst_Index + 2].$clone();
                this.uvs2[dst_Index + 2] = this.uvs2[src_Index + 2].$clone();
                this.uvs2[src_Index + 2] = uvs.$clone();

                uvs = this.uvs2[dst_Index + 3].$clone();
                this.uvs2[dst_Index + 3] = this.uvs2[src_Index + 3].$clone();
                this.uvs2[src_Index + 3] = uvs.$clone();

                // Vertex Colors
                var color = new UnityEngine.Color32();
                color = this.colors32[dst_Index + 0].$clone();
                this.colors32[dst_Index + 0] = this.colors32[src_Index + 0].$clone();
                this.colors32[src_Index + 0] = color.$clone();

                color = this.colors32[dst_Index + 1].$clone();
                this.colors32[dst_Index + 1] = this.colors32[src_Index + 1].$clone();
                this.colors32[src_Index + 1] = color.$clone();

                color = this.colors32[dst_Index + 2].$clone();
                this.colors32[dst_Index + 2] = this.colors32[src_Index + 2].$clone();
                this.colors32[src_Index + 2] = color.$clone();

                color = this.colors32[dst_Index + 3].$clone();
                this.colors32[dst_Index + 3] = this.colors32[src_Index + 3].$clone();
                this.colors32[src_Index + 3] = color.$clone();
            },
            /*TMPro.TMP_MeshInfo.SwapVertexData end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_MeshInfo#getHashCode", this ); }

                var h = Bridge.addHash([5220475114, this.mesh, this.vertexCount, this.vertices, this.normals, this.tangents, this.uvs0, this.uvs2, this.colors32, this.triangles, this.material]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.TMP_MeshInfo#equals", this ); }

                if (!Bridge.is(o, TMPro.TMP_MeshInfo)) {
                    return false;
                }
                return Bridge.equals(this.mesh, o.mesh) && Bridge.equals(this.vertexCount, o.vertexCount) && Bridge.equals(this.vertices, o.vertices) && Bridge.equals(this.normals, o.normals) && Bridge.equals(this.tangents, o.tangents) && Bridge.equals(this.uvs0, o.uvs0) && Bridge.equals(this.uvs2, o.uvs2) && Bridge.equals(this.colors32, o.colors32) && Bridge.equals(this.triangles, o.triangles) && Bridge.equals(this.material, o.material);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.TMP_MeshInfo#$clone", this ); }

                var s = to || new TMPro.TMP_MeshInfo();
                s.mesh = this.mesh;
                s.vertexCount = this.vertexCount;
                s.vertices = this.vertices;
                s.normals = this.normals;
                s.tangents = this.tangents;
                s.uvs0 = this.uvs0;
                s.uvs2 = this.uvs2;
                s.colors32 = this.colors32;
                s.triangles = this.triangles;
                s.material = this.material;
                return s;
            }
        },
        overloads: {
            "ResizeMeshInfo(int, bool)": "ResizeMeshInfo$1",
            "Clear(bool)": "Clear$1",
            "ClearUnusedVertices(int)": "ClearUnusedVertices$1",
            "ClearUnusedVertices(int, bool)": "ClearUnusedVertices$2",
            "SortGeometry(VertexSortingOrder)": "SortGeometry$1"
        }
    });
    /*TMPro.TMP_MeshInfo end.*/

    /*TMPro.TMP_ObjectPool$1 start.*/
    Bridge.define("TMPro.TMP_ObjectPool$1", function (T) { return {
        fields: {
            m_Stack: null,
            m_ActionOnGet: null,
            m_ActionOnRelease: null,
            countAll: 0
        },
        props: {
            countActive: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_ObjectPool$1#countActive#get", this ); }

                    return this.countAll - this.countInactive;
                }
            },
            countInactive: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_ObjectPool$1#countInactive#get", this ); }

                    return this.m_Stack.Count;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_ObjectPool$1#init", this ); }

                this.m_Stack = new (System.Collections.Generic.Stack$1(T)).ctor();
            },
            ctor: function (actionOnGet, actionOnRelease) {
if ( TRACE ) { TRACE( "TMPro.TMP_ObjectPool$1#ctor", this ); }

                this.$initialize();
                this.m_ActionOnGet = actionOnGet;
                this.m_ActionOnRelease = actionOnRelease;
            }
        },
        methods: {
            /*TMPro.TMP_ObjectPool$1.Get start.*/
            Get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_ObjectPool$1#Get", this ); }

                var element;
                if (this.m_Stack.Count === 0) {
                    element = Bridge.createInstance(T);
                    this.countAll++;
                } else {
                    element = this.m_Stack.Pop();
                }

                if (!Bridge.staticEquals(this.m_ActionOnGet, null)) {
                    this.m_ActionOnGet(element);
                }

                return element;
            },
            /*TMPro.TMP_ObjectPool$1.Get end.*/

            /*TMPro.TMP_ObjectPool$1.Release start.*/
            Release: function (element) {
if ( TRACE ) { TRACE( "TMPro.TMP_ObjectPool$1#Release", this ); }

                if (this.m_Stack.Count > 0 && Bridge.referenceEquals(this.m_Stack.Peek(), element)) {
                    UnityEngine.Debug.LogError$2("Internal error. Trying to destroy object that is already released to pool.");
                }

                if (!Bridge.staticEquals(this.m_ActionOnRelease, null)) {
                    this.m_ActionOnRelease(element);
                }

                this.m_Stack.Push(element);
            },
            /*TMPro.TMP_ObjectPool$1.Release end.*/


        }
    }; });
    /*TMPro.TMP_ObjectPool$1 end.*/

    /*TMPro.TMP_Offset start.*/
    /**
     * @public
     * @class TMPro.TMP_Offset
     */
    Bridge.define("TMPro.TMP_Offset", {
        $kind: 4,
        statics: {
            fields: {
                k_ZeroOffset: null
            },
            props: {
                /**
                 * @static
                 * @public
                 * @readonly
                 * @memberof TMPro.TMP_Offset
                 * @function zero
                 * @type TMPro.TMP_Offset
                 */
                zero: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Offset#zero#get", this ); }

                        return TMPro.TMP_Offset.k_ZeroOffset.$clone();
                    }
                }
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Offset#init", this ); }

                    this.k_ZeroOffset = new TMPro.TMP_Offset();
                    this.k_ZeroOffset = new TMPro.TMP_Offset.$ctor2(0.0, 0.0, 0.0, 0.0);
                }
            },
            methods: {
                op_Equality: function (lhs, rhs) {
if ( TRACE ) { TRACE( "TMPro.TMP_Offset#op_Equality", this ); }

                    return lhs.m_Left === rhs.m_Left && lhs.m_Right === rhs.m_Right && lhs.m_Top === rhs.m_Top && lhs.m_Bottom === rhs.m_Bottom;
                },
                op_Inequality: function (lhs, rhs) {
if ( TRACE ) { TRACE( "TMPro.TMP_Offset#op_Inequality", this ); }

                    return !(TMPro.TMP_Offset.op_Equality(lhs.$clone(), rhs.$clone()));
                },
                op_Multiply: function (a, b) {
if ( TRACE ) { TRACE( "TMPro.TMP_Offset#op_Multiply", this ); }

                    return new TMPro.TMP_Offset.$ctor2(a.m_Left * b, a.m_Right * b, a.m_Top * b, a.m_Bottom * b);
                },
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Offset#getDefaultValue", this ); }
 return new TMPro.TMP_Offset(); }
            }
        },
        fields: {
            m_Left: 0,
            m_Right: 0,
            m_Top: 0,
            m_Bottom: 0
        },
        props: {
            left: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Offset#left#get", this ); }

                    return this.m_Left;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Offset#left#set", this ); }

                    this.m_Left = value;
                }
            },
            right: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Offset#right#get", this ); }

                    return this.m_Right;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Offset#right#set", this ); }

                    this.m_Right = value;
                }
            },
            top: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Offset#top#get", this ); }

                    return this.m_Top;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Offset#top#set", this ); }

                    this.m_Top = value;
                }
            },
            bottom: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Offset#bottom#get", this ); }

                    return this.m_Bottom;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Offset#bottom#set", this ); }

                    this.m_Bottom = value;
                }
            },
            horizontal: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Offset#horizontal#get", this ); }

                    return this.m_Left;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Offset#horizontal#set", this ); }

                    this.m_Left = value;
                    this.m_Right = value;
                }
            },
            vertical: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Offset#vertical#get", this ); }

                    return this.m_Top;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Offset#vertical#set", this ); }

                    this.m_Top = value;
                    this.m_Bottom = value;
                }
            }
        },
        ctors: {
            /**
             * @instance
             * @public
             * @this TMPro.TMP_Offset
             * @memberof TMPro.TMP_Offset
             * @param   {number}    left      
             * @param   {number}    right     
             * @param   {number}    top       
             * @param   {number}    bottom
             * @return  {void}
             */
            $ctor2: function (left, right, top, bottom) {
if ( TRACE ) { TRACE( "TMPro.TMP_Offset#$ctor2", this ); }

                this.$initialize();
                this.m_Left = left;
                this.m_Right = right;
                this.m_Top = top;
                this.m_Bottom = bottom;
            },
            /**
             * @instance
             * @public
             * @this TMPro.TMP_Offset
             * @memberof TMPro.TMP_Offset
             * @param   {number}    horizontal    
             * @param   {number}    vertical
             * @return  {void}
             */
            $ctor1: function (horizontal, vertical) {
if ( TRACE ) { TRACE( "TMPro.TMP_Offset#$ctor1", this ); }

                this.$initialize();
                this.m_Left = horizontal;
                this.m_Right = horizontal;
                this.m_Top = vertical;
                this.m_Bottom = vertical;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Offset#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*TMPro.TMP_Offset.Copy start.*/
            Copy: function (other) {
if ( TRACE ) { TRACE( "TMPro.TMP_Offset#Copy", this ); }

                this.m_Left = other.m_Left;
                this.m_Right = other.m_Right;
                this.m_Top = other.m_Top;
                this.m_Bottom = other.m_Bottom;
            },
            /*TMPro.TMP_Offset.Copy end.*/

            /*TMPro.TMP_Offset.getHashCode start.*/
            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Offset#getHashCode", this ); }

                return Bridge.getHashCode(this);
            },
            /*TMPro.TMP_Offset.getHashCode end.*/

            /*TMPro.TMP_Offset.equals start.*/
            equals: function (obj) {
if ( TRACE ) { TRACE( "TMPro.TMP_Offset#equals", this ); }

                return Bridge.equals(this, obj);
            },
            /*TMPro.TMP_Offset.equals end.*/

            /*TMPro.TMP_Offset.Equals start.*/
            Equals: function (other) {
if ( TRACE ) { TRACE( "TMPro.TMP_Offset#Equals", this ); }

                return Bridge.equals(this, other.$clone());
            },
            /*TMPro.TMP_Offset.Equals end.*/

            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.TMP_Offset#$clone", this ); }

                var s = to || new TMPro.TMP_Offset();
                s.m_Left = this.m_Left;
                s.m_Right = this.m_Right;
                s.m_Top = this.m_Top;
                s.m_Bottom = this.m_Bottom;
                return s;
            }
        },
        overloads: {
            "GetHashCode()": "getHashCode",
            "Equals(object)": "equals"
        }
    });
    /*TMPro.TMP_Offset end.*/

    /*TMPro.TMP_PageInfo start.*/
    Bridge.define("TMPro.TMP_PageInfo", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_PageInfo#getDefaultValue", this ); }
 return new TMPro.TMP_PageInfo(); }
            }
        },
        fields: {
            firstCharacterIndex: 0,
            lastCharacterIndex: 0,
            ascender: 0,
            baseLine: 0,
            descender: 0
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_PageInfo#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_PageInfo#getHashCode", this ); }

                var h = Bridge.addHash([5169356013, this.firstCharacterIndex, this.lastCharacterIndex, this.ascender, this.baseLine, this.descender]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.TMP_PageInfo#equals", this ); }

                if (!Bridge.is(o, TMPro.TMP_PageInfo)) {
                    return false;
                }
                return Bridge.equals(this.firstCharacterIndex, o.firstCharacterIndex) && Bridge.equals(this.lastCharacterIndex, o.lastCharacterIndex) && Bridge.equals(this.ascender, o.ascender) && Bridge.equals(this.baseLine, o.baseLine) && Bridge.equals(this.descender, o.descender);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.TMP_PageInfo#$clone", this ); }

                var s = to || new TMPro.TMP_PageInfo();
                s.firstCharacterIndex = this.firstCharacterIndex;
                s.lastCharacterIndex = this.lastCharacterIndex;
                s.ascender = this.ascender;
                s.baseLine = this.baseLine;
                s.descender = this.descender;
                return s;
            }
        }
    });
    /*TMPro.TMP_PageInfo end.*/

    /*TMPro.TMP_ResourceManager start.*/
    /**
     * @public
     * @class TMPro.TMP_ResourceManager
     */
    Bridge.define("TMPro.TMP_ResourceManager", {
        statics: {
            fields: {
                s_instance: null,
                s_TextSettings: null,
                s_FontAssetReferences: null,
                s_FontAssetReferenceLookup: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_ResourceManager#init", this ); }

                    this.s_instance = new TMPro.TMP_ResourceManager();
                    this.s_FontAssetReferences = new (System.Collections.Generic.List$1(TMPro.TMP_FontAsset)).ctor();
                    this.s_FontAssetReferenceLookup = new (System.Collections.Generic.Dictionary$2(System.Int32,TMPro.TMP_FontAsset)).ctor();
                },
                ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_ResourceManager#ctor", this ); }

                }
            },
            methods: {
                /*TMPro.TMP_ResourceManager.GetTextSettings:static start.*/
                GetTextSettings: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_ResourceManager#GetTextSettings", this ); }

                    if (TMPro.TMP_ResourceManager.s_TextSettings == null) {
                        // Try loading the TMP Settings from a Resources folder in the user project.
                        TMPro.TMP_ResourceManager.s_TextSettings = UnityEngine.Resources.Load(TMPro.TMP_Settings, "TextSettings"); // ?? ScriptableObject.CreateInstance<TMP_Settings>();

                    }

                    return TMPro.TMP_ResourceManager.s_TextSettings;
                },
                /*TMPro.TMP_ResourceManager.GetTextSettings:static end.*/

                /*TMPro.TMP_ResourceManager.AddFontAsset:static start.*/
                /**
                 * @static
                 * @public
                 * @this TMPro.TMP_ResourceManager
                 * @memberof TMPro.TMP_ResourceManager
                 * @param   {TMPro.TMP_FontAsset}    fontAsset
                 * @return  {void}
                 */
                AddFontAsset: function (fontAsset) {
if ( TRACE ) { TRACE( "TMPro.TMP_ResourceManager#AddFontAsset", this ); }

                    var hashcode = fontAsset.hashCode;

                    if (TMPro.TMP_ResourceManager.s_FontAssetReferenceLookup.containsKey(hashcode)) {
                        return;
                    }

                    TMPro.TMP_ResourceManager.s_FontAssetReferences.add(fontAsset);
                    TMPro.TMP_ResourceManager.s_FontAssetReferenceLookup.add(hashcode, fontAsset);
                },
                /*TMPro.TMP_ResourceManager.AddFontAsset:static end.*/

                /*TMPro.TMP_ResourceManager.TryGetFontAsset:static start.*/
                /**
                 * @static
                 * @public
                 * @this TMPro.TMP_ResourceManager
                 * @memberof TMPro.TMP_ResourceManager
                 * @param   {number}                 hashcode     
                 * @param   {TMPro.TMP_FontAsset}    fontAsset
                 * @return  {boolean}
                 */
                TryGetFontAsset: function (hashcode, fontAsset) {
if ( TRACE ) { TRACE( "TMPro.TMP_ResourceManager#TryGetFontAsset", this ); }

                    fontAsset.v = null;

                    return TMPro.TMP_ResourceManager.s_FontAssetReferenceLookup.tryGetValue(hashcode, fontAsset);
                },
                /*TMPro.TMP_ResourceManager.TryGetFontAsset:static end.*/

                /*TMPro.TMP_ResourceManager.RebuildFontAssetCache:static start.*/
                RebuildFontAssetCache: function (instanceID) {
if ( TRACE ) { TRACE( "TMPro.TMP_ResourceManager#RebuildFontAssetCache", this ); }

                    // Iterate over loaded font assets to update affected font assets
                    for (var i = 0; i < TMPro.TMP_ResourceManager.s_FontAssetReferences.Count; i++) {
                        var fontAsset = TMPro.TMP_ResourceManager.s_FontAssetReferences.getItem(i);

                        if (fontAsset.FallbackSearchQueryLookup.contains(instanceID)) {
                            fontAsset.ReadFontAssetDefinition();
                        }
                    }
                },
                /*TMPro.TMP_ResourceManager.RebuildFontAssetCache:static end.*/


            }
        }
    });
    /*TMPro.TMP_ResourceManager end.*/

    /*TMPro.TMP_ScrollbarEventHandler start.*/
    Bridge.define("TMPro.TMP_ScrollbarEventHandler", {
        inherits: [UnityEngine.MonoBehaviour,UnityEngine.EventSystems.IPointerClickHandler,UnityEngine.EventSystems.ISelectHandler,UnityEngine.EventSystems.IDeselectHandler],
        fields: {
            isSelected: false
        },
        alias: [
            "OnPointerClick", "UnityEngine$EventSystems$IPointerClickHandler$OnPointerClick",
            "OnSelect", "UnityEngine$EventSystems$ISelectHandler$OnSelect",
            "OnDeselect", "UnityEngine$EventSystems$IDeselectHandler$OnDeselect"
        ],
        methods: {
            /*TMPro.TMP_ScrollbarEventHandler.OnPointerClick start.*/
            OnPointerClick: function (eventData) {
if ( TRACE ) { TRACE( "TMPro.TMP_ScrollbarEventHandler#OnPointerClick", this ); }

                UnityEngine.Debug.Log$1("Scrollbar click...");
            },
            /*TMPro.TMP_ScrollbarEventHandler.OnPointerClick end.*/

            /*TMPro.TMP_ScrollbarEventHandler.OnSelect start.*/
            OnSelect: function (eventData) {
if ( TRACE ) { TRACE( "TMPro.TMP_ScrollbarEventHandler#OnSelect", this ); }

                UnityEngine.Debug.Log$1("Scrollbar selected");
                this.isSelected = true;
            },
            /*TMPro.TMP_ScrollbarEventHandler.OnSelect end.*/

            /*TMPro.TMP_ScrollbarEventHandler.OnDeselect start.*/
            OnDeselect: function (eventData) {
if ( TRACE ) { TRACE( "TMPro.TMP_ScrollbarEventHandler#OnDeselect", this ); }

                UnityEngine.Debug.Log$1("Scrollbar De-Selected");
                this.isSelected = false;
            },
            /*TMPro.TMP_ScrollbarEventHandler.OnDeselect end.*/


        }
    });
    /*TMPro.TMP_ScrollbarEventHandler end.*/

    /*TMPro.TMP_SelectionCaret start.*/
    /**
     * A simple component that can be added to a newly created object where inheriting from MaskableGraphic is needed.
     *
     * @public
     * @class TMPro.TMP_SelectionCaret
     * @augments UnityEngine.UI.MaskableGraphic
     */
    Bridge.define("TMPro.TMP_SelectionCaret", {
        inherits: [UnityEngine.UI.MaskableGraphic],
        alias: ["Cull", "UnityEngine$UI$IClippable$Cull"],
        methods: {
            /*TMPro.TMP_SelectionCaret.Cull start.*/
            /**
             * Override to Cull function of MaskableGraphic to prevent Culling.
             *
             * @instance
             * @public
             * @override
             * @this TMPro.TMP_SelectionCaret
             * @memberof TMPro.TMP_SelectionCaret
             * @param   {UnityEngine.Rect}    clipRect     
             * @param   {boolean}             validRect
             * @return  {void}
             */
            Cull: function (clipRect, validRect) {
if ( TRACE ) { TRACE( "TMPro.TMP_SelectionCaret#Cull", this ); }

                //Debug.Log("***** Cull (" + clipRect + ")   Valid Rect: " + validRect + "   Cull: " + canvasRenderer.cull + " *****");

                if (validRect) {
                    this.canvasRenderer.cull = false;
                    UnityEngine.UI.CanvasUpdateRegistry.RegisterCanvasElementForGraphicRebuild(this);
                    return;
                }

                UnityEngine.UI.MaskableGraphic.prototype.Cull.call(this, clipRect.$clone(), validRect);
            },
            /*TMPro.TMP_SelectionCaret.Cull end.*/

            /*TMPro.TMP_SelectionCaret.UpdateGeometry start.*/
            UpdateGeometry: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SelectionCaret#UpdateGeometry", this ); }

                // Function overridden as Caret and text Selection Highlight is controlled by the Input Field.
            },
            /*TMPro.TMP_SelectionCaret.UpdateGeometry end.*/


        }
    });
    /*TMPro.TMP_SelectionCaret end.*/

    /*TMPro.TMP_Settings start.*/
    /**
     * Scaling options for the sprites
     *
     * @public
     * @class TMPro.TMP_Settings
     * @augments UnityEngine.ScriptableObject
     */
    Bridge.define("TMPro.TMP_Settings", {
        inherits: [UnityEngine.ScriptableObject],
        statics: {
            fields: {
                s_Instance: null
            },
            props: {
                /**
                 * Returns the release version of the product.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof TMPro.TMP_Settings
                 * @function version
                 * @type string
                 */
                version: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#version#get", this ); }

                        return "1.4.0";
                    }
                },
                /**
                 * Controls if Word Wrapping will be enabled on newly created text objects by default.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof TMPro.TMP_Settings
                 * @function enableWordWrapping
                 * @type boolean
                 */
                enableWordWrapping: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#enableWordWrapping#get", this ); }

                        return TMPro.TMP_Settings.instance.m_enableWordWrapping;
                    }
                },
                /**
                 * Controls if Kerning is enabled on newly created text objects by default.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof TMPro.TMP_Settings
                 * @function enableKerning
                 * @type boolean
                 */
                enableKerning: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#enableKerning#get", this ); }

                        return TMPro.TMP_Settings.instance.m_enableKerning;
                    }
                },
                /**
                 * Controls if Extra Padding is enabled on newly created text objects by default.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof TMPro.TMP_Settings
                 * @function enableExtraPadding
                 * @type boolean
                 */
                enableExtraPadding: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#enableExtraPadding#get", this ); }

                        return TMPro.TMP_Settings.instance.m_enableExtraPadding;
                    }
                },
                /**
                 * Controls if TintAllSprites is enabled on newly created text objects by default.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof TMPro.TMP_Settings
                 * @function enableTintAllSprites
                 * @type boolean
                 */
                enableTintAllSprites: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#enableTintAllSprites#get", this ); }

                        return TMPro.TMP_Settings.instance.m_enableTintAllSprites;
                    }
                },
                /**
                 * Controls if Escape Characters will be parsed in the Text Input Box on newly created text objects.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof TMPro.TMP_Settings
                 * @function enableParseEscapeCharacters
                 * @type boolean
                 */
                enableParseEscapeCharacters: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#enableParseEscapeCharacters#get", this ); }

                        return TMPro.TMP_Settings.instance.m_enableParseEscapeCharacters;
                    }
                },
                /**
                 * Controls if Raycast Target is enabled by default on newly created text objects.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof TMPro.TMP_Settings
                 * @function enableRaycastTarget
                 * @type boolean
                 */
                enableRaycastTarget: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#enableRaycastTarget#get", this ); }

                        return TMPro.TMP_Settings.instance.m_EnableRaycastTarget;
                    }
                },
                /**
                 * Determines if OpenType Font Features should be retrieved at runtime from the source font file.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof TMPro.TMP_Settings
                 * @function getFontFeaturesAtRuntime
                 * @type boolean
                 */
                getFontFeaturesAtRuntime: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#getFontFeaturesAtRuntime#get", this ); }

                        return TMPro.TMP_Settings.instance.m_GetFontFeaturesAtRuntime;
                    }
                },
                /**
                 * The character that will be used as a replacement for missing glyphs in a font asset.
                 *
                 * @static
                 * @public
                 * @memberof TMPro.TMP_Settings
                 * @function missingGlyphCharacter
                 * @type number
                 */
                missingGlyphCharacter: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#missingGlyphCharacter#get", this ); }

                        return TMPro.TMP_Settings.instance.m_missingGlyphCharacter;
                    },
                    set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#missingGlyphCharacter#set", this ); }

                        TMPro.TMP_Settings.instance.m_missingGlyphCharacter = value;
                    }
                },
                /**
                 * Controls the display of warning message in the console.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof TMPro.TMP_Settings
                 * @function warningsDisabled
                 * @type boolean
                 */
                warningsDisabled: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#warningsDisabled#get", this ); }

                        return TMPro.TMP_Settings.instance.m_warningsDisabled;
                    }
                },
                /**
                 * Returns the Default Font Asset to be used by newly created text objects.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof TMPro.TMP_Settings
                 * @function defaultFontAsset
                 * @type TMPro.TMP_FontAsset
                 */
                defaultFontAsset: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#defaultFontAsset#get", this ); }

                        return TMPro.TMP_Settings.instance.m_defaultFontAsset;
                    }
                },
                /**
                 * The relative path to a Resources folder in the project.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof TMPro.TMP_Settings
                 * @function defaultFontAssetPath
                 * @type string
                 */
                defaultFontAssetPath: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#defaultFontAssetPath#get", this ); }

                        return TMPro.TMP_Settings.instance.m_defaultFontAssetPath;
                    }
                },
                /**
                 * The Default Point Size of newly created text objects.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof TMPro.TMP_Settings
                 * @function defaultFontSize
                 * @type number
                 */
                defaultFontSize: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#defaultFontSize#get", this ); }

                        return TMPro.TMP_Settings.instance.m_defaultFontSize;
                    }
                },
                /**
                 * The multiplier used to computer the default Min point size when Text Auto Sizing is used.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof TMPro.TMP_Settings
                 * @function defaultTextAutoSizingMinRatio
                 * @type number
                 */
                defaultTextAutoSizingMinRatio: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#defaultTextAutoSizingMinRatio#get", this ); }

                        return TMPro.TMP_Settings.instance.m_defaultAutoSizeMinRatio;
                    }
                },
                /**
                 * The multiplier used to computer the default Max point size when Text Auto Sizing is used.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof TMPro.TMP_Settings
                 * @function defaultTextAutoSizingMaxRatio
                 * @type number
                 */
                defaultTextAutoSizingMaxRatio: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#defaultTextAutoSizingMaxRatio#get", this ); }

                        return TMPro.TMP_Settings.instance.m_defaultAutoSizeMaxRatio;
                    }
                },
                /**
                 * The Default Size of the Text Container of a TextMeshPro object.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof TMPro.TMP_Settings
                 * @function defaultTextMeshProTextContainerSize
                 * @type UnityEngine.Vector2
                 */
                defaultTextMeshProTextContainerSize: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#defaultTextMeshProTextContainerSize#get", this ); }

                        return TMPro.TMP_Settings.instance.m_defaultTextMeshProTextContainerSize.$clone();
                    }
                },
                /**
                 * The Default Width of the Text Container of a TextMeshProUI object.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof TMPro.TMP_Settings
                 * @function defaultTextMeshProUITextContainerSize
                 * @type UnityEngine.Vector2
                 */
                defaultTextMeshProUITextContainerSize: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#defaultTextMeshProUITextContainerSize#get", this ); }

                        return TMPro.TMP_Settings.instance.m_defaultTextMeshProUITextContainerSize.$clone();
                    }
                },
                /**
                 * Set the size of the text container of newly created text objects to match the size of the text.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof TMPro.TMP_Settings
                 * @function autoSizeTextContainer
                 * @type boolean
                 */
                autoSizeTextContainer: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#autoSizeTextContainer#get", this ); }

                        return TMPro.TMP_Settings.instance.m_autoSizeTextContainer;
                    }
                },
                /**
                 * Disables InternalUpdate() calls when true. This can improve performance when the scale of the text object is static.
                 *
                 * @static
                 * @public
                 * @memberof TMPro.TMP_Settings
                 * @function isTextObjectScaleStatic
                 * @type boolean
                 */
                isTextObjectScaleStatic: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#isTextObjectScaleStatic#get", this ); }

                        return TMPro.TMP_Settings.instance.m_IsTextObjectScaleStatic;
                    },
                    set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#isTextObjectScaleStatic#set", this ); }

                        TMPro.TMP_Settings.instance.m_IsTextObjectScaleStatic = value;
                    }
                },
                /**
                 * Returns the list of Fallback Fonts defined in the TMP Settings file.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof TMPro.TMP_Settings
                 * @function fallbackFontAssets
                 * @type System.Collections.Generic.List$1
                 */
                fallbackFontAssets: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#fallbackFontAssets#get", this ); }

                        return TMPro.TMP_Settings.instance.m_fallbackFontAssets;
                    }
                },
                /**
                 * Controls whether or not TMP will create a matching material preset or use the default material of the fallback font asset.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof TMPro.TMP_Settings
                 * @function matchMaterialPreset
                 * @type boolean
                 */
                matchMaterialPreset: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#matchMaterialPreset#get", this ); }

                        return TMPro.TMP_Settings.instance.m_matchMaterialPreset;
                    }
                },
                /**
                 * The Default Sprite Asset to be used by default.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof TMPro.TMP_Settings
                 * @function defaultSpriteAsset
                 * @type TMPro.TMP_SpriteAsset
                 */
                defaultSpriteAsset: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#defaultSpriteAsset#get", this ); }

                        return TMPro.TMP_Settings.instance.m_defaultSpriteAsset;
                    }
                },
                /**
                 * The relative path to a Resources folder in the project.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof TMPro.TMP_Settings
                 * @function defaultSpriteAssetPath
                 * @type string
                 */
                defaultSpriteAssetPath: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#defaultSpriteAssetPath#get", this ); }

                        return TMPro.TMP_Settings.instance.m_defaultSpriteAssetPath;
                    }
                },
                /**
                 * Determines if Emoji support is enabled in the Input Field TouchScreenKeyboard.
                 *
                 * @static
                 * @public
                 * @memberof TMPro.TMP_Settings
                 * @function enableEmojiSupport
                 * @type boolean
                 */
                enableEmojiSupport: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#enableEmojiSupport#get", this ); }

                        return TMPro.TMP_Settings.instance.m_enableEmojiSupport;
                    },
                    set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#enableEmojiSupport#set", this ); }

                        TMPro.TMP_Settings.instance.m_enableEmojiSupport = value;
                    }
                },
                /**
                 * The unicode value of the sprite that will be used when the requested sprite is missing from the sprite asset and potential fallbacks.
                 *
                 * @static
                 * @public
                 * @memberof TMPro.TMP_Settings
                 * @function missingCharacterSpriteUnicode
                 * @type number
                 */
                missingCharacterSpriteUnicode: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#missingCharacterSpriteUnicode#get", this ); }

                        return TMPro.TMP_Settings.instance.m_MissingCharacterSpriteUnicode;
                    },
                    set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#missingCharacterSpriteUnicode#set", this ); }

                        TMPro.TMP_Settings.instance.m_MissingCharacterSpriteUnicode = value;
                    }
                },
                /**
                 * Determines if sprites will be scaled relative to the primary font asset assigned to the text object or relative to the current font asset.
                 * The relative path to a Resources folder in the project that contains Color Gradient Presets.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof TMPro.TMP_Settings
                 * @function defaultColorGradientPresetsPath
                 * @type string
                 */
                defaultColorGradientPresetsPath: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#defaultColorGradientPresetsPath#get", this ); }

                        return TMPro.TMP_Settings.instance.m_defaultColorGradientPresetsPath;
                    }
                },
                /**
                 * The Default Style Sheet used by the text objects.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof TMPro.TMP_Settings
                 * @function defaultStyleSheet
                 * @type TMPro.TMP_StyleSheet
                 */
                defaultStyleSheet: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#defaultStyleSheet#get", this ); }

                        return TMPro.TMP_Settings.instance.m_defaultStyleSheet;
                    }
                },
                /**
                 * The relative path to a Resources folder in the project that contains the TMP Style Sheets.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof TMPro.TMP_Settings
                 * @function styleSheetsResourcePath
                 * @type string
                 */
                styleSheetsResourcePath: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#styleSheetsResourcePath#get", this ); }

                        return TMPro.TMP_Settings.instance.m_StyleSheetsResourcePath;
                    }
                },
                /**
                 * Text file that contains the leading characters used for line breaking for Asian languages.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof TMPro.TMP_Settings
                 * @function leadingCharacters
                 * @type UnityEngine.TextAsset
                 */
                leadingCharacters: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#leadingCharacters#get", this ); }

                        return TMPro.TMP_Settings.instance.m_leadingCharacters;
                    }
                },
                /**
                 * Text file that contains the following characters used for line breaking for Asian languages.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof TMPro.TMP_Settings
                 * @function followingCharacters
                 * @type UnityEngine.TextAsset
                 */
                followingCharacters: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#followingCharacters#get", this ); }

                        return TMPro.TMP_Settings.instance.m_followingCharacters;
                    }
                },
                /**
                 * @static
                 * @public
                 * @readonly
                 * @memberof TMPro.TMP_Settings
                 * @function linebreakingRules
                 * @type TMPro.TMP_Settings.LineBreakingTable
                 */
                linebreakingRules: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#linebreakingRules#get", this ); }

                        if (TMPro.TMP_Settings.instance.m_linebreakingRules == null) {
                            TMPro.TMP_Settings.LoadLinebreakingRules();
                        }

                        return TMPro.TMP_Settings.instance.m_linebreakingRules;
                    }
                },
                /**
                 * Determines if Modern or Traditional line breaking rules should be used for Korean text.
                 *
                 * @static
                 * @public
                 * @memberof TMPro.TMP_Settings
                 * @function useModernHangulLineBreakingRules
                 * @type boolean
                 */
                useModernHangulLineBreakingRules: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#useModernHangulLineBreakingRules#get", this ); }

                        return TMPro.TMP_Settings.instance.m_UseModernHangulLineBreakingRules;
                    },
                    set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#useModernHangulLineBreakingRules#set", this ); }

                        TMPro.TMP_Settings.instance.m_UseModernHangulLineBreakingRules = value;
                    }
                },
                /**
                 * Get a singleton instance of the settings class.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof TMPro.TMP_Settings
                 * @function instance
                 * @type TMPro.TMP_Settings
                 */
                instance: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#instance#get", this ); }

                        if (TMPro.TMP_Settings.s_Instance == null) {
                            TMPro.TMP_Settings.s_Instance = UnityEngine.Resources.Load(TMPro.TMP_Settings, "TMP Settings");

                        }

                        return TMPro.TMP_Settings.s_Instance;
                    }
                }
            },
            methods: {
                /*TMPro.TMP_Settings.LoadDefaultSettings:static start.*/
                /**
                 * Static Function to load the TMP Settings file.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_Settings
                 * @memberof TMPro.TMP_Settings
                 * @return  {TMPro.TMP_Settings}
                 */
                LoadDefaultSettings: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#LoadDefaultSettings", this ); }

                    if (TMPro.TMP_Settings.s_Instance == null) {
                        // Load settings from TMP_Settings file
                        var settings = UnityEngine.Resources.Load(TMPro.TMP_Settings, "TMP Settings");
                        if (settings != null) {
                            TMPro.TMP_Settings.s_Instance = settings;
                        }
                    }

                    return TMPro.TMP_Settings.s_Instance;
                },
                /*TMPro.TMP_Settings.LoadDefaultSettings:static end.*/

                /*TMPro.TMP_Settings.GetSettings:static start.*/
                /**
                 * Returns the Sprite Asset defined in the TMP Settings file.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_Settings
                 * @memberof TMPro.TMP_Settings
                 * @return  {TMPro.TMP_Settings}
                 */
                GetSettings: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#GetSettings", this ); }

                    if (TMPro.TMP_Settings.instance == null) {
                        return null;
                    }

                    return TMPro.TMP_Settings.instance;
                },
                /*TMPro.TMP_Settings.GetSettings:static end.*/

                /*TMPro.TMP_Settings.GetFontAsset:static start.*/
                /**
                 * Returns the Font Asset defined in the TMP Settings file.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_Settings
                 * @memberof TMPro.TMP_Settings
                 * @return  {TMPro.TMP_FontAsset}
                 */
                GetFontAsset: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#GetFontAsset", this ); }

                    if (TMPro.TMP_Settings.instance == null) {
                        return null;
                    }

                    return TMPro.TMP_Settings.instance.m_defaultFontAsset;
                },
                /*TMPro.TMP_Settings.GetFontAsset:static end.*/

                /*TMPro.TMP_Settings.GetSpriteAsset:static start.*/
                /**
                 * Returns the Sprite Asset defined in the TMP Settings file.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_Settings
                 * @memberof TMPro.TMP_Settings
                 * @return  {TMPro.TMP_SpriteAsset}
                 */
                GetSpriteAsset: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#GetSpriteAsset", this ); }

                    if (TMPro.TMP_Settings.instance == null) {
                        return null;
                    }

                    return TMPro.TMP_Settings.instance.m_defaultSpriteAsset;
                },
                /*TMPro.TMP_Settings.GetSpriteAsset:static end.*/

                /*TMPro.TMP_Settings.GetStyleSheet:static start.*/
                /**
                 * Returns the Style Sheet defined in the TMP Settings file.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_Settings
                 * @memberof TMPro.TMP_Settings
                 * @return  {TMPro.TMP_StyleSheet}
                 */
                GetStyleSheet: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#GetStyleSheet", this ); }

                    if (TMPro.TMP_Settings.instance == null) {
                        return null;
                    }

                    return TMPro.TMP_Settings.instance.m_defaultStyleSheet;
                },
                /*TMPro.TMP_Settings.GetStyleSheet:static end.*/

                /*TMPro.TMP_Settings.LoadLinebreakingRules:static start.*/
                LoadLinebreakingRules: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#LoadLinebreakingRules", this ); }

                    //Debug.Log("Loading Line Breaking Rules for Asian Languages.");

                    if (TMPro.TMP_Settings.instance == null) {
                        return;
                    }

                    if (TMPro.TMP_Settings.s_Instance.m_linebreakingRules == null) {
                        TMPro.TMP_Settings.s_Instance.m_linebreakingRules = new TMPro.TMP_Settings.LineBreakingTable();
                    }

                    TMPro.TMP_Settings.s_Instance.m_linebreakingRules.leadingCharacters = TMPro.TMP_Settings.GetCharacters(TMPro.TMP_Settings.s_Instance.m_leadingCharacters);
                    TMPro.TMP_Settings.s_Instance.m_linebreakingRules.followingCharacters = TMPro.TMP_Settings.GetCharacters(TMPro.TMP_Settings.s_Instance.m_followingCharacters);
                },
                /*TMPro.TMP_Settings.LoadLinebreakingRules:static end.*/

                /*TMPro.TMP_Settings.GetCharacters:static start.*/
                /**
                 * Get the characters from the line breaking files
                 *
                 * @static
                 * @private
                 * @this TMPro.TMP_Settings
                 * @memberof TMPro.TMP_Settings
                 * @param   {UnityEngine.TextAsset}                      file
                 * @return  {System.Collections.Generic.Dictionary$2}
                 */
                GetCharacters: function (file) {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#GetCharacters", this ); }

                    var dict = new (System.Collections.Generic.Dictionary$2(System.Int32,System.Char)).ctor();
                    var text = file.text;

                    for (var i = 0; i < text.length; i++) {
                        var c = text.charCodeAt(i);
                        // Check to make sure we don't include duplicates
                        if (dict.containsKey(c) === false) {
                            dict.add(c, c);
                            //Debug.Log("Adding [" + (int)c + "] to dictionary.");
                        }
                        //else
                        //    Debug.Log("Character [" + text[i] + "] is a duplicate.");
                    }

                    return dict;
                },
                /*TMPro.TMP_Settings.GetCharacters:static end.*/


            }
        },
        fields: {
            m_enableWordWrapping: false,
            m_enableKerning: false,
            m_enableExtraPadding: false,
            m_enableTintAllSprites: false,
            m_enableParseEscapeCharacters: false,
            m_EnableRaycastTarget: false,
            m_GetFontFeaturesAtRuntime: false,
            m_missingGlyphCharacter: 0,
            m_warningsDisabled: false,
            m_defaultFontAsset: null,
            m_defaultFontAssetPath: null,
            m_defaultFontSize: 0,
            m_defaultAutoSizeMinRatio: 0,
            m_defaultAutoSizeMaxRatio: 0,
            m_defaultTextMeshProTextContainerSize: null,
            m_defaultTextMeshProUITextContainerSize: null,
            m_autoSizeTextContainer: false,
            m_IsTextObjectScaleStatic: false,
            m_fallbackFontAssets: null,
            m_matchMaterialPreset: false,
            m_defaultSpriteAsset: null,
            m_defaultSpriteAssetPath: null,
            m_enableEmojiSupport: false,
            m_MissingCharacterSpriteUnicode: 0,
            m_defaultColorGradientPresetsPath: null,
            m_defaultStyleSheet: null,
            m_StyleSheetsResourcePath: null,
            m_leadingCharacters: null,
            m_followingCharacters: null,
            m_linebreakingRules: null,
            m_UseModernHangulLineBreakingRules: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Settings#init", this ); }

                this.m_defaultTextMeshProTextContainerSize = new UnityEngine.Vector2();
                this.m_defaultTextMeshProUITextContainerSize = new UnityEngine.Vector2();
                this.m_EnableRaycastTarget = true;
                this.m_GetFontFeaturesAtRuntime = true;
            }
        }
    });
    /*TMPro.TMP_Settings end.*/

    /*TMPro.TMP_Settings+LineBreakingTable start.*/
    Bridge.define("TMPro.TMP_Settings.LineBreakingTable", {
        $kind: 1002,
        fields: {
            leadingCharacters: null,
            followingCharacters: null
        }
    });
    /*TMPro.TMP_Settings+LineBreakingTable end.*/

    /*TMPro.TMP_SpriteAnimator start.*/
    Bridge.define("TMPro.TMP_SpriteAnimator", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            m_animations: null,
            m_TextComponent: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteAnimator#init", this ); }

                this.m_animations = new (System.Collections.Generic.Dictionary$2(System.Int32,System.Boolean)).$ctor4(16);
            }
        },
        methods: {
            /*TMPro.TMP_SpriteAnimator.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteAnimator#Awake", this ); }

                this.m_TextComponent = this.GetComponent(TMPro.TMP_Text);
            },
            /*TMPro.TMP_SpriteAnimator.Awake end.*/

            /*TMPro.TMP_SpriteAnimator.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteAnimator#OnEnable", this ); }

                //m_playAnimations = true;
            },
            /*TMPro.TMP_SpriteAnimator.OnEnable end.*/

            /*TMPro.TMP_SpriteAnimator.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteAnimator#OnDisable", this ); }

                //m_playAnimations = false;
            },
            /*TMPro.TMP_SpriteAnimator.OnDisable end.*/

            /*TMPro.TMP_SpriteAnimator.StopAllAnimations start.*/
            StopAllAnimations: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteAnimator#StopAllAnimations", this ); }

                this.StopAllCoroutines();
                this.m_animations.clear();
            },
            /*TMPro.TMP_SpriteAnimator.StopAllAnimations end.*/

            /*TMPro.TMP_SpriteAnimator.DoSpriteAnimation start.*/
            DoSpriteAnimation: function (currentCharacter, spriteAsset, start, end, framerate) {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteAnimator#DoSpriteAnimation", this ); }

                var isPlaying = { };

                // Need to add tracking of coroutines that have been lunched for this text object.
                if (!this.m_animations.tryGetValue(currentCharacter, isPlaying)) {
                    this.StartCoroutine$1(this.DoSpriteAnimationInternal(currentCharacter, spriteAsset, start, end, framerate));
                    this.m_animations.add(currentCharacter, true);
                }
            },
            /*TMPro.TMP_SpriteAnimator.DoSpriteAnimation end.*/

            /*TMPro.TMP_SpriteAnimator.DoSpriteAnimationInternal start.*/
            DoSpriteAnimationInternal: function (currentCharacter, spriteAsset, start, end, framerate) {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteAnimator#DoSpriteAnimationInternal", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    currentFrame,
                    charInfo,
                    $t,
                    materialIndex,
                    vertexIndex,
                    meshInfo,
                    $t1,
                    baseSpriteScale,
                    elapsedTime,
                    targetTime,
                    character,
                    $t2,
                    spriteCharacter,
                    vertices,
                    origin,
                    spriteScale,
                    bl,
                    tl,
                    tr,
                    br,
                    uvs0,
                    uv0,
                    uv1,
                    uv2,
                    uv3,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if (UnityEngine.MonoBehaviour.op_Equality(this.m_TextComponent, null)) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 2;
                                        continue;
                                }
                                case 1: {
                                    return false;
                                }
                                case 2: {
                                    // We yield otherwise this gets called before the sprite has rendered.
                                        $enumerator.current = null;
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    currentFrame = start;

                                        // Make sure end frame does not exceed the number of sprites in the sprite asset.
                                        if (end > spriteAsset.spriteCharacterTable.Count) {
                                            end = spriteAsset.spriteCharacterTable.Count - 1;
                                        }

                                        // Get a reference to the current character's info
                                        charInfo = ($t = this.m_TextComponent.textInfo.characterInfo)[currentCharacter].$clone();

                                        materialIndex = charInfo.materialReferenceIndex;
                                        vertexIndex = charInfo.vertexIndex;

                                        meshInfo = ($t1 = this.m_TextComponent.textInfo.meshInfo)[materialIndex].$clone();

                                        baseSpriteScale = spriteAsset.spriteCharacterTable.getItem(start).scale * spriteAsset.spriteCharacterTable.getItem(start).glyph.scale;

                                        elapsedTime = 0;
                                        targetTime = 1.0 / Math.abs(framerate);
                                    $step = 4;
                                    continue;
                                }
                                case 4: {
                                    if ( true ) {
                                            $step = 5;
                                            continue;
                                        } 
                                        $step = 11;
                                        continue;
                                }
                                case 5: {
                                    if (elapsedTime > targetTime) {
                                            $step = 6;
                                            continue;
                                        } 
                                        $step = 9;
                                        continue;
                                }
                                case 6: {
                                    elapsedTime = 0;

                                        // Return if sprite was truncated or replaced by the Ellipsis character.
                                        character = ($t2 = this.m_TextComponent.textInfo.characterInfo)[currentCharacter].character;
                                        if (character === 3 || character === 8230) {
                                            $step = 7;
                                            continue;
                                        } 
                                        $step = 8;
                                        continue;
                                }
                                case 7: {
                                    this.m_animations.remove(currentCharacter);
                                        return false;
                                    $step = 8;
                                    continue;
                                }
                                case 8: {
                                    // Get a reference to the current sprite
                                        spriteCharacter = spriteAsset.spriteCharacterTable.getItem(currentFrame);

                                        // Update the vertices for the new sprite
                                        vertices = meshInfo.vertices;

                                        origin = new pc.Vec2( charInfo.origin, charInfo.baseLine );

                                        spriteScale = charInfo.scale / baseSpriteScale * spriteCharacter.scale * spriteCharacter.glyph.scale;

                                        bl = new pc.Vec3( origin.x + spriteCharacter.glyph.metrics.horizontalBearingX * spriteScale, origin.y + (spriteCharacter.glyph.metrics.horizontalBearingY - spriteCharacter.glyph.metrics.height) * spriteScale, 0 );
                                        tl = new pc.Vec3( bl.x, origin.y + spriteCharacter.glyph.metrics.horizontalBearingY * spriteScale, 0 );
                                        tr = new pc.Vec3( origin.x + (spriteCharacter.glyph.metrics.horizontalBearingX + spriteCharacter.glyph.metrics.width) * spriteScale, tl.y, 0 );
                                        br = new pc.Vec3( tr.x, bl.y, 0 );

                                        vertices[vertexIndex + 0] = bl.$clone();
                                        vertices[vertexIndex + 1] = tl.$clone();
                                        vertices[vertexIndex + 2] = tr.$clone();
                                        vertices[vertexIndex + 3] = br.$clone();

                                        // Update the UV to point to the new sprite
                                        uvs0 = meshInfo.uvs0;

                                        uv0 = new pc.Vec2( spriteCharacter.glyph.glyphRect.x / spriteAsset.spriteSheet.width, spriteCharacter.glyph.glyphRect.y / spriteAsset.spriteSheet.height );
                                        uv1 = new pc.Vec2( uv0.x, (spriteCharacter.glyph.glyphRect.y + spriteCharacter.glyph.glyphRect.height) / spriteAsset.spriteSheet.height );
                                        uv2 = new pc.Vec2( (spriteCharacter.glyph.glyphRect.x + spriteCharacter.glyph.glyphRect.width) / spriteAsset.spriteSheet.width, uv1.y );
                                        uv3 = new pc.Vec2( uv2.x, uv0.y );

                                        uvs0[vertexIndex + 0] = uv0.$clone();
                                        uvs0[vertexIndex + 1] = uv1.$clone();
                                        uvs0[vertexIndex + 2] = uv2.$clone();
                                        uvs0[vertexIndex + 3] = uv3.$clone();

                                        // Update the modified vertex attributes
                                        meshInfo.mesh.vertices = vertices;
                                        meshInfo.mesh.uv = uvs0;
                                        this.m_TextComponent.UpdateGeometry$1(meshInfo.mesh, materialIndex);


                                        if (framerate > 0) {
                                            if (currentFrame < end) {
                                                currentFrame += 1;
                                            } else {
                                                currentFrame = start;
                                            }
                                        } else {
                                            if (currentFrame > start) {
                                                currentFrame -= 1;
                                            } else {
                                                currentFrame = end;
                                            }
                                        }
                                    $step = 9;
                                    continue;
                                }
                                case 9: {
                                    elapsedTime += UnityEngine.Time.deltaTime;

                                        $enumerator.current = null;
                                        $step = 10;
                                        return true;
                                }
                                case 10: {
                                    
                                        $step = 4;
                                        continue;
                                }
                                case 11: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*TMPro.TMP_SpriteAnimator.DoSpriteAnimationInternal end.*/


        }
    });
    /*TMPro.TMP_SpriteAnimator end.*/

    /*TMPro.TMP_SpriteGlyph start.*/
    /**
     * The visual representation of the sprite character using this glyph.
     *
     * @public
     * @class TMPro.TMP_SpriteGlyph
     * @augments UnityEngine.TextCore.Glyph
     */
    Bridge.define("TMPro.TMP_SpriteGlyph", {
        inherits: [UnityEngine.TextCore.Glyph],
        fields: {
            /**
             * An optional reference to the underlying sprite used to create this glyph.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_SpriteGlyph
             * @type UnityEngine.Sprite
             */
            sprite: null
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteGlyph#ctor", this ); }

                this.$initialize();
                UnityEngine.TextCore.Glyph.ctor.call(this);
            },
            /**
             * Constructor for new sprite glyph.
             *
             * @instance
             * @public
             * @this TMPro.TMP_SpriteGlyph
             * @memberof TMPro.TMP_SpriteGlyph
             * @param   {number}                               index         Index of the sprite glyph.
             * @param   {UnityEngine.TextCore.GlyphMetrics}    metrics       Metrics which define the position of the glyph in the context of text layout.
             * @param   {UnityEngine.TextCore.GlyphRect}       glyphRect     GlyphRect which defines the coordinates of the glyph in the atlas texture.
             * @param   {number}                               scale         Scale of the glyph.
             * @param   {number}                               atlasIndex    Index of the atlas texture that contains the glyph.
             * @return  {void}
             */
            $ctor1: function (index, metrics, glyphRect, scale, atlasIndex) {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteGlyph#$ctor1", this ); }

                this.$initialize();
                UnityEngine.TextCore.Glyph.ctor.call(this);
                this.index = index;
                this.metrics = metrics.$clone();
                this.glyphRect = glyphRect.$clone();
                this.scale = scale;
                this.atlasIndex = atlasIndex;
            },
            /**
             * Constructor for new sprite glyph.
             *
             * @instance
             * @public
             * @this TMPro.TMP_SpriteGlyph
             * @memberof TMPro.TMP_SpriteGlyph
             * @param   {number}                               index         &gt;Index of the sprite glyph.
             * @param   {UnityEngine.TextCore.GlyphMetrics}    metrics       Metrics which define the position of the glyph in the context of text layout.
             * @param   {UnityEngine.TextCore.GlyphRect}       glyphRect     GlyphRect which defines the coordinates of the glyph in the atlas texture.
             * @param   {number}                               scale         Scale of the glyph.
             * @param   {number}                               atlasIndex    Index of the atlas texture that contains the glyph.
             * @param   {UnityEngine.Sprite}                   sprite        A reference to the Unity Sprite representing this sprite glyph.
             * @return  {void}
             */
            $ctor2: function (index, metrics, glyphRect, scale, atlasIndex, sprite) {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteGlyph#$ctor2", this ); }

                this.$initialize();
                UnityEngine.TextCore.Glyph.ctor.call(this);
                this.index = index;
                this.metrics = metrics.$clone();
                this.glyphRect = glyphRect.$clone();
                this.scale = scale;
                this.atlasIndex = atlasIndex;
                this.sprite = sprite;
            }
        }
    });
    /*TMPro.TMP_SpriteGlyph end.*/

    /*TMPro.TMP_SpriteInfo start.*/
    Bridge.define("TMPro.TMP_SpriteInfo", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteInfo#getDefaultValue", this ); }
 return new TMPro.TMP_SpriteInfo(); }
            }
        },
        fields: {
            spriteIndex: 0,
            characterIndex: 0,
            vertexIndex: 0
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteInfo#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteInfo#getHashCode", this ); }

                var h = Bridge.addHash([5218538113, this.spriteIndex, this.characterIndex, this.vertexIndex]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteInfo#equals", this ); }

                if (!Bridge.is(o, TMPro.TMP_SpriteInfo)) {
                    return false;
                }
                return Bridge.equals(this.spriteIndex, o.spriteIndex) && Bridge.equals(this.characterIndex, o.characterIndex) && Bridge.equals(this.vertexIndex, o.vertexIndex);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteInfo#$clone", this ); }

                var s = to || new TMPro.TMP_SpriteInfo();
                s.spriteIndex = this.spriteIndex;
                s.characterIndex = this.characterIndex;
                s.vertexIndex = this.vertexIndex;
                return s;
            }
        }
    });
    /*TMPro.TMP_SpriteInfo end.*/

    /*TMPro.TMP_Style start.*/
    Bridge.define("TMPro.TMP_Style", {
        statics: {
            fields: {
                k_NormalStyle: null
            },
            props: {
                NormalStyle: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Style#NormalStyle#get", this ); }

                        if (TMPro.TMP_Style.k_NormalStyle == null) {
                            TMPro.TMP_Style.k_NormalStyle = new TMPro.TMP_Style("Normal", "", "");
                        }

                        return TMPro.TMP_Style.k_NormalStyle;
                    }
                }
            }
        },
        fields: {
            m_Name: null,
            m_HashCode: 0,
            m_OpeningDefinition: null,
            m_ClosingDefinition: null,
            m_OpeningTagArray: null,
            m_ClosingTagArray: null,
            m_OpeningTagUnicodeArray: null,
            m_ClosingTagUnicodeArray: null
        },
        props: {
            
            name: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Style#name#get", this ); }

                    return this.m_Name;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Style#name#set", this ); }

                    if (!Bridge.referenceEquals(value, this.m_Name)) {
                        this.m_Name = value;
                    }
                }
            },
            /**
             * The hash code corresponding to the name of this style.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_Style
             * @function hashCode
             * @type number
             */
            hashCode: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Style#hashCode#get", this ); }

                    return this.m_HashCode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Style#hashCode#set", this ); }

                    if (value !== this.m_HashCode) {
                        this.m_HashCode = value;
                    }
                }
            },
            
            styleOpeningDefinition: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Style#styleOpeningDefinition#get", this ); }

                    return this.m_OpeningDefinition;
                }
            },
            
            styleClosingDefinition: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Style#styleClosingDefinition#get", this ); }

                    return this.m_ClosingDefinition;
                }
            },
            styleOpeningTagArray: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Style#styleOpeningTagArray#get", this ); }

                    return this.m_OpeningTagArray;
                }
            },
            styleClosingTagArray: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Style#styleClosingTagArray#get", this ); }

                    return this.m_ClosingTagArray;
                }
            }
        },
        ctors: {
            /**
             * Constructor
             *
             * @instance
             * @this TMPro.TMP_Style
             * @memberof TMPro.TMP_Style
             * @param   {string}    styleName                 Name of the style.
             * @param   {string}    styleOpeningDefinition    Style opening definition.
             * @param   {string}    styleClosingDefinition    Style closing definition.
             * @return  {void}
             */
            ctor: function (styleName, styleOpeningDefinition, styleClosingDefinition) {
if ( TRACE ) { TRACE( "TMPro.TMP_Style#ctor", this ); }

                this.$initialize();
                this.m_Name = styleName;
                this.m_HashCode = TMPro.TMP_TextParsingUtilities.GetHashCode(styleName);
                this.m_OpeningDefinition = styleOpeningDefinition;
                this.m_ClosingDefinition = styleClosingDefinition;

                this.RefreshStyle();
            }
        },
        methods: {
            /*TMPro.TMP_Style.RefreshStyle start.*/
            
            RefreshStyle: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Style#RefreshStyle", this ); }

                this.m_HashCode = TMPro.TMP_TextParsingUtilities.GetHashCode(this.m_Name);

                var s1 = this.m_OpeningDefinition.length;
                this.m_OpeningTagArray = System.Array.init(s1, 0, System.Int32);
                this.m_OpeningTagUnicodeArray = System.Array.init(s1, 0, System.UInt32);

                for (var i = 0; i < s1; i++) {
                    this.m_OpeningTagArray[i] = this.m_OpeningDefinition.charCodeAt(i);
                    this.m_OpeningTagUnicodeArray[i] = this.m_OpeningDefinition.charCodeAt(i);
                }

                var s2 = this.m_ClosingDefinition.length;
                this.m_ClosingTagArray = System.Array.init(s2, 0, System.Int32);
                this.m_ClosingTagUnicodeArray = System.Array.init(s2, 0, System.UInt32);

                for (var i1 = 0; i1 < s2; i1++) {
                    this.m_ClosingTagArray[i1] = this.m_ClosingDefinition.charCodeAt(i1);
                    this.m_ClosingTagUnicodeArray[i1] = this.m_ClosingDefinition.charCodeAt(i1);
                }
            },
            /*TMPro.TMP_Style.RefreshStyle end.*/


        }
    });
    /*TMPro.TMP_Style end.*/

    /*TMPro.TMP_StyleSheet start.*/
    Bridge.define("TMPro.TMP_StyleSheet", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            m_StyleList: null,
            m_StyleLookupDictionary: null
        },
        props: {
            /**
             * @instance
             * @readonly
             * @memberof TMPro.TMP_StyleSheet
             * @function styles
             * @type System.Collections.Generic.List$1
             */
            styles: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_StyleSheet#styles#get", this ); }

                    return this.m_StyleList;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_StyleSheet#init", this ); }

                this.m_StyleList = new (System.Collections.Generic.List$1(TMPro.TMP_Style)).$ctor2(1);
            }
        },
        methods: {
            /*TMPro.TMP_StyleSheet.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_StyleSheet#Reset", this ); }

                this.LoadStyleDictionaryInternal();
            },
            /*TMPro.TMP_StyleSheet.Reset end.*/

            /*TMPro.TMP_StyleSheet.GetStyle start.*/
            /**
             * Get the Style for the given hash code value.
             *
             * @instance
             * @public
             * @this TMPro.TMP_StyleSheet
             * @memberof TMPro.TMP_StyleSheet
             * @param   {number}             hashCode    Hash code of the style.
             * @return  {TMPro.TMP_Style}                The style matching the hash code.
             */
            GetStyle: function (hashCode) {
if ( TRACE ) { TRACE( "TMPro.TMP_StyleSheet#GetStyle", this ); }

                if (this.m_StyleLookupDictionary == null) {
                    this.LoadStyleDictionaryInternal();
                }

                var style = { };

                if (this.m_StyleLookupDictionary.tryGetValue(hashCode, style)) {
                    return style.v;
                }

                return null;
            },
            /*TMPro.TMP_StyleSheet.GetStyle end.*/

            /*TMPro.TMP_StyleSheet.GetStyle$1 start.*/
            /**
             * Get the Style for the given name.
             *
             * @instance
             * @public
             * @this TMPro.TMP_StyleSheet
             * @memberof TMPro.TMP_StyleSheet
             * @param   {string}             name    The name of the style.
             * @return  {TMPro.TMP_Style}            The style if found.
             */
            GetStyle$1: function (name) {
if ( TRACE ) { TRACE( "TMPro.TMP_StyleSheet#GetStyle$1", this ); }

                if (this.m_StyleLookupDictionary == null) {
                    this.LoadStyleDictionaryInternal();
                }

                var hashCode = TMPro.TMP_TextParsingUtilities.GetHashCode(name);
                var style = { };

                if (this.m_StyleLookupDictionary.tryGetValue(hashCode, style)) {
                    return style.v;
                }

                return null;
            },
            /*TMPro.TMP_StyleSheet.GetStyle$1 end.*/

            /*TMPro.TMP_StyleSheet.RefreshStyles start.*/
            /**
             * Function to refresh the Style Dictionary.
             *
             * @instance
             * @public
             * @this TMPro.TMP_StyleSheet
             * @memberof TMPro.TMP_StyleSheet
             * @return  {void}
             */
            RefreshStyles: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_StyleSheet#RefreshStyles", this ); }

                this.LoadStyleDictionaryInternal();
            },
            /*TMPro.TMP_StyleSheet.RefreshStyles end.*/

            /*TMPro.TMP_StyleSheet.LoadStyleDictionaryInternal start.*/
            /**
             * @instance
             * @private
             * @this TMPro.TMP_StyleSheet
             * @memberof TMPro.TMP_StyleSheet
             * @return  {void}
             */
            LoadStyleDictionaryInternal: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_StyleSheet#LoadStyleDictionaryInternal", this ); }

                if (this.m_StyleLookupDictionary == null) {
                    this.m_StyleLookupDictionary = new (System.Collections.Generic.Dictionary$2(System.Int32,TMPro.TMP_Style)).ctor();
                } else {
                    this.m_StyleLookupDictionary.clear();
                }

                // Read Styles from style list and store them into dictionary for faster access.
                for (var i = 0; i < this.m_StyleList.Count; i++) {
                    this.m_StyleList.getItem(i).RefreshStyle();

                    if (!this.m_StyleLookupDictionary.containsKey(this.m_StyleList.getItem(i).hashCode)) {
                        this.m_StyleLookupDictionary.add(this.m_StyleList.getItem(i).hashCode, this.m_StyleList.getItem(i));
                    }
                }

                // Add Normal Style if it does not already exists
                var normalStyleHashCode = TMPro.TMP_TextParsingUtilities.GetHashCode("Normal");
                if (!this.m_StyleLookupDictionary.containsKey(normalStyleHashCode)) {
                    var style = new TMPro.TMP_Style("Normal", "", "");
                    this.m_StyleList.add(style);
                    this.m_StyleLookupDictionary.add(normalStyleHashCode, style);
                }

            },
            /*TMPro.TMP_StyleSheet.LoadStyleDictionaryInternal end.*/


        },
        overloads: {
            "GetStyle(string)": "GetStyle$1"
        }
    });
    /*TMPro.TMP_StyleSheet end.*/

    /*TMPro.TMP_SubMesh start.*/
    /**
     * @public
     * @class TMPro.TMP_SubMesh
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("TMPro.TMP_SubMesh", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            methods: {
                /*TMPro.TMP_SubMesh.AddSubTextObject:static start.*/
                AddSubTextObject: function (textComponent, materialReference) {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#AddSubTextObject", this ); }

                    var go = new UnityEngine.GameObject.$ctor3("TMP SubMesh [" + (materialReference.material.name || "") + "]", TMPro.TMP_SubMesh);
                    go.hideFlags = UnityEngine.HideFlags.DontSave;

                    var subMesh = go.GetComponent(TMPro.TMP_SubMesh);

                    go.transform.SetParent(textComponent.transform$2, false);
                    go.transform.localPosition = pc.Vec3.ZERO.clone();
                    go.transform.localRotation = pc.Quat.IDENTITY.clone();
                    go.transform.localScale = new pc.Vec3( 1, 1, 1 );
                    go.layer = textComponent.gameObject.layer;

                    subMesh.m_TextComponent = textComponent;
                    subMesh.m_fontAsset = materialReference.fontAsset;
                    subMesh.m_spriteAsset = materialReference.spriteAsset;
                    subMesh.m_isDefaultMaterial = materialReference.isDefaultMaterial;
                    subMesh.SetSharedMaterial(materialReference.material);

                    subMesh.renderer.sortingLayerID = textComponent.renderer.sortingLayerID;
                    subMesh.renderer.sortingOrder = textComponent.renderer.sortingOrder;

                    return subMesh;
                },
                /*TMPro.TMP_SubMesh.AddSubTextObject:static end.*/


            }
        },
        fields: {
            m_fontAsset: null,
            m_spriteAsset: null,
            m_material: null,
            m_sharedMaterial: null,
            m_fallbackMaterial: null,
            m_fallbackSourceMaterial: null,
            m_isDefaultMaterial: false,
            m_padding: 0,
            m_renderer: null,
            m_meshFilter: null,
            m_mesh: null,
            m_TextComponent: null,
            m_isRegisteredForEvents: false
        },
        props: {
            /**
             * The TMP Font Asset assigned to this sub text object.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_SubMesh
             * @function fontAsset
             * @type TMPro.TMP_FontAsset
             */
            fontAsset: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#fontAsset#get", this ); }

                    return this.m_fontAsset;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#fontAsset#set", this ); }

                    this.m_fontAsset = value;
                }
            },
            /**
             * The TMP Sprite Asset assigned to this sub text object.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_SubMesh
             * @function spriteAsset
             * @type TMPro.TMP_SpriteAsset
             */
            spriteAsset: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#spriteAsset#get", this ); }

                    return this.m_spriteAsset;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#spriteAsset#set", this ); }

                    this.m_spriteAsset = value;
                }
            },
            /**
             * The material to be assigned to this object. Returns an instance of the material.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_SubMesh
             * @function material
             * @type UnityEngine.Material
             */
            material: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#material#get", this ); }

                    return this.GetMaterial(this.m_sharedMaterial);
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#material#set", this ); }

                    if (this.m_sharedMaterial.GetInstanceID() === value.GetInstanceID()) {
                        return;
                    }

                    this.m_sharedMaterial = (this.m_material = value);
                    this.m_padding = this.GetPaddingForMaterial();
                    this.SetVerticesDirty();
                    this.SetMaterialDirty();
                }
            },
            /**
             * The material to be assigned to this text object.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_SubMesh
             * @function sharedMaterial
             * @type UnityEngine.Material
             */
            sharedMaterial: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#sharedMaterial#get", this ); }

                    return this.m_sharedMaterial;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#sharedMaterial#set", this ); }

                    this.SetSharedMaterial(value);
                }
            },
            /**
             * The fallback material created from the properties of the fallback source material.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_SubMesh
             * @function fallbackMaterial
             * @type UnityEngine.Material
             */
            fallbackMaterial: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#fallbackMaterial#get", this ); }

                    return this.m_fallbackMaterial;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#fallbackMaterial#set", this ); }

                    if (Bridge.referenceEquals(this.m_fallbackMaterial, value)) {
                        return;
                    }

                    if (this.m_fallbackMaterial != null && !Bridge.referenceEquals(this.m_fallbackMaterial, value)) {
                        TMPro.TMP_MaterialManager.ReleaseFallbackMaterial(this.m_fallbackMaterial);
                    }

                    this.m_fallbackMaterial = value;
                    TMPro.TMP_MaterialManager.AddFallbackMaterialReference(this.m_fallbackMaterial);
                    this.SetSharedMaterial(this.m_fallbackMaterial);
                }
            },
            /**
             * The source material used by the fallback font
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_SubMesh
             * @function fallbackSourceMaterial
             * @type UnityEngine.Material
             */
            fallbackSourceMaterial: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#fallbackSourceMaterial#get", this ); }

                    return this.m_fallbackSourceMaterial;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#fallbackSourceMaterial#set", this ); }

                    this.m_fallbackSourceMaterial = value;
                }
            },
            /**
             * Is the text object using the default font asset material.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_SubMesh
             * @function isDefaultMaterial
             * @type boolean
             */
            isDefaultMaterial: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#isDefaultMaterial#get", this ); }

                    return this.m_isDefaultMaterial;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#isDefaultMaterial#set", this ); }

                    this.m_isDefaultMaterial = value;
                }
            },
            /**
             * Padding value resulting for the property settings on the material.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_SubMesh
             * @function padding
             * @type number
             */
            padding: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#padding#get", this ); }

                    return this.m_padding;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#padding#set", this ); }

                    this.m_padding = value;
                }
            },
            /**
             * The Mesh Renderer of this text sub object.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_SubMesh
             * @function renderer
             * @type UnityEngine.Renderer
             */
            renderer: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#renderer#get", this ); }

                    if (UnityEngine.Component.op_Equality(this.m_renderer, null)) {
                        this.m_renderer = this.GetComponent(UnityEngine.Renderer);
                    }

                    return this.m_renderer;
                }
            },
            /**
             * The MeshFilter of this text sub object.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_SubMesh
             * @function meshFilter
             * @type UnityEngine.MeshFilter
             */
            meshFilter: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#meshFilter#get", this ); }

                    if (UnityEngine.Component.op_Equality(this.m_meshFilter, null)) {
                        this.m_meshFilter = this.GetComponent(UnityEngine.MeshFilter);

                        if (UnityEngine.Component.op_Equality(this.m_meshFilter, null)) {
                            this.m_meshFilter = this.gameObject.AddComponent(UnityEngine.MeshFilter);
                            this.m_meshFilter.hideFlags = 63;
                        }
                    }

                    return this.m_meshFilter;
                }
            },
            /**
             * The Mesh of this text sub object.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_SubMesh
             * @function mesh
             * @type UnityEngine.Mesh
             */
            mesh: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#mesh#get", this ); }

                    if (this.m_mesh == null) {
                        this.m_mesh = new UnityEngine.Mesh.ctor();
                        this.m_mesh.hideFlags = UnityEngine.HideFlags.HideAndDontSave;
                    }

                    return this.m_mesh;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#mesh#set", this ); }

                    this.m_mesh = value;
                }
            },
            /**
             * 
             * Reference to the parent Text Component.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_SubMesh
             * @function textComponent
             * @type TMPro.TMP_Text
             */
            textComponent: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#textComponent#get", this ); }

                    if (UnityEngine.MonoBehaviour.op_Equality(this.m_TextComponent, null)) {
                        this.m_TextComponent = this.GetComponentInParent(TMPro.TextMeshPro);
                    }

                    return this.m_TextComponent;
                }
            }
        },
        methods: {
            /*TMPro.TMP_SubMesh.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#OnEnable", this ); }

                //Debug.Log("***** OnEnable() called on object ID " + GetInstanceID() + "]. Parent Text Object ID [" + (textComponent == null ? "" : textComponent.GetInstanceID().ToString()) + "] *****");

                // Register Callbacks for various events.
                if (!this.m_isRegisteredForEvents) {

                    this.m_isRegisteredForEvents = true;
                }

                // Update HideFlags on previously created sub text objects.
                if (this.hideFlags !== UnityEngine.HideFlags.DontSave) {
                    this.hideFlags = UnityEngine.HideFlags.DontSave;
                }

                // Make the geometry visible when the object is enabled.
                this.meshFilter.sharedMesh = this.mesh;

                // Update _ClipRect values
                if (this.m_sharedMaterial != null) {
                    this.m_sharedMaterial.SetVector(TMPro.ShaderUtilities.ID_ClipRect, new pc.Vec4( -32767, -32767, 32767, 32767 ));
                }
            },
            /*TMPro.TMP_SubMesh.OnEnable end.*/

            /*TMPro.TMP_SubMesh.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#OnDisable", this ); }

                //Debug.Log("***** OnDisable() called on Sub Object ID [" + GetInstanceID() + "]. Parent Text Object ID [" + textComponent.GetInstanceID() + "] *****");

                // Hide the geometry when the object is disabled.
                this.m_meshFilter.sharedMesh = null;

                if (this.m_fallbackMaterial != null) {
                    TMPro.TMP_MaterialManager.ReleaseFallbackMaterial(this.m_fallbackMaterial);
                    this.m_fallbackMaterial = null;
                }
            },
            /*TMPro.TMP_SubMesh.OnDisable end.*/

            /*TMPro.TMP_SubMesh.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#OnDestroy", this ); }

                //Debug.Log("***** OnDestroy() called on Sub Object ID [" + GetInstanceID() + "]. Parent Text Object ID [" + textComponent.GetInstanceID() + "] *****");

                // Destroy Mesh
                if (this.m_mesh != null) {
                    UnityEngine.Object.DestroyImmediate(this.m_mesh);
                }

                if (this.m_fallbackMaterial != null) {
                    TMPro.TMP_MaterialManager.ReleaseFallbackMaterial(this.m_fallbackMaterial);
                    this.m_fallbackMaterial = null;
                }

                this.m_isRegisteredForEvents = false;

                // Notify parent text object
                if (UnityEngine.MonoBehaviour.op_Inequality(this.m_TextComponent, null)) {
                    this.m_TextComponent.havePropertiesChanged = true;
                    this.m_TextComponent.SetAllDirty();
                }
            },
            /*TMPro.TMP_SubMesh.OnDestroy end.*/

            /*TMPro.TMP_SubMesh.DestroySelf start.*/
            DestroySelf: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#DestroySelf", this ); }

                this.Destroy(this.gameObject, 1.0);
            },
            /*TMPro.TMP_SubMesh.DestroySelf end.*/

            /*TMPro.TMP_SubMesh.GetMaterial start.*/
            GetMaterial: function (mat) {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#GetMaterial", this ); }

                // Check in case Object is disabled. If so, we don't have a valid reference to the Renderer.
                // This can occur when the Duplicate Material Context menu is used on an inactive object.
                if (UnityEngine.Component.op_Equality(this.m_renderer, null)) {
                    this.m_renderer = this.GetComponent(UnityEngine.Renderer);
                }

                // Create Instance Material only if the new material is not the same instance previously used.
                if (this.m_material == null || this.m_material.GetInstanceID() !== mat.GetInstanceID()) {
                    this.m_material = this.CreateMaterialInstance(mat);
                }

                this.m_sharedMaterial = this.m_material;

                // Compute and Set new padding values for this new material.
                this.m_padding = this.GetPaddingForMaterial();

                this.SetVerticesDirty();
                this.SetMaterialDirty();

                return this.m_sharedMaterial;
            },
            /*TMPro.TMP_SubMesh.GetMaterial end.*/

            /*TMPro.TMP_SubMesh.CreateMaterialInstance start.*/
            /**
             * Method used to create an instance of the material
             *
             * @instance
             * @private
             * @this TMPro.TMP_SubMesh
             * @memberof TMPro.TMP_SubMesh
             * @param   {UnityEngine.Material}    source
             * @return  {UnityEngine.Material}
             */
            CreateMaterialInstance: function (source) {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#CreateMaterialInstance", this ); }

                var mat = new UnityEngine.Material.$ctor1(source);
                mat.shaderKeywords = source.shaderKeywords;
                mat.name = (mat.name || "") + " (Instance)";

                return mat;
            },
            /*TMPro.TMP_SubMesh.CreateMaterialInstance end.*/

            /*TMPro.TMP_SubMesh.GetSharedMaterial start.*/
            /**
             * Method returning the shared material assigned to the text object.
             *
             * @instance
             * @private
             * @this TMPro.TMP_SubMesh
             * @memberof TMPro.TMP_SubMesh
             * @return  {UnityEngine.Material}
             */
            GetSharedMaterial: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#GetSharedMaterial", this ); }

                if (UnityEngine.Component.op_Equality(this.m_renderer, null)) {
                    this.m_renderer = this.GetComponent(UnityEngine.Renderer);
                }

                return this.m_renderer.sharedMaterial;
            },
            /*TMPro.TMP_SubMesh.GetSharedMaterial end.*/

            /*TMPro.TMP_SubMesh.SetSharedMaterial start.*/
            /**
             * Method to set the shared material.
             *
             * @instance
             * @private
             * @this TMPro.TMP_SubMesh
             * @memberof TMPro.TMP_SubMesh
             * @param   {UnityEngine.Material}    mat
             * @return  {void}
             */
            SetSharedMaterial: function (mat) {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#SetSharedMaterial", this ); }

                //Debug.Log("*** SetSharedMaterial() *** FRAME (" + Time.frameCount + ")");

                // Assign new material.
                this.m_sharedMaterial = mat;

                // Compute and Set new padding values for this new material.
                this.m_padding = this.GetPaddingForMaterial();

                this.SetMaterialDirty();

            },
            /*TMPro.TMP_SubMesh.SetSharedMaterial end.*/

            /*TMPro.TMP_SubMesh.GetPaddingForMaterial start.*/
            /**
             * Function called when the padding value for the material needs to be re-calculated.
             *
             * @instance
             * @public
             * @this TMPro.TMP_SubMesh
             * @memberof TMPro.TMP_SubMesh
             * @return  {number}
             */
            GetPaddingForMaterial: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#GetPaddingForMaterial", this ); }

                var padding = TMPro.ShaderUtilities.GetPadding(this.m_sharedMaterial, this.m_TextComponent.extraPadding, this.m_TextComponent.isUsingBold);

                return padding;
            },
            /*TMPro.TMP_SubMesh.GetPaddingForMaterial end.*/

            /*TMPro.TMP_SubMesh.UpdateMeshPadding start.*/
            /**
             * Function to update the padding values of the object.
             *
             * @instance
             * @public
             * @this TMPro.TMP_SubMesh
             * @memberof TMPro.TMP_SubMesh
             * @param   {boolean}    isExtraPadding    
             * @param   {boolean}    isUsingBold
             * @return  {void}
             */
            UpdateMeshPadding: function (isExtraPadding, isUsingBold) {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#UpdateMeshPadding", this ); }

                this.m_padding = TMPro.ShaderUtilities.GetPadding(this.m_sharedMaterial, isExtraPadding, isUsingBold);
            },
            /*TMPro.TMP_SubMesh.UpdateMeshPadding end.*/

            /*TMPro.TMP_SubMesh.SetVerticesDirty start.*/
            /**
             * @instance
             * @public
             * @this TMPro.TMP_SubMesh
             * @memberof TMPro.TMP_SubMesh
             * @return  {void}
             */
            SetVerticesDirty: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#SetVerticesDirty", this ); }

                if (!this.enabled) {
                    return;
                }

                // This is called on the parent TextMeshPro component.
                if (UnityEngine.MonoBehaviour.op_Inequality(this.m_TextComponent, null)) {
                    this.m_TextComponent.havePropertiesChanged = true;
                    this.m_TextComponent.SetVerticesDirty();
                }
            },
            /*TMPro.TMP_SubMesh.SetVerticesDirty end.*/

            /*TMPro.TMP_SubMesh.SetMaterialDirty start.*/
            /**
             * @instance
             * @public
             * @this TMPro.TMP_SubMesh
             * @memberof TMPro.TMP_SubMesh
             * @return  {void}
             */
            SetMaterialDirty: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#SetMaterialDirty", this ); }

                //if (!this.enabled)
                //    return;

                this.UpdateMaterial();

                //m_materialDirty = true;
                //TMP_UpdateRegistry.RegisterCanvasElementForGraphicRebuild((ICanvasElement)this);
            },
            /*TMPro.TMP_SubMesh.SetMaterialDirty end.*/

            /*TMPro.TMP_SubMesh.UpdateMaterial start.*/
            /**
             * @instance
             * @protected
             * @this TMPro.TMP_SubMesh
             * @memberof TMPro.TMP_SubMesh
             * @return  {void}
             */
            UpdateMaterial: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMesh#UpdateMaterial", this ); }

                //Debug.Log("*** STO - UpdateMaterial() *** FRAME (" + Time.frameCount + ")");

                if (UnityEngine.Component.op_Equality(this.renderer, null) || this.m_sharedMaterial == null) {
                    return;
                }

                this.m_renderer.sharedMaterial = this.m_sharedMaterial;

                // Special handling to keep the Culling of the material in sync with parent text object
                if (this.m_sharedMaterial.HasProperty$1(TMPro.ShaderUtilities.ShaderTag_CullMode)) {
                    var cullMode = this.textComponent.fontSharedMaterial.GetFloat$1(TMPro.ShaderUtilities.ShaderTag_CullMode);
                    this.m_sharedMaterial.SetFloat$1(TMPro.ShaderUtilities.ShaderTag_CullMode, cullMode);
                }

            },
            /*TMPro.TMP_SubMesh.UpdateMaterial end.*/


        }
    });
    /*TMPro.TMP_SubMesh end.*/

    /*TMPro.TMP_SubMeshUI start.*/
    Bridge.define("TMPro.TMP_SubMeshUI", {
        inherits: [UnityEngine.UI.MaskableGraphic],
        statics: {
            methods: {
                /*TMPro.TMP_SubMeshUI.AddSubTextObject:static start.*/
                /**
                 * Function to add a new sub text object.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_SubMeshUI
                 * @memberof TMPro.TMP_SubMeshUI
                 * @param   {TMPro.TextMeshProUGUI}      textComponent        
                 * @param   {TMPro.MaterialReference}    materialReference
                 * @return  {TMPro.TMP_SubMeshUI}
                 */
                AddSubTextObject: function (textComponent, materialReference) {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#AddSubTextObject", this ); }

                    var go = new UnityEngine.GameObject.$ctor3("TMP UI SubObject [" + (materialReference.material.name || "") + "]", UnityEngine.RectTransform);
                    go.hideFlags = UnityEngine.HideFlags.DontSave;

                    go.transform.SetParent(textComponent.transform$1, false);
                    go.transform.SetAsFirstSibling();
                    go.layer = textComponent.gameObject.layer;

                    var rectTransform = go.GetComponent(UnityEngine.RectTransform);
                    rectTransform.anchorMin = pc.Vec2.ZERO.clone();
                    rectTransform.anchorMax = pc.Vec2.ONE.clone();
                    rectTransform.sizeDelta = pc.Vec2.ZERO.clone();
                    rectTransform.pivot = textComponent.rectTransform$1.pivot.$clone();

                    var layoutElement = go.AddComponent(UnityEngine.UI.LayoutElement);
                    layoutElement.ignoreLayout = true;

                    var subMesh = go.AddComponent(TMPro.TMP_SubMeshUI);

                    //subMesh.canvasRenderer = subMesh.canvasRenderer;
                    subMesh.m_TextComponent = textComponent;

                    subMesh.m_materialReferenceIndex = materialReference.index;
                    subMesh.m_fontAsset = materialReference.fontAsset;
                    subMesh.m_spriteAsset = materialReference.spriteAsset;
                    subMesh.m_isDefaultMaterial = materialReference.isDefaultMaterial;
                    subMesh.SetSharedMaterial(materialReference.material);

                    return subMesh;
                },
                /*TMPro.TMP_SubMeshUI.AddSubTextObject:static end.*/


            }
        },
        fields: {
            m_fontAsset: null,
            m_spriteAsset: null,
            m_material: null,
            m_sharedMaterial: null,
            m_fallbackMaterial: null,
            m_fallbackSourceMaterial: null,
            m_isDefaultMaterial: false,
            m_padding: 0,
            m_mesh: null,
            m_TextComponent: null,
            m_isRegisteredForEvents: false,
            m_materialDirty: false,
            m_materialReferenceIndex: 0,
            m_RootCanvasTransform: null
        },
        props: {
            /**
             * The TMP Font Asset assigned to this sub text object.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_SubMeshUI
             * @function fontAsset
             * @type TMPro.TMP_FontAsset
             */
            fontAsset: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#fontAsset#get", this ); }

                    return this.m_fontAsset;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#fontAsset#set", this ); }

                    this.m_fontAsset = value;
                }
            },
            /**
             * The TMP Sprite Asset assigned to this sub text object.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_SubMeshUI
             * @function spriteAsset
             * @type TMPro.TMP_SpriteAsset
             */
            spriteAsset: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#spriteAsset#get", this ); }

                    return this.m_spriteAsset;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#spriteAsset#set", this ); }

                    this.m_spriteAsset = value;
                }
            },
            /**
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof TMPro.TMP_SubMeshUI
             * @function mainTexture
             * @type UnityEngine.Texture
             */
            mainTexture: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#mainTexture#get", this ); }

                    if (this.sharedMaterial != null) {
                        return this.sharedMaterial.GetTexture(TMPro.ShaderUtilities.ID_MainTex);
                    }

                    return null;
                }
            },
            /**
             * The material to be assigned to this object. Returns an instance of the material.
             *
             * @instance
             * @public
             * @override
             * @memberof TMPro.TMP_SubMeshUI
             * @function material
             * @type UnityEngine.Material
             */
            material: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#material#get", this ); }

                    return this.GetMaterial$1(this.m_sharedMaterial);
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#material#set", this ); }

                    if (this.m_sharedMaterial != null && this.m_sharedMaterial.GetInstanceID() === value.GetInstanceID()) {
                        return;
                    }

                    this.m_sharedMaterial = (this.m_material = value);
                    this.m_padding = this.GetPaddingForMaterial();
                    this.SetVerticesDirty();
                    this.SetMaterialDirty();
                }
            },
            /**
             * The material to be assigned to this text object.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_SubMeshUI
             * @function sharedMaterial
             * @type UnityEngine.Material
             */
            sharedMaterial: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#sharedMaterial#get", this ); }

                    return this.m_sharedMaterial;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#sharedMaterial#set", this ); }

                    this.SetSharedMaterial(value);
                }
            },
            /**
             * @instance
             * @public
             * @memberof TMPro.TMP_SubMeshUI
             * @function fallbackMaterial
             * @type UnityEngine.Material
             */
            fallbackMaterial: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#fallbackMaterial#get", this ); }

                    return this.m_fallbackMaterial;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#fallbackMaterial#set", this ); }

                    if (Bridge.referenceEquals(this.m_fallbackMaterial, value)) {
                        return;
                    }

                    if (this.m_fallbackMaterial != null && !Bridge.referenceEquals(this.m_fallbackMaterial, value)) {
                        TMPro.TMP_MaterialManager.ReleaseFallbackMaterial(this.m_fallbackMaterial);
                    }

                    this.m_fallbackMaterial = value;
                    TMPro.TMP_MaterialManager.AddFallbackMaterialReference(this.m_fallbackMaterial);
                    this.SetSharedMaterial(this.m_fallbackMaterial);
                }
            },
            /**
             * The source material used by the fallback font
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_SubMeshUI
             * @function fallbackSourceMaterial
             * @type UnityEngine.Material
             */
            fallbackSourceMaterial: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#fallbackSourceMaterial#get", this ); }

                    return this.m_fallbackSourceMaterial;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#fallbackSourceMaterial#set", this ); }

                    this.m_fallbackSourceMaterial = value;
                }
            },
            /**
             * Get the material that will be used for rendering.
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof TMPro.TMP_SubMeshUI
             * @function materialForRendering
             * @type UnityEngine.Material
             */
            materialForRendering: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#materialForRendering#get", this ); }

                    return TMPro.TMP_MaterialManager.GetMaterialForRendering(this, this.m_sharedMaterial);
                }
            },
            /**
             * Is the text object using the default font asset material.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_SubMeshUI
             * @function isDefaultMaterial
             * @type boolean
             */
            isDefaultMaterial: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#isDefaultMaterial#get", this ); }

                    return this.m_isDefaultMaterial;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#isDefaultMaterial#set", this ); }

                    this.m_isDefaultMaterial = value;
                }
            },
            /**
             * Padding value resulting for the property settings on the material.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_SubMeshUI
             * @function padding
             * @type number
             */
            padding: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#padding#get", this ); }

                    return this.m_padding;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#padding#set", this ); }

                    this.m_padding = value;
                }
            },
            /**
             * The Mesh of this text sub object.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_SubMeshUI
             * @function mesh
             * @type UnityEngine.Mesh
             */
            mesh: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#mesh#get", this ); }

                    if (this.m_mesh == null) {
                        this.m_mesh = new UnityEngine.Mesh.ctor();
                        this.m_mesh.hideFlags = UnityEngine.HideFlags.HideAndDontSave;
                    }

                    return this.m_mesh;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#mesh#set", this ); }

                    this.m_mesh = value;
                }
            },
            /**
             * Reference to the parent Text Component.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_SubMeshUI
             * @function textComponent
             * @type TMPro.TMP_Text
             */
            textComponent: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#textComponent#get", this ); }

                    if (UnityEngine.MonoBehaviour.op_Equality(this.m_TextComponent, null)) {
                        this.m_TextComponent = this.GetComponentInParent(TMPro.TextMeshProUGUI);
                    }

                    return this.m_TextComponent;
                }
            }
        },
        alias: [
            "GetModifiedMaterial", "UnityEngine$UI$IMaterialModifier$GetModifiedMaterial",
            "Cull", "UnityEngine$UI$IClippable$Cull",
            "Rebuild", "UnityEngine$UI$ICanvasElement$Rebuild",
            "RecalculateClipping", "UnityEngine$UI$IClippable$RecalculateClipping"
        ],
        methods: {
            /*TMPro.TMP_SubMeshUI.OnEnable start.*/
            /**
             * @instance
             * @protected
             * @override
             * @this TMPro.TMP_SubMeshUI
             * @memberof TMPro.TMP_SubMeshUI
             * @return  {void}
             */
            OnEnable: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#OnEnable", this ); }

                //Debug.Log("*** SubObject OnEnable() ***");

                // Register Callbacks for various events.
                if (!this.m_isRegisteredForEvents) {

                    this.m_isRegisteredForEvents = true;
                }

                // Update HideFlags on previously created sub text objects.
                if (this.hideFlags !== UnityEngine.HideFlags.DontSave) {
                    this.hideFlags = UnityEngine.HideFlags.DontSave;
                }

                this.m_ShouldRecalculateStencil = true;
                this.RecalculateClipping();
                this.RecalculateMasking();

                //SetAllDirty();
            },
            /*TMPro.TMP_SubMeshUI.OnEnable end.*/

            /*TMPro.TMP_SubMeshUI.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#OnDisable", this ); }

                //Debug.Log("*** SubObject OnDisable() ***");
                UnityEngine.UI.MaskableGraphic.prototype.OnDisable.call(this);

                // if (m_MaskMaterial != null)
                // {
                //     TMP_MaterialManager.ReleaseStencilMaterial(m_MaskMaterial);
                //     m_MaskMaterial = null;
                // }

                if (this.m_fallbackMaterial != null) {
                    TMPro.TMP_MaterialManager.ReleaseFallbackMaterial(this.m_fallbackMaterial);
                    this.m_fallbackMaterial = null;
                }
            },
            /*TMPro.TMP_SubMeshUI.OnDisable end.*/

            /*TMPro.TMP_SubMeshUI.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#OnDestroy", this ); }

                //Debug.Log("*** OnDestroy() ***");

                // Destroy Mesh
                if (this.m_mesh != null) {
                    UnityEngine.Object.DestroyImmediate(this.m_mesh);
                }

                if (this.m_MaskMaterial != null) {
                    TMPro.TMP_MaterialManager.ReleaseStencilMaterial(this.m_MaskMaterial);
                }

                if (this.m_fallbackMaterial != null) {
                    TMPro.TMP_MaterialManager.ReleaseFallbackMaterial(this.m_fallbackMaterial);
                    this.m_fallbackMaterial = null;
                }


                this.m_isRegisteredForEvents = false;

                this.RecalculateClipping();

                // Notify parent text object
                if (UnityEngine.MonoBehaviour.op_Inequality(this.m_TextComponent, null)) {
                    this.m_TextComponent.havePropertiesChanged = true;
                    this.m_TextComponent.SetAllDirty();
                }
            },
            /*TMPro.TMP_SubMeshUI.OnDestroy end.*/

            /*TMPro.TMP_SubMeshUI.OnTransformParentChanged start.*/
            /**
             * @instance
             * @protected
             * @override
             * @this TMPro.TMP_SubMeshUI
             * @memberof TMPro.TMP_SubMeshUI
             * @return  {void}
             */
            OnTransformParentChanged: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#OnTransformParentChanged", this ); }

                if (!this.IsActive()) {
                    return;
                }

                this.m_ShouldRecalculateStencil = true;
                this.RecalculateClipping();
                this.RecalculateMasking();
            },
            /*TMPro.TMP_SubMeshUI.OnTransformParentChanged end.*/

            /*TMPro.TMP_SubMeshUI.GetModifiedMaterial start.*/
            /**
             * Function returning the modified material for masking if necessary.
             *
             * @instance
             * @public
             * @override
             * @this TMPro.TMP_SubMeshUI
             * @memberof TMPro.TMP_SubMeshUI
             * @param   {UnityEngine.Material}    baseMaterial
             * @return  {UnityEngine.Material}
             */
            GetModifiedMaterial: function (baseMaterial) {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#GetModifiedMaterial", this ); }

                var mat = baseMaterial;

                if (this.m_ShouldRecalculateStencil) {
                    var rootCanvas = UnityEngine.UI.MaskUtilities.FindRootSortOverrideCanvas(this.transform);
                    this.m_StencilValue = this.maskable ? UnityEngine.UI.MaskUtilities.GetStencilDepth(this.transform, rootCanvas) : 0;
                    this.m_ShouldRecalculateStencil = false;
                }

                if (this.m_StencilValue > 0) {
                    var maskMat = UnityEngine.UI.StencilMaterial.Add$2(mat, (1 << this.m_StencilValue) - 1, UnityEngine.Rendering.StencilOp.Keep, UnityEngine.Rendering.CompareFunction.Equal, UnityEngine.Rendering.ColorWriteMask.All, (1 << this.m_StencilValue) - 1, 0);
                    UnityEngine.UI.StencilMaterial.Remove(this.m_MaskMaterial);
                    this.m_MaskMaterial = maskMat;
                    mat = this.m_MaskMaterial;
                }

                return mat;
            },
            /*TMPro.TMP_SubMeshUI.GetModifiedMaterial end.*/

            /*TMPro.TMP_SubMeshUI.GetPaddingForMaterial start.*/
            /**
             * Function called when the padding value for the material needs to be re-calculated.
             *
             * @instance
             * @public
             * @this TMPro.TMP_SubMeshUI
             * @memberof TMPro.TMP_SubMeshUI
             * @return  {number}
             */
            GetPaddingForMaterial: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#GetPaddingForMaterial", this ); }

                var padding = TMPro.ShaderUtilities.GetPadding(this.m_sharedMaterial, this.m_TextComponent.extraPadding, this.m_TextComponent.isUsingBold);

                return padding;
            },
            /*TMPro.TMP_SubMeshUI.GetPaddingForMaterial end.*/

            /*TMPro.TMP_SubMeshUI.GetPaddingForMaterial$1 start.*/
            /**
             * Function called when the padding value for the material needs to be re-calculated.
             *
             * @instance
             * @public
             * @this TMPro.TMP_SubMeshUI
             * @memberof TMPro.TMP_SubMeshUI
             * @param   {UnityEngine.Material}    mat
             * @return  {number}
             */
            GetPaddingForMaterial$1: function (mat) {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#GetPaddingForMaterial$1", this ); }

                var padding = TMPro.ShaderUtilities.GetPadding(mat, this.m_TextComponent.extraPadding, this.m_TextComponent.isUsingBold);

                return padding;
            },
            /*TMPro.TMP_SubMeshUI.GetPaddingForMaterial$1 end.*/

            /*TMPro.TMP_SubMeshUI.UpdateMeshPadding start.*/
            /**
             * @instance
             * @public
             * @this TMPro.TMP_SubMeshUI
             * @memberof TMPro.TMP_SubMeshUI
             * @param   {boolean}    isExtraPadding    
             * @param   {boolean}    isUsingBold
             * @return  {void}
             */
            UpdateMeshPadding: function (isExtraPadding, isUsingBold) {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#UpdateMeshPadding", this ); }

                this.m_padding = TMPro.ShaderUtilities.GetPadding(this.m_sharedMaterial, isExtraPadding, isUsingBold);
            },
            /*TMPro.TMP_SubMeshUI.UpdateMeshPadding end.*/

            /*TMPro.TMP_SubMeshUI.SetAllDirty start.*/
            /**
             * @instance
             * @public
             * @override
             * @this TMPro.TMP_SubMeshUI
             * @memberof TMPro.TMP_SubMeshUI
             * @return  {void}
             */
            SetAllDirty: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#SetAllDirty", this ); }

                //SetLayoutDirty();
                //SetVerticesDirty();
                //SetMaterialDirty();
            },
            /*TMPro.TMP_SubMeshUI.SetAllDirty end.*/

            /*TMPro.TMP_SubMeshUI.SetVerticesDirty start.*/
            /**
             * @instance
             * @public
             * @override
             * @this TMPro.TMP_SubMeshUI
             * @memberof TMPro.TMP_SubMeshUI
             * @return  {void}
             */
            SetVerticesDirty: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#SetVerticesDirty", this ); }

                if (!this.IsActive()) {
                    return;
                }

                // This is called on the parent TextMeshPro component.
                if (UnityEngine.MonoBehaviour.op_Inequality(this.m_TextComponent, null)) {
                    this.m_TextComponent.havePropertiesChanged = true;
                    this.m_TextComponent.SetVerticesDirty();
                }
            },
            /*TMPro.TMP_SubMeshUI.SetVerticesDirty end.*/

            /*TMPro.TMP_SubMeshUI.SetLayoutDirty start.*/
            /**
             * @instance
             * @public
             * @override
             * @this TMPro.TMP_SubMeshUI
             * @memberof TMPro.TMP_SubMeshUI
             * @return  {void}
             */
            SetLayoutDirty: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#SetLayoutDirty", this ); }
 },
            /*TMPro.TMP_SubMeshUI.SetLayoutDirty end.*/

            /*TMPro.TMP_SubMeshUI.SetMaterialDirty start.*/
            /**
             * @instance
             * @public
             * @override
             * @this TMPro.TMP_SubMeshUI
             * @memberof TMPro.TMP_SubMeshUI
             * @return  {void}
             */
            SetMaterialDirty: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#SetMaterialDirty", this ); }

                //Debug.Log("*** STO-UI - SetMaterialDirty() *** FRAME (" + Time.frameCount + ")");

                //if (!this.IsActive())
                //    return;

                this.m_materialDirty = true;

                this.UpdateMaterial();

                if (!Bridge.staticEquals(this.m_OnDirtyMaterialCallback, null)) {
                    this.m_OnDirtyMaterialCallback();
                }

                //TMP_ITextElementUpdateManager.RegisterTextElementForGraphicRebuild(this);

                //TMP_UpdateRegistry.RegisterCanvasElementForGraphicRebuild((ICanvasElement)this);
                //m_TextComponent.SetMaterialDirty();
            },
            /*TMPro.TMP_SubMeshUI.SetMaterialDirty end.*/

            /*TMPro.TMP_SubMeshUI.SetPivotDirty start.*/
            /**
             * @instance
             * @public
             * @this TMPro.TMP_SubMeshUI
             * @memberof TMPro.TMP_SubMeshUI
             * @return  {void}
             */
            SetPivotDirty: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#SetPivotDirty", this ); }

                if (!this.IsActive()) {
                    return;
                }

                this.rectTransform.pivot = this.m_TextComponent.rectTransform$1.pivot.$clone();
            },
            /*TMPro.TMP_SubMeshUI.SetPivotDirty end.*/

            /*TMPro.TMP_SubMeshUI.GetRootCanvasTransform start.*/
            GetRootCanvasTransform: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#GetRootCanvasTransform", this ); }

                if (UnityEngine.Component.op_Equality(this.m_RootCanvasTransform, null)) {
                    this.m_RootCanvasTransform = this.m_TextComponent.canvas.rootCanvas.transform;
                }

                return this.m_RootCanvasTransform;
            },
            /*TMPro.TMP_SubMeshUI.GetRootCanvasTransform end.*/

            /*TMPro.TMP_SubMeshUI.Cull start.*/
            /**
             * Override Cull function as this is handled by the parent text object.
             *
             * @instance
             * @public
             * @override
             * @this TMPro.TMP_SubMeshUI
             * @memberof TMPro.TMP_SubMeshUI
             * @param   {UnityEngine.Rect}    clipRect     
             * @param   {boolean}             validRect
             * @return  {void}
             */
            Cull: function (clipRect, validRect) {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#Cull", this ); }

                // Do nothing as this functionality is handled by the parent text object.
            },
            /*TMPro.TMP_SubMeshUI.Cull end.*/

            /*TMPro.TMP_SubMeshUI.UpdateGeometry start.*/
            /**
             * @instance
             * @protected
             * @override
             * @this TMPro.TMP_SubMeshUI
             * @memberof TMPro.TMP_SubMeshUI
             * @return  {void}
             */
            UpdateGeometry: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#UpdateGeometry", this ); }

                // Need to override to prevent Unity from changing the geometry of the object.
                //Debug.Log("UpdateGeometry()");
            },
            /*TMPro.TMP_SubMeshUI.UpdateGeometry end.*/

            /*TMPro.TMP_SubMeshUI.Rebuild start.*/
            /**
             * @instance
             * @public
             * @override
             * @this TMPro.TMP_SubMeshUI
             * @memberof TMPro.TMP_SubMeshUI
             * @param   {UnityEngine.UI.CanvasUpdate}    update
             * @return  {void}
             */
            Rebuild: function (update) {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#Rebuild", this ); }

                if (update === UnityEngine.UI.CanvasUpdate.PreRender) {
                    if (!this.m_materialDirty) {
                        return;
                    }

                    this.UpdateMaterial();
                    this.m_materialDirty = false;
                }
            },
            /*TMPro.TMP_SubMeshUI.Rebuild end.*/

            /*TMPro.TMP_SubMeshUI.RefreshMaterial start.*/
            /**
             * Function to update the material from the parent text object.
             *
             * @instance
             * @public
             * @this TMPro.TMP_SubMeshUI
             * @memberof TMPro.TMP_SubMeshUI
             * @return  {void}
             */
            RefreshMaterial: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#RefreshMaterial", this ); }

                this.UpdateMaterial();
            },
            /*TMPro.TMP_SubMeshUI.RefreshMaterial end.*/

            /*TMPro.TMP_SubMeshUI.UpdateMaterial start.*/
            /**
             * @instance
             * @protected
             * @override
             * @this TMPro.TMP_SubMeshUI
             * @memberof TMPro.TMP_SubMeshUI
             * @return  {void}
             */
            UpdateMaterial: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#UpdateMaterial", this ); }

                //Debug.Log("*** STO-UI - UpdateMaterial() *** FRAME (" + Time.frameCount + ")");

                if (this.m_sharedMaterial == null) {
                    return;
                }

                //if (canvasRenderer == null) m_canvasRenderer = this.canvasRenderer;

                // Special handling to keep the Culling of the material in sync with parent text object
                if (this.m_sharedMaterial.HasProperty$1(TMPro.ShaderUtilities.ShaderTag_CullMode)) {
                    var cullMode = this.textComponent.fontSharedMaterial.GetFloat$1(TMPro.ShaderUtilities.ShaderTag_CullMode);
                    this.m_sharedMaterial.SetFloat$1(TMPro.ShaderUtilities.ShaderTag_CullMode, cullMode);
                }

                this.canvasRenderer.materialCount = 1;
                this.canvasRenderer.SetMaterial(this.materialForRendering, 0);
                //canvasRenderer.SetTexture(materialForRendering.mainTexture);

            },
            /*TMPro.TMP_SubMeshUI.UpdateMaterial end.*/

            /*TMPro.TMP_SubMeshUI.RecalculateClipping start.*/
            /**
             * Method called when the state of a parent changes.
             *
             * @instance
             * @public
             * @override
             * @this TMPro.TMP_SubMeshUI
             * @memberof TMPro.TMP_SubMeshUI
             * @return  {void}
             */
            RecalculateClipping: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#RecalculateClipping", this ); }

                //Debug.Log("*** RecalculateClipping() ***");
                UnityEngine.UI.MaskableGraphic.prototype.RecalculateClipping.call(this);
            },
            /*TMPro.TMP_SubMeshUI.RecalculateClipping end.*/

            /*TMPro.TMP_SubMeshUI.GetMaterial start.*/
            /**
             * 
             * Method which returns an instance of the shared material
             *
             * @instance
             * @private
             * @this TMPro.TMP_SubMeshUI
             * @memberof TMPro.TMP_SubMeshUI
             * @return  {UnityEngine.Material}
             */
            GetMaterial: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#GetMaterial", this ); }

                // Make sure we have a valid reference to the renderer.
                //if (m_renderer == null) m_renderer = GetComponent<Renderer>();

                //if (m_material == null || m_isNewSharedMaterial)
                //{
                //    m_renderer.material = m_sharedMaterial;
                //    m_material = m_renderer.material;
                //    m_sharedMaterial = m_material;
                //    m_padding = ShaderUtilities.GetPadding(m_sharedMaterial, m_TextMeshPro.extraPadding, false);
                //    m_isNewSharedMaterial = false;
                //}

                return this.m_sharedMaterial;
            },
            /*TMPro.TMP_SubMeshUI.GetMaterial end.*/

            /*TMPro.TMP_SubMeshUI.GetMaterial$1 start.*/
            GetMaterial$1: function (mat) {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#GetMaterial$1", this ); }

                // Check in case Object is disabled. If so, we don't have a valid reference to the Renderer.
                // This can occur when the Duplicate Material Context menu is used on an inactive object.
                //if (m_renderer == null)
                //    m_renderer = GetComponent<Renderer>();

                // Create Instance Material only if the new material is not the same instance previously used.
                if (this.m_material == null || this.m_material.GetInstanceID() !== mat.GetInstanceID()) {
                    this.m_material = this.CreateMaterialInstance(mat);
                }

                this.m_sharedMaterial = this.m_material;

                // Compute and Set new padding values for this new material.
                this.m_padding = this.GetPaddingForMaterial();

                this.SetVerticesDirty();
                this.SetMaterialDirty();

                return this.m_sharedMaterial;
            },
            /*TMPro.TMP_SubMeshUI.GetMaterial$1 end.*/

            /*TMPro.TMP_SubMeshUI.CreateMaterialInstance start.*/
            /**
             * Method used to create an instance of the material
             *
             * @instance
             * @private
             * @this TMPro.TMP_SubMeshUI
             * @memberof TMPro.TMP_SubMeshUI
             * @param   {UnityEngine.Material}    source
             * @return  {UnityEngine.Material}
             */
            CreateMaterialInstance: function (source) {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#CreateMaterialInstance", this ); }

                var mat = new UnityEngine.Material.$ctor1(source);
                mat.shaderKeywords = source.shaderKeywords;
                mat.name = (mat.name || "") + " (Instance)";

                return mat;
            },
            /*TMPro.TMP_SubMeshUI.CreateMaterialInstance end.*/

            /*TMPro.TMP_SubMeshUI.GetSharedMaterial start.*/
            /**
             * Method returning the shared material assigned to the text object.
             *
             * @instance
             * @private
             * @this TMPro.TMP_SubMeshUI
             * @memberof TMPro.TMP_SubMeshUI
             * @return  {UnityEngine.Material}
             */
            GetSharedMaterial: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#GetSharedMaterial", this ); }

                //if (canvasRenderer == null)
                //    canvasRenderer = GetComponent<CanvasRenderer>();

                return this.canvasRenderer.GetMaterial();
            },
            /*TMPro.TMP_SubMeshUI.GetSharedMaterial end.*/

            /*TMPro.TMP_SubMeshUI.SetSharedMaterial start.*/
            /**
             * Method to set the shared material.
             *
             * @instance
             * @private
             * @this TMPro.TMP_SubMeshUI
             * @memberof TMPro.TMP_SubMeshUI
             * @param   {UnityEngine.Material}    mat
             * @return  {void}
             */
            SetSharedMaterial: function (mat) {
if ( TRACE ) { TRACE( "TMPro.TMP_SubMeshUI#SetSharedMaterial", this ); }

                //Debug.Log("*** SetSharedMaterial UI() *** FRAME (" + Time.frameCount + ")");

                // Assign new material.
                this.m_sharedMaterial = mat;
                this.m_Material = this.m_sharedMaterial;

                //m_isDefaultMaterial = false;
                //if (mat.GetInstanceID() == m_fontAsset.material.GetInstanceID())
                //    m_isDefaultMaterial = true;

                // Compute and Set new padding values for this new material.
                this.m_padding = this.GetPaddingForMaterial();

                //SetVerticesDirty();
                this.SetMaterialDirty();

            },
            /*TMPro.TMP_SubMeshUI.SetSharedMaterial end.*/


        },
        overloads: {
            "GetPaddingForMaterial(Material)": "GetPaddingForMaterial$1",
            "GetMaterial(Material)": "GetMaterial$1"
        }
    });
    /*TMPro.TMP_SubMeshUI end.*/

    /*TMPro.TMP_Text+CharacterSubstitution start.*/
    Bridge.define("TMPro.TMP_Text.CharacterSubstitution", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text.CharacterSubstitution#getDefaultValue", this ); }
 return new TMPro.TMP_Text.CharacterSubstitution(); }
            }
        },
        fields: {
            index: 0,
            unicode: 0
        },
        ctors: {
            $ctor1: function (index, unicode) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text.CharacterSubstitution#$ctor1", this ); }

                this.$initialize();
                this.index = index;
                this.unicode = unicode;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text.CharacterSubstitution#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text.CharacterSubstitution#getHashCode", this ); }

                var h = Bridge.addHash([9095219308, this.index, this.unicode]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text.CharacterSubstitution#equals", this ); }

                if (!Bridge.is(o, TMPro.TMP_Text.CharacterSubstitution)) {
                    return false;
                }
                return Bridge.equals(this.index, o.index) && Bridge.equals(this.unicode, o.unicode);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text.CharacterSubstitution#$clone", this ); }

                var s = to || new TMPro.TMP_Text.CharacterSubstitution();
                s.index = this.index;
                s.unicode = this.unicode;
                return s;
            }
        }
    });
    /*TMPro.TMP_Text+CharacterSubstitution end.*/

    /*TMPro.TMP_Text+SpecialCharacter start.*/
    Bridge.define("TMPro.TMP_Text.SpecialCharacter", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text.SpecialCharacter#getDefaultValue", this ); }
 return new TMPro.TMP_Text.SpecialCharacter(); }
            }
        },
        fields: {
            character: null,
            fontAsset: null,
            material: null,
            materialIndex: 0
        },
        ctors: {
            $ctor1: function (character, materialIndex) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text.SpecialCharacter#$ctor1", this ); }

                this.$initialize();
                this.character = character;
                this.fontAsset = Bridge.as(character.textAsset, TMPro.TMP_FontAsset);
                this.material = this.fontAsset != null ? this.fontAsset.material : null;
                this.materialIndex = materialIndex;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text.SpecialCharacter#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text.SpecialCharacter#getHashCode", this ); }

                var h = Bridge.addHash([6352906119, this.character, this.fontAsset, this.material, this.materialIndex]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text.SpecialCharacter#equals", this ); }

                if (!Bridge.is(o, TMPro.TMP_Text.SpecialCharacter)) {
                    return false;
                }
                return Bridge.equals(this.character, o.character) && Bridge.equals(this.fontAsset, o.fontAsset) && Bridge.equals(this.material, o.material) && Bridge.equals(this.materialIndex, o.materialIndex);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text.SpecialCharacter#$clone", this ); }

                var s = to || new TMPro.TMP_Text.SpecialCharacter();
                s.character = this.character;
                s.fontAsset = this.fontAsset;
                s.material = this.material;
                s.materialIndex = this.materialIndex;
                return s;
            }
        }
    });
    /*TMPro.TMP_Text+SpecialCharacter end.*/

    /*TMPro.TMP_Text+TextBackingContainer start.*/
    /**
     * @private
     * @class TMPro.TMP_Text.TextBackingContainer
     */
    Bridge.define("TMPro.TMP_Text.TextBackingContainer", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text.TextBackingContainer#getDefaultValue", this ); }
 return new TMPro.TMP_Text.TextBackingContainer(); }
            }
        },
        fields: {
            m_Array: null,
            m_Count: 0
        },
        props: {
            Capacity: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text.TextBackingContainer#Capacity#get", this ); }

                    return this.m_Array.length;
                }
            },
            Count: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text.TextBackingContainer#Count#get", this ); }

                    return this.m_Count;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text.TextBackingContainer#Count#set", this ); }

                    this.m_Count = value;
                }
            }
        },
        ctors: {
            $ctor1: function (size) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text.TextBackingContainer#$ctor1", this ); }

                this.$initialize();
                this.m_Array = System.Array.init(size, 0, System.UInt32);
                this.m_Count = 0;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text.TextBackingContainer#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getItem: function (index) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text.TextBackingContainer#getItem", this ); }

                return this.m_Array[index];
            },
            setItem: function (index, value) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text.TextBackingContainer#setItem", this ); }

                if (index >= this.m_Array.length) {
                    this.Resize(index);
                }

                this.m_Array[index] = value;
            },
            /*TMPro.TMP_Text+TextBackingContainer.Resize start.*/
            Resize: function (size) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text.TextBackingContainer#Resize", this ); }

                size = UnityEngine.Mathf.NextPowerOfTwo(size + 1);

                System.Array.resize(Bridge.ref(this, "m_Array"), size, 0, System.UInt32);
            },
            /*TMPro.TMP_Text+TextBackingContainer.Resize end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text.TextBackingContainer#getHashCode", this ); }

                var h = Bridge.addHash([8440844759, this.m_Array, this.m_Count]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text.TextBackingContainer#equals", this ); }

                if (!Bridge.is(o, TMPro.TMP_Text.TextBackingContainer)) {
                    return false;
                }
                return Bridge.equals(this.m_Array, o.m_Array) && Bridge.equals(this.m_Count, o.m_Count);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text.TextBackingContainer#$clone", this ); }

                var s = to || new TMPro.TMP_Text.TextBackingContainer();
                s.m_Array = this.m_Array;
                s.m_Count = this.m_Count;
                return s;
            }
        }
    });
    /*TMPro.TMP_Text+TextBackingContainer end.*/

    /*TMPro.TMP_Text+TextInputSources start.*/
    Bridge.define("TMPro.TMP_Text.TextInputSources", {
        $kind: 1006,
        statics: {
            fields: {
                TextInputBox: 0,
                SetText: 1,
                SetTextArray: 2,
                TextString: 3
            }
        }
    });
    /*TMPro.TMP_Text+TextInputSources end.*/

    /*TMPro.TMP_Text+UnicodeChar start.*/
    Bridge.define("TMPro.TMP_Text.UnicodeChar", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text.UnicodeChar#getDefaultValue", this ); }
 return new TMPro.TMP_Text.UnicodeChar(); }
            }
        },
        fields: {
            unicode: 0,
            stringIndex: 0,
            length: 0
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text.UnicodeChar#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Text.UnicodeChar#getHashCode", this ); }

                var h = Bridge.addHash([2806068268, this.unicode, this.stringIndex, this.length]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text.UnicodeChar#equals", this ); }

                if (!Bridge.is(o, TMPro.TMP_Text.UnicodeChar)) {
                    return false;
                }
                return Bridge.equals(this.unicode, o.unicode) && Bridge.equals(this.stringIndex, o.stringIndex) && Bridge.equals(this.length, o.length);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.TMP_Text.UnicodeChar#$clone", this ); }

                var s = to || new TMPro.TMP_Text.UnicodeChar();
                s.unicode = this.unicode;
                s.stringIndex = this.stringIndex;
                s.length = this.length;
                return s;
            }
        }
    });
    /*TMPro.TMP_Text+UnicodeChar end.*/

    /*TMPro.TMP_TextElementType start.*/
    Bridge.define("TMPro.TMP_TextElementType", {
        $kind: 6,
        statics: {
            fields: {
                Character: 0,
                Sprite: 1
            }
        }
    });
    /*TMPro.TMP_TextElementType end.*/

    /*TMPro.TMP_TextInfo start.*/
    /**
     * Class which contains information about every element contained within the text object.
     *
     * @public
     * @class TMPro.TMP_TextInfo
     */
    Bridge.define("TMPro.TMP_TextInfo", {
        statics: {
            fields: {
                k_InfinityVectorPositive: null,
                k_InfinityVectorNegative: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextInfo#init", this ); }

                    this.k_InfinityVectorPositive = new UnityEngine.Vector2();
                    this.k_InfinityVectorNegative = new UnityEngine.Vector2();
                    this.k_InfinityVectorPositive = new pc.Vec2( 32767, 32767 );
                    this.k_InfinityVectorNegative = new pc.Vec2( -32767, -32767 );
                }
            },
            methods: {
                /*TMPro.TMP_TextInfo.Resize:static start.*/
                /**
                 * Function to resize any of the structure contained in the TMP_TextInfo class.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_TextInfo
                 * @memberof TMPro.TMP_TextInfo
                 * @param   {Function}    T        
                 * @param   {T}           array    
                 * @param   {number}      size
                 * @return  {void}
                 */
                Resize: function (T, array, size) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextInfo#Resize", this ); }

                    // Allocated to the next power of two
                    var newSize = size > 1024 ? size + 256 : UnityEngine.Mathf.NextPowerOfTwo(size);

                    System.Array.resize(array, newSize, function () {
                        return Bridge.getDefaultValue(T);
                    }, T);
                },
                /*TMPro.TMP_TextInfo.Resize:static end.*/

                /*TMPro.TMP_TextInfo.Resize$1:static start.*/
                /**
                 * Function to resize any of the structure contained in the TMP_TextInfo class.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_TextInfo
                 * @memberof TMPro.TMP_TextInfo
                 * @param   {Function}    T                   
                 * @param   {T}           array               
                 * @param   {number}      size                
                 * @param   {boolean}     isBlockAllocated
                 * @return  {void}
                 */
                Resize$1: function (T, array, size, isBlockAllocated) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextInfo#Resize$1", this ); }

                    if (isBlockAllocated) {
                        size = size > 1024 ? size + 256 : UnityEngine.Mathf.NextPowerOfTwo(size);
                    }

                    if (size === array.v.length) {
                        return;
                    }

                    //Debug.Log("Resizing TextInfo from [" + array.Length + "] to [" + size + "]");

                    System.Array.resize(array, size, function () {
                        return Bridge.getDefaultValue(T);
                    }, T);
                },
                /*TMPro.TMP_TextInfo.Resize$1:static end.*/


            }
        },
        fields: {
            textComponent: null,
            characterCount: 0,
            spriteCount: 0,
            spaceCount: 0,
            wordCount: 0,
            linkCount: 0,
            lineCount: 0,
            pageCount: 0,
            materialCount: 0,
            characterInfo: null,
            wordInfo: null,
            linkInfo: null,
            lineInfo: null,
            pageInfo: null,
            meshInfo: null,
            m_CachedMeshInfo: null
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextInfo#ctor", this ); }

                this.$initialize();
                this.characterInfo = System.Array.init(8, function (){
                    return new TMPro.TMP_CharacterInfo();
                }, TMPro.TMP_CharacterInfo);
                this.wordInfo = System.Array.init(16, function (){
                    return new TMPro.TMP_WordInfo();
                }, TMPro.TMP_WordInfo);
                this.linkInfo = System.Array.init(0, function (){
                    return new TMPro.TMP_LinkInfo();
                }, TMPro.TMP_LinkInfo);
                this.lineInfo = System.Array.init(2, function (){
                    return new TMPro.TMP_LineInfo();
                }, TMPro.TMP_LineInfo);
                this.pageInfo = System.Array.init(4, function (){
                    return new TMPro.TMP_PageInfo();
                }, TMPro.TMP_PageInfo);

                this.meshInfo = System.Array.init(1, function (){
                    return new TMPro.TMP_MeshInfo();
                }, TMPro.TMP_MeshInfo);
            },
            $ctor1: function (characterCount) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextInfo#$ctor1", this ); }

                this.$initialize();
                this.characterInfo = System.Array.init(characterCount, function (){
                    return new TMPro.TMP_CharacterInfo();
                }, TMPro.TMP_CharacterInfo);
                this.wordInfo = System.Array.init(16, function (){
                    return new TMPro.TMP_WordInfo();
                }, TMPro.TMP_WordInfo);
                this.linkInfo = System.Array.init(0, function (){
                    return new TMPro.TMP_LinkInfo();
                }, TMPro.TMP_LinkInfo);
                this.lineInfo = System.Array.init(2, function (){
                    return new TMPro.TMP_LineInfo();
                }, TMPro.TMP_LineInfo);
                this.pageInfo = System.Array.init(4, function (){
                    return new TMPro.TMP_PageInfo();
                }, TMPro.TMP_PageInfo);

                this.meshInfo = System.Array.init(1, function (){
                    return new TMPro.TMP_MeshInfo();
                }, TMPro.TMP_MeshInfo);
            },
            $ctor2: function (textComponent) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextInfo#$ctor2", this ); }

                this.$initialize();
                this.textComponent = textComponent;

                this.characterInfo = System.Array.init(8, function (){
                    return new TMPro.TMP_CharacterInfo();
                }, TMPro.TMP_CharacterInfo);

                this.wordInfo = System.Array.init(4, function (){
                    return new TMPro.TMP_WordInfo();
                }, TMPro.TMP_WordInfo);
                this.linkInfo = System.Array.init(0, function (){
                    return new TMPro.TMP_LinkInfo();
                }, TMPro.TMP_LinkInfo);

                this.lineInfo = System.Array.init(2, function (){
                    return new TMPro.TMP_LineInfo();
                }, TMPro.TMP_LineInfo);
                this.pageInfo = System.Array.init(4, function (){
                    return new TMPro.TMP_PageInfo();
                }, TMPro.TMP_PageInfo);

                this.meshInfo = System.Array.init(1, function (){
                    return new TMPro.TMP_MeshInfo();
                }, TMPro.TMP_MeshInfo);
                this.meshInfo[0].mesh = textComponent.mesh;
                this.materialCount = 1;
            }
        },
        methods: {
            /*TMPro.TMP_TextInfo.Clear start.*/
            /**
             * Function to clear the counters of the text object.
             *
             * @instance
             * @public
             * @this TMPro.TMP_TextInfo
             * @memberof TMPro.TMP_TextInfo
             * @return  {void}
             */
            Clear: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextInfo#Clear", this ); }

                this.characterCount = 0;
                this.spaceCount = 0;
                this.wordCount = 0;
                this.linkCount = 0;
                this.lineCount = 0;
                this.pageCount = 0;
                this.spriteCount = 0;

                for (var i = 0; i < this.meshInfo.length; i++) {
                    this.meshInfo[i].vertexCount = 0;
                }
            },
            /*TMPro.TMP_TextInfo.Clear end.*/

            /*TMPro.TMP_TextInfo.ClearAllData start.*/
            /**
             * @instance
             * @this TMPro.TMP_TextInfo
             * @memberof TMPro.TMP_TextInfo
             * @return  {void}
             */
            ClearAllData: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextInfo#ClearAllData", this ); }

                this.characterCount = 0;
                this.spaceCount = 0;
                this.wordCount = 0;
                this.linkCount = 0;
                this.lineCount = 0;
                this.pageCount = 0;
                this.spriteCount = 0;

                this.characterInfo = System.Array.init(4, function (){
                    return new TMPro.TMP_CharacterInfo();
                }, TMPro.TMP_CharacterInfo);
                this.wordInfo = System.Array.init(1, function (){
                    return new TMPro.TMP_WordInfo();
                }, TMPro.TMP_WordInfo);
                this.lineInfo = System.Array.init(1, function (){
                    return new TMPro.TMP_LineInfo();
                }, TMPro.TMP_LineInfo);
                this.pageInfo = System.Array.init(1, function (){
                    return new TMPro.TMP_PageInfo();
                }, TMPro.TMP_PageInfo);
                this.linkInfo = System.Array.init(0, function (){
                    return new TMPro.TMP_LinkInfo();
                }, TMPro.TMP_LinkInfo);

                this.materialCount = 0;

                this.meshInfo = System.Array.init(1, function (){
                    return new TMPro.TMP_MeshInfo();
                }, TMPro.TMP_MeshInfo);
            },
            /*TMPro.TMP_TextInfo.ClearAllData end.*/

            /*TMPro.TMP_TextInfo.ClearMeshInfo start.*/
            /**
             * Function to clear the content of the MeshInfo array while preserving the Triangles, Normals and Tangents.
             *
             * @instance
             * @public
             * @this TMPro.TMP_TextInfo
             * @memberof TMPro.TMP_TextInfo
             * @param   {boolean}    updateMesh
             * @return  {void}
             */
            ClearMeshInfo: function (updateMesh) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextInfo#ClearMeshInfo", this ); }

                for (var i = 0; i < this.meshInfo.length; i++) {
                    this.meshInfo[i].Clear$1(updateMesh);
                }
            },
            /*TMPro.TMP_TextInfo.ClearMeshInfo end.*/

            /*TMPro.TMP_TextInfo.ClearAllMeshInfo start.*/
            /**
             * Function to clear the content of all the MeshInfo arrays while preserving their Triangles, Normals and Tangents.
             *
             * @instance
             * @public
             * @this TMPro.TMP_TextInfo
             * @memberof TMPro.TMP_TextInfo
             * @return  {void}
             */
            ClearAllMeshInfo: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextInfo#ClearAllMeshInfo", this ); }

                for (var i = 0; i < this.meshInfo.length; i++) {
                    this.meshInfo[i].Clear$1(true);
                }
            },
            /*TMPro.TMP_TextInfo.ClearAllMeshInfo end.*/

            /*TMPro.TMP_TextInfo.ResetVertexLayout start.*/
            /**
             * @instance
             * @public
             * @this TMPro.TMP_TextInfo
             * @memberof TMPro.TMP_TextInfo
             * @param   {boolean}    isVolumetric
             * @return  {void}
             */
            ResetVertexLayout: function (isVolumetric) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextInfo#ResetVertexLayout", this ); }

                for (var i = 0; i < this.meshInfo.length; i++) {
                    this.meshInfo[i].ResizeMeshInfo$1(0, isVolumetric);
                }
            },
            /*TMPro.TMP_TextInfo.ResetVertexLayout end.*/

            /*TMPro.TMP_TextInfo.ClearUnusedVertices start.*/
            /**
             * Function used to mark unused vertices as degenerate.
             *
             * @instance
             * @public
             * @this TMPro.TMP_TextInfo
             * @memberof TMPro.TMP_TextInfo
             * @param   {Array.<TMPro.MaterialReference>}    materials
             * @return  {void}
             */
            ClearUnusedVertices: function (materials) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextInfo#ClearUnusedVertices", this ); }

                for (var i = 0; i < this.meshInfo.length; i++) {
                    var start = 0; // materials[i].referenceCount * 4;
                    this.meshInfo[i].ClearUnusedVertices$1(start);
                }
            },
            /*TMPro.TMP_TextInfo.ClearUnusedVertices end.*/

            /*TMPro.TMP_TextInfo.ClearLineInfo start.*/
            /**
             * Function to clear and initialize the lineInfo array.
             *
             * @instance
             * @public
             * @this TMPro.TMP_TextInfo
             * @memberof TMPro.TMP_TextInfo
             * @return  {void}
             */
            ClearLineInfo: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextInfo#ClearLineInfo", this ); }

                if (this.lineInfo == null) {
                    this.lineInfo = System.Array.init(2, function (){
                        return new TMPro.TMP_LineInfo();
                    }, TMPro.TMP_LineInfo);
                }

                var length = this.lineInfo.length;

                for (var i = 0; i < length; i++) {
                    this.lineInfo[i].characterCount = 0;
                    this.lineInfo[i].spaceCount = 0;
                    this.lineInfo[i].wordCount = 0;
                    this.lineInfo[i].controlCharacterCount = 0;
                    this.lineInfo[i].width = 0;

                    this.lineInfo[i].ascender = TMPro.TMP_TextInfo.k_InfinityVectorNegative.x;
                    this.lineInfo[i].descender = TMPro.TMP_TextInfo.k_InfinityVectorPositive.x;

                    this.lineInfo[i].marginLeft = 0;
                    this.lineInfo[i].marginRight = 0;

                    this.lineInfo[i].lineExtents.min.set( TMPro.TMP_TextInfo.k_InfinityVectorPositive.x, TMPro.TMP_TextInfo.k_InfinityVectorPositive.y );
                    this.lineInfo[i].lineExtents.max.set( TMPro.TMP_TextInfo.k_InfinityVectorPositive.x, TMPro.TMP_TextInfo.k_InfinityVectorPositive.y );

                    this.lineInfo[i].maxAdvance = 0;
                    //this.lineInfo[i].maxScale = 0;
                }
            },
            /*TMPro.TMP_TextInfo.ClearLineInfo end.*/

            /*TMPro.TMP_TextInfo.ClearPageInfo start.*/
            ClearPageInfo: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextInfo#ClearPageInfo", this ); }

                if (this.pageInfo == null) {
                    this.pageInfo = System.Array.init(2, function (){
                        return new TMPro.TMP_PageInfo();
                    }, TMPro.TMP_PageInfo);
                }

                var length = this.pageInfo.length;

                for (var i = 0; i < length; i++) {
                    this.pageInfo[i].firstCharacterIndex = 0;
                    this.pageInfo[i].lastCharacterIndex = 0;
                    this.pageInfo[i].ascender = -32767;
                    this.pageInfo[i].baseLine = 0;
                    this.pageInfo[i].descender = 32767;
                }
            },
            /*TMPro.TMP_TextInfo.ClearPageInfo end.*/

            /*TMPro.TMP_TextInfo.CopyMeshInfoVertexData start.*/
            /**
             * Function to copy the MeshInfo Arrays and their primary vertex data content.
             *
             * @instance
             * @public
             * @this TMPro.TMP_TextInfo
             * @memberof TMPro.TMP_TextInfo
             * @return  {Array.<TMPro.TMP_MeshInfo>}        A copy of the MeshInfo[]
             */
            CopyMeshInfoVertexData: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextInfo#CopyMeshInfoVertexData", this ); }

                if (this.m_CachedMeshInfo == null || this.m_CachedMeshInfo.length !== this.meshInfo.length) {
                    this.m_CachedMeshInfo = System.Array.init(this.meshInfo.length, function (){
                        return new TMPro.TMP_MeshInfo();
                    }, TMPro.TMP_MeshInfo);

                    // Initialize all the vertex data arrays
                    for (var i = 0; i < this.m_CachedMeshInfo.length; i++) {
                        var length = this.meshInfo[i].vertices.length;

                        this.m_CachedMeshInfo[i].vertices = System.Array.init(length, function (){
                            return new UnityEngine.Vector3();
                        }, UnityEngine.Vector3);
                        this.m_CachedMeshInfo[i].uvs0 = System.Array.init(length, function (){
                            return new UnityEngine.Vector2();
                        }, UnityEngine.Vector2);
                        this.m_CachedMeshInfo[i].uvs2 = System.Array.init(length, function (){
                            return new UnityEngine.Vector2();
                        }, UnityEngine.Vector2);
                        this.m_CachedMeshInfo[i].colors32 = System.Array.init(length, function (){
                            return new UnityEngine.Color32();
                        }, UnityEngine.Color32);

                        //m_CachedMeshInfo[i].normals = new Vector3[length];
                        //m_CachedMeshInfo[i].tangents = new Vector4[length];
                        //m_CachedMeshInfo[i].triangles = new int[meshInfo[i].triangles.Length];
                    }
                }

                for (var i1 = 0; i1 < this.m_CachedMeshInfo.length; i1++) {
                    var length1 = this.meshInfo[i1].vertices.length;

                    if (this.m_CachedMeshInfo[i1].vertices.length !== length1) {
                        this.m_CachedMeshInfo[i1].vertices = System.Array.init(length1, function (){
                            return new UnityEngine.Vector3();
                        }, UnityEngine.Vector3);
                        this.m_CachedMeshInfo[i1].uvs0 = System.Array.init(length1, function (){
                            return new UnityEngine.Vector2();
                        }, UnityEngine.Vector2);
                        this.m_CachedMeshInfo[i1].uvs2 = System.Array.init(length1, function (){
                            return new UnityEngine.Vector2();
                        }, UnityEngine.Vector2);
                        this.m_CachedMeshInfo[i1].colors32 = System.Array.init(length1, function (){
                            return new UnityEngine.Color32();
                        }, UnityEngine.Color32);

                        //m_CachedMeshInfo[i].normals = new Vector3[length];
                        //m_CachedMeshInfo[i].tangents = new Vector4[length];
                        //m_CachedMeshInfo[i].triangles = new int[meshInfo[i].triangles.Length];
                    }


                    // Only copy the primary vertex data
                    System.Array.copy(this.meshInfo[i1].vertices, 0, this.m_CachedMeshInfo[i1].vertices, 0, length1);
                    System.Array.copy(this.meshInfo[i1].uvs0, 0, this.m_CachedMeshInfo[i1].uvs0, 0, length1);
                    System.Array.copy(this.meshInfo[i1].uvs2, 0, this.m_CachedMeshInfo[i1].uvs2, 0, length1);
                    System.Array.copy(this.meshInfo[i1].colors32, 0, this.m_CachedMeshInfo[i1].colors32, 0, length1);

                    //Array.Copy(meshInfo[i].normals, m_CachedMeshInfo[i].normals, length);
                    //Array.Copy(meshInfo[i].tangents, m_CachedMeshInfo[i].tangents, length);
                    //Array.Copy(meshInfo[i].triangles, m_CachedMeshInfo[i].triangles, meshInfo[i].triangles.Length);
                }

                return this.m_CachedMeshInfo;
            },
            /*TMPro.TMP_TextInfo.CopyMeshInfoVertexData end.*/


        }
    });
    /*TMPro.TMP_TextInfo end.*/

    /*TMPro.TMP_TextParsingUtilities start.*/
    Bridge.define("TMPro.TMP_TextParsingUtilities", {
        statics: {
            fields: {
                /**
                 * Table used to convert character to lowercase.
                 *
                 * @static
                 * @private
                 * @memberof TMPro.TMP_TextParsingUtilities
                 * @constant
                 * @default "-------------------------------- !-#$%&-()*+,-./0123456789:;<=>?@abcdefghijklmnopqrstuvwxyz[-]^_`abcdefghijklmnopqrstuvwxyz{|}~-"
                 * @type string
                 */
                k_LookupStringL: null,
                /**
                 * Table used to convert character to uppercase.
                 *
                 * @static
                 * @private
                 * @memberof TMPro.TMP_TextParsingUtilities
                 * @constant
                 * @default "-------------------------------- !-#$%&-()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[-]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~-"
                 * @type string
                 */
                k_LookupStringU: null,
                s_Instance: null
            },
            props: {
                /**
                 * Get a singleton instance of the TextModuleUtilities.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof TMPro.TMP_TextParsingUtilities
                 * @function instance
                 * @type TMPro.TMP_TextParsingUtilities
                 */
                instance: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextParsingUtilities#instance#get", this ); }

                        return TMPro.TMP_TextParsingUtilities.s_Instance;
                    }
                }
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextParsingUtilities#init", this ); }

                    this.k_LookupStringL = "-------------------------------- !-#$%&-()*+,-./0123456789:;<=>?@abcdefghijklmnopqrstuvwxyz[-]^_`abcdefghijklmnopqrstuvwxyz{|}~-";
                    this.k_LookupStringU = "-------------------------------- !-#$%&-()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[-]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~-";
                    this.s_Instance = new TMPro.TMP_TextParsingUtilities();
                },
                ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextParsingUtilities#ctor", this ); }

                }
            },
            methods: {
                /*TMPro.TMP_TextParsingUtilities.GetHashCode:static start.*/
                /**
                 * Function returning the hashcode value of a given string.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_TextParsingUtilities
                 * @memberof TMPro.TMP_TextParsingUtilities
                 * @param   {string}    s
                 * @return  {number}
                 */
                GetHashCode: function (s) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextParsingUtilities#GetHashCode", this ); }

                    var hashCode = 0;

                    for (var i = 0; i < s.length; i++) {
                        hashCode = ((hashCode << 5) + hashCode) ^ TMPro.TMP_TextParsingUtilities.ToUpperASCIIFast(s.charCodeAt(i));
                    }

                    return hashCode;
                },
                /*TMPro.TMP_TextParsingUtilities.GetHashCode:static end.*/

                /*TMPro.TMP_TextParsingUtilities.GetHashCodeCaseSensitive:static start.*/
                GetHashCodeCaseSensitive: function (s) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextParsingUtilities#GetHashCodeCaseSensitive", this ); }

                    var hashCode = 0;

                    for (var i = 0; i < s.length; i++) {
                        hashCode = ((hashCode << 5) + hashCode) ^ s.charCodeAt(i);
                    }

                    return hashCode;
                },
                /*TMPro.TMP_TextParsingUtilities.GetHashCodeCaseSensitive:static end.*/

                /*TMPro.TMP_TextParsingUtilities.ToLowerASCIIFast:static start.*/
                /**
                 * Get lowercase version of this ASCII character.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_TextParsingUtilities
                 * @memberof TMPro.TMP_TextParsingUtilities
                 * @param   {number}    c
                 * @return  {number}
                 */
                ToLowerASCIIFast: function (c) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextParsingUtilities#ToLowerASCIIFast", this ); }

                    if (c > TMPro.TMP_TextParsingUtilities.k_LookupStringL.length - 1) {
                        return c;
                    }

                    return TMPro.TMP_TextParsingUtilities.k_LookupStringL.charCodeAt(c);
                },
                /*TMPro.TMP_TextParsingUtilities.ToLowerASCIIFast:static end.*/

                /*TMPro.TMP_TextParsingUtilities.ToLowerASCIIFast$1:static start.*/
                /**
                 * Get lowercase version of this ASCII character.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_TextParsingUtilities
                 * @memberof TMPro.TMP_TextParsingUtilities
                 * @param   {number}    c
                 * @return  {number}
                 */
                ToLowerASCIIFast$1: function (c) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextParsingUtilities#ToLowerASCIIFast$1", this ); }

                    if (System.Int64(c).gt(System.Int64(TMPro.TMP_TextParsingUtilities.k_LookupStringL.length - 1))) {
                        return c;
                    }

                    return TMPro.TMP_TextParsingUtilities.k_LookupStringL.charCodeAt(c);
                },
                /*TMPro.TMP_TextParsingUtilities.ToLowerASCIIFast$1:static end.*/

                /*TMPro.TMP_TextParsingUtilities.ToUpperASCIIFast:static start.*/
                /**
                 * Get uppercase version of this ASCII character.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_TextParsingUtilities
                 * @memberof TMPro.TMP_TextParsingUtilities
                 * @param   {number}    c
                 * @return  {number}
                 */
                ToUpperASCIIFast: function (c) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextParsingUtilities#ToUpperASCIIFast", this ); }

                    if (c > TMPro.TMP_TextParsingUtilities.k_LookupStringU.length - 1) {
                        return c;
                    }

                    return TMPro.TMP_TextParsingUtilities.k_LookupStringU.charCodeAt(c);
                },
                /*TMPro.TMP_TextParsingUtilities.ToUpperASCIIFast:static end.*/

                /*TMPro.TMP_TextParsingUtilities.ToUpperASCIIFast$1:static start.*/
                /**
                 * Get uppercase version of this ASCII character.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_TextParsingUtilities
                 * @memberof TMPro.TMP_TextParsingUtilities
                 * @param   {number}    c
                 * @return  {number}
                 */
                ToUpperASCIIFast$1: function (c) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextParsingUtilities#ToUpperASCIIFast$1", this ); }

                    if (System.Int64(c).gt(System.Int64(TMPro.TMP_TextParsingUtilities.k_LookupStringU.length - 1))) {
                        return c;
                    }

                    return TMPro.TMP_TextParsingUtilities.k_LookupStringU.charCodeAt(c);
                },
                /*TMPro.TMP_TextParsingUtilities.ToUpperASCIIFast$1:static end.*/

                /*TMPro.TMP_TextParsingUtilities.IsHighSurrogate:static start.*/
                /**
                 * Check if Unicode is High Surrogate
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_TextParsingUtilities
                 * @memberof TMPro.TMP_TextParsingUtilities
                 * @param   {number}     c
                 * @return  {boolean}
                 */
                IsHighSurrogate: function (c) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextParsingUtilities#IsHighSurrogate", this ); }

                    return c > 55296 && c < 56319;
                },
                /*TMPro.TMP_TextParsingUtilities.IsHighSurrogate:static end.*/

                /*TMPro.TMP_TextParsingUtilities.IsLowSurrogate:static start.*/
                /**
                 * Check if Unicode is Low Surrogate
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_TextParsingUtilities
                 * @memberof TMPro.TMP_TextParsingUtilities
                 * @param   {number}     c
                 * @return  {boolean}
                 */
                IsLowSurrogate: function (c) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextParsingUtilities#IsLowSurrogate", this ); }

                    return c > 56320 && c < 57343;
                },
                /*TMPro.TMP_TextParsingUtilities.IsLowSurrogate:static end.*/

                /*TMPro.TMP_TextParsingUtilities.ConvertToUTF32:static start.*/
                /**
                 * @static
                 * @this TMPro.TMP_TextParsingUtilities
                 * @memberof TMPro.TMP_TextParsingUtilities
                 * @param   {number}    highSurrogate    
                 * @param   {number}    lowSurrogate
                 * @return  {number}
                 */
                ConvertToUTF32: function (highSurrogate, lowSurrogate) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextParsingUtilities#ConvertToUTF32", this ); }

                    return (highSurrogate - TMPro.CodePoint.HIGH_SURROGATE_START) * 1024 + (lowSurrogate - TMPro.CodePoint.LOW_SURROGATE_START) + TMPro.CodePoint.UNICODE_PLANE01_START;
                },
                /*TMPro.TMP_TextParsingUtilities.ConvertToUTF32:static end.*/


            }
        }
    });
    /*TMPro.TMP_TextParsingUtilities end.*/

    /*TMPro.TMP_TextProcessingStack$1 start.*/
    /**
     * Structure used to track XML tags of various types.
     *
     * @public
     * @class TMPro.TMP_TextProcessingStack$1
     * @param   {Function}    [name]
     */
    Bridge.define("TMPro.TMP_TextProcessingStack$1", function (T) { return {
        $kind: 4,
        statics: {
            fields: {
                k_DefaultCapacity: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextProcessingStack$1#init", this ); }

                    this.k_DefaultCapacity = 4;
                }
            },
            methods: {
                /*TMPro.TMP_TextProcessingStack$1.SetDefault:static start.*/
                /**
                 * Set stack elements to default item.
                 *
                 * @static
                 * @this TMPro.TMP_TextProcessingStack$1
                 * @memberof TMPro.TMP_TextProcessingStack$1
                 * @param   {Array.<TMPro.TMP_TextProcessingStack$1>}    stack    The stack of elements.
                 * @param   {T}                                          item
                 * @return  {void}
                 */
                SetDefault: function (stack, item) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextProcessingStack$1#SetDefault", this ); }

                    for (var i = 0; i < stack.length; i++) {
                        stack[i].SetDefault(item);
                    }
                },
                /*TMPro.TMP_TextProcessingStack$1.SetDefault:static end.*/

                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextProcessingStack$1#getDefaultValue", this ); }
 return new (TMPro.TMP_TextProcessingStack$1(T))(); }
            }
        },
        fields: {
            itemStack: null,
            index: 0,
            m_DefaultItem: Bridge.getDefaultValue(T),
            m_Capacity: 0,
            m_RolloverSize: 0,
            m_Count: 0
        },
        props: {
            /**
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_TextProcessingStack$1
             * @function Count
             * @type number
             */
            Count: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextProcessingStack$1#Count#get", this ); }

                    return this.m_Count;
                }
            },
            /**
             * Returns the current item on the stack.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_TextProcessingStack$1
             * @function current
             * @type T
             */
            current: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextProcessingStack$1#current#get", this ); }

                    if (this.index > 0) {
                        return this.itemStack[this.index - 1];
                    }

                    return this.itemStack[0];
                }
            },
            /**
             * @instance
             * @public
             * @memberof TMPro.TMP_TextProcessingStack$1
             * @function rolloverSize
             * @type number
             */
            rolloverSize: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextProcessingStack$1#rolloverSize#get", this ); }

                    return this.m_RolloverSize;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextProcessingStack$1#rolloverSize#set", this ); }

                    this.m_RolloverSize = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextProcessingStack$1#init", this ); }

                this.m_DefaultItem = Bridge.getDefaultValue(T);
            },
            /**
             * Constructor to create a new item stack.
             *
             * @instance
             * @public
             * @this TMPro.TMP_TextProcessingStack$1
             * @memberof TMPro.TMP_TextProcessingStack$1
             * @param   {Array.<T>}    stack
             * @return  {void}
             */
            $ctor1: function (stack) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextProcessingStack$1#$ctor1", this ); }

                this.$initialize();
                this.itemStack = stack;
                this.m_Capacity = stack.length;
                this.index = 0;
                this.m_RolloverSize = 0;

                this.m_DefaultItem = Bridge.getDefaultValue(T);
                this.m_Count = 0;
            },
            /**
             * Constructor for a new item stack with the given capacity.
             *
             * @instance
             * @public
             * @this TMPro.TMP_TextProcessingStack$1
             * @memberof TMPro.TMP_TextProcessingStack$1
             * @param   {number}    capacity
             * @return  {void}
             */
            $ctor2: function (capacity) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextProcessingStack$1#$ctor2", this ); }

                this.$initialize();
                this.itemStack = System.Array.init(capacity, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
                this.m_Capacity = capacity;
                this.index = 0;
                this.m_RolloverSize = 0;

                this.m_DefaultItem = Bridge.getDefaultValue(T);
                this.m_Count = 0;
            },
            $ctor3: function (capacity, rolloverSize) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextProcessingStack$1#$ctor3", this ); }

                this.$initialize();
                this.itemStack = System.Array.init(capacity, function (){
                    return Bridge.getDefaultValue(T);
                }, T);
                this.m_Capacity = capacity;
                this.index = 0;
                this.m_RolloverSize = rolloverSize;

                this.m_DefaultItem = Bridge.getDefaultValue(T);
                this.m_Count = 0;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextProcessingStack$1#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*TMPro.TMP_TextProcessingStack$1.CopyBase start.*/
            CopyBase: function (other) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextProcessingStack$1#CopyBase", this ); }

                this.index = other.index;
                this.m_Capacity = other.m_Capacity;
                this.m_RolloverSize = other.m_RolloverSize;
                this.m_Count = other.m_Count;
                this.itemStack = other.itemStack;
            },
            /*TMPro.TMP_TextProcessingStack$1.CopyBase end.*/

            /*TMPro.TMP_TextProcessingStack$1.Copy start.*/
            Copy: function (other) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextProcessingStack$1#Copy", this ); }

                this.CopyBase(other);
                this.m_DefaultItem = other.m_DefaultItem;
            },
            /*TMPro.TMP_TextProcessingStack$1.Copy end.*/

            /*TMPro.TMP_TextProcessingStack$1.CopyStruct start.*/
            CopyStruct: function (other) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextProcessingStack$1#CopyStruct", this ); }

                this.CopyBase(other);
                this.m_DefaultItem.Copy( other.m_DefaultItem );
            },
            /*TMPro.TMP_TextProcessingStack$1.CopyStruct end.*/

            /*TMPro.TMP_TextProcessingStack$1.Clear start.*/
            /**
             * Function to clear and reset stack to first item.
             *
             * @instance
             * @public
             * @this TMPro.TMP_TextProcessingStack$1
             * @memberof TMPro.TMP_TextProcessingStack$1
             * @return  {void}
             */
            Clear: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextProcessingStack$1#Clear", this ); }

                this.index = 0;
                this.m_Count = 0;
            },
            /*TMPro.TMP_TextProcessingStack$1.Clear end.*/

            /*TMPro.TMP_TextProcessingStack$1.SetDefault start.*/
            /**
             * Function to set the first item on the stack and reset index.
             *
             * @instance
             * @public
             * @this TMPro.TMP_TextProcessingStack$1
             * @memberof TMPro.TMP_TextProcessingStack$1
             * @param   {T}       item
             * @return  {void}
             */
            SetDefault: function (item) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextProcessingStack$1#SetDefault", this ); }

                if (this.itemStack == null) {
                    this.m_Capacity = TMPro.TMP_TextProcessingStack$1(T).k_DefaultCapacity;
                    this.itemStack = System.Array.init(this.m_Capacity, function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                    this.m_DefaultItem = Bridge.getDefaultValue(T);
                }

                this.itemStack[0] = item;
                this.index = 1;
            },
            /*TMPro.TMP_TextProcessingStack$1.SetDefault end.*/

            /*TMPro.TMP_TextProcessingStack$1.Add start.*/
            /**
             * Function to add a new item to the stack.
             *
             * @instance
             * @public
             * @this TMPro.TMP_TextProcessingStack$1
             * @memberof TMPro.TMP_TextProcessingStack$1
             * @param   {T}       item
             * @return  {void}
             */
            Add: function (item) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextProcessingStack$1#Add", this ); }

                if (this.index < this.itemStack.length) {
                    this.itemStack[this.index] = item;
                    this.index += 1;
                }
            },
            /*TMPro.TMP_TextProcessingStack$1.Add end.*/

            /*TMPro.TMP_TextProcessingStack$1.Remove start.*/
            /**
             * Function to retrieve an item from the stack.
             *
             * @instance
             * @public
             * @this TMPro.TMP_TextProcessingStack$1
             * @memberof TMPro.TMP_TextProcessingStack$1
             * @return  {T}
             */
            Remove: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextProcessingStack$1#Remove", this ); }

                this.index -= 1;

                if (this.index <= 0) {
                    this.index = 1;
                    return this.itemStack[0];
                }

                return this.itemStack[this.index - 1];
            },
            /*TMPro.TMP_TextProcessingStack$1.Remove end.*/

            /*TMPro.TMP_TextProcessingStack$1.Push start.*/
            Push: function (item) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextProcessingStack$1#Push", this ); }

                if (this.index === this.m_Capacity) {
                    this.m_Capacity *= 2;
                    if (this.m_Capacity === 0) {
                        this.m_Capacity = TMPro.TMP_TextProcessingStack$1(T).k_DefaultCapacity;
                    }

                    System.Array.resize(Bridge.ref(this, "itemStack"), this.m_Capacity, function () {
                        return Bridge.getDefaultValue(T);
                    }, T);
                }

                this.itemStack[this.index] = item;

                if (this.m_RolloverSize === 0) {
                    this.index += 1;
                    this.m_Count += 1;
                } else {
                    this.index = (this.index + 1) % this.m_RolloverSize;
                    this.m_Count = this.m_Count < this.m_RolloverSize ? this.m_Count + 1 : this.m_RolloverSize;
                }
            },
            /*TMPro.TMP_TextProcessingStack$1.Push end.*/

            /*TMPro.TMP_TextProcessingStack$1.Pop start.*/
            Pop: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextProcessingStack$1#Pop", this ); }

                if (this.index === 0 && this.m_RolloverSize === 0) {
                    return Bridge.getDefaultValue(T);
                }

                if (this.m_RolloverSize === 0) {
                    this.index -= 1;
                } else {
                    this.index = (this.index - 1) % this.m_RolloverSize;
                    this.index = this.index < 0 ? this.index + this.m_RolloverSize : this.index;
                }

                var item = this.itemStack[this.index];
                this.itemStack[this.index] = this.m_DefaultItem;

                this.m_Count = this.m_Count > 0 ? this.m_Count - 1 : 0;

                return item;
            },
            /*TMPro.TMP_TextProcessingStack$1.Pop end.*/

            /*TMPro.TMP_TextProcessingStack$1.Peek start.*/
            /**
             * @instance
             * @public
             * @this TMPro.TMP_TextProcessingStack$1
             * @memberof TMPro.TMP_TextProcessingStack$1
             * @return  {T}
             */
            Peek: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextProcessingStack$1#Peek", this ); }

                if (this.index === 0) {
                    return this.m_DefaultItem;
                }

                return this.itemStack[this.index - 1];
            },
            /*TMPro.TMP_TextProcessingStack$1.Peek end.*/

            /*TMPro.TMP_TextProcessingStack$1.CurrentItem start.*/
            
            CurrentItem: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextProcessingStack$1#CurrentItem", this ); }

                if (this.index > 0) {
                    return this.itemStack[this.index - 1];
                }

                return this.itemStack[0];
            },
            /*TMPro.TMP_TextProcessingStack$1.CurrentItem end.*/

            /*TMPro.TMP_TextProcessingStack$1.PreviousItem start.*/
            /**
             * Function to retrieve the previous item without affecting the stack.
             *
             * @instance
             * @public
             * @this TMPro.TMP_TextProcessingStack$1
             * @memberof TMPro.TMP_TextProcessingStack$1
             * @return  {T}
             */
            PreviousItem: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextProcessingStack$1#PreviousItem", this ); }

                if (this.index > 1) {
                    return this.itemStack[this.index - 2];
                }

                return this.itemStack[0];
            },
            /*TMPro.TMP_TextProcessingStack$1.PreviousItem end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextProcessingStack$1#getHashCode", this ); }

                var h = Bridge.addHash([8949228332, this.itemStack, this.index, this.m_DefaultItem, this.m_Capacity, this.m_RolloverSize, this.m_Count]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextProcessingStack$1#equals", this ); }

                if (!Bridge.is(o, TMPro.TMP_TextProcessingStack$1(T))) {
                    return false;
                }
                return Bridge.equals(this.itemStack, o.itemStack) && Bridge.equals(this.index, o.index) && Bridge.equals(this.m_DefaultItem, o.m_DefaultItem) && Bridge.equals(this.m_Capacity, o.m_Capacity) && Bridge.equals(this.m_RolloverSize, o.m_RolloverSize) && Bridge.equals(this.m_Count, o.m_Count);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextProcessingStack$1#$clone", this ); }

                var s = to || new (TMPro.TMP_TextProcessingStack$1(T))();
                s.itemStack = this.itemStack;
                s.index = this.index;
                s.m_DefaultItem = this.m_DefaultItem;
                s.m_Capacity = this.m_Capacity;
                s.m_RolloverSize = this.m_RolloverSize;
                s.m_Count = this.m_Count;
                return s;
            }
        }
    }; });
    /*TMPro.TMP_TextProcessingStack$1 end.*/

    /*TMPro.TMP_TextUtilities start.*/
    Bridge.define("TMPro.TMP_TextUtilities", {
        statics: {
            fields: {
                /**
                 * Function returning the Square Distance from a Point to a Line and Direction.
                 * Table used to convert character to lowercase.
                 *
                 * @static
                 * @private
                 * @memberof TMPro.TMP_TextUtilities
                 * @constant
                 * @default "-------------------------------- !-#$%&-()*+,-./0123456789:;<=>?@abcdefghijklmnopqrstuvwxyz[-]^_`abcdefghijklmnopqrstuvwxyz{|}~-"
                 * @type string
                 * @return  {[type]}
                 */
                k_lookupStringL: null,
                /**
                 * Table used to convert character to uppercase.
                 *
                 * @static
                 * @private
                 * @memberof TMPro.TMP_TextUtilities
                 * @constant
                 * @default "-------------------------------- !-#$%&-()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[-]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~-"
                 * @type string
                 */
                k_lookupStringU: null,
                m_rectWorldCorners: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextUtilities#init", this ); }

                    this.k_lookupStringL = "-------------------------------- !-#$%&-()*+,-./0123456789:;<=>?@abcdefghijklmnopqrstuvwxyz[-]^_`abcdefghijklmnopqrstuvwxyz{|}~-";
                    this.k_lookupStringU = "-------------------------------- !-#$%&-()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[-]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~-";
                    this.m_rectWorldCorners = System.Array.init(4, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                }
            },
            methods: {
                /*TMPro.TMP_TextUtilities.GetCursorIndexFromPosition:static start.*/
                /**
                 * 
                 * Function returning the index of the character whose origin is closest to the cursor.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_TextUtilities
                 * @memberof TMPro.TMP_TextUtilities
                 * @param   {TMPro.TMP_Text}         textComponent    A reference to the text object.
                 * @param   {UnityEngine.Vector3}    position         Position to check for intersection.
                 * @param   {UnityEngine.Camera}     camera           The scene camera which may be assigned to a Canvas using ScreenSpace Camera or WorldSpace render mode. Set to null is using ScreenSpace Overlay.
                 * @return  {number}
                 */
                GetCursorIndexFromPosition: function (textComponent, position, camera) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextUtilities#GetCursorIndexFromPosition", this ); }

                    var $t;
                    position = {v:position};
                    var index = TMPro.TMP_TextUtilities.FindNearestCharacter(textComponent, position.v.$clone(), camera, false);

                    var rectTransform = textComponent.rectTransform$1;

                    // Convert position into Worldspace coordinates
                    TMPro.TMP_TextUtilities.ScreenPointToWorldPointInRectangle(rectTransform, UnityEngine.Vector2.FromVector3(position.v.$clone()), camera, position);

                    var cInfo = ($t = textComponent.textInfo.characterInfo)[index].$clone();

                    // Get Bottom Left and Top Right position of the current character
                    var bl = rectTransform.TransformPoint$1(cInfo.bottomLeft);
                    var tr = rectTransform.TransformPoint$1(cInfo.topRight);

                    var insertPosition = (position.v.x - bl.x) / (tr.x - bl.x);

                    if (insertPosition < 0.5) {
                        return index;
                    } else {
                        return index + 1;
                    }
                },
                /*TMPro.TMP_TextUtilities.GetCursorIndexFromPosition:static end.*/

                /*TMPro.TMP_TextUtilities.GetCursorIndexFromPosition$1:static start.*/
                /**
                 * Function returning the index of the character whose origin is closest to the cursor.
                 * Function returning the index of the character whose origin is closest to the cursor.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_TextUtilities
                 * @memberof TMPro.TMP_TextUtilities
                 * @param   {TMPro.TMP_Text}         textComponent    A reference to the text object.
                 * @param   {UnityEngine.Vector3}    position         Position to check for intersection.
                 * @param   {UnityEngine.Camera}     camera           The scene camera which may be assigned to a Canvas using ScreenSpace Camera or WorldSpace render mode. Set to null is using ScreenSpace Overlay.
                 * @param   {TMPro.CaretPosition}    cursor           The position of the cursor insertion position relative to the position.
                 * @return  {number}
                 */
                GetCursorIndexFromPosition$1: function (textComponent, position, camera, cursor) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextUtilities#GetCursorIndexFromPosition$1", this ); }

                    var $t, $t1;
                    position = {v:position};
                    var line = TMPro.TMP_TextUtilities.FindNearestLine(textComponent, position.v.$clone(), camera);

                    var index = TMPro.TMP_TextUtilities.FindNearestCharacterOnLine(textComponent, position.v.$clone(), line, camera, false);

                    // Special handling if line contains only one character.
                    if (($t = textComponent.textInfo.lineInfo)[line].characterCount === 1) {
                        cursor.v = TMPro.CaretPosition.Left;
                        return index;
                    }

                    var rectTransform = textComponent.rectTransform$1;

                    // Convert position into Worldspace coordinates
                    TMPro.TMP_TextUtilities.ScreenPointToWorldPointInRectangle(rectTransform, UnityEngine.Vector2.FromVector3(position.v.$clone()), camera, position);

                    var cInfo = ($t1 = textComponent.textInfo.characterInfo)[index].$clone();

                    // Get Bottom Left and Top Right position of the current character
                    var bl = rectTransform.TransformPoint$1(cInfo.bottomLeft);
                    var tr = rectTransform.TransformPoint$1(cInfo.topRight);

                    var insertPosition = (position.v.x - bl.x) / (tr.x - bl.x);

                    if (insertPosition < 0.5) {
                        cursor.v = TMPro.CaretPosition.Left;
                        return index;
                    } else {
                        cursor.v = TMPro.CaretPosition.Right;
                        return index;
                    }
                },
                /*TMPro.TMP_TextUtilities.GetCursorIndexFromPosition$1:static end.*/

                /*TMPro.TMP_TextUtilities.FindNearestLine:static start.*/
                /**
                 * Function returning the line nearest to the position.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_TextUtilities
                 * @memberof TMPro.TMP_TextUtilities
                 * @param   {TMPro.TMP_Text}         text        
                 * @param   {UnityEngine.Vector3}    position    
                 * @param   {UnityEngine.Camera}     camera
                 * @return  {number}
                 */
                FindNearestLine: function (text, position, camera) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextUtilities#FindNearestLine", this ); }

                    var $t;
                    position = {v:position};
                    var rectTransform = text.rectTransform$1;

                    var distance = window.Infinity;
                    var closest = -1;

                    // Convert position into Worldspace coordinates
                    TMPro.TMP_TextUtilities.ScreenPointToWorldPointInRectangle(rectTransform, UnityEngine.Vector2.FromVector3(position.v.$clone()), camera, position);

                    for (var i = 0; i < text.textInfo.lineCount; i++) {
                        var lineInfo = ($t = text.textInfo.lineInfo)[i].$clone();

                        var ascender = rectTransform.TransformPoint$1(new pc.Vec3( 0, lineInfo.ascender, 0 )).y;
                        var descender = rectTransform.TransformPoint$1(new pc.Vec3( 0, lineInfo.descender, 0 )).y;

                        if (ascender > position.v.y && descender < position.v.y) {
                            //Debug.Log("Position is on line " + i);
                            return i;
                        }

                        var d0 = Math.abs(ascender - position.v.y);
                        var d1 = Math.abs(descender - position.v.y);

                        var d = UnityEngine.Mathf.Min(d0, d1);
                        if (d < distance) {
                            distance = d;
                            closest = i;
                        }
                    }

                    //Debug.Log("Closest line to position is " + closest);
                    return closest;
                },
                /*TMPro.TMP_TextUtilities.FindNearestLine:static end.*/

                /*TMPro.TMP_TextUtilities.FindNearestCharacterOnLine:static start.*/
                /**
                 * Function returning the nearest character to position on a given line.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_TextUtilities
                 * @memberof TMPro.TMP_TextUtilities
                 * @param   {TMPro.TMP_Text}         text           
                 * @param   {UnityEngine.Vector3}    position       
                 * @param   {number}                 line           
                 * @param   {UnityEngine.Camera}     camera         
                 * @param   {boolean}                visibleOnly
                 * @return  {number}
                 */
                FindNearestCharacterOnLine: function (text, position, line, camera, visibleOnly) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextUtilities#FindNearestCharacterOnLine", this ); }

                    var $t, $t1, $t2;
                    position = {v:position};
                    var rectTransform = text.rectTransform$1;

                    // Convert position into Worldspace coordinates
                    TMPro.TMP_TextUtilities.ScreenPointToWorldPointInRectangle(rectTransform, UnityEngine.Vector2.FromVector3(position.v.$clone()), camera, position);

                    var firstCharacter = ($t = text.textInfo.lineInfo)[line].firstCharacterIndex;
                    var lastCharacter = ($t1 = text.textInfo.lineInfo)[line].lastCharacterIndex;

                    var distanceSqr = window.Infinity;
                    var closest = lastCharacter;

                    for (var i = firstCharacter; i < lastCharacter; i++) {
                        // Get current character info.
                        var cInfo = ($t2 = text.textInfo.characterInfo)[i].$clone();
                        if (visibleOnly && !cInfo.isVisible) {
                            continue;
                        }

                        // Get Bottom Left and Top Right position of the current character
                        var bl = rectTransform.TransformPoint$1(cInfo.bottomLeft);
                        var tl = rectTransform.TransformPoint$1(new pc.Vec3( cInfo.bottomLeft.x, cInfo.topRight.y, 0 ));
                        var tr = rectTransform.TransformPoint$1(cInfo.topRight);
                        var br = rectTransform.TransformPoint$1(new pc.Vec3( cInfo.topRight.x, cInfo.bottomLeft.y, 0 ));

                        if (TMPro.TMP_TextUtilities.PointIntersectRectangle(position.v.$clone(), bl.$clone(), tl.$clone(), tr.$clone(), br.$clone())) {
                            closest = i;
                            break;
                        }

                        // Find the closest corner to position.
                        var dbl = TMPro.TMP_TextUtilities.DistanceToLine(bl.$clone(), tl.$clone(), position.v.$clone());
                        var dtl = TMPro.TMP_TextUtilities.DistanceToLine(tl.$clone(), tr.$clone(), position.v.$clone());
                        var dtr = TMPro.TMP_TextUtilities.DistanceToLine(tr.$clone(), br.$clone(), position.v.$clone());
                        var dbr = TMPro.TMP_TextUtilities.DistanceToLine(br.$clone(), bl.$clone(), position.v.$clone());

                        var d = dbl < dtl ? dbl : dtl;
                        d = d < dtr ? d : dtr;
                        d = d < dbr ? d : dbr;

                        if (distanceSqr > d) {
                            distanceSqr = d;
                            closest = i;
                        }
                    }

                    return closest;
                },
                /*TMPro.TMP_TextUtilities.FindNearestCharacterOnLine:static end.*/

                /*TMPro.TMP_TextUtilities.IsIntersectingRectTransform:static start.*/
                /**
                 * Function used to determine if the position intersects with the RectTransform.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_TextUtilities
                 * @memberof TMPro.TMP_TextUtilities
                 * @param   {UnityEngine.RectTransform}    rectTransform    A reference to the RectTranform of the text object.
                 * @param   {UnityEngine.Vector3}          position         Position to check for intersection.
                 * @param   {UnityEngine.Camera}           camera           The scene camera which may be assigned to a Canvas using ScreenSpace Camera or WorldSpace render mode. Set to null is using ScreenSpace Overlay.
                 * @return  {boolean}
                 */
                IsIntersectingRectTransform: function (rectTransform, position, camera) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextUtilities#IsIntersectingRectTransform", this ); }

                    position = {v:position};
                    // Convert position into Worldspace coordinates
                    TMPro.TMP_TextUtilities.ScreenPointToWorldPointInRectangle(rectTransform, UnityEngine.Vector2.FromVector3(position.v.$clone()), camera, position);

                    rectTransform.GetWorldCorners(TMPro.TMP_TextUtilities.m_rectWorldCorners);

                    if (TMPro.TMP_TextUtilities.PointIntersectRectangle(position.v.$clone(), TMPro.TMP_TextUtilities.m_rectWorldCorners[0].$clone(), TMPro.TMP_TextUtilities.m_rectWorldCorners[1].$clone(), TMPro.TMP_TextUtilities.m_rectWorldCorners[2].$clone(), TMPro.TMP_TextUtilities.m_rectWorldCorners[3].$clone())) {
                        return true;
                    }

                    return false;
                },
                /*TMPro.TMP_TextUtilities.IsIntersectingRectTransform:static end.*/

                /*TMPro.TMP_TextUtilities.FindIntersectingCharacter:static start.*/
                /**
                 * Function returning the index of the character at the given position (if any).
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_TextUtilities
                 * @memberof TMPro.TMP_TextUtilities
                 * @param   {TMPro.TMP_Text}         text           A reference to the TextMeshPro component.
                 * @param   {UnityEngine.Vector3}    position       Position to check for intersection.
                 * @param   {UnityEngine.Camera}     camera         The scene camera which is rendering the text or whichever one might be assigned to a Canvas using ScreenSpace Camera or WorldSpace render mode. Set to null is using ScreenSpace Overlay.
                 * @param   {boolean}                visibleOnly    Only check for visible characters.
                 * @return  {number}
                 */
                FindIntersectingCharacter: function (text, position, camera, visibleOnly) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextUtilities#FindIntersectingCharacter", this ); }

                    var $t;
                    position = {v:position};
                    var rectTransform = text.rectTransform$1;

                    // Convert position into Worldspace coordinates
                    TMPro.TMP_TextUtilities.ScreenPointToWorldPointInRectangle(rectTransform, UnityEngine.Vector2.FromVector3(position.v.$clone()), camera, position);

                    for (var i = 0; i < text.textInfo.characterCount; i++) {
                        // Get current character info.
                        var cInfo = ($t = text.textInfo.characterInfo)[i].$clone();
                        if (visibleOnly && !cInfo.isVisible) {
                            continue;
                        }

                        // Get Bottom Left and Top Right position of the current character
                        var bl = rectTransform.TransformPoint$1(cInfo.bottomLeft);
                        var tl = rectTransform.TransformPoint$1(new pc.Vec3( cInfo.bottomLeft.x, cInfo.topRight.y, 0 ));
                        var tr = rectTransform.TransformPoint$1(cInfo.topRight);
                        var br = rectTransform.TransformPoint$1(new pc.Vec3( cInfo.topRight.x, cInfo.bottomLeft.y, 0 ));

                        if (TMPro.TMP_TextUtilities.PointIntersectRectangle(position.v.$clone(), bl.$clone(), tl.$clone(), tr.$clone(), br.$clone())) {
                            return i;
                        }
                    }

                    return -1;
                },
                /*TMPro.TMP_TextUtilities.FindIntersectingCharacter:static end.*/

                /*TMPro.TMP_TextUtilities.FindNearestCharacter:static start.*/
                /**
                 * Function returning the index of the character at the given position (if any).
                 * Function to find the nearest character to position.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_TextUtilities
                 * @memberof TMPro.TMP_TextUtilities
                 * @param   {TMPro.TMP_Text}         text           A reference to the TMP Text component.
                 * @param   {UnityEngine.Vector3}    position       Position to check for intersection.
                 * @param   {UnityEngine.Camera}     camera         The scene camera which may be assigned to a Canvas using ScreenSpace Camera or WorldSpace render mode. Set to null is using ScreenSpace Overlay.
                 * @param   {boolean}                visibleOnly    Only check for visible characters.
                 * @return  {number}
                 */
                FindNearestCharacter: function (text, position, camera, visibleOnly) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextUtilities#FindNearestCharacter", this ); }

                    var $t;
                    position = {v:position};
                    var rectTransform = text.rectTransform$1;

                    var distanceSqr = window.Infinity;
                    var closest = 0;

                    // Convert position into Worldspace coordinates
                    TMPro.TMP_TextUtilities.ScreenPointToWorldPointInRectangle(rectTransform, UnityEngine.Vector2.FromVector3(position.v.$clone()), camera, position);

                    for (var i = 0; i < text.textInfo.characterCount; i++) {
                        // Get current character info.
                        var cInfo = ($t = text.textInfo.characterInfo)[i].$clone();
                        if (visibleOnly && !cInfo.isVisible) {
                            continue;
                        }

                        // Get Bottom Left and Top Right position of the current character
                        var bl = rectTransform.TransformPoint$1(cInfo.bottomLeft);
                        var tl = rectTransform.TransformPoint$1(new pc.Vec3( cInfo.bottomLeft.x, cInfo.topRight.y, 0 ));
                        var tr = rectTransform.TransformPoint$1(cInfo.topRight);
                        var br = rectTransform.TransformPoint$1(new pc.Vec3( cInfo.topRight.x, cInfo.bottomLeft.y, 0 ));

                        if (TMPro.TMP_TextUtilities.PointIntersectRectangle(position.v.$clone(), bl.$clone(), tl.$clone(), tr.$clone(), br.$clone())) {
                            return i;
                        }

                        // Find the closest corner to position.
                        var dbl = TMPro.TMP_TextUtilities.DistanceToLine(bl.$clone(), tl.$clone(), position.v.$clone());
                        var dtl = TMPro.TMP_TextUtilities.DistanceToLine(tl.$clone(), tr.$clone(), position.v.$clone());
                        var dtr = TMPro.TMP_TextUtilities.DistanceToLine(tr.$clone(), br.$clone(), position.v.$clone());
                        var dbr = TMPro.TMP_TextUtilities.DistanceToLine(br.$clone(), bl.$clone(), position.v.$clone());

                        var d = dbl < dtl ? dbl : dtl;
                        d = d < dtr ? d : dtr;
                        d = d < dbr ? d : dbr;

                        if (distanceSqr > d) {
                            distanceSqr = d;
                            closest = i;
                        }
                    }

                    return closest;
                },
                /*TMPro.TMP_TextUtilities.FindNearestCharacter:static end.*/

                /*TMPro.TMP_TextUtilities.FindIntersectingWord:static start.*/
                /**
                 * Function to find the nearest character to position.
                 * Function to find the nearest character to position.
                 * Function returning the index of the word at the given position (if any).
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_TextUtilities
                 * @memberof TMPro.TMP_TextUtilities
                 * @param   {TMPro.TMP_Text}         text        A reference to the TMP_Text component.
                 * @param   {UnityEngine.Vector3}    position    Position to check for intersection.
                 * @param   {UnityEngine.Camera}     camera      The scene camera which may be assigned to a Canvas using ScreenSpace Camera or WorldSpace render mode. Set to null is using ScreenSpace Overlay.
                 * @return  {number}
                 */
                FindIntersectingWord: function (text, position, camera) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextUtilities#FindIntersectingWord", this ); }

                    var $t, $t1, $t2;
                    position = {v:position};
                    var rectTransform = text.rectTransform$1;

                    // Convert position into Worldspace coordinates
                    TMPro.TMP_TextUtilities.ScreenPointToWorldPointInRectangle(rectTransform, UnityEngine.Vector2.FromVector3(position.v.$clone()), camera, position);

                    for (var i = 0; i < text.textInfo.wordCount; i++) {
                        var wInfo = ($t = text.textInfo.wordInfo)[i].$clone();

                        var isBeginRegion = false;

                        var bl = pc.Vec3.ZERO.clone();
                        var tl = pc.Vec3.ZERO.clone();
                        var br = pc.Vec3.ZERO.clone();
                        var tr = pc.Vec3.ZERO.clone();

                        var maxAscender = -window.Infinity;
                        var minDescender = window.Infinity;

                        // Iterate through each character of the word
                        for (var j = 0; j < wInfo.characterCount; j++) {
                            var characterIndex = wInfo.firstCharacterIndex + j;
                            var currentCharInfo = ($t1 = text.textInfo.characterInfo)[characterIndex].$clone();
                            var currentLine = currentCharInfo.lineNumber;

                            var isCharacterVisible = currentCharInfo.isVisible;

                            // Track maximum Ascender and minimum Descender for each word.
                            maxAscender = UnityEngine.Mathf.Max(maxAscender, currentCharInfo.ascender);
                            minDescender = UnityEngine.Mathf.Min(minDescender, currentCharInfo.descender);

                            if (isBeginRegion === false && isCharacterVisible) {
                                isBeginRegion = true;

                                bl = new pc.Vec3( currentCharInfo.bottomLeft.x, currentCharInfo.descender, 0 );
                                tl = new pc.Vec3( currentCharInfo.bottomLeft.x, currentCharInfo.ascender, 0 );

                                //Debug.Log("Start Word Region at [" + currentCharInfo.character + "]");

                                // If Word is one character
                                if (wInfo.characterCount === 1) {
                                    isBeginRegion = false;

                                    br = new pc.Vec3( currentCharInfo.topRight.x, currentCharInfo.descender, 0 );
                                    tr = new pc.Vec3( currentCharInfo.topRight.x, currentCharInfo.ascender, 0 );

                                    // Transform coordinates to be relative to transform and account min descender and max ascender.
                                    bl = rectTransform.TransformPoint$1(new pc.Vec3( bl.x, minDescender, 0 ));
                                    tl = rectTransform.TransformPoint$1(new pc.Vec3( tl.x, maxAscender, 0 ));
                                    tr = rectTransform.TransformPoint$1(new pc.Vec3( tr.x, maxAscender, 0 ));
                                    br = rectTransform.TransformPoint$1(new pc.Vec3( br.x, minDescender, 0 ));

                                    // Check for Intersection
                                    if (TMPro.TMP_TextUtilities.PointIntersectRectangle(position.v.$clone(), bl.$clone(), tl.$clone(), tr.$clone(), br.$clone())) {
                                        return i;
                                    }

                                    //Debug.Log("End Word Region at [" + currentCharInfo.character + "]");
                                }
                            }

                            // Last Character of Word
                            if (isBeginRegion && j === wInfo.characterCount - 1) {
                                isBeginRegion = false;

                                br = new pc.Vec3( currentCharInfo.topRight.x, currentCharInfo.descender, 0 );
                                tr = new pc.Vec3( currentCharInfo.topRight.x, currentCharInfo.ascender, 0 );

                                // Transform coordinates to be relative to transform and account min descender and max ascender.
                                bl = rectTransform.TransformPoint$1(new pc.Vec3( bl.x, minDescender, 0 ));
                                tl = rectTransform.TransformPoint$1(new pc.Vec3( tl.x, maxAscender, 0 ));
                                tr = rectTransform.TransformPoint$1(new pc.Vec3( tr.x, maxAscender, 0 ));
                                br = rectTransform.TransformPoint$1(new pc.Vec3( br.x, minDescender, 0 ));

                                // Check for Intersection
                                if (TMPro.TMP_TextUtilities.PointIntersectRectangle(position.v.$clone(), bl.$clone(), tl.$clone(), tr.$clone(), br.$clone())) {
                                    return i;
                                }

                                //Debug.Log("End Word Region at [" + currentCharInfo.character + "]");
                            } else if (isBeginRegion && currentLine !== ($t2 = text.textInfo.characterInfo)[characterIndex + 1].lineNumber) {
                                isBeginRegion = false;

                                br = new pc.Vec3( currentCharInfo.topRight.x, currentCharInfo.descender, 0 );
                                tr = new pc.Vec3( currentCharInfo.topRight.x, currentCharInfo.ascender, 0 );

                                // Transform coordinates to be relative to transform and account min descender and max ascender.
                                bl = rectTransform.TransformPoint$1(new pc.Vec3( bl.x, minDescender, 0 ));
                                tl = rectTransform.TransformPoint$1(new pc.Vec3( tl.x, maxAscender, 0 ));
                                tr = rectTransform.TransformPoint$1(new pc.Vec3( tr.x, maxAscender, 0 ));
                                br = rectTransform.TransformPoint$1(new pc.Vec3( br.x, minDescender, 0 ));

                                maxAscender = -window.Infinity;
                                minDescender = window.Infinity;

                                // Check for Intersection
                                if (TMPro.TMP_TextUtilities.PointIntersectRectangle(position.v.$clone(), bl.$clone(), tl.$clone(), tr.$clone(), br.$clone())) {
                                    return i;
                                }

                                //Debug.Log("End Word Region at [" + currentCharInfo.character + "]");
                            }
                        }

                        //Debug.Log("Word at Index: " + i + " is located at (" + bl + ", " + tl + ", " + tr + ", " + br + ").");
                    }

                    return -1;
                },
                /*TMPro.TMP_TextUtilities.FindIntersectingWord:static end.*/

                /*TMPro.TMP_TextUtilities.FindNearestWord:static start.*/
                /**
                 * Function returning the index of the word at the given position (if any).
                 * Function returning the index of the word at the given position (if any).
                 * Function returning the index of the word at the given position (if any).
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_TextUtilities
                 * @memberof TMPro.TMP_TextUtilities
                 * @param   {TMPro.TMP_Text}         text        A reference to the TMP_Text component.
                 * @param   {UnityEngine.Vector3}    position    Position to check for intersection.
                 * @param   {UnityEngine.Camera}     camera      The scene camera which may be assigned to a Canvas using ScreenSpace Camera or WorldSpace render mode. Set to null is using ScreenSpace Overlay.
                 * @return  {number}
                 */
                FindNearestWord: function (text, position, camera) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextUtilities#FindNearestWord", this ); }

                    var $t, $t1, $t2;
                    position = {v:position};
                    var rectTransform = text.rectTransform$1;

                    var distanceSqr = window.Infinity;
                    var closest = 0;

                    // Convert position into Worldspace coordinates
                    TMPro.TMP_TextUtilities.ScreenPointToWorldPointInRectangle(rectTransform, UnityEngine.Vector2.FromVector3(position.v.$clone()), camera, position);

                    for (var i = 0; i < text.textInfo.wordCount; i++) {
                        var wInfo = ($t = text.textInfo.wordInfo)[i].$clone();

                        var isBeginRegion = false;

                        var bl = pc.Vec3.ZERO.clone();
                        var tl = pc.Vec3.ZERO.clone();
                        var br = pc.Vec3.ZERO.clone();
                        var tr = pc.Vec3.ZERO.clone();

                        // Iterate through each character of the word
                        for (var j = 0; j < wInfo.characterCount; j++) {
                            var characterIndex = wInfo.firstCharacterIndex + j;
                            var currentCharInfo = ($t1 = text.textInfo.characterInfo)[characterIndex].$clone();
                            var currentLine = currentCharInfo.lineNumber;

                            var isCharacterVisible = currentCharInfo.isVisible;

                            if (isBeginRegion === false && isCharacterVisible) {
                                isBeginRegion = true;

                                bl = rectTransform.TransformPoint$1(new pc.Vec3( currentCharInfo.bottomLeft.x, currentCharInfo.descender, 0 ));
                                tl = rectTransform.TransformPoint$1(new pc.Vec3( currentCharInfo.bottomLeft.x, currentCharInfo.ascender, 0 ));

                                //Debug.Log("Start Word Region at [" + currentCharInfo.character + "]");

                                // If Word is one character
                                if (wInfo.characterCount === 1) {
                                    isBeginRegion = false;

                                    br = rectTransform.TransformPoint$1(new pc.Vec3( currentCharInfo.topRight.x, currentCharInfo.descender, 0 ));
                                    tr = rectTransform.TransformPoint$1(new pc.Vec3( currentCharInfo.topRight.x, currentCharInfo.ascender, 0 ));

                                    // Check for Intersection
                                    if (TMPro.TMP_TextUtilities.PointIntersectRectangle(position.v.$clone(), bl.$clone(), tl.$clone(), tr.$clone(), br.$clone())) {
                                        return i;
                                    }

                                    // Find the closest line segment to position.
                                    var dbl = TMPro.TMP_TextUtilities.DistanceToLine(bl.$clone(), tl.$clone(), position.v.$clone());
                                    var dtl = TMPro.TMP_TextUtilities.DistanceToLine(tl.$clone(), tr.$clone(), position.v.$clone());
                                    var dtr = TMPro.TMP_TextUtilities.DistanceToLine(tr.$clone(), br.$clone(), position.v.$clone());
                                    var dbr = TMPro.TMP_TextUtilities.DistanceToLine(br.$clone(), bl.$clone(), position.v.$clone());

                                    var d = dbl < dtl ? dbl : dtl;
                                    d = d < dtr ? d : dtr;
                                    d = d < dbr ? d : dbr;

                                    if (distanceSqr > d) {
                                        distanceSqr = d;
                                        closest = i;
                                    }
                                }
                            }

                            // Last Character of Word
                            if (isBeginRegion && j === wInfo.characterCount - 1) {
                                isBeginRegion = false;

                                br = rectTransform.TransformPoint$1(new pc.Vec3( currentCharInfo.topRight.x, currentCharInfo.descender, 0 ));
                                tr = rectTransform.TransformPoint$1(new pc.Vec3( currentCharInfo.topRight.x, currentCharInfo.ascender, 0 ));

                                // Check for Intersection
                                if (TMPro.TMP_TextUtilities.PointIntersectRectangle(position.v.$clone(), bl.$clone(), tl.$clone(), tr.$clone(), br.$clone())) {
                                    return i;
                                }

                                // Find the closest line segment to position.
                                var dbl1 = TMPro.TMP_TextUtilities.DistanceToLine(bl.$clone(), tl.$clone(), position.v.$clone());
                                var dtl1 = TMPro.TMP_TextUtilities.DistanceToLine(tl.$clone(), tr.$clone(), position.v.$clone());
                                var dtr1 = TMPro.TMP_TextUtilities.DistanceToLine(tr.$clone(), br.$clone(), position.v.$clone());
                                var dbr1 = TMPro.TMP_TextUtilities.DistanceToLine(br.$clone(), bl.$clone(), position.v.$clone());

                                var d1 = dbl1 < dtl1 ? dbl1 : dtl1;
                                d1 = d1 < dtr1 ? d1 : dtr1;
                                d1 = d1 < dbr1 ? d1 : dbr1;

                                if (distanceSqr > d1) {
                                    distanceSqr = d1;
                                    closest = i;
                                }
                            } else if (isBeginRegion && currentLine !== ($t2 = text.textInfo.characterInfo)[characterIndex + 1].lineNumber) {
                                isBeginRegion = false;

                                br = rectTransform.TransformPoint$1(new pc.Vec3( currentCharInfo.topRight.x, currentCharInfo.descender, 0 ));
                                tr = rectTransform.TransformPoint$1(new pc.Vec3( currentCharInfo.topRight.x, currentCharInfo.ascender, 0 ));

                                // Check for Intersection
                                if (TMPro.TMP_TextUtilities.PointIntersectRectangle(position.v.$clone(), bl.$clone(), tl.$clone(), tr.$clone(), br.$clone())) {
                                    return i;
                                }

                                // Find the closest line segment to position.
                                var dbl2 = TMPro.TMP_TextUtilities.DistanceToLine(bl.$clone(), tl.$clone(), position.v.$clone());
                                var dtl2 = TMPro.TMP_TextUtilities.DistanceToLine(tl.$clone(), tr.$clone(), position.v.$clone());
                                var dtr2 = TMPro.TMP_TextUtilities.DistanceToLine(tr.$clone(), br.$clone(), position.v.$clone());
                                var dbr2 = TMPro.TMP_TextUtilities.DistanceToLine(br.$clone(), bl.$clone(), position.v.$clone());

                                var d2 = dbl2 < dtl2 ? dbl2 : dtl2;
                                d2 = d2 < dtr2 ? d2 : dtr2;
                                d2 = d2 < dbr2 ? d2 : dbr2;

                                if (distanceSqr > d2) {
                                    distanceSqr = d2;
                                    closest = i;
                                }
                            }
                        }

                        //Debug.Log("Word at Index: " + i + " is located at (" + bl + ", " + tl + ", " + tr + ", " + br + ").");
                    }

                    return closest;
                },
                /*TMPro.TMP_TextUtilities.FindNearestWord:static end.*/

                /*TMPro.TMP_TextUtilities.FindIntersectingLine:static start.*/
                /**
                 * Function returning the index of the word at the given position (if any).
                 * Function returning the index of the word at the given position (if any).
                 * Function returning the line intersecting the position.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_TextUtilities
                 * @memberof TMPro.TMP_TextUtilities
                 * @param   {TMPro.TMP_Text}         text        A reference to the TextMeshPro UGUI component.
                 * @param   {UnityEngine.Vector3}    position    Position to check for intersection.
                 * @param   {UnityEngine.Camera}     camera      The camera which is rendering the text object.
                 * @return  {number}
                 */
                FindIntersectingLine: function (text, position, camera) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextUtilities#FindIntersectingLine", this ); }

                    var $t;
                    position = {v:position};
                    var rectTransform = text.rectTransform$1;

                    var closest = -1;

                    // Convert position into Worldspace coordinates
                    TMPro.TMP_TextUtilities.ScreenPointToWorldPointInRectangle(rectTransform, UnityEngine.Vector2.FromVector3(position.v.$clone()), camera, position);

                    for (var i = 0; i < text.textInfo.lineCount; i++) {
                        var lineInfo = ($t = text.textInfo.lineInfo)[i].$clone();

                        var ascender = rectTransform.TransformPoint$1(new pc.Vec3( 0, lineInfo.ascender, 0 )).y;
                        var descender = rectTransform.TransformPoint$1(new pc.Vec3( 0, lineInfo.descender, 0 )).y;

                        if (ascender > position.v.y && descender < position.v.y) {
                            //Debug.Log("Position is on line " + i);
                            return i;
                        }
                    }

                    //Debug.Log("Closest line to position is " + closest);
                    return closest;
                },
                /*TMPro.TMP_TextUtilities.FindIntersectingLine:static end.*/

                /*TMPro.TMP_TextUtilities.FindIntersectingLink:static start.*/
                /**
                 * Function returning the index of the Link at the given position (if any).
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_TextUtilities
                 * @memberof TMPro.TMP_TextUtilities
                 * @param   {TMPro.TMP_Text}         text        A reference to the TMP_Text component.
                 * @param   {UnityEngine.Vector3}    position    Position to check for intersection.
                 * @param   {UnityEngine.Camera}     camera      The scene camera which may be assigned to a Canvas using ScreenSpace Camera or WorldSpace render mode. Set to null is using ScreenSpace Overlay.
                 * @return  {number}
                 */
                FindIntersectingLink: function (text, position, camera) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextUtilities#FindIntersectingLink", this ); }

                    var $t, $t1, $t2;
                    position = {v:position};
                    var rectTransform = text.transform$1;

                    // Convert position into Worldspace coordinates
                    TMPro.TMP_TextUtilities.ScreenPointToWorldPointInRectangle(rectTransform, UnityEngine.Vector2.FromVector3(position.v.$clone()), camera, position);

                    for (var i = 0; i < text.textInfo.linkCount; i++) {
                        var linkInfo = ($t = text.textInfo.linkInfo)[i].$clone();

                        var isBeginRegion = false;

                        var bl = pc.Vec3.ZERO.clone();
                        var tl = pc.Vec3.ZERO.clone();
                        var br = pc.Vec3.ZERO.clone();
                        var tr = pc.Vec3.ZERO.clone();

                        // Iterate through each character of the word
                        for (var j = 0; j < linkInfo.linkTextLength; j++) {
                            var characterIndex = linkInfo.linkTextfirstCharacterIndex + j;
                            var currentCharInfo = ($t1 = text.textInfo.characterInfo)[characterIndex].$clone();
                            var currentLine = currentCharInfo.lineNumber;

                            // Check if Link characters are on the current page
                            if (text.overflowMode === TMPro.TextOverflowModes.Page && currentCharInfo.pageNumber + 1 !== text.pageToDisplay) {
                                continue;
                            }

                            if (isBeginRegion === false) {
                                isBeginRegion = true;

                                bl = rectTransform.TransformPoint$1(new pc.Vec3( currentCharInfo.bottomLeft.x, currentCharInfo.descender, 0 ));
                                tl = rectTransform.TransformPoint$1(new pc.Vec3( currentCharInfo.bottomLeft.x, currentCharInfo.ascender, 0 ));

                                //Debug.Log("Start Word Region at [" + currentCharInfo.character + "]");

                                // If Word is one character
                                if (linkInfo.linkTextLength === 1) {
                                    isBeginRegion = false;

                                    br = rectTransform.TransformPoint$1(new pc.Vec3( currentCharInfo.topRight.x, currentCharInfo.descender, 0 ));
                                    tr = rectTransform.TransformPoint$1(new pc.Vec3( currentCharInfo.topRight.x, currentCharInfo.ascender, 0 ));

                                    // Check for Intersection
                                    if (TMPro.TMP_TextUtilities.PointIntersectRectangle(position.v.$clone(), bl.$clone(), tl.$clone(), tr.$clone(), br.$clone())) {
                                        return i;
                                    }

                                    //Debug.Log("End Word Region at [" + currentCharInfo.character + "]");
                                }
                            }

                            // Last Character of Word
                            if (isBeginRegion && j === linkInfo.linkTextLength - 1) {
                                isBeginRegion = false;

                                br = rectTransform.TransformPoint$1(new pc.Vec3( currentCharInfo.topRight.x, currentCharInfo.descender, 0 ));
                                tr = rectTransform.TransformPoint$1(new pc.Vec3( currentCharInfo.topRight.x, currentCharInfo.ascender, 0 ));

                                // Check for Intersection
                                if (TMPro.TMP_TextUtilities.PointIntersectRectangle(position.v.$clone(), bl.$clone(), tl.$clone(), tr.$clone(), br.$clone())) {
                                    return i;
                                }

                                //Debug.Log("End Word Region at [" + currentCharInfo.character + "]");
                            } else if (isBeginRegion && currentLine !== ($t2 = text.textInfo.characterInfo)[characterIndex + 1].lineNumber) {
                                isBeginRegion = false;

                                br = rectTransform.TransformPoint$1(new pc.Vec3( currentCharInfo.topRight.x, currentCharInfo.descender, 0 ));
                                tr = rectTransform.TransformPoint$1(new pc.Vec3( currentCharInfo.topRight.x, currentCharInfo.ascender, 0 ));

                                // Check for Intersection
                                if (TMPro.TMP_TextUtilities.PointIntersectRectangle(position.v.$clone(), bl.$clone(), tl.$clone(), tr.$clone(), br.$clone())) {
                                    return i;
                                }

                                //Debug.Log("End Word Region at [" + currentCharInfo.character + "]");
                            }
                        }

                        //Debug.Log("Word at Index: " + i + " is located at (" + bl + ", " + tl + ", " + tr + ", " + br + ").");
                    }

                    return -1;
                },
                /*TMPro.TMP_TextUtilities.FindIntersectingLink:static end.*/

                /*TMPro.TMP_TextUtilities.FindNearestLink:static start.*/
                /**
                 * Function returning the index of the Link at the given position (if any).
                 * Function returning the index of the Link at the given position (if any).
                 * Function returning the index of the word at the given position (if any).
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_TextUtilities
                 * @memberof TMPro.TMP_TextUtilities
                 * @param   {TMPro.TMP_Text}         text        A reference to the TMP_Text component.
                 * @param   {UnityEngine.Vector3}    position    Position to check for intersection.
                 * @param   {UnityEngine.Camera}     camera      The scene camera which may be assigned to a Canvas using ScreenSpace Camera or WorldSpace render mode. Set to null is using ScreenSpace Overlay.
                 * @return  {number}
                 */
                FindNearestLink: function (text, position, camera) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextUtilities#FindNearestLink", this ); }

                    var $t, $t1, $t2;
                    position = {v:position};
                    var rectTransform = text.rectTransform$1;

                    // Convert position into Worldspace coordinates
                    TMPro.TMP_TextUtilities.ScreenPointToWorldPointInRectangle(rectTransform, UnityEngine.Vector2.FromVector3(position.v.$clone()), camera, position);

                    var distanceSqr = window.Infinity;
                    var closest = 0;

                    for (var i = 0; i < text.textInfo.linkCount; i++) {
                        var linkInfo = ($t = text.textInfo.linkInfo)[i].$clone();

                        var isBeginRegion = false;

                        var bl = pc.Vec3.ZERO.clone();
                        var tl = pc.Vec3.ZERO.clone();
                        var br = pc.Vec3.ZERO.clone();
                        var tr = pc.Vec3.ZERO.clone();

                        // Iterate through each character of the link
                        for (var j = 0; j < linkInfo.linkTextLength; j++) {
                            var characterIndex = linkInfo.linkTextfirstCharacterIndex + j;
                            var currentCharInfo = ($t1 = text.textInfo.characterInfo)[characterIndex].$clone();
                            var currentLine = currentCharInfo.lineNumber;

                            // Check if Link characters are on the current page
                            if (text.overflowMode === TMPro.TextOverflowModes.Page && currentCharInfo.pageNumber + 1 !== text.pageToDisplay) {
                                continue;
                            }

                            if (isBeginRegion === false) {
                                isBeginRegion = true;

                                //Debug.Log("Start Word Region at [" + currentCharInfo.character + "]");

                                bl = rectTransform.TransformPoint$1(new pc.Vec3( currentCharInfo.bottomLeft.x, currentCharInfo.descender, 0 ));
                                tl = rectTransform.TransformPoint$1(new pc.Vec3( currentCharInfo.bottomLeft.x, currentCharInfo.ascender, 0 ));

                                // If Link is one character
                                if (linkInfo.linkTextLength === 1) {
                                    isBeginRegion = false;

                                    br = rectTransform.TransformPoint$1(new pc.Vec3( currentCharInfo.topRight.x, currentCharInfo.descender, 0 ));
                                    tr = rectTransform.TransformPoint$1(new pc.Vec3( currentCharInfo.topRight.x, currentCharInfo.ascender, 0 ));

                                    // Check for Intersection
                                    if (TMPro.TMP_TextUtilities.PointIntersectRectangle(position.v.$clone(), bl.$clone(), tl.$clone(), tr.$clone(), br.$clone())) {
                                        return i;
                                    }

                                    // Find the closest line segment to position.
                                    var dbl = TMPro.TMP_TextUtilities.DistanceToLine(bl.$clone(), tl.$clone(), position.v.$clone());
                                    var dtl = TMPro.TMP_TextUtilities.DistanceToLine(tl.$clone(), tr.$clone(), position.v.$clone());
                                    var dtr = TMPro.TMP_TextUtilities.DistanceToLine(tr.$clone(), br.$clone(), position.v.$clone());
                                    var dbr = TMPro.TMP_TextUtilities.DistanceToLine(br.$clone(), bl.$clone(), position.v.$clone());

                                    var d = dbl < dtl ? dbl : dtl;
                                    d = d < dtr ? d : dtr;
                                    d = d < dbr ? d : dbr;

                                    if (distanceSqr > d) {
                                        distanceSqr = d;
                                        closest = i;
                                    }
                                }
                            }

                            // Last Character of Word
                            if (isBeginRegion && j === linkInfo.linkTextLength - 1) {
                                isBeginRegion = false;

                                br = rectTransform.TransformPoint$1(new pc.Vec3( currentCharInfo.topRight.x, currentCharInfo.descender, 0 ));
                                tr = rectTransform.TransformPoint$1(new pc.Vec3( currentCharInfo.topRight.x, currentCharInfo.ascender, 0 ));

                                // Check for Intersection
                                if (TMPro.TMP_TextUtilities.PointIntersectRectangle(position.v.$clone(), bl.$clone(), tl.$clone(), tr.$clone(), br.$clone())) {
                                    return i;
                                }

                                // Find the closest line segment to position.
                                var dbl1 = TMPro.TMP_TextUtilities.DistanceToLine(bl.$clone(), tl.$clone(), position.v.$clone());
                                var dtl1 = TMPro.TMP_TextUtilities.DistanceToLine(tl.$clone(), tr.$clone(), position.v.$clone());
                                var dtr1 = TMPro.TMP_TextUtilities.DistanceToLine(tr.$clone(), br.$clone(), position.v.$clone());
                                var dbr1 = TMPro.TMP_TextUtilities.DistanceToLine(br.$clone(), bl.$clone(), position.v.$clone());

                                var d1 = dbl1 < dtl1 ? dbl1 : dtl1;
                                d1 = d1 < dtr1 ? d1 : dtr1;
                                d1 = d1 < dbr1 ? d1 : dbr1;

                                if (distanceSqr > d1) {
                                    distanceSqr = d1;
                                    closest = i;
                                }
                            } else if (isBeginRegion && currentLine !== ($t2 = text.textInfo.characterInfo)[characterIndex + 1].lineNumber) {
                                isBeginRegion = false;

                                br = rectTransform.TransformPoint$1(new pc.Vec3( currentCharInfo.topRight.x, currentCharInfo.descender, 0 ));
                                tr = rectTransform.TransformPoint$1(new pc.Vec3( currentCharInfo.topRight.x, currentCharInfo.ascender, 0 ));

                                // Check for Intersection
                                if (TMPro.TMP_TextUtilities.PointIntersectRectangle(position.v.$clone(), bl.$clone(), tl.$clone(), tr.$clone(), br.$clone())) {
                                    return i;
                                }

                                // Find the closest line segment to position.
                                var dbl2 = TMPro.TMP_TextUtilities.DistanceToLine(bl.$clone(), tl.$clone(), position.v.$clone());
                                var dtl2 = TMPro.TMP_TextUtilities.DistanceToLine(tl.$clone(), tr.$clone(), position.v.$clone());
                                var dtr2 = TMPro.TMP_TextUtilities.DistanceToLine(tr.$clone(), br.$clone(), position.v.$clone());
                                var dbr2 = TMPro.TMP_TextUtilities.DistanceToLine(br.$clone(), bl.$clone(), position.v.$clone());

                                var d2 = dbl2 < dtl2 ? dbl2 : dtl2;
                                d2 = d2 < dtr2 ? d2 : dtr2;
                                d2 = d2 < dbr2 ? d2 : dbr2;

                                if (distanceSqr > d2) {
                                    distanceSqr = d2;
                                    closest = i;
                                }
                            }
                        }

                        //Debug.Log("Word at Index: " + i + " is located at (" + bl + ", " + tl + ", " + tr + ", " + br + ").");
                    }

                    return closest;
                },
                /*TMPro.TMP_TextUtilities.FindNearestLink:static end.*/

                /*TMPro.TMP_TextUtilities.PointIntersectRectangle:static start.*/
                /**
                 * Function returning the index of the word at the given position (if any).
                 * Function returning the index of the word at the given position (if any).
                 * Function to check if a Point is contained within a Rectangle.
                 *
                 * @static
                 * @private
                 * @this TMPro.TMP_TextUtilities
                 * @memberof TMPro.TMP_TextUtilities
                 * @param   {UnityEngine.Vector3}    m    
                 * @param   {UnityEngine.Vector3}    a    
                 * @param   {UnityEngine.Vector3}    b    
                 * @param   {UnityEngine.Vector3}    c    
                 * @param   {UnityEngine.Vector3}    d
                 * @return  {boolean}
                 */
                PointIntersectRectangle: function (m, a, b, c, d) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextUtilities#PointIntersectRectangle", this ); }

                    var ab = b.$clone().sub( a );
                    var am = m.$clone().sub( a );
                    var bc = c.$clone().sub( b );
                    var bm = m.$clone().sub( b );

                    var abamDot = ab.dot( am );
                    var bcbmDot = bc.dot( bm );

                    return 0 <= abamDot && abamDot <= ab.dot( ab ) && 0 <= bcbmDot && bcbmDot <= bc.dot( bc );
                },
                /*TMPro.TMP_TextUtilities.PointIntersectRectangle:static end.*/

                /*TMPro.TMP_TextUtilities.ScreenPointToWorldPointInRectangle:static start.*/
                /**
                 * Method to convert ScreenPoint to WorldPoint aligned with Rectangle
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_TextUtilities
                 * @memberof TMPro.TMP_TextUtilities
                 * @param   {UnityEngine.Transform}    transform      
                 * @param   {UnityEngine.Vector2}      screenPoint    
                 * @param   {UnityEngine.Camera}       cam            
                 * @param   {UnityEngine.Vector3}      worldPoint
                 * @return  {boolean}
                 */
                ScreenPointToWorldPointInRectangle: function (transform, screenPoint, cam, worldPoint) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextUtilities#ScreenPointToWorldPointInRectangle", this ); }

                    worldPoint.v = UnityEngine.Vector3.FromVector2(pc.Vec2.ZERO.clone());
                    var ray = UnityEngine.RectTransformUtility.ScreenPointToRay(cam, screenPoint);

                    var enter = { };
                    if (!new UnityEngine.Plane.$ctor2(transform.rotation.transformVector( new pc.Vec3( 0, 0, -1 ) ), transform.position).Raycast(ray, enter)) {
                        return false;
                    }

                    worldPoint.v = ray.GetPoint(enter.v);

                    return true;
                },
                /*TMPro.TMP_TextUtilities.ScreenPointToWorldPointInRectangle:static end.*/

                /*TMPro.TMP_TextUtilities.IntersectLinePlane:static start.*/
                /**
                 * Function returning the point of intersection between a line and a plane.
                 *
                 * @static
                 * @private
                 * @this TMPro.TMP_TextUtilities
                 * @memberof TMPro.TMP_TextUtilities
                 * @param   {TMPro.TMP_TextUtilities.LineSegment}    line                 
                 * @param   {UnityEngine.Vector3}                    point                
                 * @param   {UnityEngine.Vector3}                    normal               
                 * @param   {UnityEngine.Vector3}                    intersectingPoint
                 * @return  {boolean}
                 */
                IntersectLinePlane: function (line, point, normal, intersectingPoint) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextUtilities#IntersectLinePlane", this ); }

                    intersectingPoint.v = pc.Vec3.ZERO.clone();
                    var u = line.Point2.$clone().sub( line.Point1 );
                    var w = line.Point1.$clone().sub( point );

                    var D = normal.dot( u );
                    var N = -normal.dot( w );

                    if (Math.abs(D) < Number.EPSILON) {
                        if (N === 0) {
                            return true;
                        } else {
                            return false;
                        }
                    }

                    var sI = N / D;

                    if (sI < 0 || sI > 1) {
                        return false;
                    }

                    intersectingPoint.v = line.Point1.$clone().add( u.clone().scale( sI ) );

                    return true;
                },
                /*TMPro.TMP_TextUtilities.IntersectLinePlane:static end.*/

                /*TMPro.TMP_TextUtilities.DistanceToLine:static start.*/
                /**
                 * Function returning the Square Distance from a Point to a Line.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_TextUtilities
                 * @memberof TMPro.TMP_TextUtilities
                 * @param   {UnityEngine.Vector3}    a        
                 * @param   {UnityEngine.Vector3}    b        
                 * @param   {UnityEngine.Vector3}    point
                 * @return  {number}
                 */
                DistanceToLine: function (a, b, point) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextUtilities#DistanceToLine", this ); }

                    var n = b.$clone().sub( a );
                    var pa = a.$clone().sub( point );

                    var c = n.dot( pa );

                    // Closest point is a
                    if (c > 0.0) {
                        return pa.dot( pa );
                    }

                    var bp = point.$clone().sub( b );

                    // Closest point is b
                    if (n.dot( bp ) > 0.0) {
                        return bp.dot( bp );
                    }

                    // Closest point is between a and b
                    var e = pa.$clone().sub( n.$clone().clone().scale( (c / n.dot( n )) ) );

                    return e.dot( e );
                },
                /*TMPro.TMP_TextUtilities.DistanceToLine:static end.*/

                /*TMPro.TMP_TextUtilities.ToLowerFast:static start.*/
                /**
                 * Get lowercase version of this ASCII character.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_TextUtilities
                 * @memberof TMPro.TMP_TextUtilities
                 * @param   {number}    c
                 * @return  {number}
                 */
                ToLowerFast: function (c) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextUtilities#ToLowerFast", this ); }

                    if (c > TMPro.TMP_TextUtilities.k_lookupStringL.length - 1) {
                        return c;
                    }

                    return TMPro.TMP_TextUtilities.k_lookupStringL.charCodeAt(c);
                },
                /*TMPro.TMP_TextUtilities.ToLowerFast:static end.*/

                /*TMPro.TMP_TextUtilities.ToUpperFast:static start.*/
                /**
                 * Get uppercase version of this ASCII character.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_TextUtilities
                 * @memberof TMPro.TMP_TextUtilities
                 * @param   {number}    c
                 * @return  {number}
                 */
                ToUpperFast: function (c) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextUtilities#ToUpperFast", this ); }

                    if (c > TMPro.TMP_TextUtilities.k_lookupStringU.length - 1) {
                        return c;
                    }

                    return TMPro.TMP_TextUtilities.k_lookupStringU.charCodeAt(c);
                },
                /*TMPro.TMP_TextUtilities.ToUpperFast:static end.*/

                /*TMPro.TMP_TextUtilities.ToUpperASCIIFast:static start.*/
                /**
                 * Get uppercase version of this ASCII character.
                 *
                 * @static
                 * @this TMPro.TMP_TextUtilities
                 * @memberof TMPro.TMP_TextUtilities
                 * @param   {number}    c
                 * @return  {number}
                 */
                ToUpperASCIIFast: function (c) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextUtilities#ToUpperASCIIFast", this ); }

                    if (System.Int64(c).gt(System.Int64(TMPro.TMP_TextUtilities.k_lookupStringU.length - 1))) {
                        return c;
                    }

                    return TMPro.TMP_TextUtilities.k_lookupStringU.charCodeAt(c);
                },
                /*TMPro.TMP_TextUtilities.ToUpperASCIIFast:static end.*/

                /*TMPro.TMP_TextUtilities.GetHashCode:static start.*/
                /**
                 * Returns the case insensitive hashcode for the given string.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_TextUtilities
                 * @memberof TMPro.TMP_TextUtilities
                 * @param   {string}    s
                 * @return  {number}
                 */
                GetHashCode: function (s) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextUtilities#GetHashCode", this ); }

                    var hashCode = 0;

                    for (var i = 0; i < s.length; i++) {
                        hashCode = ((hashCode << 5) + hashCode) ^ TMPro.TMP_TextUtilities.ToUpperFast(s.charCodeAt(i));
                    }

                    return hashCode;
                },
                /*TMPro.TMP_TextUtilities.GetHashCode:static end.*/

                /*TMPro.TMP_TextUtilities.GetSimpleHashCode:static start.*/
                /**
                 * Function which returns a simple hashcode from a string.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_TextUtilities
                 * @memberof TMPro.TMP_TextUtilities
                 * @param   {string}    s
                 * @return  {number}
                 */
                GetSimpleHashCode: function (s) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextUtilities#GetSimpleHashCode", this ); }

                    var hashCode = 0;

                    for (var i = 0; i < s.length; i++) {
                        hashCode = ((hashCode << 5) + hashCode) ^ s.charCodeAt(i);
                    }

                    return hashCode;
                },
                /*TMPro.TMP_TextUtilities.GetSimpleHashCode:static end.*/

                /*TMPro.TMP_TextUtilities.GetSimpleHashCodeLowercase:static start.*/
                /**
                 * Function which returns a simple hashcode from a string converted to lowercase.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_TextUtilities
                 * @memberof TMPro.TMP_TextUtilities
                 * @param   {string}    s
                 * @return  {number}
                 */
                GetSimpleHashCodeLowercase: function (s) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextUtilities#GetSimpleHashCodeLowercase", this ); }

                    var hashCode = 5381;

                    for (var i = 0; i < s.length; i++) {
                        hashCode = ((hashCode << 5) + hashCode) ^ TMPro.TMP_TextUtilities.ToLowerFast(s.charCodeAt(i));
                    }

                    return hashCode;
                },
                /*TMPro.TMP_TextUtilities.GetSimpleHashCodeLowercase:static end.*/

                /*TMPro.TMP_TextUtilities.HexToInt:static start.*/
                /**
                 * Function to convert Hex to Int
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_TextUtilities
                 * @memberof TMPro.TMP_TextUtilities
                 * @param   {number}    hex
                 * @return  {number}
                 */
                HexToInt: function (hex) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextUtilities#HexToInt", this ); }

                    switch (hex) {
                        case 48: 
                            return 0;
                        case 49: 
                            return 1;
                        case 50: 
                            return 2;
                        case 51: 
                            return 3;
                        case 52: 
                            return 4;
                        case 53: 
                            return 5;
                        case 54: 
                            return 6;
                        case 55: 
                            return 7;
                        case 56: 
                            return 8;
                        case 57: 
                            return 9;
                        case 65: 
                            return 10;
                        case 66: 
                            return 11;
                        case 67: 
                            return 12;
                        case 68: 
                            return 13;
                        case 69: 
                            return 14;
                        case 70: 
                            return 15;
                        case 97: 
                            return 10;
                        case 98: 
                            return 11;
                        case 99: 
                            return 12;
                        case 100: 
                            return 13;
                        case 101: 
                            return 14;
                        case 102: 
                            return 15;
                    }

                    return 15;
                },
                /*TMPro.TMP_TextUtilities.HexToInt:static end.*/

                /*TMPro.TMP_TextUtilities.StringHexToInt:static start.*/
                /**
                 * Function to convert a properly formatted string which contains an hex value to its decimal value.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_TextUtilities
                 * @memberof TMPro.TMP_TextUtilities
                 * @param   {string}    s
                 * @return  {number}
                 */
                StringHexToInt: function (s) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextUtilities#StringHexToInt", this ); }

                    var value = 0;

                    for (var i = 0; i < s.length; i++) {
                        value += TMPro.TMP_TextUtilities.HexToInt(s.charCodeAt(i)) * Math.pow(16, s.length - 1 - i);
                    }

                    return value;
                },
                /*TMPro.TMP_TextUtilities.StringHexToInt:static end.*/


            }
        }
    });
    /*TMPro.TMP_TextUtilities end.*/

    /*TMPro.TMP_TextUtilities+LineSegment start.*/
    Bridge.define("TMPro.TMP_TextUtilities.LineSegment", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextUtilities.LineSegment#getDefaultValue", this ); }
 return new TMPro.TMP_TextUtilities.LineSegment(); }
            }
        },
        fields: {
            Point1: null,
            Point2: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextUtilities.LineSegment#init", this ); }

                this.Point1 = new UnityEngine.Vector3();
                this.Point2 = new UnityEngine.Vector3();
            },
            $ctor1: function (p1, p2) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextUtilities.LineSegment#$ctor1", this ); }

                this.$initialize();
                this.Point1 = p1.$clone();
                this.Point2 = p2.$clone();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextUtilities.LineSegment#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_TextUtilities.LineSegment#getHashCode", this ); }

                var h = Bridge.addHash([3544857860, this.Point1, this.Point2]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextUtilities.LineSegment#equals", this ); }

                if (!Bridge.is(o, TMPro.TMP_TextUtilities.LineSegment)) {
                    return false;
                }
                return Bridge.equals(this.Point1, o.Point1) && Bridge.equals(this.Point2, o.Point2);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.TMP_TextUtilities.LineSegment#$clone", this ); }

                var s = to || new TMPro.TMP_TextUtilities.LineSegment();
                s.Point1 = this.Point1.$clone();
                s.Point2 = this.Point2.$clone();
                return s;
            }
        }
    });
    /*TMPro.TMP_TextUtilities+LineSegment end.*/

    /*TMPro.TMP_UpdateManager start.*/
    Bridge.define("TMPro.TMP_UpdateManager", {
        statics: {
            fields: {
                s_Instance: null
            },
            props: {
                /**
                 * Get a singleton instance of the registry
                 *
                 * @static
                 * @private
                 * @readonly
                 * @memberof TMPro.TMP_UpdateManager
                 * @function instance
                 * @type TMPro.TMP_UpdateManager
                 */
                instance: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_UpdateManager#instance#get", this ); }

                        if (TMPro.TMP_UpdateManager.s_Instance == null) {
                            TMPro.TMP_UpdateManager.s_Instance = new TMPro.TMP_UpdateManager();
                        }

                        return TMPro.TMP_UpdateManager.s_Instance;
                    }
                }
            },
            methods: {
                /*TMPro.TMP_UpdateManager.RegisterTextObjectForUpdate:static start.*/
                /**
                 * Function used as a replacement for LateUpdate() to handle SDF Scale updates and Legacy Animation updates.
                 *
                 * @static
                 * @this TMPro.TMP_UpdateManager
                 * @memberof TMPro.TMP_UpdateManager
                 * @param   {TMPro.TMP_Text}    textObject
                 * @return  {void}
                 */
                RegisterTextObjectForUpdate: function (textObject) {
if ( TRACE ) { TRACE( "TMPro.TMP_UpdateManager#RegisterTextObjectForUpdate", this ); }

                    TMPro.TMP_UpdateManager.instance.InternalRegisterTextObjectForUpdate(textObject);
                },
                /*TMPro.TMP_UpdateManager.RegisterTextObjectForUpdate:static end.*/

                /*TMPro.TMP_UpdateManager.RegisterTextElementForLayoutRebuild:static start.*/
                /**
                 * Function to register elements which require a layout rebuild.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_UpdateManager
                 * @memberof TMPro.TMP_UpdateManager
                 * @param   {TMPro.TMP_Text}    element
                 * @return  {void}
                 */
                RegisterTextElementForLayoutRebuild: function (element) {
if ( TRACE ) { TRACE( "TMPro.TMP_UpdateManager#RegisterTextElementForLayoutRebuild", this ); }

                    TMPro.TMP_UpdateManager.instance.InternalRegisterTextElementForLayoutRebuild(element);
                },
                /*TMPro.TMP_UpdateManager.RegisterTextElementForLayoutRebuild:static end.*/

                /*TMPro.TMP_UpdateManager.RegisterTextElementForGraphicRebuild:static start.*/
                /**
                 * Function to register elements which require a layout rebuild.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_UpdateManager
                 * @memberof TMPro.TMP_UpdateManager
                 * @param   {TMPro.TMP_Text}    element
                 * @return  {void}
                 */
                RegisterTextElementForGraphicRebuild: function (element) {
if ( TRACE ) { TRACE( "TMPro.TMP_UpdateManager#RegisterTextElementForGraphicRebuild", this ); }

                    TMPro.TMP_UpdateManager.instance.InternalRegisterTextElementForGraphicRebuild(element);
                },
                /*TMPro.TMP_UpdateManager.RegisterTextElementForGraphicRebuild:static end.*/

                /*TMPro.TMP_UpdateManager.RegisterTextElementForCullingUpdate:static start.*/
                RegisterTextElementForCullingUpdate: function (element) {
if ( TRACE ) { TRACE( "TMPro.TMP_UpdateManager#RegisterTextElementForCullingUpdate", this ); }

                    TMPro.TMP_UpdateManager.instance.InternalRegisterTextElementForCullingUpdate(element);
                },
                /*TMPro.TMP_UpdateManager.RegisterTextElementForCullingUpdate:static end.*/

                /*TMPro.TMP_UpdateManager.UnRegisterTextObjectForUpdate:static start.*/
                UnRegisterTextObjectForUpdate: function (textObject) {
if ( TRACE ) { TRACE( "TMPro.TMP_UpdateManager#UnRegisterTextObjectForUpdate", this ); }

                    TMPro.TMP_UpdateManager.instance.InternalUnRegisterTextObjectForUpdate(textObject);
                },
                /*TMPro.TMP_UpdateManager.UnRegisterTextObjectForUpdate:static end.*/

                /*TMPro.TMP_UpdateManager.UnRegisterTextElementForRebuild:static start.*/
                /**
                 * Function to unregister elements which no longer require a rebuild.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_UpdateManager
                 * @memberof TMPro.TMP_UpdateManager
                 * @param   {TMPro.TMP_Text}    element
                 * @return  {void}
                 */
                UnRegisterTextElementForRebuild: function (element) {
if ( TRACE ) { TRACE( "TMPro.TMP_UpdateManager#UnRegisterTextElementForRebuild", this ); }

                    TMPro.TMP_UpdateManager.instance.InternalUnRegisterTextElementForGraphicRebuild(element);
                    TMPro.TMP_UpdateManager.instance.InternalUnRegisterTextElementForLayoutRebuild(element);
                    TMPro.TMP_UpdateManager.instance.InternalUnRegisterTextObjectForUpdate(element);
                },
                /*TMPro.TMP_UpdateManager.UnRegisterTextElementForRebuild:static end.*/


            }
        },
        fields: {
            m_LayoutQueueLookup: null,
            m_LayoutRebuildQueue: null,
            m_GraphicQueueLookup: null,
            m_GraphicRebuildQueue: null,
            m_InternalUpdateLookup: null,
            m_InternalUpdateQueue: null,
            m_CullingUpdateLookup: null,
            m_CullingUpdateQueue: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_UpdateManager#init", this ); }

                this.m_LayoutQueueLookup = new (System.Collections.Generic.HashSet$1(System.Int32)).ctor();
                this.m_LayoutRebuildQueue = new (System.Collections.Generic.List$1(TMPro.TMP_Text)).ctor();
                this.m_GraphicQueueLookup = new (System.Collections.Generic.HashSet$1(System.Int32)).ctor();
                this.m_GraphicRebuildQueue = new (System.Collections.Generic.List$1(TMPro.TMP_Text)).ctor();
                this.m_InternalUpdateLookup = new (System.Collections.Generic.HashSet$1(System.Int32)).ctor();
                this.m_InternalUpdateQueue = new (System.Collections.Generic.List$1(TMPro.TMP_Text)).ctor();
                this.m_CullingUpdateLookup = new (System.Collections.Generic.HashSet$1(System.Int32)).ctor();
                this.m_CullingUpdateQueue = new (System.Collections.Generic.List$1(TMPro.TMP_Text)).ctor();
            },
            /**
             * Register to receive rendering callbacks.
             *
             * @instance
             * @private
             * @this TMPro.TMP_UpdateManager
             * @memberof TMPro.TMP_UpdateManager
             * @return  {void}
             */
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_UpdateManager#ctor", this ); }

                this.$initialize();
                UnityEngine.Canvas.addwillRenderCanvases(Bridge.fn.cacheBind(this, this.DoRebuilds));
            }
        },
        methods: {
            /*TMPro.TMP_UpdateManager.InternalRegisterTextObjectForUpdate start.*/
            InternalRegisterTextObjectForUpdate: function (textObject) {
if ( TRACE ) { TRACE( "TMPro.TMP_UpdateManager#InternalRegisterTextObjectForUpdate", this ); }

                var id = textObject.GetInstanceID();

                if (this.m_InternalUpdateLookup.contains(id)) {
                    return;
                }

                this.m_InternalUpdateLookup.add(id);
                this.m_InternalUpdateQueue.add(textObject);
            },
            /*TMPro.TMP_UpdateManager.InternalRegisterTextObjectForUpdate end.*/

            /*TMPro.TMP_UpdateManager.InternalRegisterTextElementForLayoutRebuild start.*/
            InternalRegisterTextElementForLayoutRebuild: function (element) {
if ( TRACE ) { TRACE( "TMPro.TMP_UpdateManager#InternalRegisterTextElementForLayoutRebuild", this ); }

                var id = element.GetInstanceID();

                if (this.m_LayoutQueueLookup.contains(id)) {
                    return;
                }

                this.m_LayoutQueueLookup.add(id);
                this.m_LayoutRebuildQueue.add(element);
            },
            /*TMPro.TMP_UpdateManager.InternalRegisterTextElementForLayoutRebuild end.*/

            /*TMPro.TMP_UpdateManager.InternalRegisterTextElementForGraphicRebuild start.*/
            InternalRegisterTextElementForGraphicRebuild: function (element) {
if ( TRACE ) { TRACE( "TMPro.TMP_UpdateManager#InternalRegisterTextElementForGraphicRebuild", this ); }

                var id = element.GetInstanceID();

                if (this.m_GraphicQueueLookup.contains(id)) {
                    return;
                }

                this.m_GraphicQueueLookup.add(id);
                this.m_GraphicRebuildQueue.add(element);
            },
            /*TMPro.TMP_UpdateManager.InternalRegisterTextElementForGraphicRebuild end.*/

            /*TMPro.TMP_UpdateManager.InternalRegisterTextElementForCullingUpdate start.*/
            InternalRegisterTextElementForCullingUpdate: function (element) {
if ( TRACE ) { TRACE( "TMPro.TMP_UpdateManager#InternalRegisterTextElementForCullingUpdate", this ); }

                var id = element.GetInstanceID();

                if (this.m_CullingUpdateLookup.contains(id)) {
                    return;
                }

                this.m_CullingUpdateLookup.add(id);
                this.m_CullingUpdateQueue.add(element);
            },
            /*TMPro.TMP_UpdateManager.InternalRegisterTextElementForCullingUpdate end.*/

            /*TMPro.TMP_UpdateManager.OnCameraPreCull start.*/
            /**
             * Callback which occurs just before the cam is rendered.
             *
             * @instance
             * @private
             * @this TMPro.TMP_UpdateManager
             * @memberof TMPro.TMP_UpdateManager
             * @return  {void}
             */
            OnCameraPreCull: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_UpdateManager#OnCameraPreCull", this ); }

                this.DoRebuilds();
            },
            /*TMPro.TMP_UpdateManager.OnCameraPreCull end.*/

            /*TMPro.TMP_UpdateManager.DoRebuilds start.*/
            /**
             * Process the rebuild requests in the rebuild queues.
             *
             * @instance
             * @private
             * @this TMPro.TMP_UpdateManager
             * @memberof TMPro.TMP_UpdateManager
             * @return  {void}
             */
            DoRebuilds: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_UpdateManager#DoRebuilds", this ); }

                // Handle text objects the require an update either as a result of scale changes or legacy animation.
                for (var i = 0; i < this.m_InternalUpdateQueue.Count; i++) {
                    this.m_InternalUpdateQueue.getItem(i).InternalUpdate();
                }

                // Handle Layout Rebuild Phase
                for (var i1 = 0; i1 < this.m_LayoutRebuildQueue.Count; i1++) {
                    this.m_LayoutRebuildQueue.getItem(i1).Rebuild(UnityEngine.UI.CanvasUpdate.Prelayout);
                }

                if (this.m_LayoutRebuildQueue.Count > 0) {
                    this.m_LayoutRebuildQueue.clear();
                    this.m_LayoutQueueLookup.clear();
                }

                // Handle Graphic Rebuild Phase
                for (var i2 = 0; i2 < this.m_GraphicRebuildQueue.Count; i2++) {
                    this.m_GraphicRebuildQueue.getItem(i2).Rebuild(UnityEngine.UI.CanvasUpdate.PreRender);
                }

                // If there are no objects in the queue, we don't need to clear the lists again.
                if (this.m_GraphicRebuildQueue.Count > 0) {
                    this.m_GraphicRebuildQueue.clear();
                    this.m_GraphicQueueLookup.clear();
                }

                // Handle Culling Update
                for (var i3 = 0; i3 < this.m_CullingUpdateQueue.Count; i3++) {
                    this.m_CullingUpdateQueue.getItem(i3).UpdateCulling();
                }

                // If there are no objects in the queue, we don't need to clear the lists again.
                if (this.m_CullingUpdateQueue.Count > 0) {
                    this.m_CullingUpdateQueue.clear();
                    this.m_CullingUpdateLookup.clear();
                }
            },
            /*TMPro.TMP_UpdateManager.DoRebuilds end.*/

            /*TMPro.TMP_UpdateManager.InternalUnRegisterTextElementForGraphicRebuild start.*/
            InternalUnRegisterTextElementForGraphicRebuild: function (element) {
if ( TRACE ) { TRACE( "TMPro.TMP_UpdateManager#InternalUnRegisterTextElementForGraphicRebuild", this ); }

                var id = element.GetInstanceID();

                this.m_GraphicRebuildQueue.remove(element);
                this.m_GraphicQueueLookup.remove(id);
            },
            /*TMPro.TMP_UpdateManager.InternalUnRegisterTextElementForGraphicRebuild end.*/

            /*TMPro.TMP_UpdateManager.InternalUnRegisterTextElementForLayoutRebuild start.*/
            InternalUnRegisterTextElementForLayoutRebuild: function (element) {
if ( TRACE ) { TRACE( "TMPro.TMP_UpdateManager#InternalUnRegisterTextElementForLayoutRebuild", this ); }

                var id = element.GetInstanceID();

                this.m_LayoutRebuildQueue.remove(element);
                this.m_LayoutQueueLookup.remove(id);
            },
            /*TMPro.TMP_UpdateManager.InternalUnRegisterTextElementForLayoutRebuild end.*/

            /*TMPro.TMP_UpdateManager.InternalUnRegisterTextObjectForUpdate start.*/
            InternalUnRegisterTextObjectForUpdate: function (textObject) {
if ( TRACE ) { TRACE( "TMPro.TMP_UpdateManager#InternalUnRegisterTextObjectForUpdate", this ); }

                var id = textObject.GetInstanceID();

                this.m_InternalUpdateQueue.remove(textObject);
                this.m_InternalUpdateLookup.remove(id);
            },
            /*TMPro.TMP_UpdateManager.InternalUnRegisterTextObjectForUpdate end.*/


        }
    });
    /*TMPro.TMP_UpdateManager end.*/

    /*TMPro.TMP_UpdateRegistry start.*/
    /**
     * Class for handling and scheduling text object updates.
     *
     * @public
     * @class TMPro.TMP_UpdateRegistry
     */
    Bridge.define("TMPro.TMP_UpdateRegistry", {
        statics: {
            fields: {
                s_Instance: null
            },
            props: {
                /**
                 * Get a singleton instance of the registry
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof TMPro.TMP_UpdateRegistry
                 * @function instance
                 * @type TMPro.TMP_UpdateRegistry
                 */
                instance: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_UpdateRegistry#instance#get", this ); }

                        if (TMPro.TMP_UpdateRegistry.s_Instance == null) {
                            TMPro.TMP_UpdateRegistry.s_Instance = new TMPro.TMP_UpdateRegistry();
                        }

                        return TMPro.TMP_UpdateRegistry.s_Instance;
                    }
                }
            },
            methods: {
                /*TMPro.TMP_UpdateRegistry.RegisterCanvasElementForLayoutRebuild:static start.*/
                /**
                 * Function to register elements which require a layout rebuild.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_UpdateRegistry
                 * @memberof TMPro.TMP_UpdateRegistry
                 * @param   {UnityEngine.UI.ICanvasElement}    element
                 * @return  {void}
                 */
                RegisterCanvasElementForLayoutRebuild: function (element) {
if ( TRACE ) { TRACE( "TMPro.TMP_UpdateRegistry#RegisterCanvasElementForLayoutRebuild", this ); }

                    TMPro.TMP_UpdateRegistry.instance.InternalRegisterCanvasElementForLayoutRebuild(element);
                },
                /*TMPro.TMP_UpdateRegistry.RegisterCanvasElementForLayoutRebuild:static end.*/

                /*TMPro.TMP_UpdateRegistry.RegisterCanvasElementForGraphicRebuild:static start.*/
                /**
                 * Function to register elements which require a graphic rebuild.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_UpdateRegistry
                 * @memberof TMPro.TMP_UpdateRegistry
                 * @param   {UnityEngine.UI.ICanvasElement}    element
                 * @return  {void}
                 */
                RegisterCanvasElementForGraphicRebuild: function (element) {
if ( TRACE ) { TRACE( "TMPro.TMP_UpdateRegistry#RegisterCanvasElementForGraphicRebuild", this ); }

                    TMPro.TMP_UpdateRegistry.instance.InternalRegisterCanvasElementForGraphicRebuild(element);
                },
                /*TMPro.TMP_UpdateRegistry.RegisterCanvasElementForGraphicRebuild:static end.*/

                /*TMPro.TMP_UpdateRegistry.UnRegisterCanvasElementForRebuild:static start.*/
                /**
                 * Function to unregister elements which no longer require a rebuild.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_UpdateRegistry
                 * @memberof TMPro.TMP_UpdateRegistry
                 * @param   {UnityEngine.UI.ICanvasElement}    element
                 * @return  {void}
                 */
                UnRegisterCanvasElementForRebuild: function (element) {
if ( TRACE ) { TRACE( "TMPro.TMP_UpdateRegistry#UnRegisterCanvasElementForRebuild", this ); }

                    TMPro.TMP_UpdateRegistry.instance.InternalUnRegisterCanvasElementForLayoutRebuild(element);
                    TMPro.TMP_UpdateRegistry.instance.InternalUnRegisterCanvasElementForGraphicRebuild(element);
                },
                /*TMPro.TMP_UpdateRegistry.UnRegisterCanvasElementForRebuild:static end.*/


            }
        },
        fields: {
            m_LayoutRebuildQueue: null,
            m_LayoutQueueLookup: null,
            m_GraphicRebuildQueue: null,
            m_GraphicQueueLookup: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_UpdateRegistry#init", this ); }

                this.m_LayoutRebuildQueue = new (System.Collections.Generic.List$1(UnityEngine.UI.ICanvasElement)).ctor();
                this.m_LayoutQueueLookup = new (System.Collections.Generic.HashSet$1(System.Int32)).ctor();
                this.m_GraphicRebuildQueue = new (System.Collections.Generic.List$1(UnityEngine.UI.ICanvasElement)).ctor();
                this.m_GraphicQueueLookup = new (System.Collections.Generic.HashSet$1(System.Int32)).ctor();
            },
            /**
             * Register to receive callback from the Canvas System.
             *
             * @instance
             * @protected
             * @this TMPro.TMP_UpdateRegistry
             * @memberof TMPro.TMP_UpdateRegistry
             * @return  {void}
             */
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_UpdateRegistry#ctor", this ); }

                this.$initialize();
                //Debug.Log("Adding WillRenderCanvases");
                UnityEngine.Canvas.addwillRenderCanvases(Bridge.fn.cacheBind(this, this.PerformUpdateForCanvasRendererObjects));
            }
        },
        methods: {
            /*TMPro.TMP_UpdateRegistry.InternalRegisterCanvasElementForLayoutRebuild start.*/
            InternalRegisterCanvasElementForLayoutRebuild: function (element) {
if ( TRACE ) { TRACE( "TMPro.TMP_UpdateRegistry#InternalRegisterCanvasElementForLayoutRebuild", this ); }

                var id = (Bridge.as(element, UnityEngine.Object)).GetInstanceID();

                if (this.m_LayoutQueueLookup.contains(id)) {
                    return false;
                }

                this.m_LayoutQueueLookup.add(id);
                this.m_LayoutRebuildQueue.add(element);

                return true;
            },
            /*TMPro.TMP_UpdateRegistry.InternalRegisterCanvasElementForLayoutRebuild end.*/

            /*TMPro.TMP_UpdateRegistry.InternalRegisterCanvasElementForGraphicRebuild start.*/
            InternalRegisterCanvasElementForGraphicRebuild: function (element) {
if ( TRACE ) { TRACE( "TMPro.TMP_UpdateRegistry#InternalRegisterCanvasElementForGraphicRebuild", this ); }

                var id = (Bridge.as(element, UnityEngine.Object)).GetInstanceID();

                if (this.m_GraphicQueueLookup.contains(id)) {
                    return false;
                }

                this.m_GraphicQueueLookup.add(id);
                this.m_GraphicRebuildQueue.add(element);

                return true;
            },
            /*TMPro.TMP_UpdateRegistry.InternalRegisterCanvasElementForGraphicRebuild end.*/

            /*TMPro.TMP_UpdateRegistry.PerformUpdateForCanvasRendererObjects start.*/
            /**
             * Method to handle objects that need updating.
             *
             * @instance
             * @private
             * @this TMPro.TMP_UpdateRegistry
             * @memberof TMPro.TMP_UpdateRegistry
             * @return  {void}
             */
            PerformUpdateForCanvasRendererObjects: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_UpdateRegistry#PerformUpdateForCanvasRendererObjects", this ); }

                //Debug.Log("Performing update of CanvasRenderer objects at Frame: " + Time.frameCount);

                // Processing elements that require a layout rebuild.
                //this.m_PerformingLayoutUpdate = true;
                for (var index = 0; index < this.m_LayoutRebuildQueue.Count; index++) {
                    var element = TMPro.TMP_UpdateRegistry.instance.m_LayoutRebuildQueue.getItem(index);

                    element.UnityEngine$UI$ICanvasElement$Rebuild(UnityEngine.UI.CanvasUpdate.Prelayout);
                }

                if (this.m_LayoutRebuildQueue.Count > 0) {
                    this.m_LayoutRebuildQueue.clear();
                    this.m_LayoutQueueLookup.clear();
                }

                // Update font assets before graphic rebuild


                // Processing elements that require a graphic rebuild.
                for (var index1 = 0; index1 < this.m_GraphicRebuildQueue.Count; index1++) {
                    var element1 = TMPro.TMP_UpdateRegistry.instance.m_GraphicRebuildQueue.getItem(index1);

                    element1.UnityEngine$UI$ICanvasElement$Rebuild(UnityEngine.UI.CanvasUpdate.PreRender);
                }

                // If there are no objects in the queue, we don't need to clear the lists again.
                if (this.m_GraphicRebuildQueue.Count > 0) {
                    this.m_GraphicRebuildQueue.clear();
                    this.m_GraphicQueueLookup.clear();
                }
            },
            /*TMPro.TMP_UpdateRegistry.PerformUpdateForCanvasRendererObjects end.*/

            /*TMPro.TMP_UpdateRegistry.PerformUpdateForMeshRendererObjects start.*/
            /**
             * Method to handle objects that need updating.
             *
             * @instance
             * @private
             * @this TMPro.TMP_UpdateRegistry
             * @memberof TMPro.TMP_UpdateRegistry
             * @return  {void}
             */
            PerformUpdateForMeshRendererObjects: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_UpdateRegistry#PerformUpdateForMeshRendererObjects", this ); }

                UnityEngine.Debug.Log$1("Perform update of MeshRenderer objects.");
            },
            /*TMPro.TMP_UpdateRegistry.PerformUpdateForMeshRendererObjects end.*/

            /*TMPro.TMP_UpdateRegistry.InternalUnRegisterCanvasElementForLayoutRebuild start.*/
            InternalUnRegisterCanvasElementForLayoutRebuild: function (element) {
if ( TRACE ) { TRACE( "TMPro.TMP_UpdateRegistry#InternalUnRegisterCanvasElementForLayoutRebuild", this ); }

                var id = (Bridge.as(element, UnityEngine.Object)).GetInstanceID();

                //element.LayoutComplete();
                TMPro.TMP_UpdateRegistry.instance.m_LayoutRebuildQueue.remove(element);
                this.m_GraphicQueueLookup.remove(id);
            },
            /*TMPro.TMP_UpdateRegistry.InternalUnRegisterCanvasElementForLayoutRebuild end.*/

            /*TMPro.TMP_UpdateRegistry.InternalUnRegisterCanvasElementForGraphicRebuild start.*/
            InternalUnRegisterCanvasElementForGraphicRebuild: function (element) {
if ( TRACE ) { TRACE( "TMPro.TMP_UpdateRegistry#InternalUnRegisterCanvasElementForGraphicRebuild", this ); }

                var id = (Bridge.as(element, UnityEngine.Object)).GetInstanceID();

                //element.GraphicUpdateComplete();
                TMPro.TMP_UpdateRegistry.instance.m_GraphicRebuildQueue.remove(element);
                this.m_LayoutQueueLookup.remove(id);
            },
            /*TMPro.TMP_UpdateRegistry.InternalUnRegisterCanvasElementForGraphicRebuild end.*/


        }
    });
    /*TMPro.TMP_UpdateRegistry end.*/

    /*TMPro.TMP_Vertex start.*/
    Bridge.define("TMPro.TMP_Vertex", {
        $kind: 4,
        statics: {
            fields: {
                k_Zero: null
            },
            props: {
                zero: {
                    get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Vertex#zero#get", this ); }

                        return TMPro.TMP_Vertex.k_Zero.$clone();
                    }
                }
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Vertex#init", this ); }

                    this.k_Zero = new TMPro.TMP_Vertex();
                }
            },
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Vertex#getDefaultValue", this ); }
 return new TMPro.TMP_Vertex(); }
            }
        },
        fields: {
            position: null,
            uv: null,
            uv2: null,
            uv4: null,
            color: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Vertex#init", this ); }

                this.position = new UnityEngine.Vector3();
                this.uv = new UnityEngine.Vector2();
                this.uv2 = new UnityEngine.Vector2();
                this.uv4 = new UnityEngine.Vector2();
                this.color = new UnityEngine.Color32();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Vertex#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Vertex#getHashCode", this ); }

                var h = Bridge.addHash([3552783119, this.position, this.uv, this.uv2, this.uv4, this.color]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.TMP_Vertex#equals", this ); }

                if (!Bridge.is(o, TMPro.TMP_Vertex)) {
                    return false;
                }
                return Bridge.equals(this.position, o.position) && Bridge.equals(this.uv, o.uv) && Bridge.equals(this.uv2, o.uv2) && Bridge.equals(this.uv4, o.uv4) && Bridge.equals(this.color, o.color);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.TMP_Vertex#$clone", this ); }

                var s = to || new TMPro.TMP_Vertex();
                s.position = this.position.$clone();
                s.uv = this.uv.$clone();
                s.uv2 = this.uv2.$clone();
                s.uv4 = this.uv4.$clone();
                s.color = this.color.$clone();
                return s;
            }
        }
    });
    /*TMPro.TMP_Vertex end.*/

    /*TMPro.TMP_VertexDataUpdateFlags start.*/
    /**
     * Flags to control what vertex data is pushed to the mesh and renderer.
     *
     * @public
     * @class TMPro.TMP_VertexDataUpdateFlags
     */
    Bridge.define("TMPro.TMP_VertexDataUpdateFlags", {
        $kind: 6,
        statics: {
            fields: {
                None: 0,
                Vertices: 1,
                Uv0: 2,
                Uv2: 4,
                Uv4: 8,
                Colors32: 16,
                All: 255
            }
        }
    });
    /*TMPro.TMP_VertexDataUpdateFlags end.*/

    /*TMPro.TMP_WordInfo start.*/
    /**
     * Structure containing information about the individual words contained in the text object.
     *
     * @public
     * @class TMPro.TMP_WordInfo
     */
    Bridge.define("TMPro.TMP_WordInfo", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_WordInfo#getDefaultValue", this ); }
 return new TMPro.TMP_WordInfo(); }
            }
        },
        fields: {
            textComponent: null,
            firstCharacterIndex: 0,
            lastCharacterIndex: 0,
            characterCount: 0
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_WordInfo#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*TMPro.TMP_WordInfo.GetWord start.*/
            /**
             * Returns the word as a string.
             *
             * @instance
             * @public
             * @this TMPro.TMP_WordInfo
             * @memberof TMPro.TMP_WordInfo
             * @return  {string}
             */
            GetWord: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_WordInfo#GetWord", this ); }

                var word = "";
                var charInfo = this.textComponent.textInfo.characterInfo;

                for (var i = this.firstCharacterIndex; i < this.lastCharacterIndex + 1; i++) {
                    word = (word || "") + String.fromCharCode(charInfo[i].character);
                }

                return word;
            },
            /*TMPro.TMP_WordInfo.GetWord end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_WordInfo#getHashCode", this ); }

                var h = Bridge.addHash([5153303284, this.textComponent, this.firstCharacterIndex, this.lastCharacterIndex, this.characterCount]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.TMP_WordInfo#equals", this ); }

                if (!Bridge.is(o, TMPro.TMP_WordInfo)) {
                    return false;
                }
                return Bridge.equals(this.textComponent, o.textComponent) && Bridge.equals(this.firstCharacterIndex, o.firstCharacterIndex) && Bridge.equals(this.lastCharacterIndex, o.lastCharacterIndex) && Bridge.equals(this.characterCount, o.characterCount);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.TMP_WordInfo#$clone", this ); }

                var s = to || new TMPro.TMP_WordInfo();
                s.textComponent = this.textComponent;
                s.firstCharacterIndex = this.firstCharacterIndex;
                s.lastCharacterIndex = this.lastCharacterIndex;
                s.characterCount = this.characterCount;
                return s;
            }
        }
    });
    /*TMPro.TMP_WordInfo end.*/

    /*TMPro.TMPro_EventManager start.*/
    Bridge.define("TMPro.TMPro_EventManager", {
        statics: {
            fields: {
                COMPUTE_DT_EVENT: null,
                MATERIAL_PROPERTY_EVENT: null,
                FONT_PROPERTY_EVENT: null,
                SPRITE_ASSET_PROPERTY_EVENT: null,
                TEXTMESHPRO_PROPERTY_EVENT: null,
                DRAG_AND_DROP_MATERIAL_EVENT: null,
                TEXT_STYLE_PROPERTY_EVENT: null,
                COLOR_GRADIENT_PROPERTY_EVENT: null,
                TMP_SETTINGS_PROPERTY_EVENT: null,
                RESOURCE_LOAD_EVENT: null,
                TEXTMESHPRO_UGUI_PROPERTY_EVENT: null,
                TEXT_CHANGED_EVENT: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "TMPro.TMPro_EventManager#init", this ); }

                    this.COMPUTE_DT_EVENT = new (TMPro.FastAction$2(System.Object,TMPro.Compute_DT_EventArgs))();
                    this.MATERIAL_PROPERTY_EVENT = new (TMPro.FastAction$2(System.Boolean,UnityEngine.Material))();
                    this.FONT_PROPERTY_EVENT = new (TMPro.FastAction$2(System.Boolean,UnityEngine.Object))();
                    this.SPRITE_ASSET_PROPERTY_EVENT = new (TMPro.FastAction$2(System.Boolean,UnityEngine.Object))();
                    this.TEXTMESHPRO_PROPERTY_EVENT = new (TMPro.FastAction$2(System.Boolean,UnityEngine.Object))();
                    this.DRAG_AND_DROP_MATERIAL_EVENT = new (TMPro.FastAction$3(UnityEngine.GameObject,UnityEngine.Material,UnityEngine.Material))();
                    this.TEXT_STYLE_PROPERTY_EVENT = new (TMPro.FastAction$1(System.Boolean))();
                    this.COLOR_GRADIENT_PROPERTY_EVENT = new (TMPro.FastAction$1(UnityEngine.Object))();
                    this.TMP_SETTINGS_PROPERTY_EVENT = new TMPro.FastAction();
                    this.RESOURCE_LOAD_EVENT = new TMPro.FastAction();
                    this.TEXTMESHPRO_UGUI_PROPERTY_EVENT = new (TMPro.FastAction$2(System.Boolean,UnityEngine.Object))();
                    this.TEXT_CHANGED_EVENT = new (TMPro.FastAction$1(UnityEngine.Object))();
                }
            },
            methods: {
                /*TMPro.TMPro_EventManager.ON_MATERIAL_PROPERTY_CHANGED:static start.*/
                ON_MATERIAL_PROPERTY_CHANGED: function (isChanged, mat) {
if ( TRACE ) { TRACE( "TMPro.TMPro_EventManager#ON_MATERIAL_PROPERTY_CHANGED", this ); }

                    TMPro.TMPro_EventManager.MATERIAL_PROPERTY_EVENT.Call(isChanged, mat);
                },
                /*TMPro.TMPro_EventManager.ON_MATERIAL_PROPERTY_CHANGED:static end.*/

                /*TMPro.TMPro_EventManager.ON_FONT_PROPERTY_CHANGED:static start.*/
                ON_FONT_PROPERTY_CHANGED: function (isChanged, obj) {
if ( TRACE ) { TRACE( "TMPro.TMPro_EventManager#ON_FONT_PROPERTY_CHANGED", this ); }

                    TMPro.TMPro_EventManager.FONT_PROPERTY_EVENT.Call(isChanged, obj);
                },
                /*TMPro.TMPro_EventManager.ON_FONT_PROPERTY_CHANGED:static end.*/

                /*TMPro.TMPro_EventManager.ON_SPRITE_ASSET_PROPERTY_CHANGED:static start.*/
                ON_SPRITE_ASSET_PROPERTY_CHANGED: function (isChanged, obj) {
if ( TRACE ) { TRACE( "TMPro.TMPro_EventManager#ON_SPRITE_ASSET_PROPERTY_CHANGED", this ); }

                    TMPro.TMPro_EventManager.SPRITE_ASSET_PROPERTY_EVENT.Call(isChanged, obj);
                },
                /*TMPro.TMPro_EventManager.ON_SPRITE_ASSET_PROPERTY_CHANGED:static end.*/

                /*TMPro.TMPro_EventManager.ON_TEXTMESHPRO_PROPERTY_CHANGED:static start.*/
                ON_TEXTMESHPRO_PROPERTY_CHANGED: function (isChanged, obj) {
if ( TRACE ) { TRACE( "TMPro.TMPro_EventManager#ON_TEXTMESHPRO_PROPERTY_CHANGED", this ); }

                    TMPro.TMPro_EventManager.TEXTMESHPRO_PROPERTY_EVENT.Call(isChanged, obj);
                },
                /*TMPro.TMPro_EventManager.ON_TEXTMESHPRO_PROPERTY_CHANGED:static end.*/

                /*TMPro.TMPro_EventManager.ON_DRAG_AND_DROP_MATERIAL_CHANGED:static start.*/
                ON_DRAG_AND_DROP_MATERIAL_CHANGED: function (sender, currentMaterial, newMaterial) {
if ( TRACE ) { TRACE( "TMPro.TMPro_EventManager#ON_DRAG_AND_DROP_MATERIAL_CHANGED", this ); }

                    TMPro.TMPro_EventManager.DRAG_AND_DROP_MATERIAL_EVENT.Call(sender, currentMaterial, newMaterial);
                },
                /*TMPro.TMPro_EventManager.ON_DRAG_AND_DROP_MATERIAL_CHANGED:static end.*/

                /*TMPro.TMPro_EventManager.ON_TEXT_STYLE_PROPERTY_CHANGED:static start.*/
                ON_TEXT_STYLE_PROPERTY_CHANGED: function (isChanged) {
if ( TRACE ) { TRACE( "TMPro.TMPro_EventManager#ON_TEXT_STYLE_PROPERTY_CHANGED", this ); }

                    TMPro.TMPro_EventManager.TEXT_STYLE_PROPERTY_EVENT.Call(isChanged);
                },
                /*TMPro.TMPro_EventManager.ON_TEXT_STYLE_PROPERTY_CHANGED:static end.*/

                /*TMPro.TMPro_EventManager.ON_COLOR_GRADIENT_PROPERTY_CHANGED:static start.*/
                ON_COLOR_GRADIENT_PROPERTY_CHANGED: function (obj) {
if ( TRACE ) { TRACE( "TMPro.TMPro_EventManager#ON_COLOR_GRADIENT_PROPERTY_CHANGED", this ); }

                    TMPro.TMPro_EventManager.COLOR_GRADIENT_PROPERTY_EVENT.Call(obj);
                },
                /*TMPro.TMPro_EventManager.ON_COLOR_GRADIENT_PROPERTY_CHANGED:static end.*/

                /*TMPro.TMPro_EventManager.ON_TEXT_CHANGED:static start.*/
                ON_TEXT_CHANGED: function (obj) {
if ( TRACE ) { TRACE( "TMPro.TMPro_EventManager#ON_TEXT_CHANGED", this ); }

                    TMPro.TMPro_EventManager.TEXT_CHANGED_EVENT.Call(obj);
                },
                /*TMPro.TMPro_EventManager.ON_TEXT_CHANGED:static end.*/

                /*TMPro.TMPro_EventManager.ON_TMP_SETTINGS_CHANGED:static start.*/
                ON_TMP_SETTINGS_CHANGED: function () {
if ( TRACE ) { TRACE( "TMPro.TMPro_EventManager#ON_TMP_SETTINGS_CHANGED", this ); }

                    TMPro.TMPro_EventManager.TMP_SETTINGS_PROPERTY_EVENT.Call();
                },
                /*TMPro.TMPro_EventManager.ON_TMP_SETTINGS_CHANGED:static end.*/

                /*TMPro.TMPro_EventManager.ON_RESOURCES_LOADED:static start.*/
                ON_RESOURCES_LOADED: function () {
if ( TRACE ) { TRACE( "TMPro.TMPro_EventManager#ON_RESOURCES_LOADED", this ); }

                    TMPro.TMPro_EventManager.RESOURCE_LOAD_EVENT.Call();
                },
                /*TMPro.TMPro_EventManager.ON_RESOURCES_LOADED:static end.*/

                /*TMPro.TMPro_EventManager.ON_TEXTMESHPRO_UGUI_PROPERTY_CHANGED:static start.*/
                ON_TEXTMESHPRO_UGUI_PROPERTY_CHANGED: function (isChanged, obj) {
if ( TRACE ) { TRACE( "TMPro.TMPro_EventManager#ON_TEXTMESHPRO_UGUI_PROPERTY_CHANGED", this ); }

                    TMPro.TMPro_EventManager.TEXTMESHPRO_UGUI_PROPERTY_EVENT.Call(isChanged, obj);
                },
                /*TMPro.TMPro_EventManager.ON_TEXTMESHPRO_UGUI_PROPERTY_CHANGED:static end.*/

                /*TMPro.TMPro_EventManager.ON_COMPUTE_DT_EVENT:static start.*/
                ON_COMPUTE_DT_EVENT: function (Sender, e) {
if ( TRACE ) { TRACE( "TMPro.TMPro_EventManager#ON_COMPUTE_DT_EVENT", this ); }

                    TMPro.TMPro_EventManager.COMPUTE_DT_EVENT.Call(Sender, e);
                },
                /*TMPro.TMPro_EventManager.ON_COMPUTE_DT_EVENT:static end.*/


            }
        }
    });
    /*TMPro.TMPro_EventManager end.*/

    /*TMPro.TMPro_ExtensionMethods start.*/
    /**
     * Insert item into array at index.
     * Insert item into array at index.
     *
     * @static
     * @abstract
     * @public
     * @class TMPro.TMPro_ExtensionMethods
     * @param   {Function}    [name]    
     * @param   {Function}    [name]
     */
    Bridge.define("TMPro.TMPro_ExtensionMethods", {
        statics: {
            methods: {
                /*TMPro.TMPro_ExtensionMethods.ToIntArray:static start.*/
                ToIntArray: function (text) {
if ( TRACE ) { TRACE( "TMPro.TMPro_ExtensionMethods#ToIntArray", this ); }

                    var intArray = System.Array.init(text.length, 0, System.Int32);

                    for (var i = 0; i < text.length; i++) {
                        intArray[i] = text.charCodeAt(i);
                    }

                    return intArray;
                },
                /*TMPro.TMPro_ExtensionMethods.ToIntArray:static end.*/

                /*TMPro.TMPro_ExtensionMethods.ArrayToString:static start.*/
                ArrayToString: function (chars) {
if ( TRACE ) { TRACE( "TMPro.TMPro_ExtensionMethods#ArrayToString", this ); }

                    var s = "";

                    for (var i = 0; i < chars.length && chars[i] !== 0; i++) {
                        s = (s || "") + String.fromCharCode(chars[i]);
                    }

                    return s;
                },
                /*TMPro.TMPro_ExtensionMethods.ArrayToString:static end.*/

                /*TMPro.TMPro_ExtensionMethods.IntToString:static start.*/
                IntToString: function (unicodes) {
if ( TRACE ) { TRACE( "TMPro.TMPro_ExtensionMethods#IntToString", this ); }

                    var chars = System.Array.init(unicodes.length, 0, System.Char);

                    for (var i = 0; i < unicodes.length; i++) {
                        chars[i] = unicodes[i];
                    }

                    return System.String.fromCharArray(chars);
                },
                /*TMPro.TMPro_ExtensionMethods.IntToString:static end.*/

                /*TMPro.TMPro_ExtensionMethods.IntToString$1:static start.*/
                IntToString$1: function (unicodes, start, length) {
if ( TRACE ) { TRACE( "TMPro.TMPro_ExtensionMethods#IntToString$1", this ); }

                    if (start > unicodes.length) {
                        return "";
                    }

                    var end = UnityEngine.Mathf.Min(start + length, unicodes.length);

                    var chars = System.Array.init(end - start, 0, System.Char);

                    var writeIndex = 0;

                    for (var i = start; i < end; i++) {
                        chars[writeIndex++] = unicodes[i];
                    }

                    return System.String.fromCharArray(chars);
                },
                /*TMPro.TMPro_ExtensionMethods.IntToString$1:static end.*/

                /*TMPro.TMPro_ExtensionMethods.UintToString:static start.*/
                UintToString: function (unicodes) {
if ( TRACE ) { TRACE( "TMPro.TMPro_ExtensionMethods#UintToString", this ); }

                    var chars = System.Array.init(unicodes.Count, 0, System.Char);

                    for (var i = 0; i < unicodes.Count; i++) {
                        chars[i] = unicodes.getItem(i);
                    }

                    return System.String.fromCharArray(chars);
                },
                /*TMPro.TMPro_ExtensionMethods.UintToString:static end.*/

                /*TMPro.TMPro_ExtensionMethods.FindInstanceID:static start.*/
                FindInstanceID: function (T, list, target) {
if ( TRACE ) { TRACE( "TMPro.TMPro_ExtensionMethods#FindInstanceID", this ); }

                    var targetID = target.GetInstanceID();

                    for (var i = 0; i < list.Count; i++) {
                        if (list.getItem(i).GetInstanceID() === targetID) {
                            return i;
                        }
                    }

                    return -1;
                },
                /*TMPro.TMPro_ExtensionMethods.FindInstanceID:static end.*/

                /*TMPro.TMPro_ExtensionMethods.Compare$1:static start.*/
                Compare$1: function (a, b) {
if ( TRACE ) { TRACE( "TMPro.TMPro_ExtensionMethods#Compare$1", this ); }

                    return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;
                },
                /*TMPro.TMPro_ExtensionMethods.Compare$1:static end.*/

                /*TMPro.TMPro_ExtensionMethods.Compare:static start.*/
                Compare: function (a, b) {
if ( TRACE ) { TRACE( "TMPro.TMPro_ExtensionMethods#Compare", this ); }

                    return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;
                },
                /*TMPro.TMPro_ExtensionMethods.Compare:static end.*/

                /*TMPro.TMPro_ExtensionMethods.Compare$3:static start.*/
                Compare$3: function (v1, v2, accuracy) {
if ( TRACE ) { TRACE( "TMPro.TMPro_ExtensionMethods#Compare$3", this ); }

                    var x = (v1.x * accuracy) === (v2.x * accuracy);
                    var y = (v1.y * accuracy) === (v2.y * accuracy);
                    var z = (v1.z * accuracy) === (v2.z * accuracy);

                    return x && y && z;
                },
                /*TMPro.TMPro_ExtensionMethods.Compare$3:static end.*/

                /*TMPro.TMPro_ExtensionMethods.Compare$2:static start.*/
                Compare$2: function (q1, q2, accuracy) {
if ( TRACE ) { TRACE( "TMPro.TMPro_ExtensionMethods#Compare$2", this ); }

                    var x = (q1.x * accuracy) === (q2.x * accuracy);
                    var y = (q1.y * accuracy) === (q2.y * accuracy);
                    var z = (q1.z * accuracy) === (q2.z * accuracy);
                    var w = (q1.w * accuracy) === (q2.w * accuracy);

                    return x && y && z && w;
                },
                /*TMPro.TMPro_ExtensionMethods.Compare$2:static end.*/

                /*TMPro.TMPro_ExtensionMethods.CompareRGB$1:static start.*/
                CompareRGB$1: function (a, b) {
if ( TRACE ) { TRACE( "TMPro.TMPro_ExtensionMethods#CompareRGB$1", this ); }

                    return a.r === b.r && a.g === b.g && a.b === b.b;
                },
                /*TMPro.TMPro_ExtensionMethods.CompareRGB$1:static end.*/

                /*TMPro.TMPro_ExtensionMethods.CompareRGB:static start.*/
                CompareRGB: function (a, b) {
if ( TRACE ) { TRACE( "TMPro.TMPro_ExtensionMethods#CompareRGB", this ); }

                    return a.r === b.r && a.g === b.g && a.b === b.b;
                },
                /*TMPro.TMPro_ExtensionMethods.CompareRGB:static end.*/

                /*TMPro.TMPro_ExtensionMethods.Multiply:static start.*/
                Multiply: function (c1, c2) {
if ( TRACE ) { TRACE( "TMPro.TMPro_ExtensionMethods#Multiply", this ); }

                    var r = c1.r / 255.0 * (c2.r / 255.0) * 255;
                    var g = c1.g / 255.0 * (c2.g / 255.0) * 255;
                    var b = c1.b / 255.0 * (c2.b / 255.0) * 255;
                    var a = c1.a / 255.0 * (c2.a / 255.0) * 255;

                    return new UnityEngine.Color32.$ctor1(r, g, b, a);
                },
                /*TMPro.TMPro_ExtensionMethods.Multiply:static end.*/

                /*TMPro.TMPro_ExtensionMethods.Tint$1:static start.*/
                Tint$1: function (c1, c2) {
if ( TRACE ) { TRACE( "TMPro.TMPro_ExtensionMethods#Tint$1", this ); }

                    var r = c1.r / 255.0 * (c2.r / 255.0) * 255;
                    var g = c1.g / 255.0 * (c2.g / 255.0) * 255;
                    var b = c1.b / 255.0 * (c2.b / 255.0) * 255;
                    var a = c1.a / 255.0 * (c2.a / 255.0) * 255;

                    return new UnityEngine.Color32.$ctor1(r, g, b, a);
                },
                /*TMPro.TMPro_ExtensionMethods.Tint$1:static end.*/

                /*TMPro.TMPro_ExtensionMethods.Tint:static start.*/
                Tint: function (c1, tint) {
if ( TRACE ) { TRACE( "TMPro.TMPro_ExtensionMethods#Tint", this ); }

                    var r = Math.max(0, Math.min(c1.r / 255.0 * tint * 255, 255));
                    var g = Math.max(0, Math.min(c1.g / 255.0 * tint * 255, 255));
                    var b = Math.max(0, Math.min(c1.b / 255.0 * tint * 255, 255));
                    var a = Math.max(0, Math.min(c1.a / 255.0 * tint * 255, 255));

                    return new UnityEngine.Color32.$ctor1(r, g, b, a);
                },
                /*TMPro.TMPro_ExtensionMethods.Tint:static end.*/

                /*TMPro.TMPro_ExtensionMethods.MinAlpha:static start.*/
                MinAlpha: function (c1, c2) {
if ( TRACE ) { TRACE( "TMPro.TMPro_ExtensionMethods#MinAlpha", this ); }

                    var a = c1.a < c2.a ? c1.a : c2.a;

                    return new pc.Color( c1.r, c1.g, c1.b, a );
                },
                /*TMPro.TMPro_ExtensionMethods.MinAlpha:static end.*/


            }
        }
    });
    /*TMPro.TMPro_ExtensionMethods end.*/

    /*TMPro.VertexGradient start.*/
    /**
     * TMP custom data type to represent 32 bit characters.
     *
     * @public
     * @class TMPro.VertexGradient
     */
    Bridge.define("TMPro.VertexGradient", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.VertexGradient#getDefaultValue", this ); }
 return new TMPro.VertexGradient(); }
            }
        },
        fields: {
            topLeft: null,
            topRight: null,
            bottomLeft: null,
            bottomRight: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.VertexGradient#init", this ); }

                this.topLeft = new UnityEngine.Color();
                this.topRight = new UnityEngine.Color();
                this.bottomLeft = new UnityEngine.Color();
                this.bottomRight = new UnityEngine.Color();
            },
            $ctor1: function (color) {
if ( TRACE ) { TRACE( "TMPro.VertexGradient#$ctor1", this ); }

                this.$initialize();
                this.topLeft = color.$clone();
                this.topRight = color.$clone();
                this.bottomLeft = color.$clone();
                this.bottomRight = color.$clone();
            },
            /**
             * The vertex colors at the corners of the characters.
             *
             * @instance
             * @public
             * @this TMPro.VertexGradient
             * @memberof TMPro.VertexGradient
             * @param   {UnityEngine.Color}    color0    Top left color.
             * @param   {UnityEngine.Color}    color1    Top right color.
             * @param   {UnityEngine.Color}    color2    Bottom left color.
             * @param   {UnityEngine.Color}    color3    Bottom right color.
             * @return  {void}
             */
            $ctor2: function (color0, color1, color2, color3) {
if ( TRACE ) { TRACE( "TMPro.VertexGradient#$ctor2", this ); }

                this.$initialize();
                this.topLeft = color0.$clone();
                this.topRight = color1.$clone();
                this.bottomLeft = color2.$clone();
                this.bottomRight = color3.$clone();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.VertexGradient#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.VertexGradient#getHashCode", this ); }

                var h = Bridge.addHash([5572376202, this.topLeft, this.topRight, this.bottomLeft, this.bottomRight]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.VertexGradient#equals", this ); }

                if (!Bridge.is(o, TMPro.VertexGradient)) {
                    return false;
                }
                return Bridge.equals(this.topLeft, o.topLeft) && Bridge.equals(this.topRight, o.topRight) && Bridge.equals(this.bottomLeft, o.bottomLeft) && Bridge.equals(this.bottomRight, o.bottomRight);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.VertexGradient#$clone", this ); }

                var s = to || new TMPro.VertexGradient();
                s.topLeft = this.topLeft.$clone();
                s.topRight = this.topRight.$clone();
                s.bottomLeft = this.bottomLeft.$clone();
                s.bottomRight = this.bottomRight.$clone();
                return s;
            }
        }
    });
    /*TMPro.VertexGradient end.*/

    /*TMPro.VertexSortingOrder start.*/
    Bridge.define("TMPro.VertexSortingOrder", {
        $kind: 6,
        statics: {
            fields: {
                Normal: 0,
                Reverse: 1
            }
        }
    });
    /*TMPro.VertexSortingOrder end.*/

    /*TMPro.VerticalAlignmentOptions start.*/
    /**
     * Vertical text alignment options.
     *
     * @public
     * @class TMPro.VerticalAlignmentOptions
     */
    Bridge.define("TMPro.VerticalAlignmentOptions", {
        $kind: 6,
        statics: {
            fields: {
                Top: 256,
                Middle: 512,
                Bottom: 1024,
                Baseline: 2048,
                Geometry: 4096,
                Capline: 8192
            }
        }
    });
    /*TMPro.VerticalAlignmentOptions end.*/

    /*TMPro.WordWrapState start.*/
    Bridge.define("TMPro.WordWrapState", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.WordWrapState#getDefaultValue", this ); }
 return new TMPro.WordWrapState(); }
            }
        },
        fields: {
            previous_WordBreak: 0,
            total_CharacterCount: 0,
            visible_CharacterCount: 0,
            visible_SpriteCount: 0,
            visible_LinkCount: 0,
            firstCharacterIndex: 0,
            firstVisibleCharacterIndex: 0,
            lastCharacterIndex: 0,
            lastVisibleCharIndex: 0,
            lineNumber: 0,
            maxCapHeight: 0,
            maxAscender: 0,
            maxDescender: 0,
            startOfLineAscender: 0,
            maxLineAscender: 0,
            maxLineDescender: 0,
            pageAscender: 0,
            horizontalAlignment: 0,
            marginLeft: 0,
            marginRight: 0,
            xAdvance: 0,
            preferredWidth: 0,
            preferredHeight: 0,
            previousLineScale: 0,
            wordCount: 0,
            fontStyle: 0,
            italicAngle: 0,
            fontScaleMultiplier: 0,
            currentFontSize: 0,
            baselineOffset: 0,
            lineOffset: 0,
            isDrivenLineSpacing: false,
            glyphHorizontalAdvanceAdjustment: 0,
            cSpace: 0,
            mSpace: 0,
            textInfo: null,
            lineInfo: null,
            vertexColor: null,
            underlineColor: null,
            strikethroughColor: null,
            highlightColor: null,
            basicStyleStack: null,
            italicAngleStack: null,
            colorStack: null,
            underlineColorStack: null,
            strikethroughColorStack: null,
            highlightColorStack: null,
            highlightStateStack: null,
            colorGradientStack: null,
            sizeStack: null,
            indentStack: null,
            fontWeightStack: null,
            styleStack: null,
            baselineStack: null,
            actionStack: null,
            materialReferenceStack: null,
            lineJustificationStack: null,
            spriteAnimationID: 0,
            currentFontAsset: null,
            currentSpriteAsset: null,
            currentMaterial: null,
            currentMaterialIndex: 0,
            meshExtents: null,
            tagNoParsing: false,
            isNonBreakingSpace: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.WordWrapState#init", this ); }

                this.lineInfo = new TMPro.TMP_LineInfo();
                this.vertexColor = new UnityEngine.Color32();
                this.underlineColor = new UnityEngine.Color32();
                this.strikethroughColor = new UnityEngine.Color32();
                this.highlightColor = new UnityEngine.Color32();
                this.basicStyleStack = new TMPro.TMP_FontStyleStack();
                this.italicAngleStack = new (TMPro.TMP_TextProcessingStack$1(System.Int32))();
                this.colorStack = new (TMPro.TMP_TextProcessingStack$1(UnityEngine.Color32))();
                this.underlineColorStack = new (TMPro.TMP_TextProcessingStack$1(UnityEngine.Color32))();
                this.strikethroughColorStack = new (TMPro.TMP_TextProcessingStack$1(UnityEngine.Color32))();
                this.highlightColorStack = new (TMPro.TMP_TextProcessingStack$1(UnityEngine.Color32))();
                this.highlightStateStack = new (TMPro.TMP_TextProcessingStack$1(TMPro.HighlightState))();
                this.colorGradientStack = new (TMPro.TMP_TextProcessingStack$1(TMPro.TMP_ColorGradient))();
                this.sizeStack = new (TMPro.TMP_TextProcessingStack$1(System.Single))();
                this.indentStack = new (TMPro.TMP_TextProcessingStack$1(System.Single))();
                this.fontWeightStack = new (TMPro.TMP_TextProcessingStack$1(TMPro.FontWeight))();
                this.styleStack = new (TMPro.TMP_TextProcessingStack$1(System.Int32))();
                this.baselineStack = new (TMPro.TMP_TextProcessingStack$1(System.Single))();
                this.actionStack = new (TMPro.TMP_TextProcessingStack$1(System.Int32))();
                this.materialReferenceStack = new (TMPro.TMP_TextProcessingStack$1(TMPro.MaterialReference))();
                this.lineJustificationStack = new (TMPro.TMP_TextProcessingStack$1(TMPro.HorizontalAlignmentOptions))();
                this.meshExtents = new TMPro.Extents();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.WordWrapState#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.WordWrapState#getHashCode", this ); }

                var h = Bridge.addHash([5523199590, this.previous_WordBreak, this.total_CharacterCount, this.visible_CharacterCount, this.visible_SpriteCount, this.visible_LinkCount, this.firstCharacterIndex, this.firstVisibleCharacterIndex, this.lastCharacterIndex, this.lastVisibleCharIndex, this.lineNumber, this.maxCapHeight, this.maxAscender, this.maxDescender, this.startOfLineAscender, this.maxLineAscender, this.maxLineDescender, this.pageAscender, this.horizontalAlignment, this.marginLeft, this.marginRight, this.xAdvance, this.preferredWidth, this.preferredHeight, this.previousLineScale, this.wordCount, this.fontStyle, this.italicAngle, this.fontScaleMultiplier, this.currentFontSize, this.baselineOffset, this.lineOffset, this.isDrivenLineSpacing, this.glyphHorizontalAdvanceAdjustment, this.cSpace, this.mSpace, this.textInfo, this.lineInfo, this.vertexColor, this.underlineColor, this.strikethroughColor, this.highlightColor, this.basicStyleStack, this.italicAngleStack, this.colorStack, this.underlineColorStack, this.strikethroughColorStack, this.highlightColorStack, this.highlightStateStack, this.colorGradientStack, this.sizeStack, this.indentStack, this.fontWeightStack, this.styleStack, this.baselineStack, this.actionStack, this.materialReferenceStack, this.lineJustificationStack, this.spriteAnimationID, this.currentFontAsset, this.currentSpriteAsset, this.currentMaterial, this.currentMaterialIndex, this.meshExtents, this.tagNoParsing, this.isNonBreakingSpace]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.WordWrapState#equals", this ); }

                if (!Bridge.is(o, TMPro.WordWrapState)) {
                    return false;
                }
                return Bridge.equals(this.previous_WordBreak, o.previous_WordBreak) && Bridge.equals(this.total_CharacterCount, o.total_CharacterCount) && Bridge.equals(this.visible_CharacterCount, o.visible_CharacterCount) && Bridge.equals(this.visible_SpriteCount, o.visible_SpriteCount) && Bridge.equals(this.visible_LinkCount, o.visible_LinkCount) && Bridge.equals(this.firstCharacterIndex, o.firstCharacterIndex) && Bridge.equals(this.firstVisibleCharacterIndex, o.firstVisibleCharacterIndex) && Bridge.equals(this.lastCharacterIndex, o.lastCharacterIndex) && Bridge.equals(this.lastVisibleCharIndex, o.lastVisibleCharIndex) && Bridge.equals(this.lineNumber, o.lineNumber) && Bridge.equals(this.maxCapHeight, o.maxCapHeight) && Bridge.equals(this.maxAscender, o.maxAscender) && Bridge.equals(this.maxDescender, o.maxDescender) && Bridge.equals(this.startOfLineAscender, o.startOfLineAscender) && Bridge.equals(this.maxLineAscender, o.maxLineAscender) && Bridge.equals(this.maxLineDescender, o.maxLineDescender) && Bridge.equals(this.pageAscender, o.pageAscender) && Bridge.equals(this.horizontalAlignment, o.horizontalAlignment) && Bridge.equals(this.marginLeft, o.marginLeft) && Bridge.equals(this.marginRight, o.marginRight) && Bridge.equals(this.xAdvance, o.xAdvance) && Bridge.equals(this.preferredWidth, o.preferredWidth) && Bridge.equals(this.preferredHeight, o.preferredHeight) && Bridge.equals(this.previousLineScale, o.previousLineScale) && Bridge.equals(this.wordCount, o.wordCount) && Bridge.equals(this.fontStyle, o.fontStyle) && Bridge.equals(this.italicAngle, o.italicAngle) && Bridge.equals(this.fontScaleMultiplier, o.fontScaleMultiplier) && Bridge.equals(this.currentFontSize, o.currentFontSize) && Bridge.equals(this.baselineOffset, o.baselineOffset) && Bridge.equals(this.lineOffset, o.lineOffset) && Bridge.equals(this.isDrivenLineSpacing, o.isDrivenLineSpacing) && Bridge.equals(this.glyphHorizontalAdvanceAdjustment, o.glyphHorizontalAdvanceAdjustment) && Bridge.equals(this.cSpace, o.cSpace) && Bridge.equals(this.mSpace, o.mSpace) && Bridge.equals(this.textInfo, o.textInfo) && Bridge.equals(this.lineInfo, o.lineInfo) && Bridge.equals(this.vertexColor, o.vertexColor) && Bridge.equals(this.underlineColor, o.underlineColor) && Bridge.equals(this.strikethroughColor, o.strikethroughColor) && Bridge.equals(this.highlightColor, o.highlightColor) && Bridge.equals(this.basicStyleStack, o.basicStyleStack) && Bridge.equals(this.italicAngleStack, o.italicAngleStack) && Bridge.equals(this.colorStack, o.colorStack) && Bridge.equals(this.underlineColorStack, o.underlineColorStack) && Bridge.equals(this.strikethroughColorStack, o.strikethroughColorStack) && Bridge.equals(this.highlightColorStack, o.highlightColorStack) && Bridge.equals(this.highlightStateStack, o.highlightStateStack) && Bridge.equals(this.colorGradientStack, o.colorGradientStack) && Bridge.equals(this.sizeStack, o.sizeStack) && Bridge.equals(this.indentStack, o.indentStack) && Bridge.equals(this.fontWeightStack, o.fontWeightStack) && Bridge.equals(this.styleStack, o.styleStack) && Bridge.equals(this.baselineStack, o.baselineStack) && Bridge.equals(this.actionStack, o.actionStack) && Bridge.equals(this.materialReferenceStack, o.materialReferenceStack) && Bridge.equals(this.lineJustificationStack, o.lineJustificationStack) && Bridge.equals(this.spriteAnimationID, o.spriteAnimationID) && Bridge.equals(this.currentFontAsset, o.currentFontAsset) && Bridge.equals(this.currentSpriteAsset, o.currentSpriteAsset) && Bridge.equals(this.currentMaterial, o.currentMaterial) && Bridge.equals(this.currentMaterialIndex, o.currentMaterialIndex) && Bridge.equals(this.meshExtents, o.meshExtents) && Bridge.equals(this.tagNoParsing, o.tagNoParsing) && Bridge.equals(this.isNonBreakingSpace, o.isNonBreakingSpace);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.WordWrapState#$clone", this ); }

                var s = to || new TMPro.WordWrapState();
                s.previous_WordBreak = this.previous_WordBreak;
                s.total_CharacterCount = this.total_CharacterCount;
                s.visible_CharacterCount = this.visible_CharacterCount;
                s.visible_SpriteCount = this.visible_SpriteCount;
                s.visible_LinkCount = this.visible_LinkCount;
                s.firstCharacterIndex = this.firstCharacterIndex;
                s.firstVisibleCharacterIndex = this.firstVisibleCharacterIndex;
                s.lastCharacterIndex = this.lastCharacterIndex;
                s.lastVisibleCharIndex = this.lastVisibleCharIndex;
                s.lineNumber = this.lineNumber;
                s.maxCapHeight = this.maxCapHeight;
                s.maxAscender = this.maxAscender;
                s.maxDescender = this.maxDescender;
                s.startOfLineAscender = this.startOfLineAscender;
                s.maxLineAscender = this.maxLineAscender;
                s.maxLineDescender = this.maxLineDescender;
                s.pageAscender = this.pageAscender;
                s.horizontalAlignment = this.horizontalAlignment;
                s.marginLeft = this.marginLeft;
                s.marginRight = this.marginRight;
                s.xAdvance = this.xAdvance;
                s.preferredWidth = this.preferredWidth;
                s.preferredHeight = this.preferredHeight;
                s.previousLineScale = this.previousLineScale;
                s.wordCount = this.wordCount;
                s.fontStyle = this.fontStyle;
                s.italicAngle = this.italicAngle;
                s.fontScaleMultiplier = this.fontScaleMultiplier;
                s.currentFontSize = this.currentFontSize;
                s.baselineOffset = this.baselineOffset;
                s.lineOffset = this.lineOffset;
                s.isDrivenLineSpacing = this.isDrivenLineSpacing;
                s.glyphHorizontalAdvanceAdjustment = this.glyphHorizontalAdvanceAdjustment;
                s.cSpace = this.cSpace;
                s.mSpace = this.mSpace;
                s.textInfo = this.textInfo;
                s.lineInfo = this.lineInfo.$clone();
                s.vertexColor = this.vertexColor.$clone();
                s.underlineColor = this.underlineColor.$clone();
                s.strikethroughColor = this.strikethroughColor.$clone();
                s.highlightColor = this.highlightColor.$clone();
                s.basicStyleStack = this.basicStyleStack.$clone();
                s.italicAngleStack = this.italicAngleStack.$clone();
                s.colorStack = this.colorStack.$clone();
                s.underlineColorStack = this.underlineColorStack.$clone();
                s.strikethroughColorStack = this.strikethroughColorStack.$clone();
                s.highlightColorStack = this.highlightColorStack.$clone();
                s.highlightStateStack = this.highlightStateStack.$clone();
                s.colorGradientStack = this.colorGradientStack.$clone();
                s.sizeStack = this.sizeStack.$clone();
                s.indentStack = this.indentStack.$clone();
                s.fontWeightStack = this.fontWeightStack.$clone();
                s.styleStack = this.styleStack.$clone();
                s.baselineStack = this.baselineStack.$clone();
                s.actionStack = this.actionStack.$clone();
                s.materialReferenceStack = this.materialReferenceStack.$clone();
                s.lineJustificationStack = this.lineJustificationStack.$clone();
                s.spriteAnimationID = this.spriteAnimationID;
                s.currentFontAsset = this.currentFontAsset;
                s.currentSpriteAsset = this.currentSpriteAsset;
                s.currentMaterial = this.currentMaterial;
                s.currentMaterialIndex = this.currentMaterialIndex;
                s.meshExtents = this.meshExtents.$clone();
                s.tagNoParsing = this.tagNoParsing;
                s.isNonBreakingSpace = this.isNonBreakingSpace;
                return s;
            }
        }
    });
    /*TMPro.WordWrapState end.*/

    /*TMPro.ColorTween start.*/
    Bridge.define("TMPro.ColorTween", {
        inherits: [TMPro.ITweenValue],
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.ColorTween#getDefaultValue", this ); }
 return new TMPro.ColorTween(); }
            }
        },
        fields: {
            m_Target: null,
            m_StartColor: null,
            m_TargetColor: null,
            m_TweenMode: 0,
            m_Duration: 0,
            m_IgnoreTimeScale: false
        },
        props: {
            startColor: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.ColorTween#startColor#get", this ); }

                    return this.m_StartColor.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.ColorTween#startColor#set", this ); }

                    this.m_StartColor = value.$clone();
                }
            },
            targetColor: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.ColorTween#targetColor#get", this ); }

                    return this.m_TargetColor.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.ColorTween#targetColor#set", this ); }

                    this.m_TargetColor = value.$clone();
                }
            },
            tweenMode: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.ColorTween#tweenMode#get", this ); }

                    return this.m_TweenMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.ColorTween#tweenMode#set", this ); }

                    this.m_TweenMode = value;
                }
            },
            duration: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.ColorTween#duration#get", this ); }

                    return this.m_Duration;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.ColorTween#duration#set", this ); }

                    this.m_Duration = value;
                }
            },
            ignoreTimeScale: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.ColorTween#ignoreTimeScale#get", this ); }

                    return this.m_IgnoreTimeScale;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.ColorTween#ignoreTimeScale#set", this ); }

                    this.m_IgnoreTimeScale = value;
                }
            }
        },
        alias: [
            "duration", "TMPro$ITweenValue$duration",
            "ignoreTimeScale", "TMPro$ITweenValue$ignoreTimeScale",
            "TweenValue", "TMPro$ITweenValue$TweenValue",
            "ValidTarget", "TMPro$ITweenValue$ValidTarget"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.ColorTween#init", this ); }

                this.m_StartColor = new UnityEngine.Color();
                this.m_TargetColor = new UnityEngine.Color();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.ColorTween#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*TMPro.ColorTween.TweenValue start.*/
            TweenValue: function (floatPercentage) {
if ( TRACE ) { TRACE( "TMPro.ColorTween#TweenValue", this ); }

                if (!this.ValidTarget()) {
                    return;
                }

                var newColor = pc.Color.lerp( this.m_StartColor, this.m_TargetColor, floatPercentage );

                if (this.m_TweenMode === TMPro.ColorTween.ColorTweenMode.Alpha) {
                    newColor.r = this.m_StartColor.r;
                    newColor.g = this.m_StartColor.g;
                    newColor.b = this.m_StartColor.b;
                } else if (this.m_TweenMode === TMPro.ColorTween.ColorTweenMode.RGB) {
                    newColor.a = this.m_StartColor.a;
                }

                this.m_Target.Invoke(newColor.$clone());
            },
            /*TMPro.ColorTween.TweenValue end.*/

            /*TMPro.ColorTween.AddOnChangedCallback start.*/
            AddOnChangedCallback: function (callback) {
if ( TRACE ) { TRACE( "TMPro.ColorTween#AddOnChangedCallback", this ); }

                if (this.m_Target == null) {
                    this.m_Target = new TMPro.ColorTween.ColorTweenCallback();
                }

                this.m_Target.AddListener(callback);
            },
            /*TMPro.ColorTween.AddOnChangedCallback end.*/

            /*TMPro.ColorTween.GetIgnoreTimescale start.*/
            GetIgnoreTimescale: function () {
if ( TRACE ) { TRACE( "TMPro.ColorTween#GetIgnoreTimescale", this ); }

                return this.m_IgnoreTimeScale;
            },
            /*TMPro.ColorTween.GetIgnoreTimescale end.*/

            /*TMPro.ColorTween.GetDuration start.*/
            GetDuration: function () {
if ( TRACE ) { TRACE( "TMPro.ColorTween#GetDuration", this ); }

                return this.m_Duration;
            },
            /*TMPro.ColorTween.GetDuration end.*/

            /*TMPro.ColorTween.ValidTarget start.*/
            ValidTarget: function () {
if ( TRACE ) { TRACE( "TMPro.ColorTween#ValidTarget", this ); }

                return this.m_Target != null;
            },
            /*TMPro.ColorTween.ValidTarget end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.ColorTween#getHashCode", this ); }

                var h = Bridge.addHash([3571724826, this.m_Target, this.m_StartColor, this.m_TargetColor, this.m_TweenMode, this.m_Duration, this.m_IgnoreTimeScale]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.ColorTween#equals", this ); }

                if (!Bridge.is(o, TMPro.ColorTween)) {
                    return false;
                }
                return Bridge.equals(this.m_Target, o.m_Target) && Bridge.equals(this.m_StartColor, o.m_StartColor) && Bridge.equals(this.m_TargetColor, o.m_TargetColor) && Bridge.equals(this.m_TweenMode, o.m_TweenMode) && Bridge.equals(this.m_Duration, o.m_Duration) && Bridge.equals(this.m_IgnoreTimeScale, o.m_IgnoreTimeScale);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.ColorTween#$clone", this ); }

                var s = to || new TMPro.ColorTween();
                s.m_Target = this.m_Target;
                s.m_StartColor = this.m_StartColor.$clone();
                s.m_TargetColor = this.m_TargetColor.$clone();
                s.m_TweenMode = this.m_TweenMode;
                s.m_Duration = this.m_Duration;
                s.m_IgnoreTimeScale = this.m_IgnoreTimeScale;
                return s;
            }
        }
    });
    /*TMPro.ColorTween end.*/

    /*TMPro.FloatTween start.*/
    Bridge.define("TMPro.FloatTween", {
        inherits: [TMPro.ITweenValue],
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TMPro.FloatTween#getDefaultValue", this ); }
 return new TMPro.FloatTween(); }
            }
        },
        fields: {
            m_Target: null,
            m_StartValue: 0,
            m_TargetValue: 0,
            m_Duration: 0,
            m_IgnoreTimeScale: false
        },
        props: {
            startValue: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.FloatTween#startValue#get", this ); }

                    return this.m_StartValue;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.FloatTween#startValue#set", this ); }

                    this.m_StartValue = value;
                }
            },
            targetValue: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.FloatTween#targetValue#get", this ); }

                    return this.m_TargetValue;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.FloatTween#targetValue#set", this ); }

                    this.m_TargetValue = value;
                }
            },
            duration: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.FloatTween#duration#get", this ); }

                    return this.m_Duration;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.FloatTween#duration#set", this ); }

                    this.m_Duration = value;
                }
            },
            ignoreTimeScale: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.FloatTween#ignoreTimeScale#get", this ); }

                    return this.m_IgnoreTimeScale;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.FloatTween#ignoreTimeScale#set", this ); }

                    this.m_IgnoreTimeScale = value;
                }
            }
        },
        alias: [
            "duration", "TMPro$ITweenValue$duration",
            "ignoreTimeScale", "TMPro$ITweenValue$ignoreTimeScale",
            "TweenValue", "TMPro$ITweenValue$TweenValue",
            "ValidTarget", "TMPro$ITweenValue$ValidTarget"
        ],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.FloatTween#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*TMPro.FloatTween.TweenValue start.*/
            TweenValue: function (floatPercentage) {
if ( TRACE ) { TRACE( "TMPro.FloatTween#TweenValue", this ); }

                if (!this.ValidTarget()) {
                    return;
                }

                var newValue = pc.math.lerp(this.m_StartValue, this.m_TargetValue, floatPercentage);
                this.m_Target.Invoke(newValue);
            },
            /*TMPro.FloatTween.TweenValue end.*/

            /*TMPro.FloatTween.AddOnChangedCallback start.*/
            AddOnChangedCallback: function (callback) {
if ( TRACE ) { TRACE( "TMPro.FloatTween#AddOnChangedCallback", this ); }

                if (this.m_Target == null) {
                    this.m_Target = new TMPro.FloatTween.FloatTweenCallback();
                }

                this.m_Target.AddListener(callback);
            },
            /*TMPro.FloatTween.AddOnChangedCallback end.*/

            /*TMPro.FloatTween.GetIgnoreTimescale start.*/
            GetIgnoreTimescale: function () {
if ( TRACE ) { TRACE( "TMPro.FloatTween#GetIgnoreTimescale", this ); }

                return this.m_IgnoreTimeScale;
            },
            /*TMPro.FloatTween.GetIgnoreTimescale end.*/

            /*TMPro.FloatTween.GetDuration start.*/
            GetDuration: function () {
if ( TRACE ) { TRACE( "TMPro.FloatTween#GetDuration", this ); }

                return this.m_Duration;
            },
            /*TMPro.FloatTween.GetDuration end.*/

            /*TMPro.FloatTween.ValidTarget start.*/
            ValidTarget: function () {
if ( TRACE ) { TRACE( "TMPro.FloatTween#ValidTarget", this ); }

                return this.m_Target != null;
            },
            /*TMPro.FloatTween.ValidTarget end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "TMPro.FloatTween#getHashCode", this ); }

                var h = Bridge.addHash([3337039647, this.m_Target, this.m_StartValue, this.m_TargetValue, this.m_Duration, this.m_IgnoreTimeScale]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "TMPro.FloatTween#equals", this ); }

                if (!Bridge.is(o, TMPro.FloatTween)) {
                    return false;
                }
                return Bridge.equals(this.m_Target, o.m_Target) && Bridge.equals(this.m_StartValue, o.m_StartValue) && Bridge.equals(this.m_TargetValue, o.m_TargetValue) && Bridge.equals(this.m_Duration, o.m_Duration) && Bridge.equals(this.m_IgnoreTimeScale, o.m_IgnoreTimeScale);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "TMPro.FloatTween#$clone", this ); }

                var s = to || new TMPro.FloatTween();
                s.m_Target = this.m_Target;
                s.m_StartValue = this.m_StartValue;
                s.m_TargetValue = this.m_TargetValue;
                s.m_Duration = this.m_Duration;
                s.m_IgnoreTimeScale = this.m_IgnoreTimeScale;
                return s;
            }
        }
    });
    /*TMPro.FloatTween end.*/

    /*TMPro.TextMeshPro start.*/
    Bridge.define("TMPro.TextMeshPro", {
        inherits: [TMPro.TMP_Text,UnityEngine.UI.ILayoutElement],
        fields: {
            _SortingLayer: 0,
            _SortingLayerID: 0,
            _SortingOrder: 0,
            m_currentAutoSizeMode: false,
            m_hasFontAssetChanged: false,
            m_previousLossyScaleY: 0,
            m_renderer: null,
            m_meshFilter: null,
            m_isFirstAllocation: false,
            m_max_characters: 0,
            m_max_numberOfLines: 0,
            m_subTextObjects: null,
            m_maskType: 0,
            m_EnvMapMatrix: null,
            m_RectTransformCorners: null,
            m_isRegisteredForEvents: false
        },
        events: {
            /**
             * Event to allow users to modify the content of the text info before the text is rendered.
             *
             * @instance
             * @public
             * @override
             * @this TMPro.TextMeshPro
             * @memberof TMPro.TextMeshPro
             * @function addOnPreRenderText
             * @param   {System.Action}    value
             * @return  {void}
             */
            /**
             * Event to allow users to modify the content of the text info before the text is rendered.
             *
             * @instance
             * @public
             * @override
             * @this TMPro.TextMeshPro
             * @memberof TMPro.TextMeshPro
             * @function removeOnPreRenderText
             * @param   {System.Action}    value
             * @return  {void}
             */
            OnPreRenderText: null
        },
        props: {
            /**
             * Sets the Renderer's sorting Layer ID
             *
             * @instance
             * @public
             * @memberof TMPro.TextMeshPro
             * @function sortingLayerID
             * @type number
             */
            sortingLayerID: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#sortingLayerID#get", this ); }

                    if (UnityEngine.Component.op_Equality(this.renderer, null)) {
                        return 0;
                    }

                    return this.m_renderer.sortingLayerID;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#sortingLayerID#set", this ); }

                    if (UnityEngine.Component.op_Equality(this.renderer, null)) {
                        return;
                    }

                    this.m_renderer.sortingLayerID = value;
                    this._SortingLayerID = value;

                    // Make sure sorting layer ID change is also reflected on sub text objects.
                    this.UpdateSubMeshSortingLayerID(value);
                }
            },
            /**
             * Sets the Renderer's sorting order within the assigned layer.
             *
             * @instance
             * @public
             * @memberof TMPro.TextMeshPro
             * @function sortingOrder
             * @type number
             */
            sortingOrder: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#sortingOrder#get", this ); }

                    if (UnityEngine.Component.op_Equality(this.renderer, null)) {
                        return 0;
                    }

                    return this.m_renderer.sortingOrder;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#sortingOrder#set", this ); }

                    if (UnityEngine.Component.op_Equality(this.renderer, null)) {
                        return;
                    }

                    this.m_renderer.sortingOrder = value;
                    this._SortingOrder = value;

                    // Make sure sorting order change is also reflected on sub text objects.
                    this.UpdateSubMeshSortingOrder(value);
                }
            },
            /**
             * Determines if the size of the text container will be adjusted to fit the text object when it is first created.
             *
             * @instance
             * @public
             * @override
             * @memberof TMPro.TextMeshPro
             * @function autoSizeTextContainer
             * @type boolean
             */
            autoSizeTextContainer: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#autoSizeTextContainer#get", this ); }

                    return this.m_autoSizeTextContainer;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#autoSizeTextContainer#set", this ); }

                    if (this.m_autoSizeTextContainer === value) {
                        return;
                    }

                    this.m_autoSizeTextContainer = value;
                    if (this.m_autoSizeTextContainer) {
                        TMPro.TMP_UpdateManager.RegisterTextElementForLayoutRebuild(this);
                        this.SetLayoutDirty();
                    }
                }
            },
            /**
             * Returns a reference to the Text Container
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TextMeshPro
             * @function textContainer
             * @type TMPro.TextContainer
             */
            textContainer: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#textContainer#get", this ); }

                    return null;
                }
            },
            /**
             * Returns a reference to the Transform
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TextMeshPro
             * @function transform$2
             * @type UnityEngine.Transform
             */
            transform$2: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#transform$2#get", this ); }

                    if (UnityEngine.Component.op_Equality(this.m_transform, null)) {
                        this.m_transform = this.GetComponent(UnityEngine.Transform);
                    }

                    return this.m_transform;
                }
            },
            /**
             * Returns the rendered assigned to the text object.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TextMeshPro
             * @function renderer
             * @type UnityEngine.Renderer
             */
            renderer: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#renderer#get", this ); }

                    if (UnityEngine.Component.op_Equality(this.m_renderer, null)) {
                        this.m_renderer = this.GetComponent(UnityEngine.Renderer);
                    }

                    return this.m_renderer;
                }
            },
            /**
             * Returns the mesh assigned to the text object.
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof TMPro.TextMeshPro
             * @function mesh
             * @type UnityEngine.Mesh
             */
            mesh: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#mesh#get", this ); }

                    if (this.m_mesh == null) {
                        this.m_mesh = new UnityEngine.Mesh.ctor();
                        this.m_mesh.hideFlags = UnityEngine.HideFlags.HideAndDontSave;
                    }

                    return this.m_mesh;
                }
            },
            /**
             * Returns the Mesh Filter of the text object.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TextMeshPro
             * @function meshFilter
             * @type UnityEngine.MeshFilter
             */
            meshFilter: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#meshFilter#get", this ); }

                    if (UnityEngine.Component.op_Equality(this.m_meshFilter, null)) {
                        this.m_meshFilter = this.GetComponent(UnityEngine.MeshFilter);

                        if (UnityEngine.Component.op_Equality(this.m_meshFilter, null)) {
                            this.m_meshFilter = this.gameObject.AddComponent(UnityEngine.MeshFilter);
                            this.m_meshFilter.hideFlags = 63;
                        }
                    }

                    return this.m_meshFilter;
                }
            },
            /**
             * Sets the mask type
             *
             * @instance
             * @public
             * @memberof TMPro.TextMeshPro
             * @function maskType
             * @type TMPro.MaskingTypes
             */
            maskType: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#maskType#get", this ); }

                    return this.m_maskType;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#maskType#set", this ); }

                    this.m_maskType = value;
                    this.SetMask$2(this.m_maskType);
                }
            }
        },
        alias: [
            "Rebuild", "UnityEngine$UI$ICanvasElement$Rebuild",
            "CalculateLayoutInputHorizontal", "UnityEngine$UI$ILayoutElement$CalculateLayoutInputHorizontal",
            "CalculateLayoutInputVertical", "UnityEngine$UI$ILayoutElement$CalculateLayoutInputVertical",
            "minWidth", "UnityEngine$UI$ILayoutElement$minWidth",
            "preferredWidth", "UnityEngine$UI$ILayoutElement$preferredWidth",
            "flexibleWidth", "UnityEngine$UI$ILayoutElement$flexibleWidth",
            "minHeight", "UnityEngine$UI$ILayoutElement$minHeight",
            "preferredHeight", "UnityEngine$UI$ILayoutElement$preferredHeight",
            "flexibleHeight", "UnityEngine$UI$ILayoutElement$flexibleHeight",
            "layoutPriority", "UnityEngine$UI$ILayoutElement$layoutPriority",
            "minWidth", "UnityEngine$UI$ILayoutElement$minWidth",
            "preferredWidth", "UnityEngine$UI$ILayoutElement$preferredWidth",
            "flexibleWidth", "UnityEngine$UI$ILayoutElement$flexibleWidth",
            "minHeight", "UnityEngine$UI$ILayoutElement$minHeight",
            "preferredHeight", "UnityEngine$UI$ILayoutElement$preferredHeight",
            "flexibleHeight", "UnityEngine$UI$ILayoutElement$flexibleHeight",
            "layoutPriority", "UnityEngine$UI$ILayoutElement$layoutPriority"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#init", this ); }

                this.m_EnvMapMatrix = new UnityEngine.Matrix4x4();
                this.m_hasFontAssetChanged = false;
                this.m_previousLossyScaleY = -1;
                this.m_max_characters = 8;
                this.m_max_numberOfLines = 4;
                this.m_subTextObjects = System.Array.init(8, null, TMPro.TMP_SubMesh);
                this.m_RectTransformCorners = System.Array.init(4, function (){
                    return new UnityEngine.Vector3();
                }, UnityEngine.Vector3);
            }
        },
        methods: {
            /*TMPro.TextMeshPro.SetMask start.*/
            /**
             * Function used to set the mask type and coordinates in World Space
             *
             * @instance
             * @public
             * @this TMPro.TextMeshPro
             * @memberof TMPro.TextMeshPro
             * @param   {TMPro.MaskingTypes}     type          
             * @param   {UnityEngine.Vector4}    maskCoords
             * @return  {void}
             */
            SetMask: function (type, maskCoords) {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#SetMask", this ); }

                this.SetMask$2(type);

                this.SetMaskCoordinates(maskCoords.$clone());
            },
            /*TMPro.TextMeshPro.SetMask end.*/

            /*TMPro.TextMeshPro.SetMask$1 start.*/
            /**
             * Function used to set the mask type, coordinates and softness
             *
             * @instance
             * @public
             * @this TMPro.TextMeshPro
             * @memberof TMPro.TextMeshPro
             * @param   {TMPro.MaskingTypes}     type          
             * @param   {UnityEngine.Vector4}    maskCoords    
             * @param   {number}                 softnessX     
             * @param   {number}                 softnessY
             * @return  {void}
             */
            SetMask$1: function (type, maskCoords, softnessX, softnessY) {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#SetMask$1", this ); }

                this.SetMask$2(type);

                this.SetMaskCoordinates$1(maskCoords.$clone(), softnessX, softnessY);
            },
            /*TMPro.TextMeshPro.SetMask$1 end.*/

            /*TMPro.TextMeshPro.SetMask$2 start.*/
            SetMask$2: function (maskType) {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#SetMask$2", this ); }

                switch (maskType) {
                    case TMPro.MaskingTypes.MaskOff: 
                        this.m_sharedMaterial.DisableKeyword(TMPro.ShaderUtilities.Keyword_MASK_SOFT);
                        this.m_sharedMaterial.DisableKeyword(TMPro.ShaderUtilities.Keyword_MASK_HARD);
                        this.m_sharedMaterial.DisableKeyword(TMPro.ShaderUtilities.Keyword_MASK_TEX);
                        break;
                    case TMPro.MaskingTypes.MaskSoft: 
                        this.m_sharedMaterial.EnableKeyword(TMPro.ShaderUtilities.Keyword_MASK_SOFT);
                        this.m_sharedMaterial.DisableKeyword(TMPro.ShaderUtilities.Keyword_MASK_HARD);
                        this.m_sharedMaterial.DisableKeyword(TMPro.ShaderUtilities.Keyword_MASK_TEX);
                        break;
                    case TMPro.MaskingTypes.MaskHard: 
                        this.m_sharedMaterial.EnableKeyword(TMPro.ShaderUtilities.Keyword_MASK_HARD);
                        this.m_sharedMaterial.DisableKeyword(TMPro.ShaderUtilities.Keyword_MASK_SOFT);
                        this.m_sharedMaterial.DisableKeyword(TMPro.ShaderUtilities.Keyword_MASK_TEX);
                        break;
                }
            },
            /*TMPro.TextMeshPro.SetMask$2 end.*/

            /*TMPro.TextMeshPro.SetVerticesDirty start.*/
            /**
             * Schedule rebuilding of the text geometry.
             *
             * @instance
             * @public
             * @override
             * @this TMPro.TextMeshPro
             * @memberof TMPro.TextMeshPro
             * @return  {void}
             */
            SetVerticesDirty: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#SetVerticesDirty", this ); }

                //Debug.Log("***** SetVerticesDirty() called on object [" + this.name + "] at frame [" + Time.frameCount + "] *****");

                if (UnityEngine.MonoBehaviour.op_Equality(this, null) || !this.IsActive()) {
                    return;
                }

                TMPro.TMP_UpdateManager.RegisterTextElementForGraphicRebuild(this);
            },
            /*TMPro.TextMeshPro.SetVerticesDirty end.*/

            /*TMPro.TextMeshPro.SetLayoutDirty start.*/
            /**
             * @instance
             * @public
             * @override
             * @this TMPro.TextMeshPro
             * @memberof TMPro.TextMeshPro
             * @return  {void}
             */
            SetLayoutDirty: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#SetLayoutDirty", this ); }

                this.m_isPreferredWidthDirty = true;
                this.m_isPreferredHeightDirty = true;

                if (UnityEngine.MonoBehaviour.op_Equality(this, null) || !this.IsActive()) {
                    return;
                }

                UnityEngine.UI.LayoutRebuilder.MarkLayoutForRebuild(this.rectTransform$1);

                this.m_isLayoutDirty = true;
            },
            /*TMPro.TextMeshPro.SetLayoutDirty end.*/

            /*TMPro.TextMeshPro.SetMaterialDirty start.*/
            /**
             * Schedule updating of the material used by the text object.
             *
             * @instance
             * @public
             * @override
             * @this TMPro.TextMeshPro
             * @memberof TMPro.TextMeshPro
             * @return  {void}
             */
            SetMaterialDirty: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#SetMaterialDirty", this ); }

                //Debug.Log("SetMaterialDirty()");

                //if (!this.IsActive())
                //    return;

                //m_isMaterialDirty = true;
                this.UpdateMaterial();
                //TMP_UpdateManager.RegisterTextElementForGraphicRebuild(this);
            },
            /*TMPro.TextMeshPro.SetMaterialDirty end.*/

            /*TMPro.TextMeshPro.SetAllDirty start.*/
            /**
             * @instance
             * @public
             * @override
             * @this TMPro.TextMeshPro
             * @memberof TMPro.TextMeshPro
             * @return  {void}
             */
            SetAllDirty: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#SetAllDirty", this ); }

                this.SetLayoutDirty();
                this.SetVerticesDirty();
                this.SetMaterialDirty();
            },
            /*TMPro.TextMeshPro.SetAllDirty end.*/

            /*TMPro.TextMeshPro.Rebuild start.*/
            /**
             * @instance
             * @public
             * @override
             * @this TMPro.TextMeshPro
             * @memberof TMPro.TextMeshPro
             * @param   {UnityEngine.UI.CanvasUpdate}    update
             * @return  {void}
             */
            Rebuild: function (update) {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#Rebuild", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this, null)) {
                    return;
                }

                if (update === UnityEngine.UI.CanvasUpdate.Prelayout) {
                    if (this.m_autoSizeTextContainer) {
                        this.m_rectTransform.sizeDelta = this.GetPreferredValues$1(window.Infinity, window.Infinity);
                    }
                } else if (update === UnityEngine.UI.CanvasUpdate.PreRender) {
                    this.OnPreRenderObject();

                    if (!this.m_isMaterialDirty) {
                        return;
                    }

                    this.UpdateMaterial();
                    this.m_isMaterialDirty = false;
                }
            },
            /*TMPro.TextMeshPro.Rebuild end.*/

            /*TMPro.TextMeshPro.UpdateMaterial start.*/
            /**
             * @instance
             * @protected
             * @override
             * @this TMPro.TextMeshPro
             * @memberof TMPro.TextMeshPro
             * @return  {void}
             */
            UpdateMaterial: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#UpdateMaterial", this ); }

                //Debug.Log("***** UpdateMaterial() called on object ID " + GetInstanceID() + ". *****");

                //if (!this.IsActive())
                //    return;

                if (UnityEngine.Component.op_Equality(this.renderer, null) || this.m_sharedMaterial == null) {
                    return;
                }

                // Only update the material if it has changed.
                if (this.m_renderer.sharedMaterial == null || this.m_renderer.sharedMaterial.GetInstanceID() !== this.m_sharedMaterial.GetInstanceID()) {
                    this.m_renderer.sharedMaterial = this.m_sharedMaterial;
                }
            },
            /*TMPro.TextMeshPro.UpdateMaterial end.*/

            /*TMPro.TextMeshPro.UpdateMeshPadding start.*/
            /**
             * Function to be used to force recomputing of character padding when Shader / Material properties have been changed via script.
             *
             * @instance
             * @public
             * @override
             * @this TMPro.TextMeshPro
             * @memberof TMPro.TextMeshPro
             * @return  {void}
             */
            UpdateMeshPadding: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#UpdateMeshPadding", this ); }

                this.m_padding = TMPro.ShaderUtilities.GetPadding(this.m_sharedMaterial, this.m_enableExtraPadding, this.m_isUsingBold);
                this.m_isMaskingEnabled = TMPro.ShaderUtilities.IsMaskingEnabled(this.m_sharedMaterial);
                this.m_havePropertiesChanged = true;
                this.checkPaddingRequired = false;

                // Return if text object is not awake yet.
                if (this.m_textInfo == null) {
                    return;
                }

                // Update sub text objects
                for (var i = 1; i < this.m_textInfo.materialCount; i++) {
                    this.m_subTextObjects[i].UpdateMeshPadding(this.m_enableExtraPadding, this.m_isUsingBold);
                }
            },
            /*TMPro.TextMeshPro.UpdateMeshPadding end.*/

            /*TMPro.TextMeshPro.ForceMeshUpdate start.*/
            /**
             * Function to force regeneration of the text object before its normal process time. This is useful when changes to the text object properties need to be applied immediately.
             *
             * @instance
             * @public
             * @override
             * @this TMPro.TextMeshPro
             * @memberof TMPro.TextMeshPro
             * @param   {boolean}    ignoreActiveState     Ignore Active State of text objects. Inactive objects are ignored by default.
             * @param   {boolean}    forceTextReparsing    Force re-parsing of the text.
             * @return  {void}
             */
            ForceMeshUpdate: function (ignoreActiveState, forceTextReparsing) {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#ForceMeshUpdate", this ); }

                if (ignoreActiveState === void 0) { ignoreActiveState = false; }
                if (forceTextReparsing === void 0) { forceTextReparsing = false; }
                this.m_havePropertiesChanged = true;
                this.m_ignoreActiveState = ignoreActiveState;
                this.OnPreRenderObject();
            },
            /*TMPro.TextMeshPro.ForceMeshUpdate end.*/

            /*TMPro.TextMeshPro.GetTextInfo start.*/
            /**
             * Function used to evaluate the length of a text string.
             *
             * @instance
             * @public
             * @override
             * @this TMPro.TextMeshPro
             * @memberof TMPro.TextMeshPro
             * @param   {string}                text
             * @return  {TMPro.TMP_TextInfo}
             */
            GetTextInfo: function (text) {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#GetTextInfo", this ); }

                this.SetText$2(text);
                this.SetArraySizes(this.m_TextProcessingArray);

                this.m_renderMode = TMPro.TextRenderFlags.DontRender;

                this.ComputeMarginSize();

                this.GenerateTextMesh();

                this.m_renderMode = TMPro.TextRenderFlags.Render;

                return this.textInfo;
            },
            /*TMPro.TextMeshPro.GetTextInfo end.*/

            /*TMPro.TextMeshPro.ClearMesh$1 start.*/
            /**
             * Function to clear the geometry of the Primary and Sub Text objects.
             *
             * @instance
             * @public
             * @override
             * @this TMPro.TextMeshPro
             * @memberof TMPro.TextMeshPro
             * @param   {boolean}    updateMesh
             * @return  {void}
             */
            ClearMesh$1: function (updateMesh) {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#ClearMesh$1", this ); }

                var $t, $t1;
                if (($t = this.m_textInfo.meshInfo)[0].mesh == null) {
                    ($t1 = this.m_textInfo.meshInfo)[0].mesh = this.m_mesh;
                }

                this.m_textInfo.ClearMeshInfo(updateMesh);
            },
            /*TMPro.TextMeshPro.ClearMesh$1 end.*/

            /*TMPro.TextMeshPro.UpdateGeometry$1 start.*/
            /**
             * Function to update the geometry of the main and sub text objects.
             *
             * @instance
             * @public
             * @override
             * @this TMPro.TextMeshPro
             * @memberof TMPro.TextMeshPro
             * @param   {UnityEngine.Mesh}    mesh     
             * @param   {number}              index
             * @return  {void}
             */
            UpdateGeometry$1: function (mesh, index) {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#UpdateGeometry$1", this ); }

                mesh.RecalculateBounds();
            },
            /*TMPro.TextMeshPro.UpdateGeometry$1 end.*/

            /*TMPro.TextMeshPro.UpdateVertexData$1 start.*/
            /**
             * Function to upload the updated vertex data and renderer.
             *
             * @instance
             * @public
             * @override
             * @this TMPro.TextMeshPro
             * @memberof TMPro.TextMeshPro
             * @param   {TMPro.TMP_VertexDataUpdateFlags}    flags
             * @return  {void}
             */
            UpdateVertexData$1: function (flags) {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#UpdateVertexData$1", this ); }

                var $t, $t1, $t2, $t3;
                var materialCount = this.m_textInfo.materialCount;

                for (var i = 0; i < materialCount; i++) {
                    var mesh;

                    if (i === 0) {
                        mesh = this.m_mesh;
                    } else {
                        // Clear unused vertices
                        // TODO: Causes issues when sorting geometry as last vertex data attribute get wiped out.
                        //m_textInfo.meshInfo[i].ClearUnusedVertices();

                        mesh = this.m_subTextObjects[i].mesh;
                    }

                    //mesh.MarkDynamic();

                    if ((flags & TMPro.TMP_VertexDataUpdateFlags.Vertices) === TMPro.TMP_VertexDataUpdateFlags.Vertices) {
                        mesh.vertices = ($t = this.m_textInfo.meshInfo)[i].vertices;
                    }

                    if ((flags & TMPro.TMP_VertexDataUpdateFlags.Uv0) === TMPro.TMP_VertexDataUpdateFlags.Uv0) {
                        mesh.uv = ($t1 = this.m_textInfo.meshInfo)[i].uvs0;
                    }

                    if ((flags & TMPro.TMP_VertexDataUpdateFlags.Uv2) === TMPro.TMP_VertexDataUpdateFlags.Uv2) {
                        mesh.uv2 = ($t2 = this.m_textInfo.meshInfo)[i].uvs2;
                    }

                    //if ((flags & TMP_VertexDataUpdateFlags.Uv4) == TMP_VertexDataUpdateFlags.Uv4)
                    //    mesh.uv4 = m_textInfo.meshInfo[i].uvs4;

                    if ((flags & TMPro.TMP_VertexDataUpdateFlags.Colors32) === TMPro.TMP_VertexDataUpdateFlags.Colors32) {
                        mesh.colors32 = ($t3 = this.m_textInfo.meshInfo)[i].colors32;
                    }

                    mesh.RecalculateBounds();
                }
            },
            /*TMPro.TextMeshPro.UpdateVertexData$1 end.*/

            /*TMPro.TextMeshPro.UpdateVertexData start.*/
            /**
             * Function to upload the updated vertex data and renderer.
             *
             * @instance
             * @public
             * @override
             * @this TMPro.TextMeshPro
             * @memberof TMPro.TextMeshPro
             * @return  {void}
             */
            UpdateVertexData: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#UpdateVertexData", this ); }

                var $t, $t1, $t2, $t3, $t4;
                var materialCount = this.m_textInfo.materialCount;

                for (var i = 0; i < materialCount; i++) {
                    var mesh;

                    if (i === 0) {
                        mesh = this.m_mesh;
                    } else {
                        // Clear unused vertices
                        ($t = this.m_textInfo.meshInfo)[i].ClearUnusedVertices();

                        mesh = this.m_subTextObjects[i].mesh;
                    }


                    //mesh.MarkDynamic();
                    mesh.vertices = ($t1 = this.m_textInfo.meshInfo)[i].vertices;
                    mesh.uv = ($t2 = this.m_textInfo.meshInfo)[i].uvs0;
                    mesh.uv2 = ($t3 = this.m_textInfo.meshInfo)[i].uvs2;
                    //mesh.uv4 = m_textInfo.meshInfo[i].uvs4;
                    mesh.colors32 = ($t4 = this.m_textInfo.meshInfo)[i].colors32;

                    mesh.RecalculateBounds();
                }
            },
            /*TMPro.TextMeshPro.UpdateVertexData end.*/

            /*TMPro.TextMeshPro.UpdateFontAsset start.*/
            UpdateFontAsset: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#UpdateFontAsset", this ); }

                this.LoadFontAsset();
            },
            /*TMPro.TextMeshPro.UpdateFontAsset end.*/

            /*TMPro.TextMeshPro.CalculateLayoutInputHorizontal start.*/
            CalculateLayoutInputHorizontal: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#CalculateLayoutInputHorizontal", this ); }
 },
            /*TMPro.TextMeshPro.CalculateLayoutInputHorizontal end.*/

            /*TMPro.TextMeshPro.CalculateLayoutInputVertical start.*/
            CalculateLayoutInputVertical: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#CalculateLayoutInputVertical", this ); }
 },
            /*TMPro.TextMeshPro.CalculateLayoutInputVertical end.*/

            /*TMPro.TextMeshPro.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#Awake", this ); }

                //Debug.Log("***** Awake() called on object ID " + GetInstanceID() + ". *****");


                // Cache Reference to the Mesh Renderer.
                this.m_renderer = this.GetComponent(UnityEngine.Renderer);
                if (UnityEngine.Component.op_Equality(this.m_renderer, null)) {
                    this.m_renderer = this.gameObject.AddComponent(UnityEngine.Renderer);
                }

                // Cache Reference to RectTransform
                this.m_rectTransform = this.rectTransform$1;

                // Cache Reference to the transform;
                this.m_transform = this.transform$2;

                // Cache a reference to the Mesh Filter.
                this.m_meshFilter = this.GetComponent(UnityEngine.MeshFilter);
                if (UnityEngine.Component.op_Equality(this.m_meshFilter, null)) {
                    this.m_meshFilter = this.gameObject.AddComponent(UnityEngine.MeshFilter);
                }

                // Create new Mesh if necessary and cache reference to it.
                if (this.m_mesh == null) {
                    this.m_mesh = new UnityEngine.Mesh.ctor();
                    this.m_mesh.hideFlags = UnityEngine.HideFlags.HideAndDontSave;
                    this.m_meshFilter.sharedMesh = this.m_mesh;

                    // Create new TextInfo for the text object.
                    this.m_textInfo = new TMPro.TMP_TextInfo.$ctor2(this);
                }

                this.m_meshFilter.hideFlags = 63;


                // Load TMP Settings for new text object instances.
                this.LoadDefaultSettings();

                // Load the font asset and assign material to renderer.
                this.LoadFontAsset();

                // Allocate our initial buffers.
                if (this.m_TextProcessingArray == null) {
                    this.m_TextProcessingArray = System.Array.init(this.m_max_characters, function (){
                        return new TMPro.TMP_Text.UnicodeChar();
                    }, TMPro.TMP_Text.UnicodeChar);
                }

                this.m_cached_TextElement = new TMPro.TMP_Character.ctor();
                this.m_isFirstAllocation = true;

                // Check to make sure Sub Text Objects are tracked correctly in the event a Prefab is used.
                var subTextObjects = this.GetComponentsInChildren(TMPro.TMP_SubMesh);
                if (subTextObjects.length > 0) {
                    var subTextObjectCount = subTextObjects.length;

                    if (subTextObjectCount + 1 > this.m_subTextObjects.length) {
                        System.Array.resize(Bridge.ref(this, "m_subTextObjects"), subTextObjectCount + 1, null, TMPro.TMP_SubMesh);
                    }

                    for (var i = 0; i < subTextObjectCount; i++) {
                        this.m_subTextObjects[i + 1] = subTextObjects[i];
                    }
                }

                // Set flags to ensure our text is parsed and redrawn.
                this.m_havePropertiesChanged = true;

                this.m_isAwake = true;
            },
            /*TMPro.TextMeshPro.Awake end.*/

            /*TMPro.TextMeshPro.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#OnEnable", this ); }

                //Debug.Log("***** OnEnable() called on object ID " + GetInstanceID() + ". *****");

                // Return if Awake() has not been called on the text object.
                if (this.m_isAwake === false) {
                    return;
                }

                // Register Callbacks for various events.
                if (!this.m_isRegisteredForEvents) {
                    this.m_isRegisteredForEvents = true;
                }

                // Register text object for internal updates
                if (this.m_IsTextObjectScaleStatic === false) {
                    TMPro.TMP_UpdateManager.RegisterTextObjectForUpdate(this);
                }

                this.meshFilter.sharedMesh = this.mesh;
                this.SetActiveSubMeshes(true);

                // Schedule potential text object update (if any of the properties have changed.
                this.ComputeMarginSize();

                this.SetAllDirty();

                //m_havePropertiesChanged = true;
            },
            /*TMPro.TextMeshPro.OnEnable end.*/

            /*TMPro.TextMeshPro.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#OnDisable", this ); }

                //Debug.Log("***** OnDisable() called on object ID " + GetInstanceID() + ". *****");

                // Return if Awake() has not been called on the text object.
                if (this.m_isAwake === false) {
                    return;
                }

                TMPro.TMP_UpdateManager.UnRegisterTextElementForRebuild(this);
                TMPro.TMP_UpdateManager.UnRegisterTextObjectForUpdate(this);

                this.meshFilter.sharedMesh = null;
                this.SetActiveSubMeshes(false);
            },
            /*TMPro.TextMeshPro.OnDisable end.*/

            /*TMPro.TextMeshPro.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#OnDestroy", this ); }

                //Debug.Log("***** OnDestroy() called on object ID " + GetInstanceID() + ". *****");

                // Destroy the mesh if we have one.
                if (this.m_mesh != null) {
                    UnityEngine.Object.DestroyImmediate(this.m_mesh);
                }

                // Unregister the event this object was listening to

                this.m_isRegisteredForEvents = false;
                TMPro.TMP_UpdateManager.UnRegisterTextElementForRebuild(this);
                TMPro.TMP_UpdateManager.UnRegisterTextObjectForUpdate(this);
            },
            /*TMPro.TextMeshPro.OnDestroy end.*/

            /*TMPro.TextMeshPro.LoadFontAsset start.*/
            LoadFontAsset: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#LoadFontAsset", this ); }

                //Debug.Log("TextMeshPro LoadFontAsset() has been called."); // Current Font Asset is " + (font != null ? font.name: "Null") );

                TMPro.ShaderUtilities.GetShaderPropertyIDs(); // Initialize & Get shader property IDs.

                if (this.m_fontAsset == null) {
                    if (TMPro.TMP_Settings.defaultFontAsset != null) {
                        this.m_fontAsset = TMPro.TMP_Settings.defaultFontAsset;
                    } else {
                        this.m_fontAsset = UnityEngine.Resources.Load(TMPro.TMP_FontAsset, "Fonts & Materials/LiberationSans SDF");
                    }

                    if (this.m_fontAsset == null) {
                        UnityEngine.Debug.LogWarning$1("The LiberationSans SDF Font Asset was not found. There is no Font Asset assigned to " + (this.gameObject.name || "") + ".", this);
                        return;
                    }

                    if (this.m_fontAsset.characterLookupTable == null) {
                        UnityEngine.Debug.Log$1("Dictionary is Null!");
                    }

                    this.m_sharedMaterial = this.m_fontAsset.material;
                    this.m_sharedMaterial.SetFloat$1("_CullMode", 0);
                    this.m_sharedMaterial.SetFloat$1(TMPro.ShaderUtilities.ShaderTag_ZTestMode, 4);

                    this.m_renderer.receiveShadows = false;
                    this.m_renderer.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.Off;
                } else {
                    if (this.m_fontAsset.characterLookupTable == null) {
                        this.m_fontAsset.ReadFontAssetDefinition();
                    }

                    // If font atlas texture doesn't match the assigned material font atlas, switch back to default material specified in the Font Asset.
                    if (this.m_sharedMaterial == null || this.m_sharedMaterial.GetTexture(TMPro.ShaderUtilities.ID_MainTex) == null || this.m_fontAsset.atlasTexture.GetInstanceID() !== this.m_sharedMaterial.GetTexture(TMPro.ShaderUtilities.ID_MainTex).GetInstanceID()) {
                        if (this.m_fontAsset.material == null) {
                            UnityEngine.Debug.LogWarning$1("The Font Atlas Texture of the Font Asset " + (this.m_fontAsset.name || "") + " assigned to " + (this.gameObject.name || "") + " is missing.", this);
                        } else {
                            this.m_sharedMaterial = this.m_fontAsset.material;
                        }
                    }

                    this.m_sharedMaterial.SetFloat$1(TMPro.ShaderUtilities.ShaderTag_ZTestMode, 4);

                    // Check if we are using the SDF Surface Shader
                    if (this.m_sharedMaterial.passCount === 1) {
                        this.m_renderer.receiveShadows = false;
                        this.m_renderer.shadowCastingMode = UnityEngine.Rendering.ShadowCastingMode.Off;
                    }
                }

                this.m_padding = this.GetPaddingForMaterial();
                this.m_isMaskingEnabled = TMPro.ShaderUtilities.IsMaskingEnabled(this.m_sharedMaterial);

                // Find and cache Underline & Ellipsis characters.
                this.GetSpecialCharacters(this.m_fontAsset);

                this.SetMaterialDirty();
            },
            /*TMPro.TextMeshPro.LoadFontAsset end.*/

            /*TMPro.TextMeshPro.UpdateEnvMapMatrix start.*/
            UpdateEnvMapMatrix: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#UpdateEnvMapMatrix", this ); }

                if (!this.m_sharedMaterial.HasProperty(TMPro.ShaderUtilities.ID_EnvMap) || this.m_sharedMaterial.GetTexture(TMPro.ShaderUtilities.ID_EnvMap) == null) {
                    return;
                }

                //Debug.Log("Updating Env Matrix...");
                var rotation = UnityEngine.Vector3.FromVector4(this.m_sharedMaterial.GetVector(TMPro.ShaderUtilities.ID_EnvMatrixRotation));
                this.m_EnvMapMatrix = new pc.Mat4().setTRS( pc.Vec3.ZERO.clone(), new pc.Quat().setFromEulerAngles_Unity( rotation.x, rotation.y, rotation.z ), new pc.Vec3( 1, 1, 1 ) );

                this.m_sharedMaterial.SetMatrix(TMPro.ShaderUtilities.ID_EnvMatrix, this.m_EnvMapMatrix.$clone());
            },
            /*TMPro.TextMeshPro.UpdateEnvMapMatrix end.*/

            /*TMPro.TextMeshPro.SetMaskCoordinates start.*/
            SetMaskCoordinates: function (coords) {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#SetMaskCoordinates", this ); }

                this.m_sharedMaterial.SetVector(TMPro.ShaderUtilities.ID_ClipRect, coords.$clone());
            },
            /*TMPro.TextMeshPro.SetMaskCoordinates end.*/

            /*TMPro.TextMeshPro.SetMaskCoordinates$1 start.*/
            SetMaskCoordinates$1: function (coords, softX, softY) {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#SetMaskCoordinates$1", this ); }

                this.m_sharedMaterial.SetVector(TMPro.ShaderUtilities.ID_ClipRect, coords.$clone());
                this.m_sharedMaterial.SetFloat(TMPro.ShaderUtilities.ID_MaskSoftnessX, softX);
                this.m_sharedMaterial.SetFloat(TMPro.ShaderUtilities.ID_MaskSoftnessY, softY);
            },
            /*TMPro.TextMeshPro.SetMaskCoordinates$1 end.*/

            /*TMPro.TextMeshPro.EnableMasking start.*/
            EnableMasking: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#EnableMasking", this ); }

                if (this.m_sharedMaterial.HasProperty(TMPro.ShaderUtilities.ID_ClipRect)) {
                    this.m_sharedMaterial.EnableKeyword(TMPro.ShaderUtilities.Keyword_MASK_SOFT);
                    this.m_sharedMaterial.DisableKeyword(TMPro.ShaderUtilities.Keyword_MASK_HARD);
                    this.m_sharedMaterial.DisableKeyword(TMPro.ShaderUtilities.Keyword_MASK_TEX);

                    this.m_isMaskingEnabled = true;
                    this.UpdateMask();
                }
            },
            /*TMPro.TextMeshPro.EnableMasking end.*/

            /*TMPro.TextMeshPro.DisableMasking start.*/
            DisableMasking: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#DisableMasking", this ); }

                if (this.m_sharedMaterial.HasProperty(TMPro.ShaderUtilities.ID_ClipRect)) {
                    this.m_sharedMaterial.DisableKeyword(TMPro.ShaderUtilities.Keyword_MASK_SOFT);
                    this.m_sharedMaterial.DisableKeyword(TMPro.ShaderUtilities.Keyword_MASK_HARD);
                    this.m_sharedMaterial.DisableKeyword(TMPro.ShaderUtilities.Keyword_MASK_TEX);

                    this.m_isMaskingEnabled = false;
                    this.UpdateMask();
                }
            },
            /*TMPro.TextMeshPro.DisableMasking end.*/

            /*TMPro.TextMeshPro.UpdateMask start.*/
            UpdateMask: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#UpdateMask", this ); }

                //Debug.Log("UpdateMask() called.");

                if (!this.m_isMaskingEnabled) {
                    // Release Masking Material

                    // Re-assign Base Material

                    return;
                }

                if (this.m_isMaskingEnabled && this.m_fontMaterial == null) {
                    this.CreateMaterialInstance$1();
                }


                /* 
                if (!m_isMaskingEnabled)
                {
                   //Debug.Log("Masking is not enabled.");
                   if (m_maskingPropertyBlock != null)
                   {
                       m_renderer.SetPropertyBlock(null);
                       //havePropertiesChanged = true;
                   }
                   return;
                }
                //else
                //    Debug.Log("Updating Masking...");
                */

                // Compute Masking Coordinates & Softness
                //float softnessX = Mathf.Min(Mathf.Min(m_textContainer.margins.x, m_textContainer.margins.z), m_sharedMaterial.GetFloat(ShaderUtilities.ID_MaskSoftnessX));
                //float softnessY = Mathf.Min(Mathf.Min(m_textContainer.margins.y, m_textContainer.margins.w), m_sharedMaterial.GetFloat(ShaderUtilities.ID_MaskSoftnessY));

                //softnessX = softnessX > 0 ? softnessX : 0;
                //softnessY = softnessY > 0 ? softnessY : 0;

                //float width = (m_textContainer.width - Mathf.Max(m_textContainer.margins.x, 0) - Mathf.Max(m_textContainer.margins.z, 0)) / 2 + softnessX;
                //float height =  (m_textContainer.height - Mathf.Max(m_textContainer.margins.y, 0) - Mathf.Max(m_textContainer.margins.w, 0)) / 2 + softnessY;

                //Vector2 center = new Vector2((0.5f - m_textContainer.pivot.x) * m_textContainer.width + (Mathf.Max(m_textContainer.margins.x, 0) - Mathf.Max(m_textContainer.margins.z, 0)) / 2, (0.5f - m_textContainer.pivot.y) * m_textContainer.height + (- Mathf.Max(m_textContainer.margins.y, 0) + Mathf.Max(m_textContainer.margins.w, 0)) / 2);
                //Vector4 mask = new Vector4(center.x, center.y, width, height);


                //m_fontMaterial.SetVector(ShaderUtilities.ID_ClipRect, mask);
                //m_fontMaterial.SetFloat(ShaderUtilities.ID_MaskSoftnessX, softnessX);
                //m_fontMaterial.SetFloat(ShaderUtilities.ID_MaskSoftnessY, softnessY);

                /* 
                if(m_maskingPropertyBlock == null)
                {
                   m_maskingPropertyBlock = new MaterialPropertyBlock();

                   //m_maskingPropertyBlock.AddFloat(ShaderUtilities.ID_VertexOffsetX,  m_sharedMaterial.GetFloat(ShaderUtilities.ID_VertexOffsetX));
                   //m_maskingPropertyBlock.AddFloat(ShaderUtilities.ID_VertexOffsetY,  m_sharedMaterial.GetFloat(ShaderUtilities.ID_VertexOffsetY));
                   //Debug.Log("Creating new MaterialPropertyBlock.");
                }

                //Debug.Log("Updating Material Property Block.");
                //m_maskingPropertyBlock.Clear();
                m_maskingPropertyBlock.AddFloat(ShaderUtilities.ID_MaskID, m_renderer.GetInstanceID());
                m_maskingPropertyBlock.AddVector(ShaderUtilities.ID_MaskCoord, mask);
                m_maskingPropertyBlock.AddFloat(ShaderUtilities.ID_MaskSoftnessX, softnessX);
                m_maskingPropertyBlock.AddFloat(ShaderUtilities.ID_MaskSoftnessY, softnessY);

                m_renderer.SetPropertyBlock(m_maskingPropertyBlock);
                */
            },
            /*TMPro.TextMeshPro.UpdateMask end.*/

            /*TMPro.TextMeshPro.GetMaterial start.*/
            GetMaterial: function (mat) {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#GetMaterial", this ); }

                // Check in case Object is disabled. If so, we don't have a valid reference to the Renderer.
                // This can occur when the Duplicate Material Context menu is used on an inactive object.
                //if (m_renderer == null)
                //    m_renderer = GetComponent<Renderer>();

                // Create Instance Material only if the new material is not the same instance previously used.
                if (this.m_fontMaterial == null || this.m_fontMaterial.GetInstanceID() !== mat.GetInstanceID()) {
                    this.m_fontMaterial = this.CreateMaterialInstance(mat);
                }

                this.m_sharedMaterial = this.m_fontMaterial;

                this.m_padding = this.GetPaddingForMaterial();

                this.SetVerticesDirty();
                this.SetMaterialDirty();

                return this.m_sharedMaterial;
            },
            /*TMPro.TextMeshPro.GetMaterial end.*/

            /*TMPro.TextMeshPro.GetMaterials start.*/
            /**
             * Method returning instances of the materials used by the text object.
             *
             * @instance
             * @protected
             * @override
             * @this TMPro.TextMeshPro
             * @memberof TMPro.TextMeshPro
             * @param   {Array.<UnityEngine.Material>}    mats
             * @return  {Array.<UnityEngine.Material>}
             */
            GetMaterials: function (mats) {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#GetMaterials", this ); }

                var materialCount = this.m_textInfo.materialCount;

                if (this.m_fontMaterials == null) {
                    this.m_fontMaterials = System.Array.init(materialCount, null, UnityEngine.Material);
                } else if (this.m_fontMaterials.length !== materialCount) {
                    TMPro.TMP_TextInfo.Resize$1(UnityEngine.Material, Bridge.ref(this, "m_fontMaterials"), materialCount, false);
                }

                // Get instances of the materials
                for (var i = 0; i < materialCount; i++) {
                    if (i === 0) {
                        this.m_fontMaterials[i] = this.fontMaterial;
                    } else {
                        this.m_fontMaterials[i] = this.m_subTextObjects[i].material;
                    }
                }

                this.m_fontSharedMaterials = this.m_fontMaterials;

                return this.m_fontMaterials;
            },
            /*TMPro.TextMeshPro.GetMaterials end.*/

            /*TMPro.TextMeshPro.SetSharedMaterial start.*/
            SetSharedMaterial: function (mat) {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#SetSharedMaterial", this ); }

                // Check in case Object is disabled. If so, we don't have a valid reference to the Renderer.
                // This can occur when the Duplicate Material Context menu is used on an inactive object.
                //if (m_renderer == null)
                //    m_renderer = GetComponent<Renderer>();

                this.m_sharedMaterial = mat;

                this.m_padding = this.GetPaddingForMaterial();

                this.SetMaterialDirty();
            },
            /*TMPro.TextMeshPro.SetSharedMaterial end.*/

            /*TMPro.TextMeshPro.GetSharedMaterials start.*/
            /**
             * Method returning an array containing the materials used by the text object.
             *
             * @instance
             * @protected
             * @override
             * @this TMPro.TextMeshPro
             * @memberof TMPro.TextMeshPro
             * @return  {Array.<UnityEngine.Material>}
             */
            GetSharedMaterials: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#GetSharedMaterials", this ); }

                var materialCount = this.m_textInfo.materialCount;

                if (this.m_fontSharedMaterials == null) {
                    this.m_fontSharedMaterials = System.Array.init(materialCount, null, UnityEngine.Material);
                } else if (this.m_fontSharedMaterials.length !== materialCount) {
                    TMPro.TMP_TextInfo.Resize$1(UnityEngine.Material, Bridge.ref(this, "m_fontSharedMaterials"), materialCount, false);
                }

                for (var i = 0; i < materialCount; i++) {
                    if (i === 0) {
                        this.m_fontSharedMaterials[i] = this.m_sharedMaterial;
                    } else {
                        this.m_fontSharedMaterials[i] = this.m_subTextObjects[i].sharedMaterial;
                    }
                }

                return this.m_fontSharedMaterials;
            },
            /*TMPro.TextMeshPro.GetSharedMaterials end.*/

            /*TMPro.TextMeshPro.SetSharedMaterials start.*/
            /**
             * Method used to assign new materials to the text and sub text objects.
             *
             * @instance
             * @protected
             * @override
             * @this TMPro.TextMeshPro
             * @memberof TMPro.TextMeshPro
             * @param   {Array.<UnityEngine.Material>}    materials
             * @return  {void}
             */
            SetSharedMaterials: function (materials) {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#SetSharedMaterials", this ); }

                var $t, $t1;
                var materialCount = this.m_textInfo.materialCount;

                // Check allocation of the fontSharedMaterials array.
                if (this.m_fontSharedMaterials == null) {
                    this.m_fontSharedMaterials = System.Array.init(materialCount, null, UnityEngine.Material);
                } else if (this.m_fontSharedMaterials.length !== materialCount) {
                    TMPro.TMP_TextInfo.Resize$1(UnityEngine.Material, Bridge.ref(this, "m_fontSharedMaterials"), materialCount, false);
                }

                // Only assign as many materials as the text object contains.
                for (var i = 0; i < materialCount; i++) {
                    var mat_MainTex = materials[i].GetTexture(TMPro.ShaderUtilities.ID_MainTex);

                    if (i === 0) {
                        // Only assign new material if the font atlas textures match.
                        if (mat_MainTex == null || mat_MainTex.GetInstanceID() !== this.m_sharedMaterial.GetTexture(TMPro.ShaderUtilities.ID_MainTex).GetInstanceID()) {
                            continue;
                        }

                        this.m_sharedMaterial = ($t = materials[i], this.m_fontSharedMaterials[i] = $t, $t);
                        this.m_padding = this.GetPaddingForMaterial$1(this.m_sharedMaterial);
                    } else {
                        // Only assign new material if the font atlas textures match.
                        if (mat_MainTex == null || mat_MainTex.GetInstanceID() !== this.m_subTextObjects[i].sharedMaterial.GetTexture(TMPro.ShaderUtilities.ID_MainTex).GetInstanceID()) {
                            continue;
                        }

                        // Only assign a new material if none were specified in the text input.
                        if (this.m_subTextObjects[i].isDefaultMaterial) {
                            this.m_subTextObjects[i].sharedMaterial = ($t1 = materials[i], this.m_fontSharedMaterials[i] = $t1, $t1);
                        }
                    }
                }
            },
            /*TMPro.TextMeshPro.SetSharedMaterials end.*/

            /*TMPro.TextMeshPro.SetOutlineThickness start.*/
            SetOutlineThickness: function (thickness) {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#SetOutlineThickness", this ); }

                thickness = Math.max(0, Math.min(1, thickness));
                this.m_renderer.material.SetFloat(TMPro.ShaderUtilities.ID_OutlineWidth, thickness);

                if (this.m_fontMaterial == null) {
                    this.m_fontMaterial = this.m_renderer.material;
                }

                this.m_fontMaterial = this.m_renderer.material;
                this.m_sharedMaterial = this.m_fontMaterial;
                this.m_padding = this.GetPaddingForMaterial();
            },
            /*TMPro.TextMeshPro.SetOutlineThickness end.*/

            /*TMPro.TextMeshPro.SetFaceColor start.*/
            SetFaceColor: function (color) {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#SetFaceColor", this ); }

                this.m_renderer.material.SetColor(TMPro.ShaderUtilities.ID_FaceColor, UnityEngine.Color32.op_Implicit(color.$clone()));

                if (this.m_fontMaterial == null) {
                    this.m_fontMaterial = this.m_renderer.material;
                }

                this.m_sharedMaterial = this.m_fontMaterial;
            },
            /*TMPro.TextMeshPro.SetFaceColor end.*/

            /*TMPro.TextMeshPro.SetOutlineColor start.*/
            SetOutlineColor: function (color) {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#SetOutlineColor", this ); }

                this.m_renderer.material.SetColor(TMPro.ShaderUtilities.ID_OutlineColor, UnityEngine.Color32.op_Implicit(color.$clone()));

                if (this.m_fontMaterial == null) {
                    this.m_fontMaterial = this.m_renderer.material;
                }

                //Debug.Log("Material ID:" + m_fontMaterial.GetInstanceID());
                this.m_sharedMaterial = this.m_fontMaterial;
            },
            /*TMPro.TextMeshPro.SetOutlineColor end.*/

            /*TMPro.TextMeshPro.CreateMaterialInstance$1 start.*/
            CreateMaterialInstance$1: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#CreateMaterialInstance$1", this ); }

                var mat = new UnityEngine.Material.$ctor1(this.m_sharedMaterial);
                mat.shaderKeywords = this.m_sharedMaterial.shaderKeywords;

                //mat.hideFlags = HideFlags.DontSave;
                mat.name = (mat.name || "") + " Instance";

                this.m_fontMaterial = mat;
            },
            /*TMPro.TextMeshPro.CreateMaterialInstance$1 end.*/

            /*TMPro.TextMeshPro.SetShaderDepth start.*/
            SetShaderDepth: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#SetShaderDepth", this ); }

                if (this.m_isOverlay) {
                    // Changing these properties results in an instance of the material
                    this.m_sharedMaterial.SetFloat$1(TMPro.ShaderUtilities.ShaderTag_ZTestMode, 0);
                    //m_renderer.material.SetFloat("_ZTestMode", 8);
                    this.m_renderer.material.renderQueue = 4000;

                    this.m_sharedMaterial = this.m_renderer.material;
                    //Debug.Log("Text set to Overlay mode.");
                } else {
                    // Should this use an instanced material?
                    this.m_sharedMaterial.SetFloat$1(TMPro.ShaderUtilities.ShaderTag_ZTestMode, 4);
                    this.m_renderer.material.renderQueue = -1;

                    this.m_sharedMaterial = this.m_renderer.material;
                    //Debug.Log("Text set to Normal mode.");
                }
            },
            /*TMPro.TextMeshPro.SetShaderDepth end.*/

            /*TMPro.TextMeshPro.SetCulling start.*/
            SetCulling: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#SetCulling", this ); }

                if (this.m_isCullingEnabled) {
                    this.m_renderer.material.SetFloat$1("_CullMode", 2);

                    for (var i = 1; i < this.m_subTextObjects.length && UnityEngine.MonoBehaviour.op_Inequality(this.m_subTextObjects[i], null); i++) {
                        var renderer = this.m_subTextObjects[i].renderer;

                        if (UnityEngine.Component.op_Inequality(renderer, null)) {
                            renderer.material.SetFloat$1(TMPro.ShaderUtilities.ShaderTag_CullMode, 2);
                        }
                    }
                } else {
                    this.m_renderer.material.SetFloat$1("_CullMode", 0);

                    for (var i1 = 1; i1 < this.m_subTextObjects.length && UnityEngine.MonoBehaviour.op_Inequality(this.m_subTextObjects[i1], null); i1++) {
                        var renderer1 = this.m_subTextObjects[i1].renderer;

                        if (UnityEngine.Component.op_Inequality(renderer1, null)) {
                            renderer1.material.SetFloat$1(TMPro.ShaderUtilities.ShaderTag_CullMode, 0);
                        }
                    }
                }
            },
            /*TMPro.TextMeshPro.SetCulling end.*/

            /*TMPro.TextMeshPro.SetPerspectiveCorrection start.*/
            SetPerspectiveCorrection: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#SetPerspectiveCorrection", this ); }

                if (this.m_isOrthographic) {
                    this.m_sharedMaterial.SetFloat(TMPro.ShaderUtilities.ID_PerspectiveFilter, 0.0);
                } else {
                    this.m_sharedMaterial.SetFloat(TMPro.ShaderUtilities.ID_PerspectiveFilter, 0.875);
                }
            },
            /*TMPro.TextMeshPro.SetPerspectiveCorrection end.*/

            /*TMPro.TextMeshPro.SetArraySizes start.*/
            SetArraySizes: function (unicodeChars) {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#SetArraySizes", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20, $t21, $t22, $t23, $t24, $t25, $t26, $t27, $t28, $t29, $t30, $t31, $t32, $t33, $t34;
                var spriteCount = 0;

                this.m_totalCharacterCount = 0;
                this.m_isUsingBold = false;
                this.m_isParsingText = false;
                this.tag_NoParsing = false;
                this.m_FontStyleInternal = this.m_fontStyle;
                this.m_fontStyleStack.Clear();

                this.m_FontWeightInternal = (this.m_FontStyleInternal & TMPro.FontStyles.Bold) === TMPro.FontStyles.Bold ? TMPro.FontWeight.Bold : this.m_fontWeight;
                this.m_FontWeightStack.SetDefault(this.m_FontWeightInternal);

                this.m_currentFontAsset = this.m_fontAsset;
                this.m_currentMaterial = this.m_sharedMaterial;
                this.m_currentMaterialIndex = 0;

                TMPro.TMP_Text.m_materialReferenceStack.SetDefault(new TMPro.MaterialReference.$ctor1(this.m_currentMaterialIndex, this.m_currentFontAsset, null, this.m_currentMaterial, this.m_padding));

                TMPro.TMP_Text.m_materialReferenceIndexLookup.clear();
                TMPro.MaterialReference.AddMaterialReference(this.m_currentMaterial, this.m_currentFontAsset, Bridge.ref(TMPro.TMP_Text, "m_materialReferences"), TMPro.TMP_Text.m_materialReferenceIndexLookup);

                // Set allocations for the text object's TextInfo
                if (this.m_textInfo == null) {
                    this.m_textInfo = new TMPro.TMP_TextInfo.$ctor1(this.m_InternalTextProcessingArraySize);
                } else if (this.m_textInfo.characterInfo.length < this.m_InternalTextProcessingArraySize) {
                    TMPro.TMP_TextInfo.Resize$1(TMPro.TMP_CharacterInfo, Bridge.ref(this.m_textInfo, "characterInfo"), this.m_InternalTextProcessingArraySize, false);
                }

                this.m_textElementType = TMPro.TMP_TextElementType.Character;

                // Handling for Underline special character


                /* 
                GetUnderlineSpecialCharacter(m_currentFontAsset);
                if (m_Underline.character != null)
                {
                   if (m_Underline.fontAsset.GetInstanceID() != m_currentFontAsset.GetInstanceID())
                   {
                       if (TMP_Settings.matchMaterialPreset && m_currentMaterial.GetInstanceID() != m_Underline.fontAsset.material.GetInstanceID())
                           m_Underline.material = TMP_MaterialManager.GetFallbackMaterial(m_currentMaterial, m_Underline.fontAsset.material);
                       else
                           m_Underline.material = m_Underline.fontAsset.material;

                       m_Underline.materialIndex = MaterialReference.AddMaterialReference(m_Underline.material, m_Underline.fontAsset, m_materialReferences, m_materialReferenceIndexLookup);
                       m_materialReferences[m_Underline.materialIndex].referenceCount = 0;
                   }
                }
                */



                // Handling for Ellipsis special character


                if (this.m_overflowMode === TMPro.TextOverflowModes.Ellipsis) {
                    this.GetEllipsisSpecialCharacter(this.m_currentFontAsset);

                    if (this.m_Ellipsis.character != null) {
                        if (this.m_Ellipsis.fontAsset.GetInstanceID() !== this.m_currentFontAsset.GetInstanceID()) {
                            if (TMPro.TMP_Settings.matchMaterialPreset && this.m_currentMaterial.GetInstanceID() !== this.m_Ellipsis.fontAsset.material.GetInstanceID()) {
                                this.m_Ellipsis.material = TMPro.TMP_MaterialManager.GetFallbackMaterial(this.m_currentMaterial, this.m_Ellipsis.fontAsset.material);
                            } else {
                                this.m_Ellipsis.material = this.m_Ellipsis.fontAsset.material;
                            }

                            this.m_Ellipsis.materialIndex = TMPro.MaterialReference.AddMaterialReference(this.m_Ellipsis.material, this.m_Ellipsis.fontAsset, Bridge.ref(TMPro.TMP_Text, "m_materialReferences"), TMPro.TMP_Text.m_materialReferenceIndexLookup);
                            TMPro.TMP_Text.m_materialReferences[this.m_Ellipsis.materialIndex].referenceCount = 0;
                        }
                    } else {
                        this.m_overflowMode = TMPro.TextOverflowModes.Truncate;

                        if (!TMPro.TMP_Settings.warningsDisabled) {
                            UnityEngine.Debug.LogWarning$1("The character used for Ellipsis is not available in font asset [" + (this.m_currentFontAsset.name || "") + "] or any potential fallbacks. Switching Text Overflow mode to Truncate.", this);
                        }
                    }
                }



                // Clear Linked Text object if we have one.
                if (this.m_overflowMode === TMPro.TextOverflowModes.Linked && UnityEngine.MonoBehaviour.op_Inequality(this.m_linkedTextComponent, null) && !this.m_isCalculatingPreferredValues) {
                    this.m_linkedTextComponent.text = "";
                }

                // Parsing XML tags in the text
                for (var i = 0; i < unicodeChars.length && unicodeChars[i].unicode !== 0; i++) {
                    //Make sure the characterInfo array can hold the next text element.
                    if (this.m_textInfo.characterInfo == null || this.m_totalCharacterCount >= this.m_textInfo.characterInfo.length) {
                        TMPro.TMP_TextInfo.Resize$1(TMPro.TMP_CharacterInfo, Bridge.ref(this.m_textInfo, "characterInfo"), this.m_totalCharacterCount + 1, true);
                    }

                    var unicode = unicodeChars[i].unicode;

                    // PARSE XML TAGS


                    if (this.m_isRichText && unicode === 60) {
                        var prev_MaterialIndex = this.m_currentMaterialIndex;
                        var endTagIndex = { };

                        // Check if Tag is Valid
                        if (this.ValidateHtmlTag(unicodeChars, i + 1, endTagIndex)) {
                            var tagStartIndex = unicodeChars[i].stringIndex;
                            i = endTagIndex.v;

                            if ((this.m_FontStyleInternal & TMPro.FontStyles.Bold) === TMPro.FontStyles.Bold) {
                                this.m_isUsingBold = true;
                            }

                            if (this.m_textElementType === TMPro.TMP_TextElementType.Sprite) {
                                TMPro.TMP_Text.m_materialReferences[this.m_currentMaterialIndex].referenceCount += 1;

                                ($t = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].character = 57344 + this.m_spriteIndex;
                                ($t1 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].spriteIndex = this.m_spriteIndex;
                                ($t2 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].fontAsset = this.m_currentFontAsset;
                                ($t3 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].spriteAsset = this.m_currentSpriteAsset;
                                ($t4 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].materialReferenceIndex = this.m_currentMaterialIndex;
                                ($t5 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].textElement = this.m_currentSpriteAsset.spriteCharacterTable.getItem(this.m_spriteIndex);
                                ($t6 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].elementType = this.m_textElementType;
                                ($t7 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].index = tagStartIndex;
                                ($t8 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].stringLength = unicodeChars[i].stringIndex - tagStartIndex + 1;

                                // Restore element type and material index to previous values.
                                this.m_textElementType = TMPro.TMP_TextElementType.Character;
                                this.m_currentMaterialIndex = prev_MaterialIndex;

                                spriteCount += 1;
                                this.m_totalCharacterCount += 1;
                            }

                            continue;
                        }
                    }


                    var isUsingAlternativeTypeface = { };
                    var isUsingFallbackOrAlternativeTypeface = false;

                    var prev_fontAsset = this.m_currentFontAsset;
                    var prev_material = this.m_currentMaterial;
                    var prev_materialIndex = this.m_currentMaterialIndex;

                    // Handle Font Styles like LowerCase, UpperCase and SmallCaps.


                    if (this.m_textElementType === TMPro.TMP_TextElementType.Character) {
                        if ((this.m_FontStyleInternal & TMPro.FontStyles.UpperCase) === TMPro.FontStyles.UpperCase) {
                            // If this character is lowercase, switch to uppercase.
                            if (Bridge.isLower(unicode)) {
                                unicode = String.fromCharCode(unicode).toUpperCase().charCodeAt(0);
                            }
                        } else if ((this.m_FontStyleInternal & TMPro.FontStyles.LowerCase) === TMPro.FontStyles.LowerCase) {
                            // If this character is uppercase, switch to lowercase.
                            if (Bridge.isUpper(unicode)) {
                                unicode = String.fromCharCode(unicode).toLowerCase().charCodeAt(0);
                            }
                        } else if ((this.m_FontStyleInternal & TMPro.FontStyles.SmallCaps) === TMPro.FontStyles.SmallCaps) {
                            // Only convert lowercase characters to uppercase.
                            if (Bridge.isLower(unicode)) {
                                unicode = String.fromCharCode(unicode).toUpperCase().charCodeAt(0);
                            }
                        }
                    }


                    // Lookup the Glyph data for each character and cache it.


                    var character = this.GetTextElement(unicode, this.m_currentFontAsset, this.m_FontStyleInternal, this.m_FontWeightInternal, isUsingAlternativeTypeface);

                    // Check if Lowercase or Uppercase variant of the character is available.
                    /* Not sure this is necessary anyone as it is very unlikely with recursive search through fallback fonts.
                    if (glyph == null)
                    {
                       if (char.IsLower((char)c))
                       {
                           if (m_currentFontAsset.characterDictionary.TryGetValue(char.ToUpper((char)c), out glyph))
                               c = chars[i] = char.ToUpper((char)c);
                       }
                       else if (char.IsUpper((char)c))
                       {
                           if (m_currentFontAsset.characterDictionary.TryGetValue(char.ToLower((char)c), out glyph))
                               c = chars[i] = char.ToLower((char)c);
                       }
                    }*/

                    // Special handling for missing character.
                    // Replace missing glyph by the Square (9633) glyph or possibly the Space (32) glyph.
                    if (character == null) {
                        // Save the original unicode character
                        var srcGlyph = unicode;

                        // Try replacing the missing glyph character by TMP Settings Missing Glyph or Square (9633) character.
                        unicode = ($t9 = TMPro.TMP_Settings.missingGlyphCharacter === 0 ? 9633 : TMPro.TMP_Settings.missingGlyphCharacter, unicodeChars[i].unicode = $t9, $t9);

                        // Check for the missing glyph character in the currently assigned font asset and its fallbacks
                        character = TMPro.TMP_FontAssetUtilities.GetCharacterFromFontAsset(unicode, this.m_currentFontAsset, true, this.m_FontStyleInternal, this.m_FontWeightInternal, isUsingAlternativeTypeface);

                        if (character == null) {
                            // Search for the missing glyph character in the TMP Settings Fallback list.
                            if (TMPro.TMP_Settings.fallbackFontAssets != null && TMPro.TMP_Settings.fallbackFontAssets.Count > 0) {
                                character = TMPro.TMP_FontAssetUtilities.GetCharacterFromFontAssets(unicode, this.m_currentFontAsset, TMPro.TMP_Settings.fallbackFontAssets, true, this.m_FontStyleInternal, this.m_FontWeightInternal, isUsingAlternativeTypeface);
                            }
                        }

                        if (character == null) {
                            // Search for the missing glyph in the TMP Settings Default Font Asset.
                            if (TMPro.TMP_Settings.defaultFontAsset != null) {
                                character = TMPro.TMP_FontAssetUtilities.GetCharacterFromFontAsset(unicode, TMPro.TMP_Settings.defaultFontAsset, true, this.m_FontStyleInternal, this.m_FontWeightInternal, isUsingAlternativeTypeface);
                            }
                        }

                        if (character == null) {
                            // Use Space (32) Glyph from the currently assigned font asset.
                            unicode = (unicodeChars[i].unicode = 32, 32);
                            character = TMPro.TMP_FontAssetUtilities.GetCharacterFromFontAsset(unicode, this.m_currentFontAsset, true, this.m_FontStyleInternal, this.m_FontWeightInternal, isUsingAlternativeTypeface);
                        }

                        if (character == null) {
                            // Use End of Text (0x03) Glyph from the currently assigned font asset.
                            unicode = (unicodeChars[i].unicode = 3, 3);
                            character = TMPro.TMP_FontAssetUtilities.GetCharacterFromFontAsset(unicode, this.m_currentFontAsset, true, this.m_FontStyleInternal, this.m_FontWeightInternal, isUsingAlternativeTypeface);
                        }

                        if (!TMPro.TMP_Settings.warningsDisabled) {
                            var formattedWarning = srcGlyph > 65535 ? System.String.format("The character with Unicode value \\U{0:X8} was not found in the [{1}] font asset or any potential fallbacks. It was replaced by Unicode character \\u{2:X4} in text object [{3}].", srcGlyph, this.m_fontAsset.name, character.unicode, this.name) : System.String.format("The character with Unicode value \\u{0:X4} was not found in the [{1}] font asset or any potential fallbacks. It was replaced by Unicode character \\u{2:X4} in text object [{3}].", srcGlyph, this.m_fontAsset.name, character.unicode, this.name);

                            UnityEngine.Debug.LogWarning$1(formattedWarning, this);
                        }
                    }

                    if (character.elementType === TMPro.TextElementType.Character) {
                        if (character.textAsset.instanceID !== this.m_currentFontAsset.instanceID) {
                            isUsingFallbackOrAlternativeTypeface = true;
                            this.m_currentFontAsset = Bridge.as(character.textAsset, TMPro.TMP_FontAsset);
                        }
                    }


                    // Save text element data
                    ($t10 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].elementType = TMPro.TMP_TextElementType.Character;
                    ($t11 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].textElement = character;
                    ($t12 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].isUsingAlternateTypeface = isUsingAlternativeTypeface.v;
                    ($t13 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].character = unicode;
                    ($t14 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].index = unicodeChars[i].stringIndex;
                    ($t15 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].stringLength = unicodeChars[i].length;
                    ($t16 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].fontAsset = this.m_currentFontAsset;

                    // Special handling if the character is a sprite.
                    if (character.elementType === TMPro.TextElementType.Sprite) {
                        var spriteAssetRef = Bridge.as(character.textAsset, TMPro.TMP_SpriteAsset);
                        this.m_currentMaterialIndex = TMPro.MaterialReference.AddMaterialReference$1(spriteAssetRef.material, spriteAssetRef, Bridge.ref(TMPro.TMP_Text, "m_materialReferences"), TMPro.TMP_Text.m_materialReferenceIndexLookup);
                        TMPro.TMP_Text.m_materialReferences[this.m_currentMaterialIndex].referenceCount += 1;

                        ($t17 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].elementType = TMPro.TMP_TextElementType.Sprite;
                        ($t18 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].materialReferenceIndex = this.m_currentMaterialIndex;
                        ($t19 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].spriteAsset = spriteAssetRef;
                        ($t20 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].spriteIndex = character.glyphIndex;

                        // Restore element type and material index to previous values.
                        this.m_textElementType = TMPro.TMP_TextElementType.Character;
                        this.m_currentMaterialIndex = prev_materialIndex;

                        spriteCount += 1;
                        this.m_totalCharacterCount += 1;

                        continue;
                    }

                    if (isUsingFallbackOrAlternativeTypeface && this.m_currentFontAsset.instanceID !== this.m_fontAsset.instanceID) {
                        // Create Fallback material instance matching current material preset if necessary
                        if (TMPro.TMP_Settings.matchMaterialPreset) {
                            this.m_currentMaterial = TMPro.TMP_MaterialManager.GetFallbackMaterial(this.m_currentMaterial, this.m_currentFontAsset.material);
                        } else {
                            this.m_currentMaterial = this.m_currentFontAsset.material;
                        }

                        this.m_currentMaterialIndex = TMPro.MaterialReference.AddMaterialReference(this.m_currentMaterial, this.m_currentFontAsset, Bridge.ref(TMPro.TMP_Text, "m_materialReferences"), TMPro.TMP_Text.m_materialReferenceIndexLookup);
                    }

                    // Handle Multi Atlas Texture support
                    if (character != null && character.glyph.atlasIndex > 0) {
                        this.m_currentMaterial = TMPro.TMP_MaterialManager.GetFallbackMaterial$1(this.m_currentFontAsset, this.m_currentMaterial, character.glyph.atlasIndex);

                        this.m_currentMaterialIndex = TMPro.MaterialReference.AddMaterialReference(this.m_currentMaterial, this.m_currentFontAsset, Bridge.ref(TMPro.TMP_Text, "m_materialReferences"), TMPro.TMP_Text.m_materialReferenceIndexLookup);

                        isUsingFallbackOrAlternativeTypeface = true;
                    }

                    if (!System.Char.isWhiteSpace(String.fromCharCode(unicode)) && unicode !== 8203) {
                        // Limit the mesh of the main text object to 65535 vertices and use sub objects for the overflow.
                        if (TMPro.TMP_Text.m_materialReferences[this.m_currentMaterialIndex].referenceCount < 16383) {
                            TMPro.TMP_Text.m_materialReferences[this.m_currentMaterialIndex].referenceCount += 1;
                        } else {
                            this.m_currentMaterialIndex = TMPro.MaterialReference.AddMaterialReference(new UnityEngine.Material.$ctor1(this.m_currentMaterial), this.m_currentFontAsset, Bridge.ref(TMPro.TMP_Text, "m_materialReferences"), TMPro.TMP_Text.m_materialReferenceIndexLookup);
                            TMPro.TMP_Text.m_materialReferences[this.m_currentMaterialIndex].referenceCount += 1;
                        }
                    }

                    ($t21 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].material = this.m_currentMaterial;
                    ($t22 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].materialReferenceIndex = this.m_currentMaterialIndex;
                    TMPro.TMP_Text.m_materialReferences[this.m_currentMaterialIndex].isFallbackMaterial = isUsingFallbackOrAlternativeTypeface;

                    // Restore previous font asset and material if fallback font was used.
                    if (isUsingFallbackOrAlternativeTypeface) {
                        TMPro.TMP_Text.m_materialReferences[this.m_currentMaterialIndex].fallbackMaterial = prev_material;
                        this.m_currentFontAsset = prev_fontAsset;
                        this.m_currentMaterial = prev_material;
                        this.m_currentMaterialIndex = prev_materialIndex;
                    }

                    this.m_totalCharacterCount += 1;
                }

                // Early return if we are calculating the preferred values.
                if (this.m_isCalculatingPreferredValues) {
                    this.m_isCalculatingPreferredValues = false;

                    return this.m_totalCharacterCount;
                }

                // Save material and sprite count.
                this.m_textInfo.spriteCount = spriteCount;
                var materialCount = ($t23 = TMPro.TMP_Text.m_materialReferenceIndexLookup.Count, this.m_textInfo.materialCount = $t23, $t23);

                // Check if we need to resize the MeshInfo array for handling different materials.
                if (materialCount > this.m_textInfo.meshInfo.length) {
                    TMPro.TMP_TextInfo.Resize$1(TMPro.TMP_MeshInfo, Bridge.ref(this.m_textInfo, "meshInfo"), materialCount, false);
                }

                // Resize SubTextObject array if necessary
                if (materialCount > this.m_subTextObjects.length) {
                    TMPro.TMP_TextInfo.Resize(TMPro.TMP_SubMesh, Bridge.ref(this, "m_subTextObjects"), UnityEngine.Mathf.NextPowerOfTwo(materialCount + 1));
                }

                // Resize CharacterInfo[] if allocations are excessive
                if (this.m_VertexBufferAutoSizeReduction && this.m_textInfo.characterInfo.length - this.m_totalCharacterCount > 256) {
                    TMPro.TMP_TextInfo.Resize$1(TMPro.TMP_CharacterInfo, Bridge.ref(this.m_textInfo, "characterInfo"), UnityEngine.Mathf.Max(this.m_totalCharacterCount + 1, 256), true);
                }


                // Iterate through the material references to set the mesh buffer allocations
                for (var i1 = 0; i1 < materialCount; i1++) {
                    // Add new sub text object for each material reference
                    if (i1 > 0) {
                        if (UnityEngine.MonoBehaviour.op_Equality(this.m_subTextObjects[i1], null)) {
                            this.m_subTextObjects[i1] = TMPro.TMP_SubMesh.AddSubTextObject(this, TMPro.TMP_Text.m_materialReferences[i1].$clone());

                            // Not sure this is necessary
                            ($t24 = this.m_textInfo.meshInfo)[i1].vertices = null;
                        }
                        //else if (m_subTextObjects[i].gameObject.activeInHierarchy == false)
                        //    m_subTextObjects[i].gameObject.SetActive(true);

                        // Check if the material has changed.
                        if (this.m_subTextObjects[i1].sharedMaterial == null || this.m_subTextObjects[i1].sharedMaterial.GetInstanceID() !== TMPro.TMP_Text.m_materialReferences[i1].material.GetInstanceID()) {
                            this.m_subTextObjects[i1].sharedMaterial = TMPro.TMP_Text.m_materialReferences[i1].material;
                            this.m_subTextObjects[i1].fontAsset = TMPro.TMP_Text.m_materialReferences[i1].fontAsset;
                            this.m_subTextObjects[i1].spriteAsset = TMPro.TMP_Text.m_materialReferences[i1].spriteAsset;
                        }

                        // Check if we need to use a Fallback Material
                        if (TMPro.TMP_Text.m_materialReferences[i1].isFallbackMaterial) {
                            this.m_subTextObjects[i1].fallbackMaterial = TMPro.TMP_Text.m_materialReferences[i1].material;
                            this.m_subTextObjects[i1].fallbackSourceMaterial = TMPro.TMP_Text.m_materialReferences[i1].fallbackMaterial;
                        }
                    }

                    var referenceCount = TMPro.TMP_Text.m_materialReferences[i1].referenceCount;

                    // Check to make sure our buffers allocations can accommodate the required text elements.
                    if (($t25 = this.m_textInfo.meshInfo)[i1].vertices == null || ($t26 = this.m_textInfo.meshInfo)[i1].vertices.length < referenceCount * 4) {
                        if (($t27 = this.m_textInfo.meshInfo)[i1].vertices == null) {
                            if (i1 === 0) {
                                ($t28 = this.m_textInfo.meshInfo)[i1] = new TMPro.TMP_MeshInfo.$ctor1(this.m_mesh, referenceCount + 1);
                            } else {
                                ($t29 = this.m_textInfo.meshInfo)[i1] = new TMPro.TMP_MeshInfo.$ctor1(this.m_subTextObjects[i1].mesh, referenceCount + 1);
                            }
                        } else {
                            ($t30 = this.m_textInfo.meshInfo)[i1].ResizeMeshInfo(referenceCount > 1024 ? referenceCount + 256 : UnityEngine.Mathf.NextPowerOfTwo(referenceCount + 1));
                        }
                    } else if (this.m_VertexBufferAutoSizeReduction && referenceCount > 0 && ($t31 = this.m_textInfo.meshInfo)[i1].vertices.length / 4 - referenceCount > 256) {
                        // Resize vertex buffers if allocations are excessive.
                        //Debug.Log("Reducing the size of the vertex buffers.");
                        ($t32 = this.m_textInfo.meshInfo)[i1].ResizeMeshInfo(referenceCount > 1024 ? referenceCount + 256 : UnityEngine.Mathf.NextPowerOfTwo(referenceCount + 1));
                    }

                    // Assign material reference
                    ($t33 = this.m_textInfo.meshInfo)[i1].material = TMPro.TMP_Text.m_materialReferences[i1].material;
                }

                //TMP_MaterialManager.CleanupFallbackMaterials();

                // Clean up unused SubMeshes
                for (var i2 = materialCount; i2 < this.m_subTextObjects.length && UnityEngine.MonoBehaviour.op_Inequality(this.m_subTextObjects[i2], null); i2++) {
                    if (i2 < this.m_textInfo.meshInfo.length) {
                        ($t34 = this.m_textInfo.meshInfo)[i2].ClearUnusedVertices$2(0, true);
                    }

                    //m_subTextObjects[i].gameObject.SetActive(false);
                }

                return this.m_totalCharacterCount;
            },
            /*TMPro.TextMeshPro.SetArraySizes end.*/

            /*TMPro.TextMeshPro.ComputeMarginSize start.*/
            /**
             * Update the margin width and height
             *
             * @instance
             * @public
             * @override
             * @this TMPro.TextMeshPro
             * @memberof TMPro.TextMeshPro
             * @return  {void}
             */
            ComputeMarginSize: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#ComputeMarginSize", this ); }

                if (UnityEngine.Component.op_Inequality(this.rectTransform$1, null)) {
                    //Debug.Log("*** ComputeMarginSize() *** Current RectTransform's Width is " + m_rectTransform.rect.width + " and Height is " + m_rectTransform.rect.height); // + " and size delta is "  + m_rectTransform.sizeDelta);
                    var rect = this.m_rectTransform.rect.$clone();

                    this.m_marginWidth = rect.width - this.m_margin.x - this.m_margin.z;
                    this.m_marginHeight = rect.height - this.m_margin.y - this.m_margin.w;

                    // Cache current RectTransform width and pivot referenced in OnRectTransformDimensionsChange() to get around potential rounding error in the reported width of the RectTransform.
                    this.m_PreviousRectTransformSize = rect.size.$clone();
                    this.m_PreviousPivotPosition = this.m_rectTransform.pivot.$clone();

                    // Update the corners of the RectTransform
                    this.m_RectTransformCorners = this.GetTextContainerLocalCorners();
                }
            },
            /*TMPro.TextMeshPro.ComputeMarginSize end.*/

            /*TMPro.TextMeshPro.OnDidApplyAnimationProperties start.*/
            /**
             * @instance
             * @protected
             * @override
             * @this TMPro.TextMeshPro
             * @memberof TMPro.TextMeshPro
             * @return  {void}
             */
            OnDidApplyAnimationProperties: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#OnDidApplyAnimationProperties", this ); }

                //Debug.Log("*** OnDidApplyAnimationProperties() ***");
                this.m_havePropertiesChanged = true;
                this.isMaskUpdateRequired = true;

                this.SetVerticesDirty();
            },
            /*TMPro.TextMeshPro.OnDidApplyAnimationProperties end.*/

            /*TMPro.TextMeshPro.OnTransformParentChanged start.*/
            OnTransformParentChanged: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#OnTransformParentChanged", this ); }

                //Debug.Log("*** OnTransformParentChanged() ***");
                //ComputeMarginSize();

                this.SetVerticesDirty();
                this.SetLayoutDirty();
            },
            /*TMPro.TextMeshPro.OnTransformParentChanged end.*/

            /*TMPro.TextMeshPro.OnRectTransformDimensionsChange start.*/
            OnRectTransformDimensionsChange: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#OnRectTransformDimensionsChange", this ); }

                //Debug.Log("*** OnRectTransformDimensionsChange() ***");

                // Ignore changes to RectTransform SizeDelta that are very small and typically the result of rounding errors when using RectTransform in Anchor Stretch mode.
                if (UnityEngine.Component.op_Inequality(this.rectTransform$1, null) && Math.abs(this.m_rectTransform.rect.width - this.m_PreviousRectTransformSize.x) < 0.0001 && Math.abs(this.m_rectTransform.rect.height - this.m_PreviousRectTransformSize.y) < 0.0001 && Math.abs(this.m_rectTransform.pivot.x - this.m_PreviousPivotPosition.x) < 0.0001 && Math.abs(this.m_rectTransform.pivot.y - this.m_PreviousPivotPosition.y) < 0.0001) {
                    return;
                }

                this.ComputeMarginSize();

                this.SetVerticesDirty();
                this.SetLayoutDirty();
            },
            /*TMPro.TextMeshPro.OnRectTransformDimensionsChange end.*/

            /*TMPro.TextMeshPro.InternalUpdate start.*/
            /**
             * Function used as a replacement for LateUpdate to check if the transform or scale of the text object has changed.
             *
             * @instance
             * @override
             * @this TMPro.TextMeshPro
             * @memberof TMPro.TextMeshPro
             * @return  {void}
             */
            InternalUpdate: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#InternalUpdate", this ); }

                // We need to update the SDF scale or possibly regenerate the text object if lossy scale has changed.
                if (this.m_havePropertiesChanged === false) {
                    var lossyScaleY = this.m_rectTransform.lossyScale.y;

                    // Ignore very small lossy scale changes as their effect on SDF Scale would not be visually noticeable.
                    // Do not update SDF Scale if the text is null or empty
                    if (Math.abs(lossyScaleY - this.m_previousLossyScaleY) > 0.0001 && this.m_TextProcessingArray[0].unicode !== 0) {
                        var scaleDelta = lossyScaleY / this.m_previousLossyScaleY;

                        this.UpdateSDFScale(scaleDelta);

                        this.m_previousLossyScaleY = lossyScaleY;
                    }
                }

                // Added to handle legacy animation mode.
                if (this.m_isUsingLegacyAnimationComponent) {
                    //if (m_havePropertiesChanged)
                    this.m_havePropertiesChanged = true;
                    this.OnPreRenderObject();
                }
            },
            /*TMPro.TextMeshPro.InternalUpdate end.*/

            /*TMPro.TextMeshPro.OnPreRenderObject start.*/
            /**
             * Function called when the text needs to be updated.
             *
             * @instance
             * @private
             * @this TMPro.TextMeshPro
             * @memberof TMPro.TextMeshPro
             * @return  {void}
             */
            OnPreRenderObject: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#OnPreRenderObject", this ); }

                //Debug.Log("*** OnPreRenderObject() called on object [" + this.name + "] ***");

                // Make sure object is active.
                if (!this.m_isAwake || this.IsActive() === false && this.m_ignoreActiveState === false) {
                    return;
                }

                // Check if we have a font asset assigned. Return if we don't because no one likes to see purple squares on screen.
                if (this.m_fontAsset == null) {
                    UnityEngine.Debug.LogWarning$1("Please assign a Font Asset to this " + (this.transform$2.name || "") + " gameobject.", this);
                    return;
                }

                if (this.m_havePropertiesChanged || this.m_isLayoutDirty) {
                    //Debug.Log("Properties have changed!"); // Assigned Material is:" + m_sharedMaterial); // New Text is: " + m_text + ".");

                    if (this.isMaskUpdateRequired) {
                        this.UpdateMask();
                        this.isMaskUpdateRequired = false;
                    }

                    // Update mesh padding if necessary.
                    if (this.checkPaddingRequired) {
                        this.UpdateMeshPadding();
                    }

                    // Reparse the text as input may have changed or been truncated.
                    this.ParseInputText();
                    TMPro.TMP_FontAsset.UpdateFontFeaturesForFontAssetsInQueue();

                    // Reset Font min / max used with Auto-sizing
                    if (this.m_enableAutoSizing) {
                        this.m_fontSize = Math.max(this.m_fontSizeMin, Math.min(this.m_fontSizeBase, this.m_fontSizeMax));
                    }

                    this.m_maxFontSize = this.m_fontSizeMax;
                    this.m_minFontSize = this.m_fontSizeMin;
                    this.m_lineSpacingDelta = 0;
                    this.m_charWidthAdjDelta = 0;

                    this.m_isTextTruncated = false;

                    this.m_havePropertiesChanged = false;
                    this.m_isLayoutDirty = false;
                    this.m_ignoreActiveState = false;

                    // Reset Text Auto Size iteration tracking.
                    this.m_IsAutoSizePointSizeSet = false;
                    this.m_AutoSizeIterationCount = 0;

                    // Make sure state of MeshRenderer is mirrored on potential sub text objects.
                    this.SetActiveSubTextObjectRenderers(this.m_renderer.enabled);

                    // The GenerateTextMesh function is potentially called repeatedly when text auto size is enabled.
                    // This is a revised implementation to remove the use of recursion which could potentially result in stack overflow issues.
                    while (this.m_IsAutoSizePointSizeSet === false) {
                        this.GenerateTextMesh();
                        this.m_AutoSizeIterationCount += 1;
                    }
                }
            },
            /*TMPro.TextMeshPro.OnPreRenderObject end.*/

            /*TMPro.TextMeshPro.GenerateTextMesh start.*/
            /**
             * This is the main function that is responsible for creating / displaying the text.
             *
             * @instance
             * @protected
             * @this TMPro.TextMeshPro
             * @memberof TMPro.TextMeshPro
             * @return  {void}
             */
            GenerateTextMesh: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#GenerateTextMesh", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20, $t21, $t22, $t23, $t24, $t25, $t26, $t27, $t28, $t29, $t30, $t31, $t32, $t33, $t34, $t35, $t36, $t37, $t38, $t39, $t40, $t41, $t42, $t43, $t44, $t45, $t46, $t47, $t48, $t49, $t50, $t51, $t52, $t53, $t54, $t55, $t56, $t57, $t58, $t59, $t60, $t61, $t62, $t63, $t64, $t65, $t66, $t67, $t68, $t69, $t70, $t71, $t72, $t73, $t74, $t75, $t76, $t77, $t78, $t79, $t80, $t81, $t82, $t83, $t84, $t85, $t86, $t87, $t88, $t89, $t90, $t91, $t92, $t93, $t94, $t95, $t96, $t97, $t98, $t99, $t100, $t101, $t102, $t103, $t104, $t105, $t106, $t107, $t108, $t109, $t110, $t111, $t112, $t113, $t114, $t115, $t116, $t117, $t118, $t119, $t120, $t121, $t122, $t123, $t124, $t125, $t126, $t127, $t128, $t129, $t130, $t131, $t132, $t133, $t134, $t135;
                // Early exit if no font asset was assigned. This should not be needed since LiberationSans SDF will be assigned by default.
                if (this.m_fontAsset == null || this.m_fontAsset.characterLookupTable == null) {
                    UnityEngine.Debug.LogWarning$1("Can't Generate Mesh! No Font Asset has been assigned to Object ID: " + this.GetInstanceID());
                    this.m_IsAutoSizePointSizeSet = true;

                    return;
                }

                // Clear TextInfo
                if (this.m_textInfo != null) {
                    this.m_textInfo.Clear();
                }

                // Early exit if we don't have any Text to generate.
                if (this.m_TextProcessingArray == null || this.m_TextProcessingArray.length === 0 || this.m_TextProcessingArray[0].unicode === 0) {
                    // Clear mesh and upload changes to the mesh.
                    this.ClearMesh$1(true);

                    this.m_preferredWidth = 0;
                    this.m_preferredHeight = 0;

                    // Event indicating the text has been regenerated.
                    TMPro.TMPro_EventManager.ON_TEXT_CHANGED(this);
                    this.m_IsAutoSizePointSizeSet = true;

                    return;
                }

                this.m_currentFontAsset = this.m_fontAsset;
                this.m_currentMaterial = this.m_sharedMaterial;
                this.m_currentMaterialIndex = 0;
                TMPro.TMP_Text.m_materialReferenceStack.SetDefault(new TMPro.MaterialReference.$ctor1(this.m_currentMaterialIndex, this.m_currentFontAsset, null, this.m_currentMaterial, this.m_padding));

                this.m_currentSpriteAsset = this.m_spriteAsset;

                // Stop all Sprite Animations
                if (UnityEngine.MonoBehaviour.op_Inequality(this.m_spriteAnimator, null)) {
                    this.m_spriteAnimator.StopAllAnimations();
                }

                // Total character count is computed when the text is parsed.
                var totalCharacterCount = this.m_totalCharacterCount;

                // Calculate the scale of the font based on selected font size and sampling point size.
                // baseScale is calculated using the font asset assigned to the text object.
                var baseScale = this.m_fontSize / this.m_fontAsset.m_FaceInfo.pointSize * this.m_fontAsset.m_FaceInfo.scale * (this.m_isOrthographic ? 1 : 0.1);
                var currentElementScale = baseScale;
                var currentEmScale = this.m_fontSize * 0.01 * (this.m_isOrthographic ? 1 : 0.1);
                this.m_fontScaleMultiplier = 1;

                this.m_currentFontSize = this.m_fontSize;
                this.m_sizeStack.SetDefault(this.m_currentFontSize);
                var fontSizeDelta = 0;

                var charCode = 0; // Holds the character code of the currently being processed character.

                this.m_FontStyleInternal = this.m_fontStyle; // Set the default style.
                this.m_FontWeightInternal = (this.m_FontStyleInternal & TMPro.FontStyles.Bold) === TMPro.FontStyles.Bold ? TMPro.FontWeight.Bold : this.m_fontWeight;
                this.m_FontWeightStack.SetDefault(this.m_FontWeightInternal);
                this.m_fontStyleStack.Clear();

                this.m_lineJustification = this.m_HorizontalAlignment; // m_textAlignment; // Sets the line justification mode to match editor alignment.
                this.m_lineJustificationStack.SetDefault(this.m_lineJustification);

                var padding = 0;
                var style_padding = 0; // Extra padding required to accommodate Bold style.
                var boldSpacingAdjustment = 0;
                //float bold_xAdvance_multiplier = 1; // Used to increase spacing between character when style is bold.

                this.m_baselineOffset = 0; // Used by subscript characters.
                this.m_baselineOffsetStack.Clear();

                // Underline
                var beginUnderline = false;
                var underline_start = pc.Vec3.ZERO.clone(); // Used to track where underline starts & ends.
                var underline_end = pc.Vec3.ZERO.clone();

                // Strike-through
                var beginStrikethrough = false;
                var strikethrough_start = pc.Vec3.ZERO.clone();
                var strikethrough_end = pc.Vec3.ZERO.clone();

                // Text Highlight
                var beginHighlight = false;
                var highlight_start = pc.Vec3.ZERO.clone();
                var highlight_end = pc.Vec3.ZERO.clone();

                var vertexColor = new UnityEngine.Color32();
                this.m_fontColor32.Set(1, 1, 1, 1);
                this.m_fontColor32.MultiplyByColor( this.m_fontColor );
                this.m_htmlColor.Copy( this.m_fontColor32 );
                this.m_underlineColor.Copy( this.m_htmlColor );
                this.m_strikethroughColor.Copy( this.m_htmlColor );

                this.m_colorStack.SetDefault(this.m_htmlColor.$clone());
                this.m_underlineColorStack.SetDefault(this.m_htmlColor.$clone());
                this.m_strikethroughColorStack.SetDefault(this.m_htmlColor.$clone());
                this.m_HighlightStateStack.SetDefault(new TMPro.HighlightState.$ctor1(this.m_htmlColor.$clone(), TMPro.TMP_Offset.zero.$clone()));

                this.m_colorGradientPreset = null;
                this.m_colorGradientStack.SetDefault(null);

                this.m_ItalicAngle = this.m_currentFontAsset.italicStyle;
                this.m_ItalicAngleStack.SetDefault(this.m_ItalicAngle);

                // Clear the Style stack.
                //m_styleStack.Clear();

                // Clear the Action stack.
                this.m_actionStack.Clear();

                this.m_isFXMatrixSet = false;

                this.m_lineOffset = 0; // Amount of space between lines (font line spacing + m_linespacing).
                this.m_lineHeight = TMPro.TMP_Math.FLOAT_UNSET;
                var lineGap = this.m_currentFontAsset.m_FaceInfo.lineHeight - (this.m_currentFontAsset.m_FaceInfo.ascentLine - this.m_currentFontAsset.m_FaceInfo.descentLine);

                this.m_cSpacing = 0; // Amount of space added between characters as a result of the use of the <cspace> tag.
                this.m_monoSpacing = 0;
                this.m_xAdvance = 0; // Used to track the position of each character.

                this.tag_LineIndent = 0; // Used for indentation of text.
                this.tag_Indent = 0;
                this.m_indentStack.SetDefault(0);
                this.tag_NoParsing = false;
                //m_isIgnoringAlignment = false;

                this.m_characterCount = 0; // Total characters in the char[]

                // Tracking of line information
                this.m_firstCharacterOfLine = this.m_firstVisibleCharacter;
                this.m_lastCharacterOfLine = 0;
                this.m_firstVisibleCharacterOfLine = 0;
                this.m_lastVisibleCharacterOfLine = 0;
                this.m_maxLineAscender = TMPro.TMP_Text.k_LargeNegativeFloat;
                this.m_maxLineDescender = TMPro.TMP_Text.k_LargePositiveFloat;
                this.m_lineNumber = 0;
                this.m_startOfLineAscender = 0;
                this.m_startOfLineDescender = 0;
                this.m_lineVisibleCharacterCount = 0;
                var isStartOfNewLine = true;
                this.m_IsDrivenLineSpacing = false;
                this.m_firstOverflowCharacterIndex = -1;

                this.m_pageNumber = 0;
                var pageToDisplay = Math.max(0, Math.min(this.m_pageToDisplay - 1, this.m_textInfo.pageInfo.length - 1));
                this.m_textInfo.ClearPageInfo();

                var margins = this.m_margin.$clone();
                var marginWidth = this.m_marginWidth > 0 ? this.m_marginWidth : 0;
                var marginHeight = this.m_marginHeight > 0 ? this.m_marginHeight : 0;
                this.m_marginLeft = 0;
                this.m_marginRight = 0;
                this.m_width = -1;
                var widthOfTextArea = marginWidth + 0.0001 - this.m_marginLeft - this.m_marginRight;

                // Need to initialize these Extents structures
                this.m_meshExtents.min = TMPro.TMP_Text.k_LargePositiveVector2.$clone();
                this.m_meshExtents.max = TMPro.TMP_Text.k_LargeNegativeVector2.$clone();

                // Initialize lineInfo
                this.m_textInfo.ClearLineInfo();

                // Tracking of the highest Ascender
                this.m_maxCapHeight = 0;
                this.m_maxTextAscender = 0;
                this.m_ElementDescender = 0;
                this.m_PageAscender = 0;
                var maxVisibleDescender = { v : 0 };
                var isMaxVisibleDescenderSet = { v : false };
                this.m_isNewPage = false;

                // Initialize struct to track states of word wrapping
                var isFirstWordOfLine = true;
                this.m_isNonBreakingSpace = false;
                var ignoreNonBreakingSpace = false;
                //bool isLastCharacterCJK = false;
                var lastSoftLineBreak = 0;

                var characterToSubstitute = new TMPro.TMP_Text.CharacterSubstitution.$ctor1(-1, 0);
                var isSoftHyphenIgnored = false;

                // Save character and line state before we begin layout.
                this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedWordWrapState"), -1, -1);
                this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedLineState"), -1, -1);
                this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedEllipsisState"), -1, -1);
                this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedLastValidState"), -1, -1);
                this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedSoftLineBreakState"), -1, -1);

                TMPro.TMP_Text.m_EllipsisInsertionCandidateStack.Clear();

                // Safety Tracker
                var restoreCount = 0;

                var characterInfo = new TMPro.TMP_CharacterInfo();
                var lineInfo = new TMPro.TMP_LineInfo();

                var top_left = pc.Vec3.ZERO.clone();
                var bottom_left = pc.Vec3.ZERO.clone();
                var top_right = pc.Vec3.ZERO.clone();
                var bottom_right = pc.Vec3.ZERO.clone();
                var topShear = pc.Vec3.ZERO.clone();
                var bottomShear = pc.Vec3.ZERO.clone();
                var shearAdjustment = pc.Vec3.ZERO.clone();

                // Parse through Character buffer to read HTML tags and begin creating mesh.
                for (var i = 0; i < this.m_TextProcessingArray.length && this.m_TextProcessingArray[i].unicode !== 0; i++) {
                    charCode = this.m_TextProcessingArray[i].unicode;

                    characterInfo = this.m_textInfo.characterInfo[ this.m_characterCount ];

                    if (restoreCount > 5) {
                        UnityEngine.Debug.LogError$2("Line breaking recursion max threshold hit... Character [" + charCode + "] index: " + i);
                        characterToSubstitute.index = this.m_characterCount;
                        characterToSubstitute.unicode = 3;
                    }

                    // Parse Rich Text Tag


                    if (this.m_isRichText && charCode === 60) {
                        this.m_isParsingText = true;
                        this.m_textElementType = TMPro.TMP_TextElementType.Character;
                        var endTagIndex = { };

                        // Check if Tag is valid. If valid, skip to the end of the validated tag.
                        if (this.ValidateHtmlTag(this.m_TextProcessingArray, i + 1, endTagIndex)) {
                            i = endTagIndex.v;

                            // Continue to next character or handle the sprite element
                            if (this.m_textElementType === TMPro.TMP_TextElementType.Character) {
                                continue;
                            }
                        }
                    } else {
                        this.m_textElementType = ($t = this.m_textInfo.characterInfo)[this.m_characterCount].elementType;
                        this.m_currentMaterialIndex = ($t1 = this.m_textInfo.characterInfo)[this.m_characterCount].materialReferenceIndex;
                        this.m_currentFontAsset = ($t2 = this.m_textInfo.characterInfo)[this.m_characterCount].fontAsset;
                    }


                    var previousMaterialIndex = this.m_currentMaterialIndex;
                    var isUsingAltTypeface = ($t3 = this.m_textInfo.characterInfo)[this.m_characterCount].isUsingAlternateTypeface;

                    this.m_isParsingText = false;

                    // Handle potential character substitutions


                    var isInjectingCharacter = false;

                    if (characterToSubstitute.index === this.m_characterCount) {
                        charCode = characterToSubstitute.unicode;
                        this.m_textElementType = TMPro.TMP_TextElementType.Character;
                        isInjectingCharacter = true;

                        switch (charCode) {
                            case 3: 
                                characterInfo.textElement = this.m_currentFontAsset.characterLookupTable.getItem(3);
                                this.m_isTextTruncated = true;
                                break;
                            case 45: 
                                //
                                break;
                            case 8230: 
                                characterInfo.textElement = this.m_Ellipsis.character;
                                characterInfo.elementType = TMPro.TMP_TextElementType.Character;
                                characterInfo.fontAsset = this.m_Ellipsis.fontAsset;
                                characterInfo.material = this.m_Ellipsis.material;
                                characterInfo.materialReferenceIndex = this.m_Ellipsis.materialIndex;
                                // Indicates the source parsing data has been modified.
                                this.m_isTextTruncated = true;
                                // End Of Text
                                characterToSubstitute.index = this.m_characterCount + 1;
                                characterToSubstitute.unicode = 3;
                                break;
                        }
                    }



                    // When using Linked text, mark character as ignored and skip to next character.


                    if (this.m_characterCount < this.m_firstVisibleCharacter && charCode !== 3) {
                        characterInfo.isVisible = false;
                        characterInfo.character = 8203;
                        characterInfo.lineNumber = 0;
                        this.m_characterCount += 1;
                        continue;
                    }



                    // Handle Font Styles like LowerCase, UpperCase and SmallCaps.


                    var smallCapsMultiplier = 1.0;

                    if (this.m_textElementType === TMPro.TMP_TextElementType.Character) {
                        if ((this.m_FontStyleInternal & TMPro.FontStyles.UpperCase) === TMPro.FontStyles.UpperCase) {
                            // If this character is lowercase, switch to uppercase.
                            if (Bridge.isLower(charCode)) {
                                charCode = String.fromCharCode(charCode).toUpperCase().charCodeAt(0);
                            }
                        } else if ((this.m_FontStyleInternal & TMPro.FontStyles.LowerCase) === TMPro.FontStyles.LowerCase) {
                            // If this character is uppercase, switch to lowercase.
                            if (Bridge.isUpper(charCode)) {
                                charCode = String.fromCharCode(charCode).toLowerCase().charCodeAt(0);
                            }
                        } else if ((this.m_FontStyleInternal & TMPro.FontStyles.SmallCaps) === TMPro.FontStyles.SmallCaps) {
                            if (Bridge.isLower(charCode)) {
                                smallCapsMultiplier = 0.8;
                                charCode = String.fromCharCode(charCode).toUpperCase().charCodeAt(0);
                            }
                        }
                    }



                    // Look up Character Data from Dictionary and cache it.


                    var baselineOffset = 0;
                    var elementAscentLine = 0;
                    var elementDescentLine = 0;
                    if (this.m_textElementType === TMPro.TMP_TextElementType.Sprite) {
                        // If a sprite is used as a fallback then get a reference to it and set the color to white.
                        this.m_currentSpriteAsset = characterInfo.spriteAsset;
                        this.m_spriteIndex = characterInfo.spriteIndex;

                        var sprite = this.m_currentSpriteAsset.spriteCharacterTable.getItem(this.m_spriteIndex);
                        if (sprite == null) {
                            continue;
                        }

                        // Sprites are assigned in the E000 Private Area + sprite Index
                        if (charCode === 60) {
                            charCode = 57344 + this.m_spriteIndex;
                        } else {
                            this.m_spriteColor = TMPro.TMP_Text.s_colorWhite.$clone();
                        }

                        var fontScale = this.m_currentFontSize / this.m_currentFontAsset.faceInfo.pointSize * this.m_currentFontAsset.faceInfo.scale * (this.m_isOrthographic ? 1 : 0.1);

                        // The sprite scale calculations are based on the font asset assigned to the text object.
                        if (this.m_currentSpriteAsset.m_FaceInfo.pointSize > 0) {
                            var spriteScale = this.m_currentFontSize / this.m_currentSpriteAsset.m_FaceInfo.pointSize * this.m_currentSpriteAsset.m_FaceInfo.scale * (this.m_isOrthographic ? 1 : 0.1);
                            currentElementScale = sprite.m_Scale * sprite.m_Glyph.scale * spriteScale;
                            elementAscentLine = this.m_currentSpriteAsset.m_FaceInfo.ascentLine;
                            baselineOffset = this.m_currentSpriteAsset.m_FaceInfo.baseline * fontScale * this.m_fontScaleMultiplier * this.m_currentSpriteAsset.m_FaceInfo.scale;
                            elementDescentLine = this.m_currentSpriteAsset.m_FaceInfo.descentLine;
                        } else {
                            var spriteScale1 = this.m_currentFontSize / this.m_currentFontAsset.m_FaceInfo.pointSize * this.m_currentFontAsset.m_FaceInfo.scale * (this.m_isOrthographic ? 1 : 0.1);
                            currentElementScale = this.m_currentFontAsset.m_FaceInfo.ascentLine / sprite.m_Glyph.metrics.height * sprite.m_Scale * sprite.m_Glyph.scale * spriteScale1;
                            var scaleDelta = spriteScale1 / currentElementScale;
                            elementAscentLine = this.m_currentFontAsset.m_FaceInfo.ascentLine * scaleDelta;
                            baselineOffset = this.m_currentFontAsset.m_FaceInfo.baseline * fontScale * this.m_fontScaleMultiplier * this.m_currentFontAsset.m_FaceInfo.scale;
                            elementDescentLine = this.m_currentFontAsset.m_FaceInfo.descentLine * scaleDelta;
                        }

                        this.m_cached_TextElement = sprite;

                        characterInfo.elementType = TMPro.TMP_TextElementType.Sprite;
                        characterInfo.scale = currentElementScale;
                        characterInfo.spriteAsset = this.m_currentSpriteAsset;
                        characterInfo.fontAsset = this.m_currentFontAsset;
                        characterInfo.materialReferenceIndex = this.m_currentMaterialIndex;

                        this.m_currentMaterialIndex = previousMaterialIndex;

                        padding = 0;
                    } else if (this.m_textElementType === TMPro.TMP_TextElementType.Character) {
                        this.m_cached_TextElement = ($t4 = this.m_textInfo.characterInfo)[this.m_characterCount].textElement;
                        if (this.m_cached_TextElement == null) {
                            continue;
                        }

                        this.m_currentFontAsset = characterInfo.fontAsset;
                        this.m_currentMaterial = characterInfo.material;
                        this.m_currentMaterialIndex = characterInfo.materialReferenceIndex;

                        // Special handling if replaced character was a line feed where in this case we have to use the scale of the previous character.
                        var adjustedScale;
                        if (isInjectingCharacter && this.m_TextProcessingArray[i].unicode === 10 && this.m_characterCount !== this.m_firstCharacterOfLine) {
                            adjustedScale = characterInfo.pointSize * smallCapsMultiplier / this.m_currentFontAsset.m_FaceInfo.pointSize * this.m_currentFontAsset.m_FaceInfo.scale * (this.m_isOrthographic ? 1 : 0.1);
                        } else {
                            adjustedScale = this.m_currentFontSize * smallCapsMultiplier / this.m_currentFontAsset.m_FaceInfo.pointSize * this.m_currentFontAsset.m_FaceInfo.scale * (this.m_isOrthographic ? 1 : 0.1);
                        }

                        // Special handling for injected Ellipsis
                        if (isInjectingCharacter && charCode === 8230) {
                            elementAscentLine = 0;
                            elementDescentLine = 0;
                        } else {
                            elementAscentLine = this.m_currentFontAsset.m_FaceInfo.ascentLine;
                            elementDescentLine = this.m_currentFontAsset.m_FaceInfo.descentLine;
                        }

                        currentElementScale = adjustedScale * this.m_fontScaleMultiplier * this.m_cached_TextElement.m_Scale * this.m_cached_TextElement.m_Glyph.scale;
                        baselineOffset = this.m_currentFontAsset.m_FaceInfo.baseline * adjustedScale * this.m_fontScaleMultiplier * this.m_currentFontAsset.m_FaceInfo.scale;

                        characterInfo.elementType = TMPro.TMP_TextElementType.Character;
                        characterInfo.scale = currentElementScale;

                        padding = this.m_currentMaterialIndex === 0 ? this.m_padding : this.m_subTextObjects[this.m_currentMaterialIndex].padding;
                    }



                    // Handle Soft Hyphen


                    var currentElementUnmodifiedScale = currentElementScale;
                    if (charCode === 173 || charCode === 3) {
                        currentElementScale = 0;
                    }



                    // Store some of the text object's information
                    characterInfo.character = charCode;
                    characterInfo.pointSize = this.m_currentFontSize;
                    characterInfo.style = this.m_FontStyleInternal;

                    
                    characterInfo.color.Copy( this.m_htmlColor );
                    characterInfo.underlineColor.Copy( this.m_underlineColor );
                    characterInfo.strikethroughColor.Copy( this.m_strikethroughColor );
                    characterInfo.highlightState.Copy( this.m_HighlightStateStack.current );
                

                    // Cache glyph metrics
                    var currentGlyphMetrics = this.m_cached_TextElement.m_Glyph.metrics.$clone();

                    // Optimization to avoid calling this more than once per character.
                    var isWhiteSpace = charCode <= 65535 && System.Char.isWhiteSpace(String.fromCharCode(charCode));

                    // Handle Kerning if Enabled.


                    var glyphAdjustments = new TMPro.TMP_GlyphValueRecord.ctor();
                    var characterSpacingAdjustment = this.m_characterSpacing;
                    this.m_GlyphHorizontalAdvanceAdjustment = 0;
                    if (this.m_enableKerning) {
                        var adjustmentPair = { };
                        var baseGlyphIndex = this.m_cached_TextElement.m_GlyphIndex;

                        if (this.m_characterCount < totalCharacterCount - 1) {
                            var nextGlyphIndex = ($t5 = this.m_textInfo.characterInfo)[this.m_characterCount + 1].textElement.m_GlyphIndex;
                            var key = (nextGlyphIndex << 16) | baseGlyphIndex;

                            if (this.m_currentFontAsset.m_FontFeatureTable.m_GlyphPairAdjustmentRecordLookupDictionary.tryGetValue(key, adjustmentPair)) {
                                glyphAdjustments = adjustmentPair.v.m_FirstAdjustmentRecord.m_GlyphValueRecord.$clone();
                                characterSpacingAdjustment = (adjustmentPair.v.m_FeatureLookupFlags & TMPro.FontFeatureLookupFlags.IgnoreSpacingAdjustments) === TMPro.FontFeatureLookupFlags.IgnoreSpacingAdjustments ? 0 : characterSpacingAdjustment;
                            }
                        }

                        if (this.m_characterCount >= 1) {
                            var previousGlyphIndex = ($t6 = this.m_textInfo.characterInfo)[this.m_characterCount - 1].textElement.m_GlyphIndex;
                            var key1 = (baseGlyphIndex << 16) | previousGlyphIndex;

                            if (this.m_currentFontAsset.m_FontFeatureTable.m_GlyphPairAdjustmentRecordLookupDictionary.tryGetValue(key1, adjustmentPair)) {
                                glyphAdjustments = TMPro.TMP_GlyphValueRecord.op_Addition(glyphAdjustments.$clone(), adjustmentPair.v.m_SecondAdjustmentRecord.m_GlyphValueRecord.$clone());
                                characterSpacingAdjustment = (adjustmentPair.v.m_FeatureLookupFlags & TMPro.FontFeatureLookupFlags.IgnoreSpacingAdjustments) === TMPro.FontFeatureLookupFlags.IgnoreSpacingAdjustments ? 0 : characterSpacingAdjustment;
                            }
                        }

                        this.m_GlyphHorizontalAdvanceAdjustment = glyphAdjustments.xAdvance;
                    }



                    // Initial Implementation for RTL support.


                    if (this.m_isRightToLeft) {
                        this.m_xAdvance -= currentGlyphMetrics.horizontalAdvance * (1 - this.m_charWidthAdjDelta) * currentElementScale;

                        if (isWhiteSpace || charCode === 8203) {
                            this.m_xAdvance -= this.m_wordSpacing * currentEmScale;
                        }
                    }



                    // Handle Mono Spacing


                    var monoAdvance = 0;
                    if (this.m_monoSpacing !== 0) {
                        monoAdvance = (this.m_monoSpacing / 2 - (currentGlyphMetrics.width / 2 + currentGlyphMetrics.horizontalBearingX) * currentElementScale) * (1 - this.m_charWidthAdjDelta);
                        this.m_xAdvance += monoAdvance;
                    }



                    // Set Padding based on selected font style


                    if (this.m_textElementType === TMPro.TMP_TextElementType.Character && !isUsingAltTypeface && (this.m_FontStyleInternal & TMPro.FontStyles.Bold) === TMPro.FontStyles.Bold) {
                        if (this.m_currentMaterial != null && this.m_currentMaterial.HasProperty(TMPro.ShaderUtilities.ID_GradientScale)) {
                            var gradientScale = this.m_currentMaterial.GetFloat(TMPro.ShaderUtilities.ID_GradientScale);
                            style_padding = this.m_currentFontAsset.boldStyle / 4.0 * gradientScale * this.m_currentMaterial.GetFloat(TMPro.ShaderUtilities.ID_ScaleRatio_A);

                            // Clamp overall padding to Gradient Scale size.
                            if (style_padding + padding > gradientScale) {
                                padding = gradientScale - style_padding;
                            }
                        } else {
                            style_padding = 0;
                        }

                        boldSpacingAdjustment = this.m_currentFontAsset.boldSpacing;
                    } else {
                        if (this.m_currentMaterial != null && this.m_currentMaterial.HasProperty(TMPro.ShaderUtilities.ID_GradientScale) && this.m_currentMaterial.HasProperty(TMPro.ShaderUtilities.ID_ScaleRatio_A)) {
                            var gradientScale1 = this.m_currentMaterial.GetFloat(TMPro.ShaderUtilities.ID_GradientScale);
                            style_padding = this.m_currentFontAsset.normalStyle / 4.0 * gradientScale1 * this.m_currentMaterial.GetFloat(TMPro.ShaderUtilities.ID_ScaleRatio_A);

                            // Clamp overall padding to Gradient Scale size.
                            if (style_padding + padding > gradientScale1) {
                                padding = gradientScale1 - style_padding;
                            }
                        } else {
                            style_padding = 0;
                        }

                        boldSpacingAdjustment = 0;
                    }



                    // Determine the position of the vertices of the Character or Sprite.


                    top_left.x = this.m_xAdvance + (currentGlyphMetrics.horizontalBearingX - padding - style_padding + glyphAdjustments.m_XPlacement) * currentElementScale * (1 - this.m_charWidthAdjDelta);
                    top_left.y = baselineOffset + (currentGlyphMetrics.horizontalBearingY + padding + glyphAdjustments.m_YPlacement) * currentElementScale - this.m_lineOffset + this.m_baselineOffset;
                    top_left.z = 0;

                    bottom_left.x = top_left.x;
                    bottom_left.y = top_left.y - (currentGlyphMetrics.height + padding * 2) * currentElementScale;
                    bottom_left.z = 0;

                    top_right.x = bottom_left.x + (currentGlyphMetrics.width + padding * 2 + style_padding * 2) * currentElementScale * (1 - this.m_charWidthAdjDelta);
                    top_right.y = top_left.y;
                    top_right.z = 0;

                    bottom_right.x = top_right.x;
                    bottom_right.y = bottom_left.y;
                    bottom_right.z = 0;



                    // Check if we need to Shear the rectangles for Italic styles


                    if (this.m_textElementType === TMPro.TMP_TextElementType.Character && !isUsingAltTypeface && (this.m_FontStyleInternal & TMPro.FontStyles.Italic) === TMPro.FontStyles.Italic) {
                        // Shift Top vertices forward by half (Shear Value * height of character) and Bottom vertices back by same amount.
                        var shear_value = this.m_ItalicAngle * 0.01;

                        topShear.set( shear_value * ((currentGlyphMetrics.horizontalBearingY + padding + style_padding) * currentElementScale), 0, 0 );
                        bottomShear.set( shear_value * ((currentGlyphMetrics.horizontalBearingY - currentGlyphMetrics.height - padding - style_padding) * currentElementScale), 0, 0 );

                        shearAdjustment.set( (topShear.x - bottomShear.x) / 2, 0, 0 );

                        top_left.add( topShear );
                        top_left.sub( shearAdjustment );
                        bottom_left.add( bottomShear );
                        bottom_left.sub( shearAdjustment );
                        top_right.add( topShear );
                        top_right.sub( shearAdjustment );
                        bottom_right.add( bottomShear );
                        bottom_right.sub( shearAdjustment );
                    }



                    // Handle Character Rotation


                    if (this.m_isFXMatrixSet) {
                        // Apply scale matrix when simulating Condensed text.
                        if (this.m_FXMatrix.getScale().x !== 1) {
                            //top_left = m_FXMatrix.MultiplyPoint3x4(top_left);
                            //bottom_left = m_FXMatrix.MultiplyPoint3x4(bottom_left);
                            //top_right = m_FXMatrix.MultiplyPoint3x4(top_right);
                            //bottom_right = m_FXMatrix.MultiplyPoint3x4(bottom_right);
                        }

                        var positionOffset = (top_right.$clone().add( bottom_left )).scale( 1.0 / ( 2 ) );

                        top_left = this.m_FXMatrix.transformPoint( top_left.$clone().sub( positionOffset ) ).add( positionOffset );
                        bottom_left = this.m_FXMatrix.transformPoint( bottom_left.$clone().sub( positionOffset ) ).add( positionOffset );
                        top_right = this.m_FXMatrix.transformPoint( top_right.$clone().sub( positionOffset ) ).add( positionOffset );
                        bottom_right = this.m_FXMatrix.transformPoint( bottom_right.$clone().sub( positionOffset ) ).add( positionOffset );
                    }



                    // Store vertex information for the character or sprite.
                    
                    characterInfo.bottomLeft.copy( bottom_left );
                    characterInfo.topLeft.copy( top_left );
                    characterInfo.topRight.copy( top_right );
                    characterInfo.bottomRight.copy( bottom_right );
                    characterInfo.origin = this.m_xAdvance;
                    characterInfo.baseLine = baselineOffset - this.m_lineOffset + this.m_baselineOffset;
                    characterInfo.aspectRatio = ( top_right.x - bottom_left.x ) / ( top_left.y - bottom_left.y );
                


                    // Compute text metrics


                    // Element Ascender in line space
                    var elementAscender = this.m_textElementType === TMPro.TMP_TextElementType.Character ? elementAscentLine * currentElementScale / smallCapsMultiplier + this.m_baselineOffset : elementAscentLine * currentElementScale + this.m_baselineOffset;

                    // Element Descender in line space
                    var elementDescender = this.m_textElementType === TMPro.TMP_TextElementType.Character ? elementDescentLine * currentElementScale / smallCapsMultiplier + this.m_baselineOffset : elementDescentLine * currentElementScale + this.m_baselineOffset;

                    var adjustedAscender = elementAscender;
                    var adjustedDescender = elementDescender;

                    var isFirstCharacterOfLine = this.m_characterCount === this.m_firstCharacterOfLine;
                    // Max line ascender and descender in line space
                    if (isFirstCharacterOfLine || isWhiteSpace === false) {
                        // Special handling for Superscript and Subscript where we use the unadjusted line ascender and descender
                        if (this.m_baselineOffset !== 0) {
                            adjustedAscender = UnityEngine.Mathf.Max((elementAscender - this.m_baselineOffset) / this.m_fontScaleMultiplier, adjustedAscender);
                            adjustedDescender = UnityEngine.Mathf.Min((elementDescender - this.m_baselineOffset) / this.m_fontScaleMultiplier, adjustedDescender);
                        }

                        this.m_maxLineAscender = UnityEngine.Mathf.Max(adjustedAscender, this.m_maxLineAscender);
                        this.m_maxLineDescender = UnityEngine.Mathf.Min(adjustedDescender, this.m_maxLineDescender);
                    }

                    // Element Ascender and Descender in object space
                    if (isFirstCharacterOfLine || isWhiteSpace === false) {
                        characterInfo.adjustedAscender = adjustedAscender;
                        characterInfo.adjustedDescender = adjustedDescender;

                        this.m_ElementAscender = (characterInfo.ascender = elementAscender - this.m_lineOffset);
                        this.m_ElementDescender = (characterInfo.descender = elementDescender - this.m_lineOffset);
                    } else {
                        characterInfo.adjustedAscender = this.m_maxLineAscender;
                        characterInfo.adjustedDescender = this.m_maxLineDescender;

                        this.m_ElementAscender = (characterInfo.ascender = this.m_maxLineAscender - this.m_lineOffset);
                        this.m_ElementDescender = (characterInfo.descender = this.m_maxLineDescender - this.m_lineOffset);
                    }

                    // Max text object ascender and cap height
                    if (this.m_lineNumber === 0 || this.m_isNewPage) {
                        if (isFirstCharacterOfLine || isWhiteSpace === false) {
                            this.m_maxTextAscender = this.m_maxLineAscender;
                            this.m_maxCapHeight = UnityEngine.Mathf.Max(this.m_maxCapHeight, this.m_currentFontAsset.m_FaceInfo.capLine * currentElementScale / smallCapsMultiplier);
                        }
                    }

                    // Page ascender
                    if (this.m_lineOffset === 0) {
                        if (isFirstCharacterOfLine || isWhiteSpace === false) {
                            this.m_PageAscender = this.m_PageAscender > elementAscender ? this.m_PageAscender : elementAscender;
                        }
                    }



                    // Set Characters to not visible by default.
                    ($t7 = this.m_textInfo.characterInfo)[this.m_characterCount].isVisible = false;

                    var isJustifiedOrFlush = (this.m_lineJustification & TMPro.HorizontalAlignmentOptions.Flush) === TMPro.HorizontalAlignmentOptions.Flush || (this.m_lineJustification & TMPro.HorizontalAlignmentOptions.Justified) === TMPro.HorizontalAlignmentOptions.Justified;

                    // Setup Mesh for visible text elements. ie. not a SPACE / LINEFEED / CARRIAGE RETURN.


                    if (charCode === 9 || isWhiteSpace === false && charCode !== 8203 && charCode !== 173 && charCode !== 3 || charCode === 173 && isSoftHyphenIgnored === false || this.m_textElementType === TMPro.TMP_TextElementType.Sprite) {
                        ($t8 = this.m_textInfo.characterInfo)[this.m_characterCount].isVisible = true;


                        //Vector2 shapedMargins;
                        //if (marginShaper)
                        //{
                        //    shapedMargins = m_marginShaper.GetShapedMargins(m_textInfo.characterInfo[m_characterCount].baseLine);
                        //    if (shapedMargins.x < margins.x)
                        //    {
                        //        shapedMargins.x = m_marginLeft;
                        //    }
                        //    else
                        //    {
                        //        shapedMargins.x += m_marginLeft - margins.x;
                        //    }
                        //    if (shapedMargins.y < margins.z)
                        //    {
                        //        shapedMargins.y = m_marginRight;
                        //    }
                        //    else
                        //    {
                        //        shapedMargins.y += m_marginRight - margins.z;
                        //    }
                        //}
                        //else
                        //{
                        //    shapedMargins.x = m_marginLeft;
                        //    shapedMargins.y = m_marginRight;
                        //}
                        //width = marginWidth + 0.0001f - shapedMargins.x - shapedMargins.y;
                        //if (m_width != -1 && m_width < width)
                        //{
                        //    width = m_width;
                        //}
                        //m_textInfo.lineInfo[m_lineNumber].marginLeft = shapedMargins.x;


                        var marginLeft = this.m_marginLeft;
                        var marginRight = this.m_marginRight;

                        // Injected characters do not override margins
                        if (isInjectingCharacter) {
                            marginLeft = this.m_textInfo.lineInfo[ this.m_lineNumber ].marginLeft;
                            marginRight = this.m_textInfo.lineInfo[ this.m_lineNumber ].marginRight;
                        }

                        widthOfTextArea = this.m_width !== -1 ? UnityEngine.Mathf.Min(marginWidth + 0.0001 - marginLeft - marginRight, this.m_width) : marginWidth + 0.0001 - marginLeft - marginRight;

                        // Calculate the line breaking width of the text.
                        var textWidth = Math.abs(this.m_xAdvance) + (!this.m_isRightToLeft ? currentGlyphMetrics.horizontalAdvance : 0) * (1 - this.m_charWidthAdjDelta) * (charCode === 173 ? currentElementUnmodifiedScale : currentElementScale);
                        var textHeight = this.m_maxTextAscender - (this.m_maxLineDescender - this.m_lineOffset) + (this.m_lineOffset > 0 && this.m_IsDrivenLineSpacing === false ? this.m_maxLineAscender - this.m_startOfLineAscender : 0);

                        var testedCharacterCount = this.m_characterCount;

                        // Handling of current line Vertical Bounds


                        if (textHeight > marginHeight + 0.0001) {
                            // Set isTextOverflowing and firstOverflowCharacterIndex
                            if (this.m_firstOverflowCharacterIndex === -1) {
                                this.m_firstOverflowCharacterIndex = this.m_characterCount;
                            }

                            // Check if Auto-Size is enabled
                            if (this.m_enableAutoSizing) {
                                // Handle Line spacing adjustments


                                if (this.m_lineSpacingDelta > this.m_lineSpacingMax && this.m_lineOffset > 0 && this.m_AutoSizeIterationCount < this.m_AutoSizeMaxIterationCount) {
                                    var adjustmentDelta = (marginHeight - textHeight) / this.m_lineNumber;

                                    this.m_lineSpacingDelta = UnityEngine.Mathf.Max(this.m_lineSpacingDelta + adjustmentDelta / baseScale, this.m_lineSpacingMax);

                                    //Debug.Log("[" + m_AutoSizeIterationCount + "] Reducing Line Spacing. Delta of [" + m_lineSpacingDelta.ToString("f3") + "].");
                                    return;
                                }



                                // Handle Text Auto-sizing resulting from text exceeding vertical bounds.


                                if (this.m_fontSize > this.m_fontSizeMin && this.m_AutoSizeIterationCount < this.m_AutoSizeMaxIterationCount) {
                                    this.m_maxFontSize = this.m_fontSize;

                                    var sizeDelta = UnityEngine.Mathf.Max((this.m_fontSize - this.m_minFontSize) / 2, 0.05);
                                    this.m_fontSize -= sizeDelta;
                                    this.m_fontSize = UnityEngine.Mathf.Max((this.m_fontSize * 20 + 0.5) / 20.0, this.m_fontSizeMin);

                                    //Debug.Log("[" + m_AutoSizeIterationCount + "] Reducing Point Size from [" + m_maxFontSize.ToString("f3") + "] to [" + m_fontSize.ToString("f3") + "] with delta of [" + sizeDelta.ToString("f3") + "].");
                                    return;
                                }

                            }

                            // Handle Vertical Overflow on current line
                            switch (this.m_overflowMode) {
                                case TMPro.TextOverflowModes.Overflow: 
                                case TMPro.TextOverflowModes.ScrollRect: 
                                case TMPro.TextOverflowModes.Masking: 
                                    // Nothing happens as vertical bounds are ignored in this mode.
                                    break;
                                case TMPro.TextOverflowModes.Truncate: 
                                    i = this.RestoreWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedLastValidState"));
                                    characterToSubstitute.index = testedCharacterCount;
                                    characterToSubstitute.unicode = 3;
                                    continue;
                                case TMPro.TextOverflowModes.Ellipsis: 
                                    if (TMPro.TMP_Text.m_EllipsisInsertionCandidateStack.Count === 0) {
                                        i = -1;
                                        this.m_characterCount = 0;
                                        characterToSubstitute.index = 0;
                                        characterToSubstitute.unicode = 3;
                                        this.m_firstCharacterOfLine = 0;
                                        continue;
                                    }
                                    var ellipsisState = { v : TMPro.TMP_Text.m_EllipsisInsertionCandidateStack.Pop().$clone() };
                                    i = this.RestoreWordWrappingState(ellipsisState);
                                    i -= 1;
                                    this.m_characterCount -= 1;
                                    characterToSubstitute.index = this.m_characterCount;
                                    characterToSubstitute.unicode = 8230;
                                    restoreCount += 1;
                                    continue;
                                case TMPro.TextOverflowModes.Linked: 
                                    i = this.RestoreWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedLastValidState"));
                                    if (UnityEngine.MonoBehaviour.op_Inequality(this.m_linkedTextComponent, null)) {
                                        this.m_linkedTextComponent.text = this.text;
                                        this.m_linkedTextComponent.m_inputSource = this.m_inputSource;
                                        this.m_linkedTextComponent.firstVisibleCharacter = this.m_characterCount;
                                        this.m_linkedTextComponent.ForceMeshUpdate();

                                        this.m_isTextTruncated = true;
                                    }
                                    // Truncate remaining text
                                    characterToSubstitute.index = testedCharacterCount;
                                    characterToSubstitute.unicode = 3;
                                    continue;
                                case TMPro.TextOverflowModes.Page: 
                                    // End layout of text if first character / page doesn't fit.
                                    if (i < 0 || testedCharacterCount === 0) {
                                        i = -1;
                                        this.m_characterCount = 0;
                                        characterToSubstitute.index = 0;
                                        characterToSubstitute.unicode = 3;
                                        continue;
                                    } else if (this.m_maxLineAscender - this.m_maxLineDescender > marginHeight + 0.0001) {
                                        // Current line exceeds the height of the text container
                                        // as such we stop on the previous line.
                                        i = this.RestoreWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedLineState"));

                                        characterToSubstitute.index = testedCharacterCount;
                                        characterToSubstitute.unicode = 3;
                                        continue;
                                    }
                                    // Go back to previous line and re-layout
                                    i = this.RestoreWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedLineState"));
                                    this.m_isNewPage = true;
                                    this.m_firstCharacterOfLine = this.m_characterCount;
                                    this.m_maxLineAscender = TMPro.TMP_Text.k_LargeNegativeFloat;
                                    this.m_maxLineDescender = TMPro.TMP_Text.k_LargePositiveFloat;
                                    this.m_startOfLineAscender = 0;
                                    this.m_xAdvance = 0 + this.tag_Indent;
                                    this.m_lineOffset = 0;
                                    this.m_maxTextAscender = 0;
                                    this.m_PageAscender = 0;
                                    this.m_lineNumber += 1;
                                    this.m_pageNumber += 1;
                                    // Should consider saving page data here
                                    continue;
                            }
                        }



                        // Handling of Horizontal Bounds


                        if (textWidth > widthOfTextArea * (isJustifiedOrFlush ? 1.05 : 1.0)) {
                            // Handle Line Breaking (if still possible)
                            if (this.m_enableWordWrapping && this.m_characterCount !== this.m_firstCharacterOfLine) {
                                // Restore state to previous safe line breaking
                                i = this.RestoreWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedWordWrapState"));

                                // Compute potential new line offset in the event a line break is needed.
                                var lineOffsetDelta = 0;
                                if (this.m_lineHeight === TMPro.TMP_Math.FLOAT_UNSET) {
                                    var ascender = characterInfo.adjustedAscender;
                                    lineOffsetDelta = (this.m_lineOffset > 0 && this.m_IsDrivenLineSpacing === false ? this.m_maxLineAscender - this.m_startOfLineAscender : 0) - this.m_maxLineDescender + ascender + (lineGap + this.m_lineSpacingDelta) * baseScale + this.m_lineSpacing * currentEmScale;
                                } else {
                                    lineOffsetDelta = this.m_lineHeight + this.m_lineSpacing * currentEmScale;
                                    this.m_IsDrivenLineSpacing = true;
                                }

                                // Calculate new text height
                                var newTextHeight = this.m_maxTextAscender + lineOffsetDelta + this.m_lineOffset - characterInfo.adjustedDescender;

                                // Replace Soft Hyphen by Hyphen Minus 0x2D


                                if (this.m_textInfo.characterInfo[ this.m_characterCount - 1 ].character === 173 && isSoftHyphenIgnored === false) {
                                    // Only inject Hyphen Minus if new line is possible
                                    if (this.m_overflowMode === TMPro.TextOverflowModes.Overflow || newTextHeight < marginHeight + 0.0001) {
                                        characterToSubstitute.index = this.m_characterCount - 1;
                                        characterToSubstitute.unicode = 45;

                                        i -= 1;
                                        this.m_characterCount -= 1;
                                        continue;
                                    }
                                }

                                isSoftHyphenIgnored = false;

                                // Ignore Soft Hyphen to prevent it from wrapping
                                if (characterInfo.character === 173) {
                                    isSoftHyphenIgnored = true;
                                    continue;
                                }


                                // Adjust character spacing before breaking up word if auto size is enabled
                                if (this.m_enableAutoSizing && isFirstWordOfLine) {
                                    // Handle Character Width Adjustments


                                    if (this.m_charWidthAdjDelta < this.m_charWidthMaxAdj / 100 && this.m_AutoSizeIterationCount < this.m_AutoSizeMaxIterationCount) {
                                        var adjustedTextWidth = textWidth;

                                        // Determine full width of the text
                                        if (this.m_charWidthAdjDelta > 0) {
                                            adjustedTextWidth /= 1.0 - this.m_charWidthAdjDelta;
                                        }

                                        var adjustmentDelta1 = textWidth - (widthOfTextArea - 0.0001) * (isJustifiedOrFlush ? 1.05 : 1.0);
                                        this.m_charWidthAdjDelta += adjustmentDelta1 / adjustedTextWidth;
                                        this.m_charWidthAdjDelta = UnityEngine.Mathf.Min(this.m_charWidthAdjDelta, this.m_charWidthMaxAdj / 100);

                                        //Debug.Log("[" + m_AutoSizeIterationCount + "] Reducing Character Width by " + (m_charWidthAdjDelta * 100) + "%");
                                        return;
                                    }


                                    // Handle Text Auto-sizing resulting from text exceeding vertical bounds.


                                    if (this.m_fontSize > this.m_fontSizeMin && this.m_AutoSizeIterationCount < this.m_AutoSizeMaxIterationCount) {
                                        this.m_maxFontSize = this.m_fontSize;

                                        var sizeDelta1 = UnityEngine.Mathf.Max((this.m_fontSize - this.m_minFontSize) / 2, 0.05);
                                        this.m_fontSize -= sizeDelta1;
                                        this.m_fontSize = UnityEngine.Mathf.Max((this.m_fontSize * 20 + 0.5) / 20.0, this.m_fontSizeMin);

                                        //Debug.Log("[" + m_AutoSizeIterationCount + "] Reducing Point Size from [" + m_maxFontSize.ToString("f3") + "] to [" + m_fontSize.ToString("f3") + "] with delta of [" + sizeDelta.ToString("f3") + "].");
                                        return;
                                    }

                                }


                                // Special handling if first word of line and non breaking space
                                var savedSoftLineBreakingSpace = TMPro.TMP_Text.m_SavedSoftLineBreakState.previous_WordBreak;
                                if (isFirstWordOfLine && savedSoftLineBreakingSpace !== -1) {
                                    if (savedSoftLineBreakingSpace !== lastSoftLineBreak) {
                                        i = this.RestoreWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedSoftLineBreakState"));
                                        lastSoftLineBreak = savedSoftLineBreakingSpace;

                                        // check if soft hyphen
                                        if (this.m_textInfo.characterInfo[ this.m_characterCount - 1 ].character === 173) {
                                            characterToSubstitute.index = this.m_characterCount - 1;
                                            characterToSubstitute.unicode = 45;

                                            i -= 1;
                                            this.m_characterCount -= 1;
                                            continue;
                                        }
                                    }
                                }

                                // Determine if new line of text would exceed the vertical bounds of text container
                                if (newTextHeight > marginHeight + 0.0001) {
                                    // Set isTextOverflowing and firstOverflowCharacterIndex
                                    if (this.m_firstOverflowCharacterIndex === -1) {
                                        this.m_firstOverflowCharacterIndex = this.m_characterCount;
                                    }

                                    // Check if Auto-Size is enabled
                                    if (this.m_enableAutoSizing) {
                                        // Handle Line spacing adjustments


                                        if (this.m_lineSpacingDelta > this.m_lineSpacingMax && this.m_AutoSizeIterationCount < this.m_AutoSizeMaxIterationCount) {
                                            var adjustmentDelta2 = (marginHeight - newTextHeight) / (this.m_lineNumber + 1);

                                            this.m_lineSpacingDelta = UnityEngine.Mathf.Max(this.m_lineSpacingDelta + adjustmentDelta2 / baseScale, this.m_lineSpacingMax);

                                            //Debug.Log("[" + m_AutoSizeIterationCount + "] Reducing Line Spacing. Delta of [" + m_lineSpacingDelta.ToString("f3") + "].");
                                            return;
                                        }


                                        // Handle Character Width Adjustments


                                        if (this.m_charWidthAdjDelta < this.m_charWidthMaxAdj / 100 && this.m_AutoSizeIterationCount < this.m_AutoSizeMaxIterationCount) {
                                            var adjustedTextWidth1 = textWidth;

                                            // Determine full width of the text
                                            if (this.m_charWidthAdjDelta > 0) {
                                                adjustedTextWidth1 /= 1.0 - this.m_charWidthAdjDelta;
                                            }

                                            var adjustmentDelta3 = textWidth - (widthOfTextArea - 0.0001) * (isJustifiedOrFlush ? 1.05 : 1.0);
                                            this.m_charWidthAdjDelta += adjustmentDelta3 / adjustedTextWidth1;
                                            this.m_charWidthAdjDelta = UnityEngine.Mathf.Min(this.m_charWidthAdjDelta, this.m_charWidthMaxAdj / 100);

                                            //Debug.Log("[" + m_AutoSizeIterationCount + "] Reducing Character Width by " + (m_charWidthAdjDelta * 100) + "%");
                                            return;
                                        }


                                        // Handle Text Auto-sizing resulting from text exceeding vertical bounds.


                                        if (this.m_fontSize > this.m_fontSizeMin && this.m_AutoSizeIterationCount < this.m_AutoSizeMaxIterationCount) {
                                            this.m_maxFontSize = this.m_fontSize;

                                            var sizeDelta2 = UnityEngine.Mathf.Max((this.m_fontSize - this.m_minFontSize) / 2, 0.05);
                                            this.m_fontSize -= sizeDelta2;
                                            this.m_fontSize = UnityEngine.Mathf.Max((this.m_fontSize * 20 + 0.5) / 20.0, this.m_fontSizeMin);

                                            //Debug.Log("[" + m_AutoSizeIterationCount + "] Reducing Point Size from [" + m_maxFontSize.ToString("f3") + "] to [" + m_fontSize.ToString("f3") + "] with delta of [" + sizeDelta.ToString("f3") + "].");
                                            return;
                                        }

                                    }

                                    // Check Text Overflow Modes
                                    switch (this.m_overflowMode) {
                                        case TMPro.TextOverflowModes.Overflow: 
                                        case TMPro.TextOverflowModes.ScrollRect: 
                                        case TMPro.TextOverflowModes.Masking: 
                                            this.InsertNewLine(i, baseScale, currentElementScale, currentEmScale, this.m_GlyphHorizontalAdvanceAdjustment, boldSpacingAdjustment, characterSpacingAdjustment, widthOfTextArea, lineGap, isMaxVisibleDescenderSet, maxVisibleDescender);
                                            isStartOfNewLine = true;
                                            isFirstWordOfLine = true;
                                            continue;
                                        case TMPro.TextOverflowModes.Truncate: 
                                            i = this.RestoreWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedLastValidState"));
                                            characterToSubstitute.index = testedCharacterCount;
                                            characterToSubstitute.unicode = 3;
                                            continue;
                                        case TMPro.TextOverflowModes.Ellipsis: 
                                            if (TMPro.TMP_Text.m_EllipsisInsertionCandidateStack.Count === 0) {
                                                i = -1;
                                                this.m_characterCount = 0;
                                                characterToSubstitute.index = 0;
                                                characterToSubstitute.unicode = 3;
                                                this.m_firstCharacterOfLine = 0;
                                                continue;
                                            }
                                            var ellipsisState1 = { v : TMPro.TMP_Text.m_EllipsisInsertionCandidateStack.Pop().$clone() };
                                            i = this.RestoreWordWrappingState(ellipsisState1);
                                            i -= 1;
                                            this.m_characterCount -= 1;
                                            characterToSubstitute.index = this.m_characterCount;
                                            characterToSubstitute.unicode = 8230;
                                            restoreCount += 1;
                                            continue;
                                        case TMPro.TextOverflowModes.Linked: 
                                            if (UnityEngine.MonoBehaviour.op_Inequality(this.m_linkedTextComponent, null)) {
                                                this.m_linkedTextComponent.text = this.text;
                                                this.m_linkedTextComponent.m_inputSource = this.m_inputSource;
                                                this.m_linkedTextComponent.firstVisibleCharacter = this.m_characterCount;
                                                this.m_linkedTextComponent.ForceMeshUpdate();

                                                this.m_isTextTruncated = true;
                                            }
                                            // Truncate remaining text
                                            characterToSubstitute.index = this.m_characterCount;
                                            characterToSubstitute.unicode = 3;
                                            continue;
                                        case TMPro.TextOverflowModes.Page: 
                                            // Add new page
                                            this.m_isNewPage = true;
                                            this.InsertNewLine(i, baseScale, currentElementScale, currentEmScale, this.m_GlyphHorizontalAdvanceAdjustment, boldSpacingAdjustment, characterSpacingAdjustment, widthOfTextArea, lineGap, isMaxVisibleDescenderSet, maxVisibleDescender);
                                            this.m_startOfLineAscender = 0;
                                            this.m_lineOffset = 0;
                                            this.m_maxTextAscender = 0;
                                            this.m_PageAscender = 0;
                                            this.m_pageNumber += 1;
                                            isStartOfNewLine = true;
                                            isFirstWordOfLine = true;
                                            continue;
                                    }
                                } else {
                                    //if (m_enableAutoSizing && isFirstWordOfLine)
                                    //{
                                    //    // Handle Character Width Adjustments
                                    //    #region Character Width Adjustments
                                    //    if (m_charWidthAdjDelta < m_charWidthMaxAdj / 100 && m_AutoSizeIterationCount < m_AutoSizeMaxIterationCount)
                                    //    {
                                    //        //m_AutoSizeIterationCount = 0;
                                    //        float adjustedTextWidth = textWidth;

                                    //        // Determine full width of the text
                                    //        if (m_charWidthAdjDelta > 0)
                                    //            adjustedTextWidth /= 1f - m_charWidthAdjDelta;

                                    //        float adjustmentDelta = textWidth - (widthOfTextArea - 0.0001f) * (isJustifiedOrFlush ? 1.05f : 1.0f);
                                    //        m_charWidthAdjDelta += adjustmentDelta / adjustedTextWidth;
                                    //        m_charWidthAdjDelta = Mathf.Min(m_charWidthAdjDelta, m_charWidthMaxAdj / 100);

                                    //        //Debug.Log("[" + m_AutoSizeIterationCount + "] Reducing Character Width by " + (m_charWidthAdjDelta * 100) + "%");

                                    //        GenerateTextMesh();
                                    //        return;
                                    //    }
                                    //    #endregion
                                    //}

                                    // New line of text does not exceed vertical bounds of text container
                                    this.InsertNewLine(i, baseScale, currentElementScale, currentEmScale, this.m_GlyphHorizontalAdvanceAdjustment, boldSpacingAdjustment, characterSpacingAdjustment, widthOfTextArea, lineGap, isMaxVisibleDescenderSet, maxVisibleDescender);
                                    isStartOfNewLine = true;
                                    isFirstWordOfLine = true;
                                    continue;
                                }
                            } else {
                                if (this.m_enableAutoSizing && this.m_AutoSizeIterationCount < this.m_AutoSizeMaxIterationCount) {
                                    // Handle Character Width Adjustments


                                    if (this.m_charWidthAdjDelta < this.m_charWidthMaxAdj / 100) {
                                        var adjustedTextWidth2 = textWidth;

                                        // Determine full width of the text
                                        if (this.m_charWidthAdjDelta > 0) {
                                            adjustedTextWidth2 /= 1.0 - this.m_charWidthAdjDelta;
                                        }

                                        var adjustmentDelta4 = textWidth - (widthOfTextArea - 0.0001) * (isJustifiedOrFlush ? 1.05 : 1.0);
                                        this.m_charWidthAdjDelta += adjustmentDelta4 / adjustedTextWidth2;
                                        this.m_charWidthAdjDelta = UnityEngine.Mathf.Min(this.m_charWidthAdjDelta, this.m_charWidthMaxAdj / 100);

                                        //Debug.Log("[" + m_AutoSizeIterationCount + "] Reducing Character Width by " + (m_charWidthAdjDelta * 100) + "%");
                                        return;
                                    }


                                    // Handle Text Auto-sizing resulting from text exceeding horizontal bounds.


                                    if (this.m_fontSize > this.m_fontSizeMin) {
                                        // Reset character width adjustment delta
                                        //m_charWidthAdjDelta = 0;

                                        // Adjust Point Size
                                        this.m_maxFontSize = this.m_fontSize;

                                        var sizeDelta3 = UnityEngine.Mathf.Max((this.m_fontSize - this.m_minFontSize) / 2, 0.05);
                                        this.m_fontSize -= sizeDelta3;
                                        this.m_fontSize = UnityEngine.Mathf.Max((this.m_fontSize * 20 + 0.5) / 20.0, this.m_fontSizeMin);

                                        //Debug.Log("[" + m_AutoSizeIterationCount + "] Reducing Point Size from [" + m_maxFontSize.ToString("f3") + "] to [" + m_fontSize.ToString("f3") + "] with delta of [" + sizeDelta.ToString("f3") + "].");
                                        return;
                                    }

                                }

                                // Check Text Overflow Modes
                                switch (this.m_overflowMode) {
                                    case TMPro.TextOverflowModes.Overflow: 
                                    case TMPro.TextOverflowModes.ScrollRect: 
                                    case TMPro.TextOverflowModes.Masking: 
                                        // Nothing happens as horizontal bounds are ignored in this mode.
                                        break;
                                    case TMPro.TextOverflowModes.Truncate: 
                                        i = this.RestoreWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedWordWrapState"));
                                        characterToSubstitute.index = testedCharacterCount;
                                        characterToSubstitute.unicode = 3;
                                        continue;
                                    case TMPro.TextOverflowModes.Ellipsis: 
                                        if (TMPro.TMP_Text.m_EllipsisInsertionCandidateStack.Count === 0) {
                                            i = -1;
                                            this.m_characterCount = 0;
                                            characterToSubstitute.index = 0;
                                            characterToSubstitute.unicode = 3;
                                            this.m_firstCharacterOfLine = 0;
                                            continue;
                                        }
                                        var ellipsisState2 = { v : TMPro.TMP_Text.m_EllipsisInsertionCandidateStack.Pop().$clone() };
                                        i = this.RestoreWordWrappingState(ellipsisState2);
                                        i -= 1;
                                        this.m_characterCount -= 1;
                                        characterToSubstitute.index = this.m_characterCount;
                                        characterToSubstitute.unicode = 8230;
                                        restoreCount += 1;
                                        continue;
                                    case TMPro.TextOverflowModes.Linked: 
                                        i = this.RestoreWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedWordWrapState"));
                                        if (UnityEngine.MonoBehaviour.op_Inequality(this.m_linkedTextComponent, null)) {
                                            this.m_linkedTextComponent.text = this.text;
                                            this.m_linkedTextComponent.m_inputSource = this.m_inputSource;
                                            this.m_linkedTextComponent.firstVisibleCharacter = this.m_characterCount;
                                            this.m_linkedTextComponent.ForceMeshUpdate();

                                            this.m_isTextTruncated = true;
                                        }
                                        // Truncate text the overflows the vertical bounds
                                        characterToSubstitute.index = this.m_characterCount;
                                        characterToSubstitute.unicode = 3;
                                        continue;
                                }
                            }
                        }



                        // Special handling of characters that are not ignored at the end of a line.
                        if (charCode === 9) {
                            characterInfo.isVisible = false;
                            this.m_lastVisibleCharacterOfLine = this.m_characterCount;
                            this.m_textInfo.lineInfo[ this.m_lineNumber ].spaceCount += 1;
                            this.m_textInfo.spaceCount += 1;
                        } else if (charCode === 173) {
                            characterInfo.isVisible = false;
                        } else {
                            // Determine Vertex Color
                            if (this.m_overrideHtmlColors) {
                                vertexColor = this.m_fontColor32.$clone();
                            } else {
                                vertexColor = this.m_htmlColor.$clone();
                            }

                            // Store Character & Sprite Vertex Information
                            if (this.m_textElementType === TMPro.TMP_TextElementType.Character) {
                                // Save Character Vertex Data
                                this.SaveGlyphVertexInfo(padding, style_padding, vertexColor.$clone());
                            } else if (this.m_textElementType === TMPro.TMP_TextElementType.Sprite) {
                                this.SaveSpriteVertexInfo(vertexColor.$clone());
                            }

                            if (isStartOfNewLine) {
                                isStartOfNewLine = false;
                                this.m_firstVisibleCharacterOfLine = this.m_characterCount;
                            }

                            this.m_lineVisibleCharacterCount += 1;
                            this.m_lastVisibleCharacterOfLine = this.m_characterCount;
                            this.m_textInfo.lineInfo[ this.m_lineNumber ].marginLeft = marginLeft;
                            this.m_textInfo.lineInfo[ this.m_lineNumber ].marginRight = marginRight;
                        }
                    } else {
                        // Special handling for text overflow linked mode


                        if (this.m_overflowMode === TMPro.TextOverflowModes.Linked && (charCode === 10 || charCode === 11)) {
                            var textHeight1 = this.m_maxTextAscender - (this.m_maxLineDescender - this.m_lineOffset) + (this.m_lineOffset > 0 && this.m_IsDrivenLineSpacing === false ? this.m_maxLineAscender - this.m_startOfLineAscender : 0);

                            var testedCharacterCount1 = this.m_characterCount;

                            if (textHeight1 > marginHeight + 0.0001) {
                                // Set isTextOverflowing and firstOverflowCharacterIndex
                                if (this.m_firstOverflowCharacterIndex === -1) {
                                    this.m_firstOverflowCharacterIndex = this.m_characterCount;
                                }

                                i = this.RestoreWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedLastValidState"));

                                if (UnityEngine.MonoBehaviour.op_Inequality(this.m_linkedTextComponent, null)) {
                                    this.m_linkedTextComponent.text = this.text;
                                    this.m_linkedTextComponent.m_inputSource = this.m_inputSource;
                                    this.m_linkedTextComponent.firstVisibleCharacter = this.m_characterCount;
                                    this.m_linkedTextComponent.ForceMeshUpdate();

                                    this.m_isTextTruncated = true;
                                }

                                // Truncate remaining text
                                characterToSubstitute.index = testedCharacterCount1;
                                characterToSubstitute.unicode = 3;
                                continue;
                            }
                        }


                        // Track # of spaces per line which is used for line justification.
                        if ((charCode === 10 || charCode === 11 || charCode === 160 || charCode === 8199 || charCode === 8232 || charCode === 8233 || System.Char.isSeparator(charCode)) && charCode !== 173 && charCode !== 8203 && charCode !== 8288) {
                            this.m_textInfo.lineInfo[ this.m_lineNumber ].spaceCount += 1;
                            this.m_textInfo.spaceCount += 1;
                        }

                        if (charCode === 160) {
                            this.m_textInfo.lineInfo[ this.m_lineNumber ].controlCharacterCount += 1;
                        }
                    }



                    // Tracking of potential insertion positions for Ellipsis character


                    if (this.m_overflowMode === TMPro.TextOverflowModes.Ellipsis && (isInjectingCharacter === false || charCode === 45)) {
                        var fontScale1 = this.m_currentFontSize / this.m_Ellipsis.fontAsset.m_FaceInfo.pointSize * this.m_Ellipsis.fontAsset.m_FaceInfo.scale * (this.m_isOrthographic ? 1 : 0.1);
                        var scale = fontScale1 * this.m_fontScaleMultiplier * this.m_Ellipsis.character.m_Scale * this.m_Ellipsis.character.m_Glyph.scale;
                        var marginLeft1 = this.m_marginLeft;
                        var marginRight1 = this.m_marginRight;

                        // Use the scale and margins of the previous character if Line Feed (LF) is not the first character of a line.
                        if (charCode === 10 && this.m_characterCount !== this.m_firstCharacterOfLine) {
                            fontScale1 = this.m_textInfo.characterInfo[ this.m_characterCount - 1 ].pointSize / this.m_Ellipsis.fontAsset.m_FaceInfo.pointSize * this.m_Ellipsis.fontAsset.m_FaceInfo.scale * (this.m_isOrthographic ? 1 : 0.1);
                            scale = fontScale1 * this.m_fontScaleMultiplier * this.m_Ellipsis.character.m_Scale * this.m_Ellipsis.character.m_Glyph.scale;
                            marginLeft1 = this.m_textInfo.lineInfo[ this.m_lineNumber ].marginLeft;
                            marginRight1 = this.m_textInfo.lineInfo[ this.m_lineNumber ].marginRight;
                        }

                        var textHeight2 = this.m_maxTextAscender - (this.m_maxLineDescender - this.m_lineOffset) + (this.m_lineOffset > 0 && this.m_IsDrivenLineSpacing === false ? this.m_maxLineAscender - this.m_startOfLineAscender : 0);
                        var textWidth1 = Math.abs(this.m_xAdvance) + (!this.m_isRightToLeft ? this.m_Ellipsis.character.m_Glyph.metrics.horizontalAdvance : 0) * (1 - this.m_charWidthAdjDelta) * scale;
                        var widthOfTextAreaForEllipsis = this.m_width !== -1 ? UnityEngine.Mathf.Min(marginWidth + 0.0001 - marginLeft1 - marginRight1, this.m_width) : marginWidth + 0.0001 - marginLeft1 - marginRight1;

                        if (textWidth1 < widthOfTextAreaForEllipsis * (isJustifiedOrFlush ? 1.05 : 1.0) && textHeight2 < marginHeight + 0.0001) {
                            this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedEllipsisState"), i, this.m_characterCount);
                            TMPro.TMP_Text.m_EllipsisInsertionCandidateStack.Push(TMPro.TMP_Text.m_SavedEllipsisState.$clone());
                        }
                    }



                    // Store Rectangle positions for each Character.


                    characterInfo.lineNumber = this.m_lineNumber;
                    characterInfo.pageNumber = this.m_pageNumber;

                    if (charCode !== 10 && charCode !== 11 && charCode !== 13 && isInjectingCharacter === false || this.m_textInfo.lineInfo[ this.m_lineNumber ].characterCount === 1) {
                        this.m_textInfo.lineInfo[ this.m_lineNumber ].alignment = this.m_lineJustification;
                    }



                    // Handle xAdvance & Tabulation Stops. Tab stops at every 25% of Font Size.


                    if (charCode === 9) {
                        var tabSize = this.m_currentFontAsset.m_FaceInfo.tabWidth * this.m_currentFontAsset.tabSize * currentElementScale;
                        var tabs = Math.ceil(this.m_xAdvance / tabSize) * tabSize;
                        this.m_xAdvance = tabs > this.m_xAdvance ? tabs : this.m_xAdvance + tabSize;
                    } else if (this.m_monoSpacing !== 0) {
                        this.m_xAdvance += (this.m_monoSpacing - monoAdvance + (this.m_currentFontAsset.normalSpacingOffset + characterSpacingAdjustment) * currentEmScale + this.m_cSpacing) * (1 - this.m_charWidthAdjDelta);

                        if (isWhiteSpace || charCode === 8203) {
                            this.m_xAdvance += this.m_wordSpacing * currentEmScale;
                        }
                    } else if (this.m_isRightToLeft) {
                        this.m_xAdvance -= (glyphAdjustments.m_XAdvance * currentElementScale + (this.m_currentFontAsset.normalSpacingOffset + characterSpacingAdjustment + boldSpacingAdjustment) * currentEmScale + this.m_cSpacing) * (1 - this.m_charWidthAdjDelta);

                        if (isWhiteSpace || charCode === 8203) {
                            this.m_xAdvance -= this.m_wordSpacing * currentEmScale;
                        }
                    } else {
                        var scaleFXMultiplier = 1;
                        if (this.m_isFXMatrixSet) {
                            scaleFXMultiplier = this.m_FXMatrix.getScale().x;
                        }

                        this.m_xAdvance += ((currentGlyphMetrics.horizontalAdvance * scaleFXMultiplier + glyphAdjustments.m_XAdvance) * currentElementScale + (this.m_currentFontAsset.normalSpacingOffset + characterSpacingAdjustment + boldSpacingAdjustment) * currentEmScale + this.m_cSpacing) * (1 - this.m_charWidthAdjDelta);

                        if (isWhiteSpace || charCode === 8203) {
                            this.m_xAdvance += this.m_wordSpacing * currentEmScale;
                        }
                    }

                    // Store xAdvance information
                    characterInfo.xAdvance = this.m_xAdvance;



                    // Handle Carriage Return


                    if (charCode === 13) {
                        this.m_xAdvance = 0 + this.tag_Indent;
                    }



                    // Handle Line Spacing Adjustments + Word Wrapping & special case for last line.


                    if (charCode === 10 || charCode === 11 || charCode === 3 || charCode === 8232 || charCode === 8233 || charCode === 45 && isInjectingCharacter || this.m_characterCount === totalCharacterCount - 1) {
                        // Adjust current line spacing (if necessary) before inserting new line
                        var baselineAdjustmentDelta = this.m_maxLineAscender - this.m_startOfLineAscender;
                        if (this.m_lineOffset > 0 && Math.abs(baselineAdjustmentDelta) > 0.01 && this.m_IsDrivenLineSpacing === false && !this.m_isNewPage) {
                            //Debug.Log("Line Feed - Adjusting Line Spacing on line #" + m_lineNumber);
                            this.AdjustLineOffset(this.m_firstCharacterOfLine, this.m_characterCount, baselineAdjustmentDelta);
                            this.m_ElementDescender -= baselineAdjustmentDelta;
                            this.m_lineOffset += baselineAdjustmentDelta;

                            // Adjust saved ellipsis state only if we are adjusting the same line number
                            if (TMPro.TMP_Text.m_SavedEllipsisState.lineNumber === this.m_lineNumber) {
                                TMPro.TMP_Text.m_SavedEllipsisState = TMPro.TMP_Text.m_EllipsisInsertionCandidateStack.Pop().$clone();
                                TMPro.TMP_Text.m_SavedEllipsisState.startOfLineAscender += baselineAdjustmentDelta;
                                TMPro.TMP_Text.m_SavedEllipsisState.lineOffset += baselineAdjustmentDelta;
                                TMPro.TMP_Text.m_EllipsisInsertionCandidateStack.Push(TMPro.TMP_Text.m_SavedEllipsisState.$clone());
                            }
                        }

                        this.m_isNewPage = false;

                        // Calculate lineAscender & make sure if last character is superscript or subscript that we check that as well.
                        var lineAscender = this.m_maxLineAscender - this.m_lineOffset;
                        var lineDescender = this.m_maxLineDescender - this.m_lineOffset;

                        // Update maxDescender and maxVisibleDescender
                        this.m_ElementDescender = this.m_ElementDescender < lineDescender ? this.m_ElementDescender : lineDescender;
                        if (!isMaxVisibleDescenderSet.v) {
                            maxVisibleDescender.v = this.m_ElementDescender;
                        }

                        if (this.m_useMaxVisibleDescender && (this.m_characterCount >= this.m_maxVisibleCharacters || this.m_lineNumber >= this.m_maxVisibleLines)) {
                            isMaxVisibleDescenderSet.v = true;
                        }

                        // Save Line Information
                        lineInfo = this.m_textInfo.lineInfo[ this.m_lineNumber ];

                        lineInfo.firstCharacterIndex = this.m_firstCharacterOfLine;
                        lineInfo.firstVisibleCharacterIndex = (this.m_firstVisibleCharacterOfLine = this.m_firstCharacterOfLine > this.m_firstVisibleCharacterOfLine ? this.m_firstCharacterOfLine : this.m_firstVisibleCharacterOfLine);
                        lineInfo.lastCharacterIndex = (this.m_lastCharacterOfLine = this.m_characterCount);
                        lineInfo.lastVisibleCharacterIndex = (this.m_lastVisibleCharacterOfLine = this.m_lastVisibleCharacterOfLine < this.m_firstVisibleCharacterOfLine ? this.m_firstVisibleCharacterOfLine : this.m_lastVisibleCharacterOfLine);
                        lineInfo.characterCount = ($t9 = this.m_textInfo.lineInfo)[this.m_lineNumber].lastCharacterIndex - ($t10 = this.m_textInfo.lineInfo)[this.m_lineNumber].firstCharacterIndex + 1;
                        lineInfo.visibleCharacterCount = this.m_lineVisibleCharacterCount;

                        lineInfo.lineExtents.min.set( ($t11 = this.m_textInfo.characterInfo)[this.m_firstVisibleCharacterOfLine].bottomLeft.x, lineDescender );
                        lineInfo.lineExtents.max.set( ($t12 = this.m_textInfo.characterInfo)[this.m_lastVisibleCharacterOfLine].topRight.x, lineAscender );
                        lineInfo.length = lineInfo.lineExtents.max.x - padding * currentElementScale;

                        lineInfo.width = widthOfTextArea;

                        if (lineInfo.characterCount === 1) {
                            lineInfo.alignment = this.m_lineJustification;
                        }

                        var maxAdvanceOffset = (boldSpacingAdjustment * currentElementScale + (this.m_currentFontAsset.normalSpacingOffset + characterSpacingAdjustment) * currentEmScale - this.m_cSpacing) * (1 - this.m_charWidthAdjDelta);
                        if (($t13 = this.m_textInfo.characterInfo)[this.m_lastVisibleCharacterOfLine].isVisible) {
                            lineInfo.maxAdvance = ($t14 = this.m_textInfo.characterInfo)[this.m_lastVisibleCharacterOfLine].xAdvance + (this.m_isRightToLeft ? maxAdvanceOffset : -maxAdvanceOffset);
                        } else {
                            lineInfo.maxAdvance = ($t15 = this.m_textInfo.characterInfo)[this.m_lastCharacterOfLine].xAdvance + (this.m_isRightToLeft ? maxAdvanceOffset : -maxAdvanceOffset);
                        }

                        lineInfo.baseline = 0 - this.m_lineOffset;
                        lineInfo.ascender = lineAscender;
                        lineInfo.descender = lineDescender;
                        lineInfo.lineHeight = lineAscender - lineDescender + lineGap * baseScale;

                        // Add new line if not last line or character.
                        if (charCode === 10 || charCode === 11 || charCode === 45 || charCode === 8232 || charCode === 8233) {
                            // Store the state of the line before starting on the new line.
                            this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedLineState"), i, this.m_characterCount);

                            this.m_lineNumber += 1;
                            isStartOfNewLine = true;
                            ignoreNonBreakingSpace = false;
                            isFirstWordOfLine = true;

                            this.m_firstCharacterOfLine = this.m_characterCount + 1;
                            this.m_lineVisibleCharacterCount = 0;

                            // Check to make sure Array is large enough to hold a new line.
                            if (this.m_lineNumber >= this.m_textInfo.lineInfo.length) {
                                this.ResizeLineExtents(this.m_lineNumber);
                            }

                            var lastVisibleAscender = ($t16 = this.m_textInfo.characterInfo)[this.m_characterCount].adjustedAscender;

                            // Apply Line Spacing with special handling for VT char(11)
                            if (this.m_lineHeight === TMPro.TMP_Math.FLOAT_UNSET) {
                                var lineOffsetDelta1 = 0 - this.m_maxLineDescender + lastVisibleAscender + (lineGap + this.m_lineSpacingDelta) * baseScale + (this.m_lineSpacing + (charCode === 10 || charCode === 8233 ? this.m_paragraphSpacing : 0)) * currentEmScale;
                                this.m_lineOffset += lineOffsetDelta1;
                                this.m_IsDrivenLineSpacing = false;
                            } else {
                                this.m_lineOffset += this.m_lineHeight + (this.m_lineSpacing + (charCode === 10 || charCode === 8233 ? this.m_paragraphSpacing : 0)) * currentEmScale;
                                this.m_IsDrivenLineSpacing = true;
                            }

                            this.m_maxLineAscender = TMPro.TMP_Text.k_LargeNegativeFloat;
                            this.m_maxLineDescender = TMPro.TMP_Text.k_LargePositiveFloat;
                            this.m_startOfLineAscender = lastVisibleAscender;

                            this.m_xAdvance = 0 + this.tag_LineIndent + this.tag_Indent;

                            this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedWordWrapState"), i, this.m_characterCount);
                            this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedLastValidState"), i, this.m_characterCount);

                            this.m_characterCount += 1;
                            continue;
                        }

                        // If End of Text
                        if (charCode === 3) {
                            i = this.m_TextProcessingArray.length;
                        }
                    }



                    // Store Rectangle positions for each Character.


                    // Determine the bounds of the Mesh.
                    if (($t17 = this.m_textInfo.characterInfo)[this.m_characterCount].isVisible) {
                        this.m_meshExtents.min.x = UnityEngine.Mathf.Min(this.m_meshExtents.min.x, ($t18 = this.m_textInfo.characterInfo)[this.m_characterCount].bottomLeft.x);
                        this.m_meshExtents.min.y = UnityEngine.Mathf.Min(this.m_meshExtents.min.y, ($t19 = this.m_textInfo.characterInfo)[this.m_characterCount].bottomLeft.y);

                        this.m_meshExtents.max.x = UnityEngine.Mathf.Max(this.m_meshExtents.max.x, ($t20 = this.m_textInfo.characterInfo)[this.m_characterCount].topRight.x);
                        this.m_meshExtents.max.y = UnityEngine.Mathf.Max(this.m_meshExtents.max.y, ($t21 = this.m_textInfo.characterInfo)[this.m_characterCount].topRight.y);

                        //m_meshExtents.min = new Vector2(Mathf.Min(m_meshExtents.min.x, m_textInfo.characterInfo[m_characterCount].bottomLeft.x), Mathf.Min(m_meshExtents.min.y, m_textInfo.characterInfo[m_characterCount].bottomLeft.y));
                        //m_meshExtents.max = new Vector2(Mathf.Max(m_meshExtents.max.x, m_textInfo.characterInfo[m_characterCount].topRight.x), Mathf.Max(m_meshExtents.max.y, m_textInfo.characterInfo[m_characterCount].topRight.y));
                    }


                    // Save pageInfo Data
                    if (this.m_overflowMode === TMPro.TextOverflowModes.Page && charCode !== 10 && charCode !== 11 && charCode !== 13 && charCode !== 8232 && charCode !== 8233) {
                        // Check if we need to increase allocations for the pageInfo array.
                        if (this.m_pageNumber + 1 > this.m_textInfo.pageInfo.length) {
                            TMPro.TMP_TextInfo.Resize$1(TMPro.TMP_PageInfo, Bridge.ref(this.m_textInfo, "pageInfo"), this.m_pageNumber + 1, true);
                        }

                        ($t22 = this.m_textInfo.pageInfo)[this.m_pageNumber].ascender = this.m_PageAscender;
                        ($t23 = this.m_textInfo.pageInfo)[this.m_pageNumber].descender = this.m_ElementDescender < ($t24 = this.m_textInfo.pageInfo)[this.m_pageNumber].descender ? this.m_ElementDescender : ($t25 = this.m_textInfo.pageInfo)[this.m_pageNumber].descender;

                        if (this.m_pageNumber === 0 && this.m_characterCount === 0) {
                            ($t26 = this.m_textInfo.pageInfo)[this.m_pageNumber].firstCharacterIndex = this.m_characterCount;
                        } else if (this.m_characterCount > 0 && this.m_pageNumber !== ($t27 = this.m_textInfo.characterInfo)[this.m_characterCount - 1].pageNumber) {
                            ($t28 = this.m_textInfo.pageInfo)[this.m_pageNumber - 1].lastCharacterIndex = this.m_characterCount - 1;
                            ($t29 = this.m_textInfo.pageInfo)[this.m_pageNumber].firstCharacterIndex = this.m_characterCount;
                        } else if (this.m_characterCount === totalCharacterCount - 1) {
                            ($t30 = this.m_textInfo.pageInfo)[this.m_pageNumber].lastCharacterIndex = this.m_characterCount;
                        }
                    }



                    // Save State of Mesh Creation for handling of Word Wrapping


                    if (this.m_enableWordWrapping || this.m_overflowMode === TMPro.TextOverflowModes.Truncate || this.m_overflowMode === TMPro.TextOverflowModes.Ellipsis || this.m_overflowMode === TMPro.TextOverflowModes.Linked) {
                        if ((isWhiteSpace || charCode === 8203 || charCode === 45 || charCode === 173) && (!this.m_isNonBreakingSpace || ignoreNonBreakingSpace) && charCode !== 160 && charCode !== 8199 && charCode !== 8209 && charCode !== 8239 && charCode !== 8288) {
                            // We store the state of numerous variables for the most recent Space, LineFeed or Carriage Return to enable them to be restored
                            // for Word Wrapping.
                            this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedWordWrapState"), i, this.m_characterCount);
                            isFirstWordOfLine = false;
                            //isLastCharacterCJK = false;

                            // Reset soft line breaking point since we now have a valid hard break point.
                            TMPro.TMP_Text.m_SavedSoftLineBreakState.previous_WordBreak = -1;
                        } else if (this.m_isNonBreakingSpace === false && ((charCode > 4352 && charCode < 4607 || charCode > 43360 && charCode < 43391 || charCode > 44032 && charCode < 55295) && TMPro.TMP_Settings.useModernHangulLineBreakingRules === false || charCode > 11904 && charCode < 40959 || charCode > 63744 && charCode < 64255 || charCode > 65072 && charCode < 65103 || charCode > 65280 && charCode < 65519)) {
                            var isCurrentLeadingCharacter = TMPro.TMP_Settings.linebreakingRules.leadingCharacters.containsKey(charCode);
                            var isNextFollowingCharacter = this.m_characterCount < totalCharacterCount - 1 && TMPro.TMP_Settings.linebreakingRules.followingCharacters.containsKey(($t31 = this.m_textInfo.characterInfo)[this.m_characterCount + 1].character);

                            if (isCurrentLeadingCharacter === false) {
                                if (isNextFollowingCharacter === false) {
                                    this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedWordWrapState"), i, this.m_characterCount);
                                    isFirstWordOfLine = false;
                                }

                                if (isFirstWordOfLine) {
                                    // Special handling for non-breaking space and soft line breaks
                                    if (isWhiteSpace) {
                                        this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedSoftLineBreakState"), i, this.m_characterCount);
                                    }

                                    this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedWordWrapState"), i, this.m_characterCount);
                                }
                            } else {
                                if (isFirstWordOfLine && isFirstCharacterOfLine) {
                                    // Special handling for non-breaking space and soft line breaks
                                    if (isWhiteSpace) {
                                        this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedSoftLineBreakState"), i, this.m_characterCount);
                                    }

                                    this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedWordWrapState"), i, this.m_characterCount);
                                }
                            }

                            //isLastCharacterCJK = true;
                        } else if (isFirstWordOfLine) {
                            // Special handling for non-breaking space and soft line breaks
                            if (isWhiteSpace || charCode === 173 && isSoftHyphenIgnored === false) {
                                this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedSoftLineBreakState"), i, this.m_characterCount);
                            }

                            this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedWordWrapState"), i, this.m_characterCount);
                            //isLastCharacterCJK = false;
                        }
                    }


                    this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedLastValidState"), i, this.m_characterCount);

                    this.m_characterCount += 1;
                }

                // Check Auto Sizing and increase font size to fill text container.


                fontSizeDelta = this.m_maxFontSize - this.m_minFontSize;
                if (this.m_enableAutoSizing && fontSizeDelta > 0.051 && this.m_fontSize < this.m_fontSizeMax && this.m_AutoSizeIterationCount < this.m_AutoSizeMaxIterationCount) {
                    // Reset character width adjustment delta
                    if (this.m_charWidthAdjDelta < this.m_charWidthMaxAdj / 100) {
                        this.m_charWidthAdjDelta = 0;
                    }

                    this.m_minFontSize = this.m_fontSize;

                    var sizeDelta4 = UnityEngine.Mathf.Max((this.m_maxFontSize - this.m_fontSize) / 2, 0.05);
                    this.m_fontSize += sizeDelta4;
                    this.m_fontSize = UnityEngine.Mathf.Min((this.m_fontSize * 20 + 0.5) / 20.0, this.m_fontSizeMax);

                    //Debug.Log("[" + m_AutoSizeIterationCount + "] Increasing Point Size from [" + m_minFontSize.ToString("f3") + "] to [" + m_fontSize.ToString("f3") + "] with delta of [" + sizeDelta.ToString("f3") + "].");
                    return;
                }


                this.m_IsAutoSizePointSizeSet = true;

                if (this.m_AutoSizeIterationCount >= this.m_AutoSizeMaxIterationCount) {
                    UnityEngine.Debug.Log$1("Auto Size Iteration Count: " + this.m_AutoSizeIterationCount + ". Final Point Size: " + System.Single.format(this.m_fontSize));
                }

                // If there are no visible characters or only character is End of Text (0x03)... no need to continue
                if (this.m_characterCount === 0 || this.m_characterCount === 1 && charCode === 3) {
                    this.ClearMesh$1(true);

                    // Event indicating the text has been regenerated.
                    TMPro.TMPro_EventManager.ON_TEXT_CHANGED(this);
                    return;
                }

                // End Sampling of Phase I

                // *** PHASE II of Text Generation ***
                var last_vert_index = { v : TMPro.TMP_Text.m_materialReferences[this.m_Underline.materialIndex].referenceCount * 4 };

                // Partial clear of the vertices array to mark unused vertices as degenerate.
                ($t32 = this.m_textInfo.meshInfo)[0].Clear$1(false);

                // Handle Text Alignment


                var anchorOffset = pc.Vec3.ZERO.clone();
                var corners = this.m_RectTransformCorners; // GetTextContainerLocalCorners();

                // Handle Vertical Text Alignment
                switch (this.m_VerticalAlignment) {
                    case TMPro.VerticalAlignmentOptions.Top: 
                        if (this.m_overflowMode !== TMPro.TextOverflowModes.Page) {
                            anchorOffset = corners[1].$clone().add( new pc.Vec3( 0 + margins.x, 0 - this.m_maxTextAscender - margins.y, 0 ) );
                        } else {
                            anchorOffset = corners[1].$clone().add( new pc.Vec3( 0 + margins.x, 0 - ($t33 = this.m_textInfo.pageInfo)[pageToDisplay].ascender - margins.y, 0 ) );
                        }
                        break;
                    case TMPro.VerticalAlignmentOptions.Middle: 
                        if (this.m_overflowMode !== TMPro.TextOverflowModes.Page) {
                            anchorOffset = (corners[0].$clone().add( corners[1] )).scale( 1.0 / ( 2 ) ).add( new pc.Vec3( 0 + margins.x, 0 - (this.m_maxTextAscender + margins.y + maxVisibleDescender.v - margins.w) / 2, 0 ) );
                        } else {
                            anchorOffset = (corners[0].$clone().add( corners[1] )).scale( 1.0 / ( 2 ) ).add( new pc.Vec3( 0 + margins.x, 0 - (($t34 = this.m_textInfo.pageInfo)[pageToDisplay].ascender + margins.y + ($t35 = this.m_textInfo.pageInfo)[pageToDisplay].descender - margins.w) / 2, 0 ) );
                        }
                        break;
                    case TMPro.VerticalAlignmentOptions.Bottom: 
                        if (this.m_overflowMode !== TMPro.TextOverflowModes.Page) {
                            anchorOffset = corners[0].$clone().add( new pc.Vec3( 0 + margins.x, 0 - maxVisibleDescender.v + margins.w, 0 ) );
                        } else {
                            anchorOffset = corners[0].$clone().add( new pc.Vec3( 0 + margins.x, 0 - ($t36 = this.m_textInfo.pageInfo)[pageToDisplay].descender + margins.w, 0 ) );
                        }
                        break;
                    case TMPro.VerticalAlignmentOptions.Baseline: 
                        anchorOffset = (corners[0].$clone().add( corners[1] )).scale( 1.0 / ( 2 ) ).add( new pc.Vec3( 0 + margins.x, 0, 0 ) );
                        break;
                    case TMPro.VerticalAlignmentOptions.Geometry: 
                        anchorOffset = (corners[0].$clone().add( corners[1] )).scale( 1.0 / ( 2 ) ).add( new pc.Vec3( 0 + margins.x, 0 - (this.m_meshExtents.max.y + margins.y + this.m_meshExtents.min.y - margins.w) / 2, 0 ) );
                        break;
                    case TMPro.VerticalAlignmentOptions.Capline: 
                        anchorOffset = (corners[0].$clone().add( corners[1] )).scale( 1.0 / ( 2 ) ).add( new pc.Vec3( 0 + margins.x, 0 - (this.m_maxCapHeight - margins.y - margins.w) / 2, 0 ) );
                        break;
                }



                // Initialization for Second Pass
                var justificationOffset = pc.Vec3.ZERO.clone();
                var offset = pc.Vec3.ZERO.clone();
                var vert_index_X4 = 0;
                var sprite_index_X4 = 0;

                var wordCount = 0;
                var lineCount = 0;
                var lastLine = 0;
                var isFirstSeperator = false;

                var isStartOfWord = false;
                var wordFirstChar = 0;
                var wordLastChar = 0;

                // Second Pass : Line Justification, UV Mapping, Character & Line Visibility & more.
                var lossyScale = (this.m_previousLossyScaleY = this.transform$2.lossyScale.y);

                var underlineColor = UnityEngine.Color32.op_Implicit$1(new pc.Color( 1, 1, 1, 1 ));
                var strikethroughColor = UnityEngine.Color32.op_Implicit$1(new pc.Color( 1, 1, 1, 1 ));
                var highlightState = new TMPro.HighlightState.$ctor1(new UnityEngine.Color32.$ctor1(255, 255, 0, 64), TMPro.TMP_Offset.zero.$clone());
                var xScale = 0;
                var xScaleMax = 0;
                var underlineStartScale = 0;
                var underlineEndScale = 0;
                var underlineMaxScale = 0;
                var underlineBaseLine = TMPro.TMP_Text.k_LargePositiveFloat;
                var lastPage = 0;

                var strikethroughPointSize = 0;
                var strikethroughScale = 0;
                var strikethroughBaseline = 0;

                var characterInfos = this.m_textInfo.characterInfo;


                for (var i1 = 0; i1 < this.m_characterCount; i1++) {
                    var counter = i1;
                    characterInfo = characterInfos[ counter ];

                    var currentFontAsset = characterInfos[i1].fontAsset;

                    var unicode = characterInfos[i1].character;

                    var currentLine = characterInfos[i1].lineNumber;
                    lineInfo = this.m_textInfo.lineInfo[ currentLine ];
                    lineCount = currentLine + 1;

                    var lineAlignment = lineInfo.alignment;

                    // Process Line Justification


                    switch (lineAlignment) {
                        case TMPro.HorizontalAlignmentOptions.Left: 
                            if (!this.m_isRightToLeft) {
                                justificationOffset.set( 0 + lineInfo.marginLeft, 0, 0 );
                            } else {
                                justificationOffset.set( 0 - lineInfo.maxAdvance, 0, 0 );
                            }
                            break;
                        case TMPro.HorizontalAlignmentOptions.Center: 
                            justificationOffset.set( lineInfo.marginLeft + lineInfo.width / 2 - lineInfo.maxAdvance / 2, 0, 0 );
                            break;
                        case TMPro.HorizontalAlignmentOptions.Geometry: 
                            justificationOffset.set( lineInfo.marginLeft + lineInfo.width / 2 - (lineInfo.lineExtents.min.x + lineInfo.lineExtents.max.x) / 2, 0, 0 );
                            break;
                        case TMPro.HorizontalAlignmentOptions.Right: 
                            if (!this.m_isRightToLeft) {
                                justificationOffset.set( lineInfo.marginLeft + lineInfo.width - lineInfo.maxAdvance, 0, 0 );
                            } else {
                                justificationOffset.set( lineInfo.marginLeft + lineInfo.width, 0, 0 );
                            }
                            break;
                        case TMPro.HorizontalAlignmentOptions.Justified: 
                        case TMPro.HorizontalAlignmentOptions.Flush: 
                            // Skip Zero Width Characters
                            if (unicode === 10 || unicode === 173 || unicode === 8203 || unicode === 8288 || unicode === 3) {
                                break;
                            }
                            var lastCharOfCurrentLine = characterInfos[lineInfo.lastCharacterIndex].character;
                            var isFlush = (lineAlignment & TMPro.HorizontalAlignmentOptions.Flush) === TMPro.HorizontalAlignmentOptions.Flush;
                            // In Justified mode, all lines are justified except the last one.
                            // In Flush mode, all lines are justified.
                            if (System.Char.isControl(lastCharOfCurrentLine) === false && currentLine < this.m_lineNumber || isFlush || lineInfo.maxAdvance > lineInfo.width) {
                                // First character of each line.
                                if (currentLine !== lastLine || i1 === 0 || i1 === this.m_firstVisibleCharacter) {
                                    if (!this.m_isRightToLeft) {
                                        justificationOffset.set( lineInfo.marginLeft, 0, 0 );
                                    } else {
                                        justificationOffset.set( lineInfo.marginLeft + lineInfo.width, 0, 0 );
                                    }

                                    if (System.Char.isSeparator(unicode)) {
                                        isFirstSeperator = true;
                                    } else {
                                        isFirstSeperator = false;
                                    }
                                } else {
                                    var gap = !this.m_isRightToLeft ? lineInfo.width - lineInfo.maxAdvance : lineInfo.width + lineInfo.maxAdvance;

                                    var visibleCount = lineInfo.visibleCharacterCount - 1 + lineInfo.controlCharacterCount;

                                    // Get the number of spaces for each line ignoring the last character if it is not visible (ie. a space or linefeed).
                                    var spaces = (characterInfos[lineInfo.lastCharacterIndex].isVisible ? lineInfo.spaceCount : lineInfo.spaceCount - 1) - lineInfo.controlCharacterCount;

                                    if (isFirstSeperator) {
                                        spaces -= 1;
                                        visibleCount += 1;
                                    }

                                    var ratio = spaces > 0 ? this.m_wordWrappingRatios : 1;

                                    if (spaces < 1) {
                                        spaces = 1;
                                    }

                                    if (unicode !== 160 && (unicode === 9 || System.Char.isSeparator(unicode))) {
                                        if (!this.m_isRightToLeft) {
                                            justificationOffset.x += gap * (1 - ratio) / spaces;
                                        } else {
                                            justificationOffset.x -= gap * (1 - ratio) / spaces;
                                        }
                                    } else {
                                        if (!this.m_isRightToLeft) {
                                            justificationOffset.x += gap * ratio / visibleCount;
                                        } else {
                                            justificationOffset.x -= gap * ratio / visibleCount;
                                        }
                                    }
                                }
                            } else {
                                if (!this.m_isRightToLeft) {
                                    justificationOffset.set( lineInfo.marginLeft, 0, 0 ); // Keep last line left justified.
                                } else {
                                    justificationOffset.set( lineInfo.marginLeft + lineInfo.width, 0, 0 ); // Keep last line right justified.
                                }
                            }
                            //Debug.Log("Char [" + (char)charCode + "] Code:" + charCode + "  Line # " + currentLine + "  Offset:" + justificationOffset + "  # Spaces:" + lineInfo.spaceCount + "  # Characters:" + lineInfo.characterCount);
                            break;
                    }


                    offset.copy( anchorOffset ).add( justificationOffset );

                    // Handle UV2 mapping options and packing of scale information into UV2.


                    var isCharacterVisible = characterInfos[i1].isVisible;
                    if (isCharacterVisible) {
                        var elementType = characterInfos[i1].elementType;
                        switch (elementType) {
                            case TMPro.TMP_TextElementType.Character: 
                                var lineExtents = lineInfo.lineExtents.$clone();
                                var uvOffset = this.m_uvLineOffset * currentLine % 1; // + m_uvOffset.x;
                                // Setup UV2 based on Character Mapping Options Selected
                                switch (this.m_horizontalMapping) {
                                    case TMPro.TextureMappingOptions.Character: 
                                        characterInfos[i1].vertex_BL.uv2.x = 0; //+ m_uvOffset.x;
                                        characterInfos[i1].vertex_TL.uv2.x = 0; //+ m_uvOffset.x;
                                        characterInfos[i1].vertex_TR.uv2.x = 1; //+ m_uvOffset.x;
                                        characterInfos[i1].vertex_BR.uv2.x = 1; //+ m_uvOffset.x;
                                        break;
                                    case TMPro.TextureMappingOptions.Line: 
                                        if (this.m_textAlignment !== TMPro.TextAlignmentOptions.Justified) {
                                            characterInfos[i1].vertex_BL.uv2.x = (characterInfos[i1].vertex_BL.position.x - lineExtents.min.x) / (lineExtents.max.x - lineExtents.min.x) + uvOffset;
                                            characterInfos[i1].vertex_TL.uv2.x = (characterInfos[i1].vertex_TL.position.x - lineExtents.min.x) / (lineExtents.max.x - lineExtents.min.x) + uvOffset;
                                            characterInfos[i1].vertex_TR.uv2.x = (characterInfos[i1].vertex_TR.position.x - lineExtents.min.x) / (lineExtents.max.x - lineExtents.min.x) + uvOffset;
                                            characterInfos[i1].vertex_BR.uv2.x = (characterInfos[i1].vertex_BR.position.x - lineExtents.min.x) / (lineExtents.max.x - lineExtents.min.x) + uvOffset;
                                            break;
                                        } else {
                                            characterInfos[i1].vertex_BL.uv2.x = (characterInfos[i1].vertex_BL.position.x + justificationOffset.x - this.m_meshExtents.min.x) / (this.m_meshExtents.max.x - this.m_meshExtents.min.x) + uvOffset;
                                            characterInfos[i1].vertex_TL.uv2.x = (characterInfos[i1].vertex_TL.position.x + justificationOffset.x - this.m_meshExtents.min.x) / (this.m_meshExtents.max.x - this.m_meshExtents.min.x) + uvOffset;
                                            characterInfos[i1].vertex_TR.uv2.x = (characterInfos[i1].vertex_TR.position.x + justificationOffset.x - this.m_meshExtents.min.x) / (this.m_meshExtents.max.x - this.m_meshExtents.min.x) + uvOffset;
                                            characterInfos[i1].vertex_BR.uv2.x = (characterInfos[i1].vertex_BR.position.x + justificationOffset.x - this.m_meshExtents.min.x) / (this.m_meshExtents.max.x - this.m_meshExtents.min.x) + uvOffset;
                                            break;
                                        }
                                    case TMPro.TextureMappingOptions.Paragraph: 
                                        characterInfos[i1].vertex_BL.uv2.x = (characterInfos[i1].vertex_BL.position.x + justificationOffset.x - this.m_meshExtents.min.x) / (this.m_meshExtents.max.x - this.m_meshExtents.min.x) + uvOffset;
                                        characterInfos[i1].vertex_TL.uv2.x = (characterInfos[i1].vertex_TL.position.x + justificationOffset.x - this.m_meshExtents.min.x) / (this.m_meshExtents.max.x - this.m_meshExtents.min.x) + uvOffset;
                                        characterInfos[i1].vertex_TR.uv2.x = (characterInfos[i1].vertex_TR.position.x + justificationOffset.x - this.m_meshExtents.min.x) / (this.m_meshExtents.max.x - this.m_meshExtents.min.x) + uvOffset;
                                        characterInfos[i1].vertex_BR.uv2.x = (characterInfos[i1].vertex_BR.position.x + justificationOffset.x - this.m_meshExtents.min.x) / (this.m_meshExtents.max.x - this.m_meshExtents.min.x) + uvOffset;
                                        break;
                                    case TMPro.TextureMappingOptions.MatchAspect: 
                                        switch (this.m_verticalMapping) {
                                            case TMPro.TextureMappingOptions.Character: 
                                                characterInfos[i1].vertex_BL.uv2.y = 0; // + m_uvOffset.y;
                                                characterInfos[i1].vertex_TL.uv2.y = 1; // + m_uvOffset.y;
                                                characterInfos[i1].vertex_TR.uv2.y = 0; // + m_uvOffset.y;
                                                characterInfos[i1].vertex_BR.uv2.y = 1; // + m_uvOffset.y;
                                                break;
                                            case TMPro.TextureMappingOptions.Line: 
                                                characterInfos[i1].vertex_BL.uv2.y = (characterInfos[i1].vertex_BL.position.y - lineExtents.min.y) / (lineExtents.max.y - lineExtents.min.y) + uvOffset;
                                                characterInfos[i1].vertex_TL.uv2.y = (characterInfos[i1].vertex_TL.position.y - lineExtents.min.y) / (lineExtents.max.y - lineExtents.min.y) + uvOffset;
                                                characterInfos[i1].vertex_TR.uv2.y = characterInfos[i1].vertex_BL.uv2.y;
                                                characterInfos[i1].vertex_BR.uv2.y = characterInfos[i1].vertex_TL.uv2.y;
                                                break;
                                            case TMPro.TextureMappingOptions.Paragraph: 
                                                characterInfos[i1].vertex_BL.uv2.y = (characterInfos[i1].vertex_BL.position.y - this.m_meshExtents.min.y) / (this.m_meshExtents.max.y - this.m_meshExtents.min.y) + uvOffset;
                                                characterInfos[i1].vertex_TL.uv2.y = (characterInfos[i1].vertex_TL.position.y - this.m_meshExtents.min.y) / (this.m_meshExtents.max.y - this.m_meshExtents.min.y) + uvOffset;
                                                characterInfos[i1].vertex_TR.uv2.y = characterInfos[i1].vertex_BL.uv2.y;
                                                characterInfos[i1].vertex_BR.uv2.y = characterInfos[i1].vertex_TL.uv2.y;
                                                break;
                                            case TMPro.TextureMappingOptions.MatchAspect: 
                                                UnityEngine.Debug.Log$1("ERROR: Cannot Match both Vertical & Horizontal.");
                                                break;
                                        }
                                        //float xDelta = 1 - (_uv2s[vert_index + 0].y * textMeshCharacterInfo[i].AspectRatio); // Left aligned
                                        var xDelta = (1 - (characterInfos[i1].vertex_BL.uv2.y + characterInfos[i1].vertex_TL.uv2.y) * characterInfos[i1].aspectRatio) / 2; // Center of Rectangle
                                        characterInfos[i1].vertex_BL.uv2.x = characterInfos[i1].vertex_BL.uv2.y * characterInfos[i1].aspectRatio + xDelta + uvOffset;
                                        characterInfos[i1].vertex_TL.uv2.x = characterInfos[i1].vertex_BL.uv2.x;
                                        characterInfos[i1].vertex_TR.uv2.x = characterInfos[i1].vertex_TL.uv2.y * characterInfos[i1].aspectRatio + xDelta + uvOffset;
                                        characterInfos[i1].vertex_BR.uv2.x = characterInfos[i1].vertex_TR.uv2.x;
                                        break;
                                }
                                switch (this.m_verticalMapping) {
                                    case TMPro.TextureMappingOptions.Character: 
                                        characterInfos[i1].vertex_BL.uv2.y = 0; // + m_uvOffset.y;
                                        characterInfos[i1].vertex_TL.uv2.y = 1; // + m_uvOffset.y;
                                        characterInfos[i1].vertex_TR.uv2.y = 1; // + m_uvOffset.y;
                                        characterInfos[i1].vertex_BR.uv2.y = 0; // + m_uvOffset.y;
                                        break;
                                    case TMPro.TextureMappingOptions.Line: 
                                        characterInfos[i1].vertex_BL.uv2.y = (characterInfos[i1].vertex_BL.position.y - lineInfo.descender) / (lineInfo.ascender - lineInfo.descender); // + m_uvOffset.y;
                                        characterInfos[i1].vertex_TL.uv2.y = (characterInfos[i1].vertex_TL.position.y - lineInfo.descender) / (lineInfo.ascender - lineInfo.descender); // + m_uvOffset.y;
                                        characterInfos[i1].vertex_TR.uv2.y = characterInfos[i1].vertex_TL.uv2.y;
                                        characterInfos[i1].vertex_BR.uv2.y = characterInfos[i1].vertex_BL.uv2.y;
                                        break;
                                    case TMPro.TextureMappingOptions.Paragraph: 
                                        characterInfos[i1].vertex_BL.uv2.y = (characterInfos[i1].vertex_BL.position.y - this.m_meshExtents.min.y) / (this.m_meshExtents.max.y - this.m_meshExtents.min.y); // + m_uvOffset.y;
                                        characterInfos[i1].vertex_TL.uv2.y = (characterInfos[i1].vertex_TL.position.y - this.m_meshExtents.min.y) / (this.m_meshExtents.max.y - this.m_meshExtents.min.y); // + m_uvOffset.y;
                                        characterInfos[i1].vertex_TR.uv2.y = characterInfos[i1].vertex_TL.uv2.y;
                                        characterInfos[i1].vertex_BR.uv2.y = characterInfos[i1].vertex_BL.uv2.y;
                                        break;
                                    case TMPro.TextureMappingOptions.MatchAspect: 
                                        var yDelta = (1 - (characterInfos[i1].vertex_BL.uv2.x + characterInfos[i1].vertex_TR.uv2.x) / characterInfos[i1].aspectRatio) / 2; // Center of Rectangle
                                        characterInfos[i1].vertex_BL.uv2.y = yDelta + characterInfos[i1].vertex_BL.uv2.x / characterInfos[i1].aspectRatio; // + m_uvOffset.y;
                                        characterInfos[i1].vertex_TL.uv2.y = yDelta + characterInfos[i1].vertex_TR.uv2.x / characterInfos[i1].aspectRatio; // + m_uvOffset.y;
                                        characterInfos[i1].vertex_BR.uv2.y = characterInfos[i1].vertex_BL.uv2.y;
                                        characterInfos[i1].vertex_TR.uv2.y = characterInfos[i1].vertex_TL.uv2.y;
                                        break;
                                }
                                // Pack UV's so that we can pass Xscale needed for Shader to maintain 1:1 ratio.
                                xScale = characterInfos[i1].scale * Math.abs(lossyScale) * (1 - this.m_charWidthAdjDelta);
                                if (!characterInfos[i1].isUsingAlternateTypeface && (characterInfos[i1].style & TMPro.FontStyles.Bold) === TMPro.FontStyles.Bold) {
                                    xScale *= -1;
                                }
                                //int isBold = (m_textInfo.characterInfo[i].style & FontStyles.Bold) == FontStyles.Bold ? 1 : 0;
                                //Vector2 vertexData = new Vector2(isBold, xScale);
                                //characterInfos[i].vertex_BL.uv4 = vertexData;
                                //characterInfos[i].vertex_TL.uv4 = vertexData;
                                //characterInfos[i].vertex_TR.uv4 = vertexData;
                                //characterInfos[i].vertex_BR.uv4 = vertexData;
                                var x0 = characterInfos[i1].vertex_BL.uv2.x;
                                var y0 = characterInfos[i1].vertex_BL.uv2.y;
                                var x1 = characterInfos[i1].vertex_TR.uv2.x;
                                var y1 = characterInfos[i1].vertex_TR.uv2.y;
                                var dx = x0;
                                var dy = y0;
                                x0 = x0 - dx;
                                x1 = x1 - dx;
                                y0 = y0 - dy;
                                y1 = y1 - dy;
                                // Optimization to avoid having a vector2 returned from the Pack UV function.
                                characterInfos[i1].vertex_BL.uv2.x = this.PackUV(x0, y0);
                                characterInfos[i1].vertex_BL.uv2.y = xScale;
                                characterInfos[i1].vertex_TL.uv2.x = this.PackUV(x0, y1);
                                characterInfos[i1].vertex_TL.uv2.y = xScale;
                                characterInfos[i1].vertex_TR.uv2.x = this.PackUV(x1, y1);
                                characterInfos[i1].vertex_TR.uv2.y = xScale;
                                characterInfos[i1].vertex_BR.uv2.x = this.PackUV(x1, y0);
                                characterInfos[i1].vertex_BR.uv2.y = xScale;
                                break;
                            case TMPro.TMP_TextElementType.Sprite: 
                                // Nothing right now
                                break;
                        }

                        // Handle maxVisibleCharacters, maxVisibleLines and Overflow Page Mode.


                        if (i1 < this.m_maxVisibleCharacters && wordCount < this.m_maxVisibleWords && currentLine < this.m_maxVisibleLines && this.m_overflowMode !== TMPro.TextOverflowModes.Page) {
                            characterInfo.vertex_BL.position.add( offset );
                            characterInfo.vertex_TL.position.add( offset );
                            characterInfo.vertex_TR.position.add( offset );
                            characterInfo.vertex_BR.position.add( offset );
                        } else if (i1 < this.m_maxVisibleCharacters && wordCount < this.m_maxVisibleWords && currentLine < this.m_maxVisibleLines && this.m_overflowMode === TMPro.TextOverflowModes.Page && characterInfo.pageNumber === pageToDisplay) {
                            characterInfo.vertex_BL.position.add( offset );
                            characterInfo.vertex_TL.position.add( offset );
                            characterInfo.vertex_TR.position.add( offset );
                            characterInfo.vertex_BR.position.add( offset );
                        } else {
                            characterInfo.vertex_BL.position.set( 0, 0, 0 );
                            characterInfo.vertex_TL.position.set( 0, 0, 0 );
                            characterInfo.vertex_TR.position.set( 0, 0, 0 );
                            characterInfo.vertex_BR.position.set( 0, 0, 0 );
                            characterInfo.isVisible = false;
                        }



                        // Fill Vertex Buffers for the various types of element
                        if (elementType === TMPro.TMP_TextElementType.Character) {
                            this.FillCharacterVertexBuffers(i1, vert_index_X4);
                        } else if (elementType === TMPro.TMP_TextElementType.Sprite) {
                            this.FillSpriteVertexBuffers(i1, sprite_index_X4);
                        }
                    }


                    // Apply Alignment and Justification Offset
                    characterInfo.bottomLeft.add( offset );
                    characterInfo.topLeft.add( offset );
                    characterInfo.topRight.add( offset );
                    characterInfo.bottomRight.add( offset );

                    characterInfo.origin += offset.x;
                    characterInfo.xAdvance += offset.x;

                    characterInfo.ascender += offset.y;
                    characterInfo.descender += offset.y;
                    characterInfo.baseLine += offset.y;

                    // Update MeshExtents
                    if (isCharacterVisible) {
                        //m_meshExtents.min = new Vector2(Mathf.Min(m_meshExtents.min.x, m_textInfo.characterInfo[i].bottomLeft.x), Mathf.Min(m_meshExtents.min.y, m_textInfo.characterInfo[i].bottomLeft.y));
                        //m_meshExtents.max = new Vector2(Mathf.Max(m_meshExtents.max.x, m_textInfo.characterInfo[i].topRight.x), Mathf.Max(m_meshExtents.max.y, m_textInfo.characterInfo[i].topLeft.y));
                    }

                    // Need to recompute lineExtent to account for the offset from justification.


                    if (currentLine !== lastLine || i1 === this.m_characterCount - 1) {
                        // Update the previous line's extents
                        if (currentLine !== lastLine) {
                            ($t37 = this.m_textInfo.lineInfo)[lastLine].baseline += offset.y;
                            ($t38 = this.m_textInfo.lineInfo)[lastLine].ascender += offset.y;
                            ($t39 = this.m_textInfo.lineInfo)[lastLine].descender += offset.y;

                            ($t40 = this.m_textInfo.lineInfo)[lastLine].maxAdvance += offset.x;

                            ($t41 = this.m_textInfo.lineInfo)[lastLine].lineExtents.min.set( ($t42 = this.m_textInfo.characterInfo)[($t43 = this.m_textInfo.lineInfo)[lastLine].firstCharacterIndex].bottomLeft.x, ($t44 = this.m_textInfo.lineInfo)[lastLine].descender );
                            ($t45 = this.m_textInfo.lineInfo)[lastLine].lineExtents.max.set( ($t46 = this.m_textInfo.characterInfo)[($t47 = this.m_textInfo.lineInfo)[lastLine].lastVisibleCharacterIndex].topRight.x, ($t48 = this.m_textInfo.lineInfo)[lastLine].ascender );
                        }

                        // Update the current line's extents
                        if (i1 === this.m_characterCount - 1) {
                            ($t49 = this.m_textInfo.lineInfo)[currentLine].baseline += offset.y;
                            ($t50 = this.m_textInfo.lineInfo)[currentLine].ascender += offset.y;
                            ($t51 = this.m_textInfo.lineInfo)[currentLine].descender += offset.y;

                            ($t52 = this.m_textInfo.lineInfo)[currentLine].maxAdvance += offset.x;

                            ($t53 = this.m_textInfo.lineInfo)[currentLine].lineExtents.min.set( ($t54 = this.m_textInfo.characterInfo)[($t55 = this.m_textInfo.lineInfo)[currentLine].firstCharacterIndex].bottomLeft.x, ($t56 = this.m_textInfo.lineInfo)[currentLine].descender );
                            ($t57 = this.m_textInfo.lineInfo)[currentLine].lineExtents.max.set( ($t58 = this.m_textInfo.characterInfo)[($t59 = this.m_textInfo.lineInfo)[currentLine].lastVisibleCharacterIndex].topRight.x, ($t60 = this.m_textInfo.lineInfo)[currentLine].ascender );
                        }
                    }



                    // Track Word Count per line and for the object


                    if ((System.Char.isDigit(unicode) || System.Char.isLetter(unicode)) || unicode === 45 || unicode === 173 || unicode === 8208 || unicode === 8209) {
                        if (isStartOfWord === false) {
                            isStartOfWord = true;
                            wordFirstChar = i1;
                        }

                        // If last character is a word
                        if (isStartOfWord && i1 === this.m_characterCount - 1) {
                            var size = this.m_textInfo.wordInfo.length;
                            var index = this.m_textInfo.wordCount;

                            if (this.m_textInfo.wordCount + 1 > size) {
                                TMPro.TMP_TextInfo.Resize(TMPro.TMP_WordInfo, Bridge.ref(this.m_textInfo, "wordInfo"), size + 1);
                            }

                            wordLastChar = i1;

                            ($t61 = this.m_textInfo.wordInfo)[index].firstCharacterIndex = wordFirstChar;
                            ($t62 = this.m_textInfo.wordInfo)[index].lastCharacterIndex = wordLastChar;
                            ($t63 = this.m_textInfo.wordInfo)[index].characterCount = wordLastChar - wordFirstChar + 1;
                            ($t64 = this.m_textInfo.wordInfo)[index].textComponent = this;

                            wordCount += 1;
                            this.m_textInfo.wordCount += 1;
                            ($t65 = this.m_textInfo.lineInfo)[currentLine].wordCount += 1;
                        }
                    } else if (isStartOfWord || i1 === 0 && (!System.Char.isPunctuation(unicode) || System.Char.isWhiteSpace(String.fromCharCode(unicode)) || unicode === 8203 || i1 === this.m_characterCount - 1)) {
                        if (i1 > 0 && i1 < characterInfos.length - 1 && i1 < this.m_characterCount && (unicode === 39 || unicode === 8217) && ($t66 = characterInfos[i1 - 1].character, (System.Char.isDigit($t66) || System.Char.isLetter($t66))) && ($t67 = characterInfos[i1 + 1].character, (System.Char.isDigit($t67) || System.Char.isLetter($t67)))) {
                        } else {
                            wordLastChar = i1 === this.m_characterCount - 1 && (System.Char.isDigit(unicode) || System.Char.isLetter(unicode)) ? i1 : i1 - 1;
                            isStartOfWord = false;

                            var size1 = this.m_textInfo.wordInfo.length;
                            var index1 = this.m_textInfo.wordCount;

                            if (this.m_textInfo.wordCount + 1 > size1) {
                                TMPro.TMP_TextInfo.Resize(TMPro.TMP_WordInfo, Bridge.ref(this.m_textInfo, "wordInfo"), size1 + 1);
                            }

                            ($t68 = this.m_textInfo.wordInfo)[index1].firstCharacterIndex = wordFirstChar;
                            ($t69 = this.m_textInfo.wordInfo)[index1].lastCharacterIndex = wordLastChar;
                            ($t70 = this.m_textInfo.wordInfo)[index1].characterCount = wordLastChar - wordFirstChar + 1;
                            ($t71 = this.m_textInfo.wordInfo)[index1].textComponent = this;

                            wordCount += 1;
                            this.m_textInfo.wordCount += 1;
                            ($t72 = this.m_textInfo.lineInfo)[currentLine].wordCount += 1;
                        }
                    }



                    // Setup & Handle Underline


                    // NOTE: Need to figure out how underline will be handled with multiple fonts and which font will be used for the underline.
                    var isUnderline = (($t73 = this.m_textInfo.characterInfo)[i1].style & TMPro.FontStyles.Underline) === TMPro.FontStyles.Underline;
                    if (isUnderline) {
                        var isUnderlineVisible = true;
                        var currentPage = ($t74 = this.m_textInfo.characterInfo)[i1].pageNumber;
                        ($t75 = this.m_textInfo.characterInfo)[i1].underlineVertexIndex = last_vert_index.v;

                        if (i1 > this.m_maxVisibleCharacters || currentLine > this.m_maxVisibleLines || this.m_overflowMode === TMPro.TextOverflowModes.Page && currentPage + 1 !== this.m_pageToDisplay) {
                            isUnderlineVisible = false;
                        }

                        // We only use the scale of visible characters.
                        if (!System.Char.isWhiteSpace(String.fromCharCode(unicode)) && unicode !== 8203) {
                            underlineMaxScale = UnityEngine.Mathf.Max(underlineMaxScale, ($t76 = this.m_textInfo.characterInfo)[i1].scale);
                            xScaleMax = UnityEngine.Mathf.Max(xScaleMax, Math.abs(xScale));
                            underlineBaseLine = UnityEngine.Mathf.Min(currentPage === lastPage ? underlineBaseLine : TMPro.TMP_Text.k_LargePositiveFloat, ($t77 = this.m_textInfo.characterInfo)[i1].baseLine + this.font.m_FaceInfo.underlineOffset * underlineMaxScale);
                            lastPage = currentPage; // Need to track pages to ensure we reset baseline for the new pages.
                        }

                        if (beginUnderline === false && isUnderlineVisible === true && i1 <= lineInfo.lastVisibleCharacterIndex && unicode !== 10 && unicode !== 11 && unicode !== 13) {
                            if (i1 === lineInfo.lastVisibleCharacterIndex && System.Char.isSeparator(unicode)) {
                            } else {
                                beginUnderline = true;
                                underlineStartScale = ($t78 = this.m_textInfo.characterInfo)[i1].scale;
                                if (underlineMaxScale === 0) {
                                    underlineMaxScale = underlineStartScale;
                                    xScaleMax = xScale;
                                }

                                underline_start = new pc.Vec3( ($t79 = this.m_textInfo.characterInfo)[i1].bottomLeft.x, underlineBaseLine, 0 );
                                underlineColor = ($t80 = this.m_textInfo.characterInfo)[i1].underlineColor.$clone();
                            }
                        }

                        // End Underline if text only contains one character.
                        if (beginUnderline && this.m_characterCount === 1) {
                            beginUnderline = false;
                            underline_end = new pc.Vec3( ($t81 = this.m_textInfo.characterInfo)[i1].topRight.x, underlineBaseLine, 0 );
                            underlineEndScale = ($t82 = this.m_textInfo.characterInfo)[i1].scale;

                            this.DrawUnderlineMesh(underline_start.$clone(), underline_end.$clone(), last_vert_index, underlineStartScale, underlineEndScale, underlineMaxScale, xScaleMax, underlineColor.$clone());
                            underlineMaxScale = 0;
                            xScaleMax = 0;
                            underlineBaseLine = TMPro.TMP_Text.k_LargePositiveFloat;
                        } else if (beginUnderline && (i1 === lineInfo.lastCharacterIndex || i1 >= lineInfo.lastVisibleCharacterIndex)) {
                            // Terminate underline at previous visible character if space or carriage return.
                            if (System.Char.isWhiteSpace(String.fromCharCode(unicode)) || unicode === 8203) {
                                var lastVisibleCharacterIndex = lineInfo.lastVisibleCharacterIndex;
                                underline_end = new pc.Vec3( ($t83 = this.m_textInfo.characterInfo)[lastVisibleCharacterIndex].topRight.x, underlineBaseLine, 0 );
                                underlineEndScale = ($t84 = this.m_textInfo.characterInfo)[lastVisibleCharacterIndex].scale;
                            } else {
                                // End underline if last character of the line.
                                underline_end = new pc.Vec3( ($t85 = this.m_textInfo.characterInfo)[i1].topRight.x, underlineBaseLine, 0 );
                                underlineEndScale = ($t86 = this.m_textInfo.characterInfo)[i1].scale;
                            }

                            beginUnderline = false;
                            this.DrawUnderlineMesh(underline_start.$clone(), underline_end.$clone(), last_vert_index, underlineStartScale, underlineEndScale, underlineMaxScale, xScaleMax, underlineColor.$clone());
                            underlineMaxScale = 0;
                            xScaleMax = 0;
                            underlineBaseLine = TMPro.TMP_Text.k_LargePositiveFloat;
                        } else if (beginUnderline && !isUnderlineVisible) {
                            beginUnderline = false;
                            underline_end = new pc.Vec3( ($t87 = this.m_textInfo.characterInfo)[i1 - 1].topRight.x, underlineBaseLine, 0 );
                            underlineEndScale = ($t88 = this.m_textInfo.characterInfo)[i1 - 1].scale;

                            this.DrawUnderlineMesh(underline_start.$clone(), underline_end.$clone(), last_vert_index, underlineStartScale, underlineEndScale, underlineMaxScale, xScaleMax, underlineColor.$clone());
                            underlineMaxScale = 0;
                            xScaleMax = 0;
                            underlineBaseLine = TMPro.TMP_Text.k_LargePositiveFloat;
                        } else if (beginUnderline && i1 < this.m_characterCount - 1 && !TMPro.TMPro_ExtensionMethods.Compare$1(underlineColor, ($t89 = this.m_textInfo.characterInfo)[i1 + 1].underlineColor.$clone())) {
                            // End underline if underline color has changed.
                            beginUnderline = false;
                            underline_end = new pc.Vec3( ($t90 = this.m_textInfo.characterInfo)[i1].topRight.x, underlineBaseLine, 0 );
                            underlineEndScale = ($t91 = this.m_textInfo.characterInfo)[i1].scale;

                            this.DrawUnderlineMesh(underline_start.$clone(), underline_end.$clone(), last_vert_index, underlineStartScale, underlineEndScale, underlineMaxScale, xScaleMax, underlineColor.$clone());
                            underlineMaxScale = 0;
                            xScaleMax = 0;
                            underlineBaseLine = TMPro.TMP_Text.k_LargePositiveFloat;
                        }
                    } else {
                        // End Underline
                        if (beginUnderline === true) {
                            beginUnderline = false;
                            underline_end = new pc.Vec3( ($t92 = this.m_textInfo.characterInfo)[i1 - 1].topRight.x, underlineBaseLine, 0 );
                            underlineEndScale = ($t93 = this.m_textInfo.characterInfo)[i1 - 1].scale;

                            this.DrawUnderlineMesh(underline_start.$clone(), underline_end.$clone(), last_vert_index, underlineStartScale, underlineEndScale, underlineMaxScale, xScaleMax, underlineColor.$clone());
                            underlineMaxScale = 0;
                            xScaleMax = 0;
                            underlineBaseLine = TMPro.TMP_Text.k_LargePositiveFloat;
                        }
                    }



                    // Setup & Handle Strikethrough


                    // NOTE: Need to figure out how underline will be handled with multiple fonts and which font will be used for the underline.
                    var isStrikethrough = (($t94 = this.m_textInfo.characterInfo)[i1].style & TMPro.FontStyles.Strikethrough) === TMPro.FontStyles.Strikethrough;
                    var strikethroughOffset = currentFontAsset.m_FaceInfo.strikethroughOffset;

                    if (isStrikethrough) {
                        var isStrikeThroughVisible = true;
                        ($t95 = this.m_textInfo.characterInfo)[i1].strikethroughVertexIndex = last_vert_index.v;

                        if (i1 > this.m_maxVisibleCharacters || currentLine > this.m_maxVisibleLines || this.m_overflowMode === TMPro.TextOverflowModes.Page && ($t96 = this.m_textInfo.characterInfo)[i1].pageNumber + 1 !== this.m_pageToDisplay) {
                            isStrikeThroughVisible = false;
                        }

                        if (beginStrikethrough === false && isStrikeThroughVisible && i1 <= lineInfo.lastVisibleCharacterIndex && unicode !== 10 && unicode !== 11 && unicode !== 13) {
                            if (i1 === lineInfo.lastVisibleCharacterIndex && System.Char.isSeparator(unicode)) {
                            } else {
                                beginStrikethrough = true;
                                strikethroughPointSize = ($t97 = this.m_textInfo.characterInfo)[i1].pointSize;
                                strikethroughScale = ($t98 = this.m_textInfo.characterInfo)[i1].scale;
                                strikethrough_start = new pc.Vec3( ($t99 = this.m_textInfo.characterInfo)[i1].bottomLeft.x, ($t100 = this.m_textInfo.characterInfo)[i1].baseLine + strikethroughOffset * strikethroughScale, 0 );
                                strikethroughColor = ($t101 = this.m_textInfo.characterInfo)[i1].strikethroughColor.$clone();
                                strikethroughBaseline = ($t102 = this.m_textInfo.characterInfo)[i1].baseLine;
                                //Debug.Log("Char [" + currentCharacter + "] Start Strikethrough POS: " + strikethrough_start);
                            }
                        }

                        // End Strikethrough if text only contains one character.
                        if (beginStrikethrough && this.m_characterCount === 1) {
                            beginStrikethrough = false;
                            strikethrough_end = new pc.Vec3( ($t103 = this.m_textInfo.characterInfo)[i1].topRight.x, ($t104 = this.m_textInfo.characterInfo)[i1].baseLine + strikethroughOffset * strikethroughScale, 0 );

                            this.DrawUnderlineMesh(strikethrough_start.$clone(), strikethrough_end.$clone(), last_vert_index, strikethroughScale, strikethroughScale, strikethroughScale, xScale, strikethroughColor.$clone());
                        } else if (beginStrikethrough && i1 === lineInfo.lastCharacterIndex) {
                            // Terminate Strikethrough at previous visible character if space or carriage return.
                            if (System.Char.isWhiteSpace(String.fromCharCode(unicode)) || unicode === 8203) {
                                var lastVisibleCharacterIndex1 = lineInfo.lastVisibleCharacterIndex;
                                strikethrough_end = new pc.Vec3( ($t105 = this.m_textInfo.characterInfo)[lastVisibleCharacterIndex1].topRight.x, ($t106 = this.m_textInfo.characterInfo)[lastVisibleCharacterIndex1].baseLine + strikethroughOffset * strikethroughScale, 0 );
                            } else {
                                // Terminate Strikethrough at last character of line.
                                strikethrough_end = new pc.Vec3( ($t107 = this.m_textInfo.characterInfo)[i1].topRight.x, ($t108 = this.m_textInfo.characterInfo)[i1].baseLine + strikethroughOffset * strikethroughScale, 0 );
                            }

                            beginStrikethrough = false;
                            this.DrawUnderlineMesh(strikethrough_start.$clone(), strikethrough_end.$clone(), last_vert_index, strikethroughScale, strikethroughScale, strikethroughScale, xScale, strikethroughColor.$clone());
                        } else if (beginStrikethrough && i1 < this.m_characterCount && (($t109 = this.m_textInfo.characterInfo)[i1 + 1].pointSize !== strikethroughPointSize || !TMPro.TMP_Math.Approximately(($t110 = this.m_textInfo.characterInfo)[i1 + 1].baseLine + offset.y, strikethroughBaseline))) {
                            // Terminate Strikethrough if scale changes.
                            beginStrikethrough = false;

                            var lastVisibleCharacterIndex2 = lineInfo.lastVisibleCharacterIndex;
                            if (i1 > lastVisibleCharacterIndex2) {
                                strikethrough_end = new pc.Vec3( ($t111 = this.m_textInfo.characterInfo)[lastVisibleCharacterIndex2].topRight.x, ($t112 = this.m_textInfo.characterInfo)[lastVisibleCharacterIndex2].baseLine + strikethroughOffset * strikethroughScale, 0 );
                            } else {
                                strikethrough_end = new pc.Vec3( ($t113 = this.m_textInfo.characterInfo)[i1].topRight.x, ($t114 = this.m_textInfo.characterInfo)[i1].baseLine + strikethroughOffset * strikethroughScale, 0 );
                            }

                            this.DrawUnderlineMesh(strikethrough_start.$clone(), strikethrough_end.$clone(), last_vert_index, strikethroughScale, strikethroughScale, strikethroughScale, xScale, strikethroughColor.$clone());
                            //Debug.Log("Char [" + currentCharacter + "] at Index: " + i + "  End Strikethrough POS: " + strikethrough_end + "  Baseline: " + m_textInfo.characterInfo[i].baseLine.ToString("f3"));
                        } else if (beginStrikethrough && i1 < this.m_characterCount && currentFontAsset.GetInstanceID() !== characterInfos[i1 + 1].fontAsset.GetInstanceID()) {
                            // Terminate Strikethrough if font asset changes.
                            beginStrikethrough = false;
                            strikethrough_end = new pc.Vec3( ($t115 = this.m_textInfo.characterInfo)[i1].topRight.x, ($t116 = this.m_textInfo.characterInfo)[i1].baseLine + strikethroughOffset * strikethroughScale, 0 );

                            this.DrawUnderlineMesh(strikethrough_start.$clone(), strikethrough_end.$clone(), last_vert_index, strikethroughScale, strikethroughScale, strikethroughScale, xScale, strikethroughColor.$clone());
                        } else if (beginStrikethrough && !isStrikeThroughVisible) {
                            // Terminate Strikethrough if character is not visible.
                            beginStrikethrough = false;
                            strikethrough_end = new pc.Vec3( ($t117 = this.m_textInfo.characterInfo)[i1 - 1].topRight.x, ($t118 = this.m_textInfo.characterInfo)[i1 - 1].baseLine + strikethroughOffset * strikethroughScale, 0 );

                            this.DrawUnderlineMesh(strikethrough_start.$clone(), strikethrough_end.$clone(), last_vert_index, strikethroughScale, strikethroughScale, strikethroughScale, xScale, strikethroughColor.$clone());
                        }
                    } else {
                        // End Strikethrough
                        if (beginStrikethrough === true) {
                            beginStrikethrough = false;
                            strikethrough_end = new pc.Vec3( ($t119 = this.m_textInfo.characterInfo)[i1 - 1].topRight.x, ($t120 = this.m_textInfo.characterInfo)[i1 - 1].baseLine + strikethroughOffset * strikethroughScale, 0 );

                            this.DrawUnderlineMesh(strikethrough_start.$clone(), strikethrough_end.$clone(), last_vert_index, strikethroughScale, strikethroughScale, strikethroughScale, xScale, strikethroughColor.$clone());
                        }
                    }



                    // HANDLE TEXT HIGHLIGHTING


                    var isHighlight = (($t121 = this.m_textInfo.characterInfo)[i1].style & TMPro.FontStyles.Highlight) === TMPro.FontStyles.Highlight;
                    if (isHighlight) {
                        var isHighlightVisible = true;
                        var currentPage1 = ($t122 = this.m_textInfo.characterInfo)[i1].pageNumber;

                        if (i1 > this.m_maxVisibleCharacters || currentLine > this.m_maxVisibleLines || this.m_overflowMode === TMPro.TextOverflowModes.Page && currentPage1 + 1 !== this.m_pageToDisplay) {
                            isHighlightVisible = false;
                        }

                        if (beginHighlight === false && isHighlightVisible === true && i1 <= lineInfo.lastVisibleCharacterIndex && unicode !== 10 && unicode !== 11 && unicode !== 13) {
                            if (i1 === lineInfo.lastVisibleCharacterIndex && System.Char.isSeparator(unicode)) {
                            } else {
                                beginHighlight = true;
                                highlight_start = UnityEngine.Vector3.FromVector2(TMPro.TMP_Text.k_LargePositiveVector2.$clone());
                                highlight_end = UnityEngine.Vector3.FromVector2(TMPro.TMP_Text.k_LargeNegativeVector2.$clone());
                                highlightState = ($t123 = this.m_textInfo.characterInfo)[i1].highlightState.$clone();
                            }
                        }

                        if (beginHighlight) {
                            var currentCharacter = ($t124 = this.m_textInfo.characterInfo)[i1].$clone();
                            var currentState = currentCharacter.highlightState.$clone();

                            var isColorTransition = false;

                            // Handle Highlight color changes
                            if (TMPro.HighlightState.op_Inequality(highlightState.$clone(), currentCharacter.highlightState.$clone())) {
                                // Adjust previous highlight section to prevent a gaps between sections.
                                highlight_end.x = (highlight_end.x - highlightState.padding.right + currentCharacter.bottomLeft.x) / 2;

                                highlight_start.y = UnityEngine.Mathf.Min(highlight_start.y, currentCharacter.descender);
                                highlight_end.y = UnityEngine.Mathf.Max(highlight_end.y, currentCharacter.ascender);

                                this.DrawTextHighlight(highlight_start.$clone(), highlight_end.$clone(), last_vert_index, highlightState.color.$clone());

                                beginHighlight = true;
                                highlight_start.set( highlight_end.x, currentCharacter.descender - currentState.padding.bottom, 0 );
                                highlight_end.set( currentCharacter.topRight.x + currentState.padding.right, currentCharacter.ascender + currentState.padding.top, 0 );

                                highlightState = currentCharacter.highlightState.$clone();

                                isColorTransition = true;
                            }

                            if (!isColorTransition) {
                                // Use the Min / Max Extents of the Highlight area to handle different character sizes and fonts.
                                highlight_start.x = UnityEngine.Mathf.Min(highlight_start.x, currentCharacter.bottomLeft.x - highlightState.padding.left);
                                highlight_start.y = UnityEngine.Mathf.Min(highlight_start.y, currentCharacter.descender - highlightState.padding.bottom);

                                highlight_end.x = UnityEngine.Mathf.Max(highlight_end.x, currentCharacter.topRight.x + highlightState.padding.right);
                                highlight_end.y = UnityEngine.Mathf.Max(highlight_end.y, currentCharacter.ascender + highlightState.padding.top);
                            }
                        }

                        // End Highlight if text only contains one character.
                        if (beginHighlight && this.m_characterCount === 1) {
                            beginHighlight = false;

                            this.DrawTextHighlight(highlight_start.$clone(), highlight_end.$clone(), last_vert_index, highlightState.color.$clone());
                        } else if (beginHighlight && (i1 === lineInfo.lastCharacterIndex || i1 >= lineInfo.lastVisibleCharacterIndex)) {
                            beginHighlight = false;
                            this.DrawTextHighlight(highlight_start.$clone(), highlight_end.$clone(), last_vert_index, highlightState.color.$clone());
                        } else if (beginHighlight && !isHighlightVisible) {
                            beginHighlight = false;
                            this.DrawTextHighlight(highlight_start.$clone(), highlight_end.$clone(), last_vert_index, highlightState.color.$clone());
                        }
                    } else {
                        // End Highlight
                        if (beginHighlight === true) {
                            beginHighlight = false;
                            this.DrawTextHighlight(highlight_start.$clone(), highlight_end.$clone(), last_vert_index, highlightState.color.$clone());
                        }
                    }


                    lastLine = currentLine;
                }


                // Set vertex count for Underline geometry
                //m_textInfo.meshInfo[m_Underline.materialIndex].vertexCount = last_vert_index;

                // METRICS ABOUT THE TEXT OBJECT
                this.m_textInfo.characterCount = this.m_characterCount;
                this.m_textInfo.spriteCount = this.m_spriteCount;
                this.m_textInfo.lineCount = lineCount;
                this.m_textInfo.wordCount = wordCount !== 0 && this.m_characterCount > 0 ? wordCount : 1;
                this.m_textInfo.pageCount = this.m_pageNumber + 1;

                // End Sampling of Phase II

                // Phase III - Update Mesh Vertex Data

                if (this.m_renderMode === TMPro.TextRenderFlags.Render && this.IsActive()) {
                    // Event to allow users to modify the content of the text info before the text is rendered.
                    !Bridge.staticEquals(this.OnPreRenderText, null) ? this.OnPreRenderText(this.m_textInfo) : null;

                    // Sort the geometry of the text object if needed.
                    if (this.m_geometrySortingOrder !== TMPro.VertexSortingOrder.Normal) {
                        ($t125 = this.m_textInfo.meshInfo)[0].SortGeometry$1(TMPro.VertexSortingOrder.Reverse);
                    }

                    // Upload Mesh Data
                    this.m_mesh.MarkDynamic();
                    this.m_mesh.vertices = ($t126 = this.m_textInfo.meshInfo)[0].vertices;
                    this.m_mesh.uv = ($t127 = this.m_textInfo.meshInfo)[0].uvs0;
                    this.m_mesh.uv2 = ($t128 = this.m_textInfo.meshInfo)[0].uvs2;
                    //m_mesh.uv4 = m_textInfo.meshInfo[0].uvs4;
                    this.m_mesh.colors32 = ($t129 = this.m_textInfo.meshInfo)[0].colors32;

                    // Compute Bounds for the mesh. Manual computation is more efficient then using Mesh.RecalcualteBounds.
                    this.m_mesh.RecalculateBounds();
                    //m_mesh.bounds = new Bounds(new Vector3((m_meshExtents.max.x + m_meshExtents.min.x) / 2, (m_meshExtents.max.y + m_meshExtents.min.y) / 2, 0) + offset, new Vector3(m_meshExtents.max.x - m_meshExtents.min.x, m_meshExtents.max.y - m_meshExtents.min.y, 0));

                    for (var i2 = 1; i2 < this.m_textInfo.materialCount; i2++) {
                        // Clear unused vertices
                        ($t130 = this.m_textInfo.meshInfo)[i2].ClearUnusedVertices();

                        if (UnityEngine.MonoBehaviour.op_Equality(this.m_subTextObjects[i2], null)) {
                            continue;
                        }

                        // Sort the geometry of the sub-text objects if needed.
                        if (this.m_geometrySortingOrder !== TMPro.VertexSortingOrder.Normal) {
                            ($t131 = this.m_textInfo.meshInfo)[i2].SortGeometry$1(TMPro.VertexSortingOrder.Reverse);
                        }

                        this.m_subTextObjects[i2].mesh.vertices = ($t132 = this.m_textInfo.meshInfo)[i2].vertices;
                        this.m_subTextObjects[i2].mesh.uv = ($t133 = this.m_textInfo.meshInfo)[i2].uvs0;
                        this.m_subTextObjects[i2].mesh.uv2 = ($t134 = this.m_textInfo.meshInfo)[i2].uvs2;
                        //m_subTextObjects[i].mesh.uv4 = m_textInfo.meshInfo[i].uvs4;
                        this.m_subTextObjects[i2].mesh.colors32 = ($t135 = this.m_textInfo.meshInfo)[i2].colors32;

                        this.m_subTextObjects[i2].mesh.RecalculateBounds();

                        // Update the collider on the sub text object
                        //m_subTextObjects[i].UpdateColliders(m_textInfo.meshInfo[i].vertexCount);
                    }
                }

                // Event indicating the text has been regenerated.
                TMPro.TMPro_EventManager.ON_TEXT_CHANGED(this);

                //Debug.Log("***** Done rendering text object ID " + GetInstanceID() + ". *****");

                // Clear allocations no longer necessary given the text object is static
                // if (true)
                // {
                //     m_isInputParsingRequired = true;
                //     m_textInfo.ClearAllData();
                // }

                // End Sampling
            },
            /*TMPro.TextMeshPro.GenerateTextMesh end.*/

            /*TMPro.TextMeshPro.GetTextContainerLocalCorners start.*/
            /**
             * Method to return the local corners of the Text Container or RectTransform.
             *
             * @instance
             * @protected
             * @override
             * @this TMPro.TextMeshPro
             * @memberof TMPro.TextMeshPro
             * @return  {Array.<UnityEngine.Vector3>}
             */
            GetTextContainerLocalCorners: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#GetTextContainerLocalCorners", this ); }

                if (UnityEngine.Component.op_Equality(this.m_rectTransform, null)) {
                    this.m_rectTransform = this.rectTransform$1;
                }

                this.m_rectTransform.GetLocalCorners(this.m_RectTransformCorners);

                return this.m_RectTransformCorners;
            },
            /*TMPro.TextMeshPro.GetTextContainerLocalCorners end.*/

            /*TMPro.TextMeshPro.SetMeshFilters start.*/
            /**
             * Method to disable the renderers.
             *
             * @instance
             * @private
             * @this TMPro.TextMeshPro
             * @memberof TMPro.TextMeshPro
             * @param   {boolean}    state
             * @return  {void}
             */
            SetMeshFilters: function (state) {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#SetMeshFilters", this ); }

                // Parent text object
                if (UnityEngine.Component.op_Inequality(this.m_meshFilter, null)) {
                    if (state) {
                        this.m_meshFilter.sharedMesh = this.m_mesh;
                    } else {
                        this.m_meshFilter.sharedMesh = null;
                    }
                }

                for (var i = 1; i < this.m_subTextObjects.length && UnityEngine.MonoBehaviour.op_Inequality(this.m_subTextObjects[i], null); i++) {
                    if (UnityEngine.Component.op_Inequality(this.m_subTextObjects[i].meshFilter, null)) {
                        if (state) {
                            this.m_subTextObjects[i].meshFilter.sharedMesh = this.m_subTextObjects[i].mesh;
                        } else {
                            this.m_subTextObjects[i].meshFilter.sharedMesh = null;
                        }
                    }
                }
            },
            /*TMPro.TextMeshPro.SetMeshFilters end.*/

            /*TMPro.TextMeshPro.SetActiveSubMeshes start.*/
            /**
             * Method to Enable or Disable child SubMesh objects.
             *
             * @instance
             * @protected
             * @override
             * @this TMPro.TextMeshPro
             * @memberof TMPro.TextMeshPro
             * @param   {boolean}    state
             * @return  {void}
             */
            SetActiveSubMeshes: function (state) {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#SetActiveSubMeshes", this ); }

                for (var i = 1; i < this.m_subTextObjects.length && UnityEngine.MonoBehaviour.op_Inequality(this.m_subTextObjects[i], null); i++) {
                    if (this.m_subTextObjects[i].enabled !== state) {
                        this.m_subTextObjects[i].enabled = state;
                    }
                }
            },
            /*TMPro.TextMeshPro.SetActiveSubMeshes end.*/

            /*TMPro.TextMeshPro.SetActiveSubTextObjectRenderers start.*/
            SetActiveSubTextObjectRenderers: function (state) {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#SetActiveSubTextObjectRenderers", this ); }

                for (var i = 1; i < this.m_subTextObjects.length && UnityEngine.MonoBehaviour.op_Inequality(this.m_subTextObjects[i], null); i++) {
                    var subMeshRenderer = this.m_subTextObjects[i].renderer;

                    if (UnityEngine.Component.op_Inequality(subMeshRenderer, null) && subMeshRenderer.enabled !== state) {
                        subMeshRenderer.enabled = state;
                    }
                }
            },
            /*TMPro.TextMeshPro.SetActiveSubTextObjectRenderers end.*/

            /*TMPro.TextMeshPro.DestroySubMeshObjects start.*/
            /**
             * Destroy Sub Mesh Objects
             *
             * @instance
             * @protected
             * @override
             * @this TMPro.TextMeshPro
             * @memberof TMPro.TextMeshPro
             * @return  {void}
             */
            DestroySubMeshObjects: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#DestroySubMeshObjects", this ); }

                for (var i = 1; i < this.m_subTextObjects.length && UnityEngine.MonoBehaviour.op_Inequality(this.m_subTextObjects[i], null); i++) {
                    UnityEngine.Object.DestroyImmediate(this.m_subTextObjects[i]);
                }
            },
            /*TMPro.TextMeshPro.DestroySubMeshObjects end.*/

            /*TMPro.TextMeshPro.UpdateSubMeshSortingLayerID start.*/
            /**
             * @instance
             * @this TMPro.TextMeshPro
             * @memberof TMPro.TextMeshPro
             * @param   {number}    id
             * @return  {void}
             */
            UpdateSubMeshSortingLayerID: function (id) {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#UpdateSubMeshSortingLayerID", this ); }

                for (var i = 1; i < this.m_subTextObjects.length; i++) {
                    var subMesh = this.m_subTextObjects[i];

                    if (UnityEngine.MonoBehaviour.op_Inequality(subMesh, null) && UnityEngine.Component.op_Inequality(subMesh.renderer, null)) {
                        subMesh.renderer.sortingLayerID = id;
                    }
                }
            },
            /*TMPro.TextMeshPro.UpdateSubMeshSortingLayerID end.*/

            /*TMPro.TextMeshPro.UpdateSubMeshSortingOrder start.*/
            /**
             * @instance
             * @this TMPro.TextMeshPro
             * @memberof TMPro.TextMeshPro
             * @param   {number}    order
             * @return  {void}
             */
            UpdateSubMeshSortingOrder: function (order) {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#UpdateSubMeshSortingOrder", this ); }

                for (var i = 1; i < this.m_subTextObjects.length; i++) {
                    var subMesh = this.m_subTextObjects[i];

                    if (UnityEngine.MonoBehaviour.op_Inequality(subMesh, null) && UnityEngine.Component.op_Inequality(subMesh.renderer, null)) {
                        subMesh.renderer.sortingOrder = order;
                    }
                }
            },
            /*TMPro.TextMeshPro.UpdateSubMeshSortingOrder end.*/

            /*TMPro.TextMeshPro.GetCompoundBounds start.*/
            /**
             * Method returning the compound bounds of the text object and child sub objects.
             *
             * @instance
             * @protected
             * @override
             * @this TMPro.TextMeshPro
             * @memberof TMPro.TextMeshPro
             * @return  {UnityEngine.Bounds}
             */
            GetCompoundBounds: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#GetCompoundBounds", this ); }

                var mainBounds = this.m_mesh.bounds;
                var min = mainBounds.min.$clone();
                var max = mainBounds.max.$clone();

                for (var i = 1; i < this.m_subTextObjects.length && UnityEngine.MonoBehaviour.op_Inequality(this.m_subTextObjects[i], null); i++) {
                    var subBounds = this.m_subTextObjects[i].mesh.bounds;
                    min.x = min.x < subBounds.min.x ? min.x : subBounds.min.x;
                    min.y = min.y < subBounds.min.y ? min.y : subBounds.min.y;

                    max.x = max.x > subBounds.max.x ? max.x : subBounds.max.x;
                    max.y = max.y > subBounds.max.y ? max.y : subBounds.max.y;
                }

                var center = (min.$clone().add( max )).scale( 1.0 / ( 2 ) );
                var size = UnityEngine.Vector2.FromVector3(max.$clone().sub( min ));
                return new pc.BoundingBox( center.$clone(), UnityEngine.Vector3.FromVector2(size.$clone()).scale( 0.5 ) );
            },
            /*TMPro.TextMeshPro.GetCompoundBounds end.*/

            /*TMPro.TextMeshPro.UpdateSDFScale start.*/
            /**
             * Method to Update Scale in UV2
             * Method to update the SDF Scale in UV2.
             *
             * @instance
             * @private
             * @this TMPro.TextMeshPro
             * @memberof TMPro.TextMeshPro
             * @param   {number}    scaleDelta
             * @return  {void}
             */
            UpdateSDFScale: function (scaleDelta) {
if ( TRACE ) { TRACE( "TMPro.TextMeshPro#UpdateSDFScale", this ); }

                var $t, $t1, $t2;
                if (scaleDelta === 0 || scaleDelta === Number.POSITIVE_INFINITY || scaleDelta === Number.NEGATIVE_INFINITY) {
                    this.m_havePropertiesChanged = true;
                    this.OnPreRenderObject();
                    return;
                }

                for (var materialIndex = 0; materialIndex < this.m_textInfo.materialCount; materialIndex++) {
                    var meshInfo = ($t = this.m_textInfo.meshInfo)[materialIndex].$clone();

                    for (var i = 0; i < meshInfo.uvs2.length; i++) {
                        meshInfo.uvs2[i].y *= Math.abs(scaleDelta);
                    }
                }

                // Push the updated uv2 scale information to the meshes.
                for (var i1 = 0; i1 < this.m_textInfo.meshInfo.length; i1++) {
                    if (i1 === 0) {
                        this.m_mesh.uv2 = ($t1 = this.m_textInfo.meshInfo)[0].uvs2;
                    } else {
                        this.m_subTextObjects[i1].mesh.uv2 = ($t2 = this.m_textInfo.meshInfo)[i1].uvs2;
                    }
                }
            },
            /*TMPro.TextMeshPro.UpdateSDFScale end.*/


        },
        overloads: {
            "SetMask(MaskingTypes, Vector4, float, float)": "SetMask$1",
            "SetMask(MaskingTypes)": "SetMask$2",
            "ClearMesh(bool)": "ClearMesh$1",
            "UpdateGeometry(Mesh, int)": "UpdateGeometry$1",
            "UpdateVertexData(TMP_VertexDataUpdateFlags)": "UpdateVertexData$1",
            "SetMaskCoordinates(Vector4, float, float)": "SetMaskCoordinates$1",
            "CreateMaterialInstance()": "CreateMaterialInstance$1"
        }
    });
    /*TMPro.TextMeshPro end.*/

    /*TMPro.TextMeshProUGUI start.*/
    Bridge.define("TMPro.TextMeshProUGUI", {
        inherits: [TMPro.TMP_Text,UnityEngine.UI.ILayoutElement],
        fields: {
            /**
             * Anchor dampening prevents the anchor position from being adjusted unless the positional change exceeds about 40% of the width of the underline character. This essentially stabilizes the anchor position.
             *
             * @instance
             * @private
             * @memberof TMPro.TextMeshProUGUI
             * @default false
             * @type boolean
             */
            m_isRebuildingLayout: false,
            m_DelayedGraphicRebuild: null,
            m_DelayedMaterialRebuild: null,
            m_ClipRect: null,
            m_ValidRect: false,
            m_hasFontAssetChanged: false,
            m_subTextObjects: null,
            m_previousLossyScaleY: 0,
            m_RectTransformCorners: null,
            m_canvasRenderer: null,
            m_canvas: null,
            m_CanvasScaleFactor: 0,
            m_isFirstAllocation: false,
            m_max_characters: 0,
            m_baseMaterial: null,
            m_isScrollRegionSet: false,
            m_maskOffset: null,
            m_EnvMapMatrix: null,
            m_isRegisteredForEvents: false
        },
        events: {
            /**
             * Event to allow users to modify the content of the text info before the text is rendered.
             *
             * @instance
             * @public
             * @override
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @function addOnPreRenderText
             * @param   {System.Action}    value
             * @return  {void}
             */
            /**
             * Event to allow users to modify the content of the text info before the text is rendered.
             *
             * @instance
             * @public
             * @override
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @function removeOnPreRenderText
             * @param   {System.Action}    value
             * @return  {void}
             */
            OnPreRenderText: null
        },
        props: {
            /**
             * Get the material that will be used for rendering.
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof TMPro.TextMeshProUGUI
             * @function materialForRendering
             * @type UnityEngine.Material
             */
            materialForRendering: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#materialForRendering#get", this ); }

                    return TMPro.TMP_MaterialManager.GetMaterialForRendering(this, this.m_sharedMaterial);
                }
            },
            /**
             * Determines if the size of the text container will be adjusted to fit the text object when it is first created.
             *
             * @instance
             * @public
             * @override
             * @memberof TMPro.TextMeshProUGUI
             * @function autoSizeTextContainer
             * @type boolean
             */
            autoSizeTextContainer: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#autoSizeTextContainer#get", this ); }

                    return this.m_autoSizeTextContainer;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#autoSizeTextContainer#set", this ); }

                    if (this.m_autoSizeTextContainer === value) {
                        return;
                    }

                    this.m_autoSizeTextContainer = value;
                    if (this.m_autoSizeTextContainer) {
                        UnityEngine.UI.CanvasUpdateRegistry.RegisterCanvasElementForLayoutRebuild(this);
                        this.SetLayoutDirty();
                    }
                }
            },
            /**
             * Reference to the Mesh used by the text object.
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof TMPro.TextMeshProUGUI
             * @function mesh
             * @type UnityEngine.Mesh
             */
            mesh: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#mesh#get", this ); }

                    return this.m_mesh;
                }
            },
            /**
             * Reference to the CanvasRenderer used by the text object.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TextMeshProUGUI
             * @function canvasRenderer$1
             * @type UnityEngine.CanvasRenderer
             */
            canvasRenderer$1: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#canvasRenderer$1#get", this ); }

                    if (UnityEngine.Component.op_Equality(this.m_canvasRenderer, null)) {
                        this.m_canvasRenderer = this.GetComponent(UnityEngine.CanvasRenderer);
                    }

                    return this.m_canvasRenderer;
                }
            },
            /**
             * Sets the masking offset from the bounds of the object
             *
             * @instance
             * @public
             * @memberof TMPro.TextMeshProUGUI
             * @function maskOffset
             * @type UnityEngine.Vector4
             */
            maskOffset: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#maskOffset#get", this ); }

                    return this.m_maskOffset.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#maskOffset#set", this ); }

                    this.m_maskOffset = value.$clone();
                    this.UpdateMask();
                    this.m_havePropertiesChanged = true;
                }
            }
        },
        alias: [
            "CalculateLayoutInputHorizontal", "UnityEngine$UI$ILayoutElement$CalculateLayoutInputHorizontal",
            "CalculateLayoutInputVertical", "UnityEngine$UI$ILayoutElement$CalculateLayoutInputVertical",
            "Rebuild", "UnityEngine$UI$ICanvasElement$Rebuild",
            "GetModifiedMaterial", "UnityEngine$UI$IMaterialModifier$GetModifiedMaterial",
            "RecalculateClipping", "UnityEngine$UI$IClippable$RecalculateClipping",
            "Cull", "UnityEngine$UI$IClippable$Cull",
            "minWidth", "UnityEngine$UI$ILayoutElement$minWidth",
            "preferredWidth", "UnityEngine$UI$ILayoutElement$preferredWidth",
            "flexibleWidth", "UnityEngine$UI$ILayoutElement$flexibleWidth",
            "minHeight", "UnityEngine$UI$ILayoutElement$minHeight",
            "preferredHeight", "UnityEngine$UI$ILayoutElement$preferredHeight",
            "flexibleHeight", "UnityEngine$UI$ILayoutElement$flexibleHeight",
            "layoutPriority", "UnityEngine$UI$ILayoutElement$layoutPriority",
            "minWidth", "UnityEngine$UI$ILayoutElement$minWidth",
            "preferredWidth", "UnityEngine$UI$ILayoutElement$preferredWidth",
            "flexibleWidth", "UnityEngine$UI$ILayoutElement$flexibleWidth",
            "minHeight", "UnityEngine$UI$ILayoutElement$minHeight",
            "preferredHeight", "UnityEngine$UI$ILayoutElement$preferredHeight",
            "flexibleHeight", "UnityEngine$UI$ILayoutElement$flexibleHeight",
            "layoutPriority", "UnityEngine$UI$ILayoutElement$layoutPriority"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#init", this ); }

                this.m_ClipRect = new UnityEngine.Rect();
                this.m_maskOffset = new UnityEngine.Vector4();
                this.m_EnvMapMatrix = new UnityEngine.Matrix4x4();
                this.m_isRebuildingLayout = false;
                this.m_hasFontAssetChanged = false;
                this.m_subTextObjects = System.Array.init(8, null, TMPro.TMP_SubMeshUI);
                this.m_previousLossyScaleY = -1;
                this.m_RectTransformCorners = System.Array.init(4, function (){
                    return new UnityEngine.Vector3();
                }, UnityEngine.Vector3);
                this.m_max_characters = 8;
            }
        },
        methods: {
            /*TMPro.TextMeshProUGUI.CalculateLayoutInputHorizontal start.*/
            /**
             * Function called by Unity when the horizontal layout needs to be recalculated.
             *
             * @instance
             * @public
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @return  {void}
             */
            CalculateLayoutInputHorizontal: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#CalculateLayoutInputHorizontal", this ); }

                //Debug.Log("*** CalculateLayoutHorizontal() on Object ID: " + GetInstanceID() + " at frame: " + Time.frameCount + "***");
            },
            /*TMPro.TextMeshProUGUI.CalculateLayoutInputHorizontal end.*/

            /*TMPro.TextMeshProUGUI.CalculateLayoutInputVertical start.*/
            /**
             * Function called by Unity when the vertical layout needs to be recalculated.
             *
             * @instance
             * @public
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @return  {void}
             */
            CalculateLayoutInputVertical: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#CalculateLayoutInputVertical", this ); }

                //Debug.Log("*** CalculateLayoutInputVertical() on Object ID: " + GetInstanceID() + " at frame: " + Time.frameCount + "***");
            },
            /*TMPro.TextMeshProUGUI.CalculateLayoutInputVertical end.*/

            /*TMPro.TextMeshProUGUI.SetVerticesDirty start.*/
            SetVerticesDirty: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#SetVerticesDirty", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this, null) || !this.IsActive()) {
                    return;
                }

                if (UnityEngine.UI.CanvasUpdateRegistry.IsRebuildingGraphics()) {
                    return;
                }

                UnityEngine.UI.CanvasUpdateRegistry.RegisterCanvasElementForGraphicRebuild(this);

                if (!Bridge.staticEquals(this.m_OnDirtyVertsCallback, null)) {
                    this.m_OnDirtyVertsCallback();
                }
            },
            /*TMPro.TextMeshProUGUI.SetVerticesDirty end.*/

            /*TMPro.TextMeshProUGUI.SetLayoutDirty start.*/
            /**
             * @instance
             * @public
             * @override
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @return  {void}
             */
            SetLayoutDirty: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#SetLayoutDirty", this ); }

                this.m_isPreferredWidthDirty = true;
                this.m_isPreferredHeightDirty = true;

                if (UnityEngine.MonoBehaviour.op_Equality(this, null) || !this.IsActive()) {
                    return;
                }

                UnityEngine.UI.LayoutRebuilder.MarkLayoutForRebuild(this.rectTransform$1);

                this.m_isLayoutDirty = true;

                if (!Bridge.staticEquals(this.m_OnDirtyLayoutCallback, null)) {
                    this.m_OnDirtyLayoutCallback();
                }
            },
            /*TMPro.TextMeshProUGUI.SetLayoutDirty end.*/

            /*TMPro.TextMeshProUGUI.SetMaterialDirty start.*/
            /**
             * @instance
             * @public
             * @override
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @return  {void}
             */
            SetMaterialDirty: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#SetMaterialDirty", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this, null) || !this.IsActive()) {
                    return;
                }

                if (UnityEngine.UI.CanvasUpdateRegistry.IsRebuildingGraphics()) {
                    return;
                }

                this.m_isMaterialDirty = true;
                UnityEngine.UI.CanvasUpdateRegistry.RegisterCanvasElementForGraphicRebuild(this);

                if (!Bridge.staticEquals(this.m_OnDirtyMaterialCallback, null)) {
                    this.m_OnDirtyMaterialCallback();
                }
            },
            /*TMPro.TextMeshProUGUI.SetMaterialDirty end.*/

            /*TMPro.TextMeshProUGUI.SetAllDirty start.*/
            /**
             * @instance
             * @public
             * @override
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @return  {void}
             */
            SetAllDirty: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#SetAllDirty", this ); }

                this.SetLayoutDirty();
                this.SetVerticesDirty();
                this.SetMaterialDirty();
            },
            /*TMPro.TextMeshProUGUI.SetAllDirty end.*/

            /*TMPro.TextMeshProUGUI.DelayedGraphicRebuild start.*/
            /**
             * Delay registration of text object for graphic rebuild by one frame.
             *
             * @instance
             * @private
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @return  {System.Collections.IEnumerator}
             */
            DelayedGraphicRebuild: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#DelayedGraphicRebuild", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = null;
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    UnityEngine.UI.CanvasUpdateRegistry.RegisterCanvasElementForGraphicRebuild(this);

                                        if (!Bridge.staticEquals(this.m_OnDirtyVertsCallback, null)) {
                                            this.m_OnDirtyVertsCallback();
                                        }

                                        this.m_DelayedGraphicRebuild = null;

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*TMPro.TextMeshProUGUI.DelayedGraphicRebuild end.*/

            /*TMPro.TextMeshProUGUI.DelayedMaterialRebuild start.*/
            /**
             * Delay registration of text object for graphic rebuild by one frame.
             *
             * @instance
             * @private
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @return  {System.Collections.IEnumerator}
             */
            DelayedMaterialRebuild: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#DelayedMaterialRebuild", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = null;
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    this.m_isMaterialDirty = true;
                                        UnityEngine.UI.CanvasUpdateRegistry.RegisterCanvasElementForGraphicRebuild(this);

                                        if (!Bridge.staticEquals(this.m_OnDirtyMaterialCallback, null)) {
                                            this.m_OnDirtyMaterialCallback();
                                        }

                                        this.m_DelayedMaterialRebuild = null;

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*TMPro.TextMeshProUGUI.DelayedMaterialRebuild end.*/

            /*TMPro.TextMeshProUGUI.Rebuild start.*/
            /**
             * @instance
             * @public
             * @override
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @param   {UnityEngine.UI.CanvasUpdate}    update
             * @return  {void}
             */
            Rebuild: function (update) {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#Rebuild", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this, null)) {
                    return;
                }

                if (update === UnityEngine.UI.CanvasUpdate.Prelayout) {
                    if (this.m_autoSizeTextContainer) {
                        this.m_rectTransform.sizeDelta = this.GetPreferredValues$1(window.Infinity, window.Infinity);
                    }
                } else if (update === UnityEngine.UI.CanvasUpdate.PreRender) {
                    this.OnPreRenderCanvas();

                    if (!this.m_isMaterialDirty) {
                        return;
                    }

                    this.UpdateMaterial();
                    this.m_isMaterialDirty = false;
                }
            },
            /*TMPro.TextMeshProUGUI.Rebuild end.*/

            /*TMPro.TextMeshProUGUI.UpdateSubObjectPivot start.*/
            /**
             * Method to keep the pivot of the sub text objects in sync with the parent pivot.
             *
             * @instance
             * @private
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @return  {void}
             */
            UpdateSubObjectPivot: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#UpdateSubObjectPivot", this ); }

                if (this.m_textInfo == null) {
                    return;
                }

                for (var i = 1; i < this.m_subTextObjects.length && UnityEngine.MonoBehaviour.op_Inequality(this.m_subTextObjects[i], null); i++) {
                    this.m_subTextObjects[i].SetPivotDirty();
                }
                //m_isPivotDirty = false;
            },
            /*TMPro.TextMeshProUGUI.UpdateSubObjectPivot end.*/

            /*TMPro.TextMeshProUGUI.GetModifiedMaterial start.*/
            /**
             * @instance
             * @public
             * @override
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @param   {UnityEngine.Material}    baseMaterial
             * @return  {UnityEngine.Material}
             */
            GetModifiedMaterial: function (baseMaterial) {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#GetModifiedMaterial", this ); }

                var mat = baseMaterial;

                if (this.m_ShouldRecalculateStencil) {
                    var rootCanvas = UnityEngine.UI.MaskUtilities.FindRootSortOverrideCanvas(this.transform$1);
                    this.m_StencilValue = this.maskable ? UnityEngine.UI.MaskUtilities.GetStencilDepth(this.transform$1, rootCanvas) : 0;
                    this.m_ShouldRecalculateStencil = false;
                }

                if (this.m_StencilValue > 0) {
                    var maskMat = UnityEngine.UI.StencilMaterial.Add$2(mat, (1 << this.m_StencilValue) - 1, UnityEngine.Rendering.StencilOp.Keep, UnityEngine.Rendering.CompareFunction.Equal, UnityEngine.Rendering.ColorWriteMask.All, (1 << this.m_StencilValue) - 1, 0);
                    UnityEngine.UI.StencilMaterial.Remove(this.m_MaskMaterial);
                    this.m_MaskMaterial = maskMat;
                    mat = this.m_MaskMaterial;
                }

                return mat;
            },
            /*TMPro.TextMeshProUGUI.GetModifiedMaterial end.*/

            /*TMPro.TextMeshProUGUI.UpdateMaterial start.*/
            /**
             * @instance
             * @protected
             * @override
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @return  {void}
             */
            UpdateMaterial: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#UpdateMaterial", this ); }

                //Debug.Log("*** UpdateMaterial() ***");

                //if (!this.IsActive())
                //    return;

                if (this.m_sharedMaterial == null || UnityEngine.Component.op_Equality(this.canvasRenderer$1, null)) {
                    return;
                }

                this.m_canvasRenderer.materialCount = 1;
                this.m_canvasRenderer.SetMaterial(this.materialForRendering, 0);
                //m_canvasRenderer.SetTexture(materialForRendering.mainTexture);
            },
            /*TMPro.TextMeshProUGUI.UpdateMaterial end.*/

            /*TMPro.TextMeshProUGUI.RecalculateClipping start.*/
            /**
             * Method called when the state of a parent changes.
             *
             * @instance
             * @public
             * @override
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @return  {void}
             */
            RecalculateClipping: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#RecalculateClipping", this ); }

                //Debug.Log("***** RecalculateClipping() *****");

                TMPro.TMP_Text.prototype.RecalculateClipping.call(this);
            },
            /*TMPro.TextMeshProUGUI.RecalculateClipping end.*/

            /*TMPro.TextMeshProUGUI.Cull start.*/
            /**
             * Method called when Stencil Mask needs to be updated on this element and parents.
             * Override of the Cull function to provide for the ability to override the culling of the text object.
             *
             * @instance
             * @public
             * @override
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @param   {UnityEngine.Rect}    clipRect     
             * @param   {boolean}             validRect
             * @return  {void}
             */
            Cull: function (clipRect, validRect) {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#Cull", this ); }

                // Delay culling check in the event the text layout is dirty and geometry has to be updated.
                if (this.m_isLayoutDirty) {
                    TMPro.TMP_UpdateManager.RegisterTextElementForCullingUpdate(this);
                    this.m_ClipRect = clipRect.$clone();
                    this.m_ValidRect = validRect;
                    return;
                }

                // Get compound rect for the text object and sub text objects in local canvas space.
                var rect = this.GetCanvasSpaceClippingRect();

                // No point culling if geometry bounds have no width or height.
                if (rect.width === 0 || rect.height === 0) {
                    return;
                }

                var cull = !validRect || !clipRect.Overlaps$1(rect.$clone(), true);
                if (this.m_canvasRenderer.cull !== cull) {
                    this.m_canvasRenderer.cull = cull;
                    this.onCullStateChanged.Invoke(cull);

                    // Update any potential sub mesh objects
                    for (var i = 1; i < this.m_subTextObjects.length && UnityEngine.MonoBehaviour.op_Inequality(this.m_subTextObjects[i], null); i++) {
                        this.m_subTextObjects[i].canvasRenderer.cull = cull;
                    }
                }
            },
            /*TMPro.TextMeshProUGUI.Cull end.*/

            /*TMPro.TextMeshProUGUI.UpdateCulling start.*/
            /**
             * Internal function to allow delay of culling until the text geometry has been updated.
             *
             * @instance
             * @override
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @return  {void}
             */
            UpdateCulling: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#UpdateCulling", this ); }

                // Get compound rect for the text object and sub text objects in local canvas space.
                var rect = this.GetCanvasSpaceClippingRect();

                // No point culling if geometry bounds have no width or height.
                if (rect.width === 0 || rect.height === 0) {
                    return;
                }

                var cull = !this.m_ValidRect || !this.m_ClipRect.Overlaps$1(rect.$clone(), true);
                if (this.m_canvasRenderer.cull !== cull) {
                    this.m_canvasRenderer.cull = cull;
                    this.onCullStateChanged.Invoke(cull);

                    // Update any potential sub mesh objects
                    for (var i = 1; i < this.m_subTextObjects.length && UnityEngine.MonoBehaviour.op_Inequality(this.m_subTextObjects[i], null); i++) {
                        this.m_subTextObjects[i].canvasRenderer.cull = cull;
                    }
                }
            },
            /*TMPro.TextMeshProUGUI.UpdateCulling end.*/

            /*TMPro.TextMeshProUGUI.UpdateMeshPadding start.*/
            /**
             * Function to be used to force recomputing of character padding when Shader / Material properties have been changed via script.
             *
             * @instance
             * @public
             * @override
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @return  {void}
             */
            UpdateMeshPadding: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#UpdateMeshPadding", this ); }

                this.m_padding = TMPro.ShaderUtilities.GetPadding(this.m_sharedMaterial, this.m_enableExtraPadding, this.m_isUsingBold);
                this.m_isMaskingEnabled = TMPro.ShaderUtilities.IsMaskingEnabled(this.m_sharedMaterial);
                this.m_havePropertiesChanged = true;
                this.checkPaddingRequired = false;

                // Return if text object is not awake yet.
                if (this.m_textInfo == null) {
                    return;
                }

                // Update sub text objects
                for (var i = 1; i < this.m_textInfo.materialCount; i++) {
                    this.m_subTextObjects[i].UpdateMeshPadding(this.m_enableExtraPadding, this.m_isUsingBold);
                }
            },
            /*TMPro.TextMeshProUGUI.UpdateMeshPadding end.*/

            /*TMPro.TextMeshProUGUI.InternalCrossFadeColor start.*/
            /**
             * Tweens the CanvasRenderer color associated with this Graphic.
             *
             * @instance
             * @protected
             * @override
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @param   {UnityEngine.Color}    targetColor        Target color.
             * @param   {number}               duration           Tween duration.
             * @param   {boolean}              ignoreTimeScale    Should ignore Time.scale?
             * @param   {boolean}              useAlpha           Should also Tween the alpha channel?
             * @return  {void}
             */
            InternalCrossFadeColor: function (targetColor, duration, ignoreTimeScale, useAlpha) {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#InternalCrossFadeColor", this ); }

                if (this.m_textInfo == null) {
                    return;
                }

                var materialCount = this.m_textInfo.materialCount;

                for (var i = 1; i < materialCount; i++) {
                    this.m_subTextObjects[i].CrossFadeColor(targetColor.$clone(), duration, ignoreTimeScale, useAlpha);
                }
            },
            /*TMPro.TextMeshProUGUI.InternalCrossFadeColor end.*/

            /*TMPro.TextMeshProUGUI.InternalCrossFadeAlpha start.*/
            /**
             * Tweens the alpha of the CanvasRenderer color associated with this Graphic.
             *
             * @instance
             * @protected
             * @override
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @param   {number}     alpha              Target alpha.
             * @param   {number}     duration           Duration of the tween in seconds.
             * @param   {boolean}    ignoreTimeScale    Should ignore Time.scale?
             * @return  {void}
             */
            InternalCrossFadeAlpha: function (alpha, duration, ignoreTimeScale) {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#InternalCrossFadeAlpha", this ); }

                if (this.m_textInfo == null) {
                    return;
                }

                var materialCount = this.m_textInfo.materialCount;

                for (var i = 1; i < materialCount; i++) {
                    this.m_subTextObjects[i].CrossFadeAlpha(alpha, duration, ignoreTimeScale);
                }
            },
            /*TMPro.TextMeshProUGUI.InternalCrossFadeAlpha end.*/

            /*TMPro.TextMeshProUGUI.ForceMeshUpdate start.*/
            /**
             * Function to force regeneration of the text object before its normal process time. This is useful when changes to the text object properties need to be applied immediately.
             *
             * @instance
             * @public
             * @override
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @param   {boolean}    ignoreActiveState     Ignore Active State of text objects. Inactive objects are ignored by default.
             * @param   {boolean}    forceTextReparsing    Force re-parsing of the text.
             * @return  {void}
             */
            ForceMeshUpdate: function (ignoreActiveState, forceTextReparsing) {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#ForceMeshUpdate", this ); }

                if (ignoreActiveState === void 0) { ignoreActiveState = false; }
                if (forceTextReparsing === void 0) { forceTextReparsing = false; }
                this.m_havePropertiesChanged = true;
                this.m_ignoreActiveState = ignoreActiveState;

                // Special handling in the event the Canvas is only disabled
                if (UnityEngine.Component.op_Equality(this.m_canvas, null)) {
                    this.m_canvas = this.GetComponentInParent(UnityEngine.Canvas);
                }

                this.OnPreRenderCanvas();
            },
            /*TMPro.TextMeshProUGUI.ForceMeshUpdate end.*/

            /*TMPro.TextMeshProUGUI.GetTextInfo start.*/
            /**
             * Function used to evaluate the length of a text string.
             *
             * @instance
             * @public
             * @override
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @param   {string}                text
             * @return  {TMPro.TMP_TextInfo}
             */
            GetTextInfo: function (text) {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#GetTextInfo", this ); }

                this.SetText$2(text);
                this.SetArraySizes(this.m_TextProcessingArray);

                this.m_renderMode = TMPro.TextRenderFlags.DontRender;

                this.ComputeMarginSize();

                // Need to make sure we have a valid reference to a Canvas.
                if (UnityEngine.Component.op_Equality(this.m_canvas, null)) {
                    this.m_canvas = this.canvas;
                }

                this.GenerateTextMesh();

                this.m_renderMode = TMPro.TextRenderFlags.Render;

                return this.textInfo;
            },
            /*TMPro.TextMeshProUGUI.GetTextInfo end.*/

            /*TMPro.TextMeshProUGUI.ClearMesh start.*/
            /**
             * Function to clear the geometry of the Primary and Sub Text objects.
             *
             * @instance
             * @public
             * @override
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @return  {void}
             */
            ClearMesh: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#ClearMesh", this ); }

                this.m_canvasRenderer.SetMesh(null);

                for (var i = 1; i < this.m_subTextObjects.length && UnityEngine.MonoBehaviour.op_Inequality(this.m_subTextObjects[i], null); i++) {
                    this.m_subTextObjects[i].canvasRenderer.SetMesh(null);
                }
            },
            /*TMPro.TextMeshProUGUI.ClearMesh end.*/

            /*TMPro.TextMeshProUGUI.UpdateGeometry$1 start.*/
            /**
             * Function to update the geometry of the main and sub text objects.
             *
             * @instance
             * @public
             * @override
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @param   {UnityEngine.Mesh}    mesh     
             * @param   {number}              index
             * @return  {void}
             */
            UpdateGeometry$1: function (mesh, index) {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#UpdateGeometry$1", this ); }

                mesh.RecalculateBounds();

                if (index === 0) {
                    this.m_canvasRenderer.SetMesh(mesh);
                } else {
                    this.m_subTextObjects[index].canvasRenderer.SetMesh(mesh);
                }
            },
            /*TMPro.TextMeshProUGUI.UpdateGeometry$1 end.*/

            /*TMPro.TextMeshProUGUI.UpdateVertexData$1 start.*/
            /**
             * Function to upload the updated vertex data and renderer.
             *
             * @instance
             * @public
             * @override
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @param   {TMPro.TMP_VertexDataUpdateFlags}    flags
             * @return  {void}
             */
            UpdateVertexData$1: function (flags) {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#UpdateVertexData$1", this ); }

                var $t, $t1, $t2, $t3;
                var materialCount = this.m_textInfo.materialCount;

                for (var i = 0; i < materialCount; i++) {
                    var mesh;

                    if (i === 0) {
                        mesh = this.m_mesh;
                    } else {
                        // Clear unused vertices
                        // TODO: Causes issues when sorting geometry as last vertex data attribute get wiped out.
                        //m_textInfo.meshInfo[i].ClearUnusedVertices();

                        mesh = this.m_subTextObjects[i].mesh;
                    }

                    if ((flags & TMPro.TMP_VertexDataUpdateFlags.Vertices) === TMPro.TMP_VertexDataUpdateFlags.Vertices) {
                        mesh.vertices = ($t = this.m_textInfo.meshInfo)[i].vertices;
                    }

                    if ((flags & TMPro.TMP_VertexDataUpdateFlags.Uv0) === TMPro.TMP_VertexDataUpdateFlags.Uv0) {
                        mesh.uv = ($t1 = this.m_textInfo.meshInfo)[i].uvs0;
                    }

                    if ((flags & TMPro.TMP_VertexDataUpdateFlags.Uv2) === TMPro.TMP_VertexDataUpdateFlags.Uv2) {
                        mesh.uv2 = ($t2 = this.m_textInfo.meshInfo)[i].uvs2;
                    }

                    //if ((flags & TMP_VertexDataUpdateFlags.Uv4) == TMP_VertexDataUpdateFlags.Uv4)
                    //    mesh.uv4 = m_textInfo.meshInfo[i].uvs4;

                    if ((flags & TMPro.TMP_VertexDataUpdateFlags.Colors32) === TMPro.TMP_VertexDataUpdateFlags.Colors32) {
                        mesh.colors32 = ($t3 = this.m_textInfo.meshInfo)[i].colors32;
                    }

                    mesh.RecalculateBounds();

                    if (i === 0) {
                        this.m_canvasRenderer.SetMesh(mesh);
                    } else {
                        this.m_subTextObjects[i].canvasRenderer.SetMesh(mesh);
                    }
                }
            },
            /*TMPro.TextMeshProUGUI.UpdateVertexData$1 end.*/

            /*TMPro.TextMeshProUGUI.UpdateVertexData start.*/
            /**
             * Function to upload the updated vertex data and renderer.
             *
             * @instance
             * @public
             * @override
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @return  {void}
             */
            UpdateVertexData: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#UpdateVertexData", this ); }

                var $t, $t1, $t2, $t3, $t4;
                var materialCount = this.m_textInfo.materialCount;

                for (var i = 0; i < materialCount; i++) {
                    var mesh;

                    if (i === 0) {
                        mesh = this.m_mesh;
                    } else {
                        // Clear unused vertices
                        ($t = this.m_textInfo.meshInfo)[i].ClearUnusedVertices();

                        mesh = this.m_subTextObjects[i].mesh;
                    }

                    //mesh.MarkDynamic();
                    mesh.vertices = ($t1 = this.m_textInfo.meshInfo)[i].vertices;
                    mesh.uv = ($t2 = this.m_textInfo.meshInfo)[i].uvs0;
                    mesh.uv2 = ($t3 = this.m_textInfo.meshInfo)[i].uvs2;
                    //mesh.uv4 = m_textInfo.meshInfo[i].uvs4;
                    mesh.colors32 = ($t4 = this.m_textInfo.meshInfo)[i].colors32;

                    mesh.RecalculateBounds();

                    if (i === 0) {
                        this.m_canvasRenderer.SetMesh(mesh);
                    } else {
                        this.m_subTextObjects[i].canvasRenderer.SetMesh(mesh);
                    }
                }
            },
            /*TMPro.TextMeshProUGUI.UpdateVertexData end.*/

            /*TMPro.TextMeshProUGUI.UpdateFontAsset start.*/
            UpdateFontAsset: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#UpdateFontAsset", this ); }

                this.LoadFontAsset();
            },
            /*TMPro.TextMeshProUGUI.UpdateFontAsset end.*/

            /*TMPro.TextMeshProUGUI.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#Awake", this ); }

                //Debug.Log("***** Awake() called on object ID " + GetInstanceID() + ". *****");


                // Cache Reference to the Canvas
                this.m_canvas = this.canvas;

                this.m_isOrthographic = true;

                // Cache Reference to RectTransform.
                this.m_rectTransform = this.gameObject.GetComponent(UnityEngine.RectTransform);
                if (UnityEngine.Component.op_Equality(this.m_rectTransform, null)) {
                    this.m_rectTransform = this.gameObject.AddComponent(UnityEngine.RectTransform);
                }

                // Cache a reference to the CanvasRenderer.
                this.m_canvasRenderer = this.GetComponent(UnityEngine.CanvasRenderer);
                if (UnityEngine.Component.op_Equality(this.m_canvasRenderer, null)) {
                    this.m_canvasRenderer = this.gameObject.AddComponent(UnityEngine.CanvasRenderer);
                }

                if (this.m_mesh == null) {
                    this.m_mesh = new UnityEngine.Mesh.ctor();
                    this.m_mesh.hideFlags = UnityEngine.HideFlags.HideAndDontSave;
                    // Create new TextInfo for the text object.
                    this.m_textInfo = new TMPro.TMP_TextInfo.$ctor2(this);
                }

                // Load TMP Settings for new text object instances.
                this.LoadDefaultSettings();

                // Load the font asset and assign material to renderer.
                this.LoadFontAsset();

                // Allocate our initial buffers.
                if (this.m_TextProcessingArray == null) {
                    this.m_TextProcessingArray = System.Array.init(this.m_max_characters, function (){
                        return new TMPro.TMP_Text.UnicodeChar();
                    }, TMPro.TMP_Text.UnicodeChar);
                }

                this.m_cached_TextElement = new TMPro.TMP_Character.ctor();
                this.m_isFirstAllocation = true;

                // Check to make sure Sub Text Objects are tracked correctly in the event a Prefab is used.
                var subTextObjects = this.GetComponentsInChildren(TMPro.TMP_SubMeshUI);
                if (subTextObjects.length > 0) {
                    var subTextObjectCount = subTextObjects.length;

                    if (subTextObjectCount + 1 > this.m_subTextObjects.length) {
                        System.Array.resize(Bridge.ref(this, "m_subTextObjects"), subTextObjectCount + 1, null, TMPro.TMP_SubMeshUI);
                    }

                    for (var i = 0; i < subTextObjectCount; i++) {
                        this.m_subTextObjects[i + 1] = subTextObjects[i];
                    }
                }

                // Set flags to ensure our text is parsed and redrawn.
                this.m_havePropertiesChanged = true;

                this.m_isAwake = true;
            },
            /*TMPro.TextMeshProUGUI.Awake end.*/

            /*TMPro.TextMeshProUGUI.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#OnEnable", this ); }

                //Debug.Log("***** OnEnable() called on object ID " + GetInstanceID() + ". *****");

                // Return if Awake() has not been called on the text object.
                if (this.m_isAwake === false) {
                    return;
                }

                if (!this.m_isRegisteredForEvents) {
                    //Debug.Log("Registering for Events.");

                    this.m_isRegisteredForEvents = true;
                }

                // Cache Reference to the Canvas
                this.m_canvas = this.GetCanvas();

                this.SetActiveSubMeshes(true);

                // Register Graphic Component to receive event triggers
                UnityEngine.UI.GraphicRegistry.RegisterGraphicForCanvas(this.m_canvas, this);

                // Register text object for internal updates
                if (this.m_IsTextObjectScaleStatic === false) {
                    TMPro.TMP_UpdateManager.RegisterTextObjectForUpdate(this);
                }

                this.ComputeMarginSize();

                this.SetAllDirty();

                this.RecalculateClipping();
                this.RecalculateMasking();
            },
            /*TMPro.TextMeshProUGUI.OnEnable end.*/

            /*TMPro.TextMeshProUGUI.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#OnDisable", this ); }

                //Debug.Log("***** OnDisable() called on object ID " + GetInstanceID() + ". *****");

                // Return if Awake() has not been called on the text object.
                if (this.m_isAwake === false) {
                    return;
                }

                //if (m_MaskMaterial != null)
                //{
                //    TMP_MaterialManager.ReleaseStencilMaterial(m_MaskMaterial);
                //    m_MaskMaterial = null;
                //}

                // UnRegister Graphic Component
                UnityEngine.UI.GraphicRegistry.UnregisterGraphicForCanvas(this.m_canvas, this);
                UnityEngine.UI.CanvasUpdateRegistry.UnRegisterCanvasElementForRebuild(Bridge.cast(this, UnityEngine.UI.ICanvasElement));

                TMPro.TMP_UpdateManager.UnRegisterTextObjectForUpdate(this);

                if (UnityEngine.Component.op_Inequality(this.m_canvasRenderer, null)) {
                    this.m_canvasRenderer.Clear();
                }

                this.SetActiveSubMeshes(false);

                UnityEngine.UI.LayoutRebuilder.MarkLayoutForRebuild(this.m_rectTransform);
                this.RecalculateClipping();
                this.RecalculateMasking();
            },
            /*TMPro.TextMeshProUGUI.OnDisable end.*/

            /*TMPro.TextMeshProUGUI.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#OnDestroy", this ); }

                //Debug.Log("***** OnDestroy() called on object ID " + GetInstanceID() + ". *****");

                // UnRegister Graphic Component
                UnityEngine.UI.GraphicRegistry.UnregisterGraphicForCanvas(this.m_canvas, this);

                TMPro.TMP_UpdateManager.UnRegisterTextObjectForUpdate(this);

                // Clean up remaining mesh
                if (this.m_mesh != null) {
                    UnityEngine.Object.DestroyImmediate(this.m_mesh);
                }

                // Clean up mask material
                if (this.m_MaskMaterial != null) {
                    TMPro.TMP_MaterialManager.ReleaseStencilMaterial(this.m_MaskMaterial);
                    this.m_MaskMaterial = null;
                }

                this.m_isRegisteredForEvents = false;
            },
            /*TMPro.TextMeshProUGUI.OnDestroy end.*/

            /*TMPro.TextMeshProUGUI.LoadFontAsset start.*/
            LoadFontAsset: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#LoadFontAsset", this ); }

                //Debug.Log("***** LoadFontAsset() *****"); //TextMeshPro LoadFontAsset() has been called."); // Current Font Asset is " + (font != null ? font.name: "Null") );

                TMPro.ShaderUtilities.GetShaderPropertyIDs(); // Initialize & Get shader property IDs.

                if (this.m_fontAsset == null) {
                    if (TMPro.TMP_Settings.defaultFontAsset != null) {
                        this.m_fontAsset = TMPro.TMP_Settings.defaultFontAsset;
                    } else {
                        this.m_fontAsset = UnityEngine.Resources.Load(TMPro.TMP_FontAsset, "Fonts & Materials/LiberationSans SDF");
                    }

                    if (this.m_fontAsset == null) {
                        UnityEngine.Debug.LogWarning$1("The LiberationSans SDF Font Asset was not found. There is no Font Asset assigned to " + (this.gameObject.name || "") + ".", this);
                        return;
                    }

                    if (this.m_fontAsset.characterLookupTable == null) {
                        UnityEngine.Debug.Log$1("Dictionary is Null!");
                    }

                    this.m_sharedMaterial = this.m_fontAsset.material;
                } else {
                    // Read font definition if needed.
                    if (this.m_fontAsset.characterLookupTable == null) {
                        this.m_fontAsset.ReadFontAssetDefinition();
                    }

                    // Added for compatibility with previous releases.
                    if (this.m_sharedMaterial == null && this.m_baseMaterial != null) {
                        this.m_sharedMaterial = this.m_baseMaterial;
                        this.m_baseMaterial = null;
                    }

                    // If font atlas texture doesn't match the assigned material font atlas, switch back to default material specified in the Font Asset.
                    if (this.m_sharedMaterial == null || this.m_sharedMaterial.GetTexture(TMPro.ShaderUtilities.ID_MainTex) == null || this.m_fontAsset.atlasTexture.GetInstanceID() !== this.m_sharedMaterial.GetTexture(TMPro.ShaderUtilities.ID_MainTex).GetInstanceID()) {
                        if (this.m_fontAsset.material == null) {
                            UnityEngine.Debug.LogWarning$1("The Font Atlas Texture of the Font Asset " + (this.m_fontAsset.name || "") + " assigned to " + (this.gameObject.name || "") + " is missing.", this);
                        } else {
                            this.m_sharedMaterial = this.m_fontAsset.material;
                        }
                    }
                }


                // Find and cache Underline & Ellipsis characters.
                this.GetSpecialCharacters(this.m_fontAsset);

                this.m_padding = this.GetPaddingForMaterial();

                this.SetMaterialDirty();
            },
            /*TMPro.TextMeshProUGUI.LoadFontAsset end.*/

            /*TMPro.TextMeshProUGUI.GetCanvas start.*/
            /**
             * Method to retrieve the parent Canvas.
             *
             * @instance
             * @private
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @return  {UnityEngine.Canvas}
             */
            GetCanvas: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#GetCanvas", this ); }

                var canvas = null;
                var list = TMPro.TMP_ListPool$1(UnityEngine.Canvas).Get();

                this.gameObject.GetComponentsInParent$1(UnityEngine.Canvas, false, list);
                if (list.Count > 0) {
                    // Find the first active and enabled canvas.
                    for (var i = 0; i < list.Count; ++i) {
                        if (list.getItem(i).isActiveAndEnabled) {
                            canvas = list.getItem(i);
                            break;
                        }
                    }
                }

                TMPro.TMP_ListPool$1(UnityEngine.Canvas).Release(list);

                return canvas;
            },
            /*TMPro.TextMeshProUGUI.GetCanvas end.*/

            /*TMPro.TextMeshProUGUI.UpdateEnvMapMatrix start.*/
            /**
             * Method used when animating the Env Map on the material.
             *
             * @instance
             * @private
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @return  {void}
             */
            UpdateEnvMapMatrix: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#UpdateEnvMapMatrix", this ); }

                if (!this.m_sharedMaterial.HasProperty(TMPro.ShaderUtilities.ID_EnvMap) || this.m_sharedMaterial.GetTexture(TMPro.ShaderUtilities.ID_EnvMap) == null) {
                    return;
                }

                //Debug.Log("Updating Env Matrix...");
                var rotation = UnityEngine.Vector3.FromVector4(this.m_sharedMaterial.GetVector(TMPro.ShaderUtilities.ID_EnvMatrixRotation));
                this.m_EnvMapMatrix = new pc.Mat4().setTRS( pc.Vec3.ZERO.clone(), new pc.Quat().setFromEulerAngles_Unity( rotation.x, rotation.y, rotation.z ), new pc.Vec3( 1, 1, 1 ) );

                this.m_sharedMaterial.SetMatrix(TMPro.ShaderUtilities.ID_EnvMatrix, this.m_EnvMapMatrix.$clone());
            },
            /*TMPro.TextMeshProUGUI.UpdateEnvMapMatrix end.*/

            /*TMPro.TextMeshProUGUI.EnableMasking start.*/
            EnableMasking: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#EnableMasking", this ); }

                if (this.m_fontMaterial == null) {
                    this.m_fontMaterial = this.CreateMaterialInstance(this.m_sharedMaterial);
                    this.m_canvasRenderer.SetMaterial$1(this.m_fontMaterial, this.m_sharedMaterial.GetTexture(TMPro.ShaderUtilities.ID_MainTex));
                }

                this.m_sharedMaterial = this.m_fontMaterial;
                if (this.m_sharedMaterial.HasProperty(TMPro.ShaderUtilities.ID_ClipRect)) {
                    this.m_sharedMaterial.EnableKeyword(TMPro.ShaderUtilities.Keyword_MASK_SOFT);
                    this.m_sharedMaterial.DisableKeyword(TMPro.ShaderUtilities.Keyword_MASK_HARD);
                    this.m_sharedMaterial.DisableKeyword(TMPro.ShaderUtilities.Keyword_MASK_TEX);

                    this.UpdateMask(); // Update Masking Coordinates
                }

                this.m_isMaskingEnabled = true;

                //m_uiRenderer.SetMaterial(m_sharedMaterial, null);

                //m_padding = ShaderUtilities.GetPadding(m_sharedMaterial, m_enableExtraPadding, m_isUsingBold);
                //m_alignmentPadding = ShaderUtilities.GetFontExtent(m_sharedMaterial);

                /* 
                Material mat = m_uiRenderer.GetMaterial();
                if (mat.HasProperty(ShaderUtilities.ID_MaskCoord))
                {
                   mat.EnableKeyword("MASK_SOFT");
                   mat.DisableKeyword("MASK_HARD");
                   mat.DisableKeyword("MASK_OFF");

                   m_isMaskingEnabled = true;
                   UpdateMask();
                }
                */
            },
            /*TMPro.TextMeshProUGUI.EnableMasking end.*/

            /*TMPro.TextMeshProUGUI.DisableMasking start.*/
            DisableMasking: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#DisableMasking", this ); }

                /* 
                if (m_fontMaterial != null)
                {
                   if (m_stencilID > 0)
                       m_sharedMaterial = m_MaskMaterial;
                   else
                       m_sharedMaterial = m_baseMaterial;

                   m_canvasRenderer.SetMaterial(m_sharedMaterial, m_sharedMaterial.GetTexture(ShaderUtilities.ID_MainTex));

                   DestroyImmediate(m_fontMaterial);
                }

                m_isMaskingEnabled = false;
                */

                /* 
                if (m_maskingMaterial != null && m_stencilID == 0)
                {
                   m_sharedMaterial = m_baseMaterial;
                   m_uiRenderer.SetMaterial(m_sharedMaterial, null);
                }
                else if (m_stencilID > 0)
                {
                   m_sharedMaterial.EnableKeyword("MASK_OFF");
                   m_sharedMaterial.DisableKeyword("MASK_HARD");
                   m_sharedMaterial.DisableKeyword("MASK_SOFT");
                }
                */


                /* 
                Material mat = m_uiRenderer.GetMaterial();
                if (mat.HasProperty(ShaderUtilities.ID_MaskCoord))
                {
                   mat.EnableKeyword("MASK_OFF");
                   mat.DisableKeyword("MASK_HARD");
                   mat.DisableKeyword("MASK_SOFT");

                   m_isMaskingEnabled = false;
                   UpdateMask();
                }
                */
            },
            /*TMPro.TextMeshProUGUI.DisableMasking end.*/

            /*TMPro.TextMeshProUGUI.UpdateMask start.*/
            UpdateMask: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#UpdateMask", this ); }

                //Debug.Log("Updating Mask...");

                if (UnityEngine.Component.op_Inequality(this.m_rectTransform, null)) {
                    //Material mat = m_uiRenderer.GetMaterial();
                    //if (mat == null || (m_overflowMode == TextOverflowModes.ScrollRect && m_isScrollRegionSet))
                    //    return;

                    if (!TMPro.ShaderUtilities.isInitialized) {
                        TMPro.ShaderUtilities.GetShaderPropertyIDs();
                    }

                    //Debug.Log("Setting Mask for the first time.");

                    this.m_isScrollRegionSet = true;

                    var softnessX = UnityEngine.Mathf.Min(UnityEngine.Mathf.Min(this.m_margin.x, this.m_margin.z), this.m_sharedMaterial.GetFloat(TMPro.ShaderUtilities.ID_MaskSoftnessX));
                    var softnessY = UnityEngine.Mathf.Min(UnityEngine.Mathf.Min(this.m_margin.y, this.m_margin.w), this.m_sharedMaterial.GetFloat(TMPro.ShaderUtilities.ID_MaskSoftnessY));

                    softnessX = softnessX > 0 ? softnessX : 0;
                    softnessY = softnessY > 0 ? softnessY : 0;

                    var width = (this.m_rectTransform.rect.width - UnityEngine.Mathf.Max(this.m_margin.x, 0) - UnityEngine.Mathf.Max(this.m_margin.z, 0)) / 2 + softnessX;
                    var height = (this.m_rectTransform.rect.height - UnityEngine.Mathf.Max(this.m_margin.y, 0) - UnityEngine.Mathf.Max(this.m_margin.w, 0)) / 2 + softnessY;


                    var center = UnityEngine.Vector2.FromVector3(this.m_rectTransform.localPosition.$clone().add( new pc.Vec3( (0.5 - this.m_rectTransform.pivot.x) * this.m_rectTransform.rect.width + (UnityEngine.Mathf.Max(this.m_margin.x, 0) - UnityEngine.Mathf.Max(this.m_margin.z, 0)) / 2, (0.5 - this.m_rectTransform.pivot.y) * this.m_rectTransform.rect.height + (-UnityEngine.Mathf.Max(this.m_margin.y, 0) + UnityEngine.Mathf.Max(this.m_margin.w, 0)) / 2, 0 ) ));

                    //Vector2 center = m_rectTransform.localPosition + new Vector3((0.5f - m_rectTransform.pivot.x) * m_rectTransform.rect.width + (margin.x - margin.z) / 2, (0.5f - m_rectTransform.pivot.y) * m_rectTransform.rect.height + (-margin.y + margin.w) / 2);
                    var mask = new pc.Vec4( center.x, center.y, width, height );
                    //Debug.Log(mask);


                    //Rect rect = new Rect(0, 0, m_rectTransform.rect.width + margin.x + margin.z, m_rectTransform.rect.height + margin.y + margin.w);
                    //int softness = (int)m_sharedMaterial.GetFloat(ShaderUtilities.ID_MaskSoftnessX) / 2;
                    this.m_sharedMaterial.SetVector(TMPro.ShaderUtilities.ID_ClipRect, mask.$clone());
                }
            },
            /*TMPro.TextMeshProUGUI.UpdateMask end.*/

            /*TMPro.TextMeshProUGUI.GetMaterial start.*/
            GetMaterial: function (mat) {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#GetMaterial", this ); }

                // Get Shader PropertyIDs if they haven't been cached already.
                TMPro.ShaderUtilities.GetShaderPropertyIDs();

                // Check in case Object is disabled. If so, we don't have a valid reference to the Renderer.
                // This can occur when the Duplicate Material Context menu is used on an inactive object.
                //if (m_canvasRenderer == null)
                //    m_canvasRenderer = GetComponent<CanvasRenderer>();

                // Create Instance Material only if the new material is not the same instance previously used.
                if (this.m_fontMaterial == null || this.m_fontMaterial.GetInstanceID() !== mat.GetInstanceID()) {
                    this.m_fontMaterial = this.CreateMaterialInstance(mat);
                }

                this.m_sharedMaterial = this.m_fontMaterial;

                this.m_padding = this.GetPaddingForMaterial();

                this.m_ShouldRecalculateStencil = true;
                this.SetVerticesDirty();
                this.SetMaterialDirty();

                return this.m_sharedMaterial;
            },
            /*TMPro.TextMeshProUGUI.GetMaterial end.*/

            /*TMPro.TextMeshProUGUI.GetMaterials start.*/
            /**
             * Method returning instances of the materials used by the text object.
             *
             * @instance
             * @protected
             * @override
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @param   {Array.<UnityEngine.Material>}    mats
             * @return  {Array.<UnityEngine.Material>}
             */
            GetMaterials: function (mats) {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#GetMaterials", this ); }

                var materialCount = this.m_textInfo.materialCount;

                if (this.m_fontMaterials == null) {
                    this.m_fontMaterials = System.Array.init(materialCount, null, UnityEngine.Material);
                } else if (this.m_fontMaterials.length !== materialCount) {
                    TMPro.TMP_TextInfo.Resize$1(UnityEngine.Material, Bridge.ref(this, "m_fontMaterials"), materialCount, false);
                }

                // Get instances of the materials
                for (var i = 0; i < materialCount; i++) {
                    if (i === 0) {
                        this.m_fontMaterials[i] = this.fontMaterial;
                    } else {
                        this.m_fontMaterials[i] = this.m_subTextObjects[i].material;
                    }
                }

                this.m_fontSharedMaterials = this.m_fontMaterials;

                return this.m_fontMaterials;
            },
            /*TMPro.TextMeshProUGUI.GetMaterials end.*/

            /*TMPro.TextMeshProUGUI.SetSharedMaterial start.*/
            SetSharedMaterial: function (mat) {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#SetSharedMaterial", this ); }

                // Check in case Object is disabled. If so, we don't have a valid reference to the Renderer.
                // This can occur when the Duplicate Material Context menu is used on an inactive object.
                //if (m_canvasRenderer == null)
                //    m_canvasRenderer = GetComponent<CanvasRenderer>();

                this.m_sharedMaterial = mat;

                this.m_padding = this.GetPaddingForMaterial();

                this.SetMaterialDirty();
            },
            /*TMPro.TextMeshProUGUI.SetSharedMaterial end.*/

            /*TMPro.TextMeshProUGUI.GetSharedMaterials start.*/
            /**
             * Method returning an array containing the materials used by the text object.
             *
             * @instance
             * @protected
             * @override
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @return  {Array.<UnityEngine.Material>}
             */
            GetSharedMaterials: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#GetSharedMaterials", this ); }

                var materialCount = this.m_textInfo.materialCount;

                if (this.m_fontSharedMaterials == null) {
                    this.m_fontSharedMaterials = System.Array.init(materialCount, null, UnityEngine.Material);
                } else if (this.m_fontSharedMaterials.length !== materialCount) {
                    TMPro.TMP_TextInfo.Resize$1(UnityEngine.Material, Bridge.ref(this, "m_fontSharedMaterials"), materialCount, false);
                }

                for (var i = 0; i < materialCount; i++) {
                    if (i === 0) {
                        this.m_fontSharedMaterials[i] = this.m_sharedMaterial;
                    } else {
                        this.m_fontSharedMaterials[i] = this.m_subTextObjects[i].sharedMaterial;
                    }
                }

                return this.m_fontSharedMaterials;
            },
            /*TMPro.TextMeshProUGUI.GetSharedMaterials end.*/

            /*TMPro.TextMeshProUGUI.SetSharedMaterials start.*/
            /**
             * Method used to assign new materials to the text and sub text objects.
             *
             * @instance
             * @protected
             * @override
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @param   {Array.<UnityEngine.Material>}    materials
             * @return  {void}
             */
            SetSharedMaterials: function (materials) {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#SetSharedMaterials", this ); }

                var $t, $t1;
                var materialCount = this.m_textInfo.materialCount;

                // Check allocation of the fontSharedMaterials array.
                if (this.m_fontSharedMaterials == null) {
                    this.m_fontSharedMaterials = System.Array.init(materialCount, null, UnityEngine.Material);
                } else if (this.m_fontSharedMaterials.length !== materialCount) {
                    TMPro.TMP_TextInfo.Resize$1(UnityEngine.Material, Bridge.ref(this, "m_fontSharedMaterials"), materialCount, false);
                }

                // Only assign as many materials as the text object contains.
                for (var i = 0; i < materialCount; i++) {
                    if (i === 0) {
                        // Only assign new material if the font atlas textures match.
                        if (materials[i].GetTexture(TMPro.ShaderUtilities.ID_MainTex) == null || materials[i].GetTexture(TMPro.ShaderUtilities.ID_MainTex).GetInstanceID() !== this.m_sharedMaterial.GetTexture(TMPro.ShaderUtilities.ID_MainTex).GetInstanceID()) {
                            continue;
                        }

                        this.m_sharedMaterial = ($t = materials[i], this.m_fontSharedMaterials[i] = $t, $t);
                        this.m_padding = this.GetPaddingForMaterial$1(this.m_sharedMaterial);
                    } else {
                        // Only assign new material if the font atlas textures match.
                        if (materials[i].GetTexture(TMPro.ShaderUtilities.ID_MainTex) == null || materials[i].GetTexture(TMPro.ShaderUtilities.ID_MainTex).GetInstanceID() !== this.m_subTextObjects[i].sharedMaterial.GetTexture(TMPro.ShaderUtilities.ID_MainTex).GetInstanceID()) {
                            continue;
                        }

                        // Only assign a new material if none were specified in the text input.
                        if (this.m_subTextObjects[i].isDefaultMaterial) {
                            this.m_subTextObjects[i].sharedMaterial = ($t1 = materials[i], this.m_fontSharedMaterials[i] = $t1, $t1);
                        }
                    }
                }
            },
            /*TMPro.TextMeshProUGUI.SetSharedMaterials end.*/

            /*TMPro.TextMeshProUGUI.SetOutlineThickness start.*/
            SetOutlineThickness: function (thickness) {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#SetOutlineThickness", this ); }

                // Use material instance if one exists. Otherwise, create a new instance of the shared material.
                if (this.m_fontMaterial != null && this.m_sharedMaterial.GetInstanceID() !== this.m_fontMaterial.GetInstanceID()) {
                    this.m_sharedMaterial = this.m_fontMaterial;
                    this.m_canvasRenderer.SetMaterial$1(this.m_sharedMaterial, this.m_sharedMaterial.GetTexture(TMPro.ShaderUtilities.ID_MainTex));
                } else if (this.m_fontMaterial == null) {
                    this.m_fontMaterial = this.CreateMaterialInstance(this.m_sharedMaterial);
                    this.m_sharedMaterial = this.m_fontMaterial;
                    this.m_canvasRenderer.SetMaterial$1(this.m_sharedMaterial, this.m_sharedMaterial.GetTexture(TMPro.ShaderUtilities.ID_MainTex));
                }

                thickness = Math.max(0, Math.min(1, thickness));
                this.m_sharedMaterial.SetFloat(TMPro.ShaderUtilities.ID_OutlineWidth, thickness);
                this.m_padding = this.GetPaddingForMaterial();
            },
            /*TMPro.TextMeshProUGUI.SetOutlineThickness end.*/

            /*TMPro.TextMeshProUGUI.SetFaceColor start.*/
            SetFaceColor: function (color) {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#SetFaceColor", this ); }

                // Use material instance if one exists. Otherwise, create a new instance of the shared material.
                if (this.m_fontMaterial == null) {
                    this.m_fontMaterial = this.CreateMaterialInstance(this.m_sharedMaterial);
                }

                this.m_sharedMaterial = this.m_fontMaterial;
                this.m_padding = this.GetPaddingForMaterial();

                this.m_sharedMaterial.SetColor(TMPro.ShaderUtilities.ID_FaceColor, UnityEngine.Color32.op_Implicit(color.$clone()));
            },
            /*TMPro.TextMeshProUGUI.SetFaceColor end.*/

            /*TMPro.TextMeshProUGUI.SetOutlineColor start.*/
            SetOutlineColor: function (color) {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#SetOutlineColor", this ); }

                // Use material instance if one exists. Otherwise, create a new instance of the shared material.
                if (this.m_fontMaterial == null) {
                    this.m_fontMaterial = this.CreateMaterialInstance(this.m_sharedMaterial);
                }

                this.m_sharedMaterial = this.m_fontMaterial;
                this.m_padding = this.GetPaddingForMaterial();

                this.m_sharedMaterial.SetColor(TMPro.ShaderUtilities.ID_OutlineColor, UnityEngine.Color32.op_Implicit(color.$clone()));
            },
            /*TMPro.TextMeshProUGUI.SetOutlineColor end.*/

            /*TMPro.TextMeshProUGUI.SetShaderDepth start.*/
            SetShaderDepth: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#SetShaderDepth", this ); }

                if (UnityEngine.Component.op_Equality(this.m_canvas, null) || this.m_sharedMaterial == null) {
                    return;
                }

                if (this.m_canvas.renderMode === UnityEngine.RenderMode.ScreenSpaceOverlay || this.m_isOverlay) {
                    // Should this use an instanced material?
                    this.m_sharedMaterial.SetFloat$1(TMPro.ShaderUtilities.ShaderTag_ZTestMode, 0);
                } else {
                    // TODO: This section needs to be tested.
                    this.m_sharedMaterial.SetFloat$1(TMPro.ShaderUtilities.ShaderTag_ZTestMode, 4);
                }
            },
            /*TMPro.TextMeshProUGUI.SetShaderDepth end.*/

            /*TMPro.TextMeshProUGUI.SetCulling start.*/
            SetCulling: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#SetCulling", this ); }

                if (this.m_isCullingEnabled) {
                    var mat = this.materialForRendering;

                    if (mat != null) {
                        mat.SetFloat$1("_CullMode", 2);
                    }

                    for (var i = 1; i < this.m_subTextObjects.length && UnityEngine.MonoBehaviour.op_Inequality(this.m_subTextObjects[i], null); i++) {
                        mat = this.m_subTextObjects[i].materialForRendering;

                        if (mat != null) {
                            mat.SetFloat$1(TMPro.ShaderUtilities.ShaderTag_CullMode, 2);
                        }
                    }
                } else {
                    var mat1 = this.materialForRendering;

                    if (mat1 != null) {
                        mat1.SetFloat$1("_CullMode", 0);
                    }

                    for (var i1 = 1; i1 < this.m_subTextObjects.length && UnityEngine.MonoBehaviour.op_Inequality(this.m_subTextObjects[i1], null); i1++) {
                        mat1 = this.m_subTextObjects[i1].materialForRendering;

                        if (mat1 != null) {
                            mat1.SetFloat$1(TMPro.ShaderUtilities.ShaderTag_CullMode, 0);
                        }
                    }
                }
            },
            /*TMPro.TextMeshProUGUI.SetCulling end.*/

            /*TMPro.TextMeshProUGUI.SetPerspectiveCorrection start.*/
            SetPerspectiveCorrection: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#SetPerspectiveCorrection", this ); }

                if (this.m_isOrthographic) {
                    this.m_sharedMaterial.SetFloat(TMPro.ShaderUtilities.ID_PerspectiveFilter, 0.0);
                } else {
                    this.m_sharedMaterial.SetFloat(TMPro.ShaderUtilities.ID_PerspectiveFilter, 0.875);
                }
            },
            /*TMPro.TextMeshProUGUI.SetPerspectiveCorrection end.*/

            /*TMPro.TextMeshProUGUI.SetMeshArrays start.*/
            SetMeshArrays: function (size) {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#SetMeshArrays", this ); }

                var $t, $t1;
                ($t = this.m_textInfo.meshInfo)[0].ResizeMeshInfo(size);

                this.m_canvasRenderer.SetMesh(($t1 = this.m_textInfo.meshInfo)[0].mesh);
            },
            /*TMPro.TextMeshProUGUI.SetMeshArrays end.*/

            /*TMPro.TextMeshProUGUI.SetArraySizes start.*/
            SetArraySizes: function (unicodeChars) {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#SetArraySizes", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20, $t21, $t22, $t23, $t24, $t25, $t26, $t27, $t28, $t29, $t30, $t31, $t32, $t33;
                var spriteCount = 0;

                this.m_totalCharacterCount = 0;
                this.m_isUsingBold = false;
                this.m_isParsingText = false;
                this.tag_NoParsing = false;
                this.m_FontStyleInternal = this.m_fontStyle;
                this.m_fontStyleStack.Clear();

                this.m_FontWeightInternal = (this.m_FontStyleInternal & TMPro.FontStyles.Bold) === TMPro.FontStyles.Bold ? TMPro.FontWeight.Bold : this.m_fontWeight;
                this.m_FontWeightStack.SetDefault(this.m_FontWeightInternal);

                this.m_currentFontAsset = this.m_fontAsset;
                this.m_currentMaterial = this.m_sharedMaterial;
                this.m_currentMaterialIndex = 0;

                TMPro.TMP_Text.m_materialReferenceStack.SetDefault(new TMPro.MaterialReference.$ctor1(this.m_currentMaterialIndex, this.m_currentFontAsset, null, this.m_currentMaterial, this.m_padding));

                TMPro.TMP_Text.m_materialReferenceIndexLookup.clear();
                TMPro.MaterialReference.AddMaterialReference(this.m_currentMaterial, this.m_currentFontAsset, Bridge.ref(TMPro.TMP_Text, "m_materialReferences"), TMPro.TMP_Text.m_materialReferenceIndexLookup);

                // Set allocations for the text object's TextInfo
                if (this.m_textInfo == null) {
                    this.m_textInfo = new TMPro.TMP_TextInfo.$ctor1(this.m_InternalTextProcessingArraySize);
                } else if (this.m_textInfo.characterInfo.length < this.m_InternalTextProcessingArraySize) {
                    TMPro.TMP_TextInfo.Resize$1(TMPro.TMP_CharacterInfo, Bridge.ref(this.m_textInfo, "characterInfo"), this.m_InternalTextProcessingArraySize, false);
                }

                this.m_textElementType = TMPro.TMP_TextElementType.Character;

                // Handling for Underline special character


                /* 
                GetUnderlineSpecialCharacter(m_currentFontAsset);
                if (m_Underline.character != null)
                {
                   if (m_Underline.fontAsset.GetInstanceID() != m_currentFontAsset.GetInstanceID())
                   {
                       if (TMP_Settings.matchMaterialPreset && m_currentMaterial.GetInstanceID() != m_Underline.fontAsset.material.GetInstanceID())
                           m_Underline.material = TMP_MaterialManager.GetFallbackMaterial(m_currentMaterial, m_Underline.fontAsset.material);
                       else
                           m_Underline.material = m_Underline.fontAsset.material;

                       m_Underline.materialIndex = MaterialReference.AddMaterialReference(m_Underline.material, m_Underline.fontAsset, m_materialReferences, m_materialReferenceIndexLookup);
                       m_materialReferences[m_Underline.materialIndex].referenceCount = 0;
                   }
                }
                */



                // Handling for Ellipsis special character


                if (this.m_overflowMode === TMPro.TextOverflowModes.Ellipsis) {
                    this.GetEllipsisSpecialCharacter(this.m_currentFontAsset);

                    if (this.m_Ellipsis.character != null) {
                        if (this.m_Ellipsis.fontAsset.GetInstanceID() !== this.m_currentFontAsset.GetInstanceID()) {
                            if (TMPro.TMP_Settings.matchMaterialPreset && this.m_currentMaterial.GetInstanceID() !== this.m_Ellipsis.fontAsset.material.GetInstanceID()) {
                                this.m_Ellipsis.material = TMPro.TMP_MaterialManager.GetFallbackMaterial(this.m_currentMaterial, this.m_Ellipsis.fontAsset.material);
                            } else {
                                this.m_Ellipsis.material = this.m_Ellipsis.fontAsset.material;
                            }

                            this.m_Ellipsis.materialIndex = TMPro.MaterialReference.AddMaterialReference(this.m_Ellipsis.material, this.m_Ellipsis.fontAsset, Bridge.ref(TMPro.TMP_Text, "m_materialReferences"), TMPro.TMP_Text.m_materialReferenceIndexLookup);
                            TMPro.TMP_Text.m_materialReferences[this.m_Ellipsis.materialIndex].referenceCount = 0;
                        }
                    } else {
                        this.m_overflowMode = TMPro.TextOverflowModes.Truncate;

                        if (!TMPro.TMP_Settings.warningsDisabled) {
                            UnityEngine.Debug.LogWarning$1("The character used for Ellipsis is not available in font asset [" + (this.m_currentFontAsset.name || "") + "] or any potential fallbacks. Switching Text Overflow mode to Truncate.", this);
                        }
                    }
                }



                // Clear Linked Text object content if we have any.
                if (this.m_overflowMode === TMPro.TextOverflowModes.Linked && UnityEngine.MonoBehaviour.op_Inequality(this.m_linkedTextComponent, null) && !this.m_isCalculatingPreferredValues) {
                    var linkedComponent = this.m_linkedTextComponent;

                    while (UnityEngine.MonoBehaviour.op_Inequality(linkedComponent, null)) {
                        linkedComponent.text = "";
                        linkedComponent.ClearMesh();
                        linkedComponent.textInfo.Clear();

                        linkedComponent = linkedComponent.linkedTextComponent;
                    }
                }


                // Parsing XML tags in the text
                for (var i = 0; i < unicodeChars.length && unicodeChars[i].unicode !== 0; i++) {
                    //Make sure the characterInfo array can hold the next text element.
                    if (this.m_textInfo.characterInfo == null || this.m_totalCharacterCount >= this.m_textInfo.characterInfo.length) {
                        TMPro.TMP_TextInfo.Resize$1(TMPro.TMP_CharacterInfo, Bridge.ref(this.m_textInfo, "characterInfo"), this.m_totalCharacterCount + 1, true);
                    }

                    var unicode = unicodeChars[i].unicode;

                    // PARSE XML TAGS


                    if (this.m_isRichText && unicode === 60) {
                        var prev_MaterialIndex = this.m_currentMaterialIndex;
                        var endTagIndex = { };

                        // Check if Tag is Valid
                        if (this.ValidateHtmlTag(unicodeChars, i + 1, endTagIndex)) {
                            var tagStartIndex = unicodeChars[i].stringIndex;
                            i = endTagIndex.v;

                            if ((this.m_FontStyleInternal & TMPro.FontStyles.Bold) === TMPro.FontStyles.Bold) {
                                this.m_isUsingBold = true;
                            }

                            if (this.m_textElementType === TMPro.TMP_TextElementType.Sprite) {
                                TMPro.TMP_Text.m_materialReferences[this.m_currentMaterialIndex].referenceCount += 1;

                                ($t = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].character = 57344 + this.m_spriteIndex;
                                ($t1 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].spriteIndex = this.m_spriteIndex;
                                ($t2 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].fontAsset = this.m_currentFontAsset;
                                ($t3 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].spriteAsset = this.m_currentSpriteAsset;
                                ($t4 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].materialReferenceIndex = this.m_currentMaterialIndex;
                                ($t5 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].textElement = this.m_currentSpriteAsset.spriteCharacterTable.getItem(this.m_spriteIndex);
                                ($t6 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].elementType = this.m_textElementType;
                                ($t7 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].index = tagStartIndex;
                                ($t8 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].stringLength = unicodeChars[i].stringIndex - tagStartIndex + 1;

                                // Restore element type and material index to previous values.
                                this.m_textElementType = TMPro.TMP_TextElementType.Character;
                                this.m_currentMaterialIndex = prev_MaterialIndex;

                                spriteCount += 1;
                                this.m_totalCharacterCount += 1;
                            }

                            continue;
                        }
                    }


                    var isUsingAlternativeTypeface = { v : false };
                    var isUsingFallbackOrAlternativeTypeface = false;

                    var prev_fontAsset = this.m_currentFontAsset;
                    var prev_material = this.m_currentMaterial;
                    var prev_materialIndex = this.m_currentMaterialIndex;

                    // Handle Font Styles like LowerCase, UpperCase and SmallCaps.


                    if (this.m_textElementType === TMPro.TMP_TextElementType.Character) {
                        if ((this.m_FontStyleInternal & TMPro.FontStyles.UpperCase) === TMPro.FontStyles.UpperCase) {
                            // If this character is lowercase, switch to uppercase.
                            if (Bridge.isLower(unicode)) {
                                unicode = String.fromCharCode(unicode).toUpperCase().charCodeAt(0);
                            }
                        } else if ((this.m_FontStyleInternal & TMPro.FontStyles.LowerCase) === TMPro.FontStyles.LowerCase) {
                            // If this character is uppercase, switch to lowercase.
                            if (Bridge.isUpper(unicode)) {
                                unicode = String.fromCharCode(unicode).toLowerCase().charCodeAt(0);
                            }
                        } else if ((this.m_FontStyleInternal & TMPro.FontStyles.SmallCaps) === TMPro.FontStyles.SmallCaps) {
                            // Only convert lowercase characters to uppercase.
                            if (Bridge.isLower(unicode)) {
                                unicode = String.fromCharCode(unicode).toUpperCase().charCodeAt(0);
                            }
                        }
                    }


                    // Lookup the Glyph data for each character and cache it.


                    var character = this.GetTextElement(unicode, this.m_currentFontAsset, this.m_FontStyleInternal, this.m_FontWeightInternal, isUsingAlternativeTypeface);

                    // Check if Lowercase or Uppercase variant of the character is available.
                    /* Not sure this is necessary anyone as it is very unlikely with recursive search through fallback fonts.
                    if (glyph == null)
                    {
                       if (char.IsLower((char)c))
                       {
                           if (m_currentFontAsset.characterDictionary.TryGetValue(char.ToUpper((char)c), out glyph))
                               c = chars[i] = char.ToUpper((char)c);
                       }
                       else if (char.IsUpper((char)c))
                       {
                           if (m_currentFontAsset.characterDictionary.TryGetValue(char.ToLower((char)c), out glyph))
                               c = chars[i] = char.ToLower((char)c);
                       }
                    }*/

                    // Special handling for missing character.
                    // Replace missing glyph by the Square (9633) glyph or possibly the Space (32) glyph.
                    if (character == null) {
                        // Save the original unicode character
                        var srcGlyph = unicode;

                        // Try replacing the missing glyph character by TMP Settings Missing Glyph or Square (9633) character.
                        unicode = ($t9 = TMPro.TMP_Settings.missingGlyphCharacter === 0 ? 9633 : TMPro.TMP_Settings.missingGlyphCharacter, unicodeChars[i].unicode = $t9, $t9);

                        // Check for the missing glyph character in the currently assigned font asset and its fallbacks
                        character = TMPro.TMP_FontAssetUtilities.GetCharacterFromFontAsset(unicode, this.m_currentFontAsset, true, this.m_FontStyleInternal, this.m_FontWeightInternal, isUsingAlternativeTypeface);

                        if (character == null) {
                            // Search for the missing glyph character in the TMP Settings Fallback list.
                            if (TMPro.TMP_Settings.fallbackFontAssets != null && TMPro.TMP_Settings.fallbackFontAssets.Count > 0) {
                                character = TMPro.TMP_FontAssetUtilities.GetCharacterFromFontAssets(unicode, this.m_currentFontAsset, TMPro.TMP_Settings.fallbackFontAssets, true, this.m_FontStyleInternal, this.m_FontWeightInternal, isUsingAlternativeTypeface);
                            }
                        }

                        if (character == null) {
                            // Search for the missing glyph in the TMP Settings Default Font Asset.
                            if (TMPro.TMP_Settings.defaultFontAsset != null) {
                                character = TMPro.TMP_FontAssetUtilities.GetCharacterFromFontAsset(unicode, TMPro.TMP_Settings.defaultFontAsset, true, this.m_FontStyleInternal, this.m_FontWeightInternal, isUsingAlternativeTypeface);
                            }
                        }

                        if (character == null) {
                            // Use Space (32) Glyph from the currently assigned font asset.
                            unicode = (unicodeChars[i].unicode = 32, 32);
                            character = TMPro.TMP_FontAssetUtilities.GetCharacterFromFontAsset(unicode, this.m_currentFontAsset, true, this.m_FontStyleInternal, this.m_FontWeightInternal, isUsingAlternativeTypeface);
                        }

                        if (character == null) {
                            // Use End of Text (0x03) Glyph from the currently assigned font asset.
                            unicode = (unicodeChars[i].unicode = 3, 3);
                            character = TMPro.TMP_FontAssetUtilities.GetCharacterFromFontAsset(unicode, this.m_currentFontAsset, true, this.m_FontStyleInternal, this.m_FontWeightInternal, isUsingAlternativeTypeface);
                        }

                        if (!TMPro.TMP_Settings.warningsDisabled) {
                            var formattedWarning = srcGlyph > 65535 ? System.String.format("The character with Unicode value \\U{0:X8} was not found in the [{1}] font asset or any potential fallbacks. It was replaced by Unicode character \\u{2:X4} in text object [{3}].", srcGlyph, this.m_fontAsset.name, character.unicode, this.name) : System.String.format("The character with Unicode value \\u{0:X4} was not found in the [{1}] font asset or any potential fallbacks. It was replaced by Unicode character \\u{2:X4} in text object [{3}].", srcGlyph, this.m_fontAsset.name, character.unicode, this.name);

                            UnityEngine.Debug.LogWarning$1(formattedWarning, this);
                        }
                    }

                    if (character.elementType === TMPro.TextElementType.Character) {
                        if (character.textAsset.instanceID !== this.m_currentFontAsset.instanceID) {
                            isUsingFallbackOrAlternativeTypeface = true;
                            this.m_currentFontAsset = Bridge.as(character.textAsset, TMPro.TMP_FontAsset);
                        }
                    }


                    // Save text element data
                    ($t10 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].elementType = TMPro.TMP_TextElementType.Character;
                    ($t11 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].textElement = character;
                    ($t12 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].isUsingAlternateTypeface = isUsingAlternativeTypeface.v;
                    ($t13 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].character = unicode;
                    ($t14 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].index = unicodeChars[i].stringIndex;
                    ($t15 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].stringLength = unicodeChars[i].length;
                    ($t16 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].fontAsset = this.m_currentFontAsset;

                    // Special handling if the character is a sprite.
                    if (character.elementType === TMPro.TextElementType.Sprite) {
                        var spriteAssetRef = Bridge.as(character.textAsset, TMPro.TMP_SpriteAsset);
                        this.m_currentMaterialIndex = TMPro.MaterialReference.AddMaterialReference$1(spriteAssetRef.material, spriteAssetRef, Bridge.ref(TMPro.TMP_Text, "m_materialReferences"), TMPro.TMP_Text.m_materialReferenceIndexLookup);
                        TMPro.TMP_Text.m_materialReferences[this.m_currentMaterialIndex].referenceCount += 1;

                        ($t17 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].elementType = TMPro.TMP_TextElementType.Sprite;
                        ($t18 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].materialReferenceIndex = this.m_currentMaterialIndex;
                        ($t19 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].spriteAsset = spriteAssetRef;
                        ($t20 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].spriteIndex = character.glyphIndex;

                        // Restore element type and material index to previous values.
                        this.m_textElementType = TMPro.TMP_TextElementType.Character;
                        this.m_currentMaterialIndex = prev_materialIndex;

                        spriteCount += 1;
                        this.m_totalCharacterCount += 1;

                        continue;
                    }

                    if (isUsingFallbackOrAlternativeTypeface && this.m_currentFontAsset.instanceID !== this.m_fontAsset.instanceID) {
                        // Create Fallback material instance matching current material preset if necessary
                        if (TMPro.TMP_Settings.matchMaterialPreset) {
                            this.m_currentMaterial = TMPro.TMP_MaterialManager.GetFallbackMaterial(this.m_currentMaterial, this.m_currentFontAsset.material);
                        } else {
                            this.m_currentMaterial = this.m_currentFontAsset.material;
                        }

                        this.m_currentMaterialIndex = TMPro.MaterialReference.AddMaterialReference(this.m_currentMaterial, this.m_currentFontAsset, Bridge.ref(TMPro.TMP_Text, "m_materialReferences"), TMPro.TMP_Text.m_materialReferenceIndexLookup);
                    }

                    // Handle Multi Atlas Texture support
                    if (character != null && character.glyph.atlasIndex > 0) {
                        this.m_currentMaterial = TMPro.TMP_MaterialManager.GetFallbackMaterial$1(this.m_currentFontAsset, this.m_currentMaterial, character.glyph.atlasIndex);

                        this.m_currentMaterialIndex = TMPro.MaterialReference.AddMaterialReference(this.m_currentMaterial, this.m_currentFontAsset, Bridge.ref(TMPro.TMP_Text, "m_materialReferences"), TMPro.TMP_Text.m_materialReferenceIndexLookup);

                        isUsingFallbackOrAlternativeTypeface = true;
                    }

                    if (!System.Char.isWhiteSpace(String.fromCharCode(unicode)) && unicode !== 8203) {
                        // Limit the mesh of the main text object to 65535 vertices and use sub objects for the overflow.
                        if (TMPro.TMP_Text.m_materialReferences[this.m_currentMaterialIndex].referenceCount < 16383) {
                            TMPro.TMP_Text.m_materialReferences[this.m_currentMaterialIndex].referenceCount += 1;
                        } else {
                            this.m_currentMaterialIndex = TMPro.MaterialReference.AddMaterialReference(new UnityEngine.Material.$ctor1(this.m_currentMaterial), this.m_currentFontAsset, Bridge.ref(TMPro.TMP_Text, "m_materialReferences"), TMPro.TMP_Text.m_materialReferenceIndexLookup);
                            TMPro.TMP_Text.m_materialReferences[this.m_currentMaterialIndex].referenceCount += 1;
                        }
                    }

                    ($t21 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].material = this.m_currentMaterial;
                    ($t22 = this.m_textInfo.characterInfo)[this.m_totalCharacterCount].materialReferenceIndex = this.m_currentMaterialIndex;
                    TMPro.TMP_Text.m_materialReferences[this.m_currentMaterialIndex].isFallbackMaterial = isUsingFallbackOrAlternativeTypeface;

                    // Restore previous font asset and material if fallback font was used.
                    if (isUsingFallbackOrAlternativeTypeface) {
                        TMPro.TMP_Text.m_materialReferences[this.m_currentMaterialIndex].fallbackMaterial = prev_material;
                        this.m_currentFontAsset = prev_fontAsset;
                        this.m_currentMaterial = prev_material;
                        this.m_currentMaterialIndex = prev_materialIndex;
                    }

                    this.m_totalCharacterCount += 1;
                }

                // Early return if we are calculating the preferred values.
                if (this.m_isCalculatingPreferredValues) {
                    this.m_isCalculatingPreferredValues = false;

                    return this.m_totalCharacterCount;
                }

                // Save material and sprite count.
                this.m_textInfo.spriteCount = spriteCount;
                var materialCount = ($t23 = TMPro.TMP_Text.m_materialReferenceIndexLookup.Count, this.m_textInfo.materialCount = $t23, $t23);

                // Check if we need to resize the MeshInfo array for handling different materials.
                if (materialCount > this.m_textInfo.meshInfo.length) {
                    TMPro.TMP_TextInfo.Resize$1(TMPro.TMP_MeshInfo, Bridge.ref(this.m_textInfo, "meshInfo"), materialCount, false);
                }

                // Resize SubTextObject array if necessary
                if (materialCount > this.m_subTextObjects.length) {
                    TMPro.TMP_TextInfo.Resize(TMPro.TMP_SubMeshUI, Bridge.ref(this, "m_subTextObjects"), UnityEngine.Mathf.NextPowerOfTwo(materialCount + 1));
                }

                // Resize CharacterInfo[] if allocations are excessive
                if (this.m_VertexBufferAutoSizeReduction && this.m_textInfo.characterInfo.length - this.m_totalCharacterCount > 256) {
                    TMPro.TMP_TextInfo.Resize$1(TMPro.TMP_CharacterInfo, Bridge.ref(this.m_textInfo, "characterInfo"), UnityEngine.Mathf.Max(this.m_totalCharacterCount + 1, 256), true);
                }


                // Iterate through the material references to set the mesh buffer allocations
                for (var i1 = 0; i1 < materialCount; i1++) {
                    // Add new sub text object for each material reference
                    if (i1 > 0) {
                        if (UnityEngine.MonoBehaviour.op_Equality(this.m_subTextObjects[i1], null)) {
                            this.m_subTextObjects[i1] = TMPro.TMP_SubMeshUI.AddSubTextObject(this, TMPro.TMP_Text.m_materialReferences[i1].$clone());

                            // Not sure this is necessary
                            ($t24 = this.m_textInfo.meshInfo)[i1].vertices = null;
                        }
                        //else if (m_subTextObjects[i].gameObject.activeInHierarchy == false)
                        //    m_subTextObjects[i].gameObject.SetActive(true);

                        // Make sure the pivots are synchronized
                        if (!pc.Vec2.equals( this.m_rectTransform.pivot, this.m_subTextObjects[i1].rectTransform.pivot )) {
                            this.m_subTextObjects[i1].rectTransform.pivot = this.m_rectTransform.pivot.$clone();
                        }

                        // Check if the material has changed.
                        if (this.m_subTextObjects[i1].sharedMaterial == null || this.m_subTextObjects[i1].sharedMaterial.GetInstanceID() !== TMPro.TMP_Text.m_materialReferences[i1].material.GetInstanceID()) {
                            this.m_subTextObjects[i1].sharedMaterial = TMPro.TMP_Text.m_materialReferences[i1].material;
                            this.m_subTextObjects[i1].fontAsset = TMPro.TMP_Text.m_materialReferences[i1].fontAsset;
                            this.m_subTextObjects[i1].spriteAsset = TMPro.TMP_Text.m_materialReferences[i1].spriteAsset;
                        }

                        // Check if we need to use a Fallback Material
                        if (TMPro.TMP_Text.m_materialReferences[i1].isFallbackMaterial) {
                            this.m_subTextObjects[i1].fallbackMaterial = TMPro.TMP_Text.m_materialReferences[i1].material;
                            this.m_subTextObjects[i1].fallbackSourceMaterial = TMPro.TMP_Text.m_materialReferences[i1].fallbackMaterial;
                        }
                    }

                    var referenceCount = TMPro.TMP_Text.m_materialReferences[i1].referenceCount;

                    // Check to make sure our buffers allocations can accommodate the required text elements.
                    if (($t25 = this.m_textInfo.meshInfo)[i1].vertices == null || ($t26 = this.m_textInfo.meshInfo)[i1].vertices.length < referenceCount * 4) {
                        if (($t27 = this.m_textInfo.meshInfo)[i1].vertices == null) {
                            if (i1 === 0) {
                                ($t28 = this.m_textInfo.meshInfo)[i1] = new TMPro.TMP_MeshInfo.$ctor1(this.m_mesh, referenceCount + 1);
                            } else {
                                ($t29 = this.m_textInfo.meshInfo)[i1] = new TMPro.TMP_MeshInfo.$ctor1(this.m_subTextObjects[i1].mesh, referenceCount + 1);
                            }
                        } else {
                            ($t30 = this.m_textInfo.meshInfo)[i1].ResizeMeshInfo(referenceCount > 1024 ? referenceCount + 256 : UnityEngine.Mathf.NextPowerOfTwo(referenceCount + 1));
                        }
                    } else if (this.m_VertexBufferAutoSizeReduction && referenceCount > 0 && ($t31 = this.m_textInfo.meshInfo)[i1].vertices.length / 4 - referenceCount > 256) {
                        // Resize vertex buffers if allocations are excessive.
                        //Debug.Log("Reducing the size of the vertex buffers.");
                        ($t32 = this.m_textInfo.meshInfo)[i1].ResizeMeshInfo(referenceCount > 1024 ? referenceCount + 256 : UnityEngine.Mathf.NextPowerOfTwo(referenceCount + 1));
                    }

                    // Assign material reference
                    ($t33 = this.m_textInfo.meshInfo)[i1].material = TMPro.TMP_Text.m_materialReferences[i1].material;
                }

                //TMP_MaterialManager.CleanupFallbackMaterials();

                // Clean up unused SubMeshes
                for (var i2 = materialCount; i2 < this.m_subTextObjects.length && UnityEngine.MonoBehaviour.op_Inequality(this.m_subTextObjects[i2], null); i2++) {
                    if (i2 < this.m_textInfo.meshInfo.length) {
                        this.m_subTextObjects[i2].canvasRenderer.SetMesh(null);

                        // TODO: Figure out a way to handle this without running into Unity's Rebuild loop issue.
                        //m_subTextObjects[i].gameObject.SetActive(false);
                    }
                }

                return this.m_totalCharacterCount;
            },
            /*TMPro.TextMeshProUGUI.SetArraySizes end.*/

            /*TMPro.TextMeshProUGUI.ComputeMarginSize start.*/
            /**
             * Update the margin width and height
             *
             * @instance
             * @public
             * @override
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @return  {void}
             */
            ComputeMarginSize: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#ComputeMarginSize", this ); }

                if (UnityEngine.Component.op_Inequality(this.rectTransform$1, null)) {
                    //Debug.Log("*** ComputeMarginSize() *** Current RectTransform's Width is " + m_rectTransform.rect.width + " and Height is " + m_rectTransform.rect.height); // + " and size delta is "  + m_rectTransform.sizeDelta);
                    var rect = this.m_rectTransform.rect.$clone();

                    this.m_marginWidth = rect.width - this.m_margin.x - this.m_margin.z;
                    this.m_marginHeight = rect.height - this.m_margin.y - this.m_margin.w;

                    // Cache current RectTransform width and pivot referenced in OnRectTransformDimensionsChange() to get around potential rounding error in the reported width of the RectTransform.
                    this.m_PreviousRectTransformSize = rect.size.$clone();
                    this.m_PreviousPivotPosition = this.m_rectTransform.pivot.$clone();

                    // Update the corners of the RectTransform
                    this.m_RectTransformCorners = this.GetTextContainerLocalCorners();
                }
            },
            /*TMPro.TextMeshProUGUI.ComputeMarginSize end.*/

            /*TMPro.TextMeshProUGUI.OnDidApplyAnimationProperties start.*/
            /**
             * @instance
             * @protected
             * @override
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @return  {void}
             */
            OnDidApplyAnimationProperties: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#OnDidApplyAnimationProperties", this ); }

                this.m_havePropertiesChanged = true;
                this.SetVerticesDirty();
                this.SetLayoutDirty();
                //Debug.Log("Animation Properties have changed.");
            },
            /*TMPro.TextMeshProUGUI.OnDidApplyAnimationProperties end.*/

            /*TMPro.TextMeshProUGUI.OnCanvasHierarchyChanged start.*/
            OnCanvasHierarchyChanged: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#OnCanvasHierarchyChanged", this ); }

                TMPro.TMP_Text.prototype.OnCanvasHierarchyChanged.call(this);

                this.m_canvas = this.canvas;

                if (!this.m_isAwake || !this.isActiveAndEnabled) {
                    return;
                }

                // Special handling to stop InternalUpdate calls when parent Canvas is disabled.
                if (UnityEngine.Component.op_Equality(this.m_canvas, null) || this.m_canvas.enabled === false) {
                    TMPro.TMP_UpdateManager.UnRegisterTextObjectForUpdate(this);
                } else if (this.m_IsTextObjectScaleStatic === false) {
                    TMPro.TMP_UpdateManager.RegisterTextObjectForUpdate(this);
                }
            },
            /*TMPro.TextMeshProUGUI.OnCanvasHierarchyChanged end.*/

            /*TMPro.TextMeshProUGUI.OnTransformParentChanged start.*/
            OnTransformParentChanged: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#OnTransformParentChanged", this ); }

                //Debug.Log("***** OnTransformParentChanged *****");

                TMPro.TMP_Text.prototype.OnTransformParentChanged.call(this);

                this.m_canvas = this.canvas;

                this.ComputeMarginSize();
                this.m_havePropertiesChanged = true;
            },
            /*TMPro.TextMeshProUGUI.OnTransformParentChanged end.*/

            /*TMPro.TextMeshProUGUI.OnRectTransformDimensionsChange start.*/
            OnRectTransformDimensionsChange: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#OnRectTransformDimensionsChange", this ); }

                //Debug.Log("*** OnRectTransformDimensionsChange() *** ActiveInHierarchy: " + this.gameObject.activeInHierarchy + "  Frame: " + Time.frameCount);

                // Make sure object is active in Hierarchy
                if (!this.gameObject.activeInHierarchy) {
                    return;
                }

                // Check if Canvas scale factor has changed as this requires an update of the SDF Scale.
                var hasCanvasScaleFactorChanged = false;
                if (UnityEngine.Component.op_Inequality(this.m_canvas, null) && this.m_CanvasScaleFactor !== this.m_canvas.scaleFactor) {
                    this.m_CanvasScaleFactor = this.m_canvas.scaleFactor;
                    hasCanvasScaleFactorChanged = true;
                }

                // Ignore changes to RectTransform SizeDelta that are very small and typically the result of rounding errors when using RectTransform in Anchor Stretch mode.
                if (hasCanvasScaleFactorChanged === false && UnityEngine.Component.op_Inequality(this.rectTransform$1, null) && Math.abs(this.m_rectTransform.rect.width - this.m_PreviousRectTransformSize.x) < 0.0001 && Math.abs(this.m_rectTransform.rect.height - this.m_PreviousRectTransformSize.y) < 0.0001 && Math.abs(this.m_rectTransform.pivot.x - this.m_PreviousPivotPosition.x) < 0.0001 && Math.abs(this.m_rectTransform.pivot.y - this.m_PreviousPivotPosition.y) < 0.0001) {
                    return;
                }

                this.ComputeMarginSize();

                this.UpdateSubObjectPivot();

                this.SetVerticesDirty();
                this.SetLayoutDirty();
            },
            /*TMPro.TextMeshProUGUI.OnRectTransformDimensionsChange end.*/

            /*TMPro.TextMeshProUGUI.InternalUpdate start.*/
            /**
             * Function used as a replacement for LateUpdate to check if the transform or scale of the text object has changed.
             *
             * @instance
             * @override
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @return  {void}
             */
            InternalUpdate: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#InternalUpdate", this ); }

                // We need to update the SDF scale or possibly regenerate the text object if lossy scale has changed.
                if (this.m_havePropertiesChanged === false) {
                    var lossyScaleY = this.m_rectTransform.lossyScale.y;

                    // Ignore very small lossy scale changes as their effect on SDF Scale would not be visually noticeable.
                    // Do not update SDF Scale if the text is null or empty
                    if (Math.abs(lossyScaleY - this.m_previousLossyScaleY) > 0.0001 && this.m_TextProcessingArray[0].unicode !== 0) {
                        var scaleDelta = lossyScaleY / this.m_previousLossyScaleY;

                        this.UpdateSDFScale(scaleDelta);

                        this.m_previousLossyScaleY = lossyScaleY;
                    }
                }

                // Added to handle legacy animation mode.
                if (this.m_isUsingLegacyAnimationComponent) {
                    //if (m_havePropertiesChanged)
                    this.m_havePropertiesChanged = true;
                    this.OnPreRenderCanvas();
                }
            },
            /*TMPro.TextMeshProUGUI.InternalUpdate end.*/

            /*TMPro.TextMeshProUGUI.OnPreRenderCanvas start.*/
            /**
             * Function called when the text needs to be updated.
             *
             * @instance
             * @private
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @return  {void}
             */
            OnPreRenderCanvas: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#OnPreRenderCanvas", this ); }

                //Debug.Log("*** OnPreRenderCanvas() *** Frame: " + Time.frameCount);

                // Make sure object is active and that we have a valid Canvas.
                if (!this.m_isAwake || this.IsActive() === false && this.m_ignoreActiveState === false) {
                    return;
                }

                if (UnityEngine.Component.op_Equality(this.m_canvas, null)) {
                    this.m_canvas = this.canvas;
                    if (UnityEngine.Component.op_Equality(this.m_canvas, null)) {
                        return;
                    }
                }

                // Check if we have a font asset assigned. Return if we don't because no one likes to see purple squares on screen.
                if (this.m_fontAsset == null) {
                    UnityEngine.Debug.LogWarning$1("Please assign a Font Asset to this " + (this.transform$1.name || "") + " gameobject.", this);
                    return;
                }

                if (this.m_havePropertiesChanged || this.m_isLayoutDirty) {
                    //Debug.Log("Properties have changed!"); // Assigned Material is:" + m_sharedMaterial); // New Text is: " + m_text + ".");

                    // Update mesh padding if necessary.
                    if (this.checkPaddingRequired) {
                        this.UpdateMeshPadding();
                    }

                    // Reparse the text as input may have changed or been truncated.
                    this.ParseInputText();
                    TMPro.TMP_FontAsset.UpdateFontFeaturesForFontAssetsInQueue();

                    // Reset Font min / max used with Auto-sizing
                    if (this.m_enableAutoSizing) {
                        this.m_fontSize = Math.max(this.m_fontSizeMin, Math.min(this.m_fontSizeBase, this.m_fontSizeMax));
                    }

                    this.m_maxFontSize = this.m_fontSizeMax;
                    this.m_minFontSize = this.m_fontSizeMin;
                    this.m_lineSpacingDelta = 0;
                    this.m_charWidthAdjDelta = 0;

                    this.m_isTextTruncated = false;

                    this.m_havePropertiesChanged = false;
                    this.m_isLayoutDirty = false;
                    this.m_ignoreActiveState = false;

                    // Reset Text Auto Size iteration tracking.
                    this.m_IsAutoSizePointSizeSet = false;
                    this.m_AutoSizeIterationCount = 0;

                    // The GenerateTextMesh function is potentially called repeatedly when text auto size is enabled.
                    // This is a revised implementation to remove the use of recursion which could potentially result in stack overflow issues.
                    while (this.m_IsAutoSizePointSizeSet === false) {
                        this.GenerateTextMesh();
                        this.m_AutoSizeIterationCount += 1;
                    }
                }
            },
            /*TMPro.TextMeshProUGUI.OnPreRenderCanvas end.*/

            /*TMPro.TextMeshProUGUI.GenerateTextMesh start.*/
            /**
             * This is the main function that is responsible for creating / displaying the text.
             *
             * @instance
             * @protected
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @return  {void}
             */
            GenerateTextMesh: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#GenerateTextMesh", this ); }

                var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7, $t8, $t9, $t10, $t11, $t12, $t13, $t14, $t15, $t16, $t17, $t18, $t19, $t20, $t21, $t22, $t23, $t24, $t25, $t26, $t27, $t28, $t29, $t30, $t31, $t32, $t33, $t34, $t35, $t36, $t37, $t38, $t39, $t40, $t41, $t42, $t43, $t44, $t45, $t46, $t47, $t48, $t49, $t50, $t51, $t52, $t53, $t54, $t55, $t56, $t57, $t58, $t59, $t60, $t61, $t62, $t63, $t64, $t65, $t66, $t67, $t68, $t69, $t70, $t71, $t72, $t73, $t74, $t75, $t76, $t77, $t78, $t79, $t80, $t81, $t82, $t83, $t84, $t85, $t86, $t87, $t88, $t89, $t90, $t91, $t92, $t93, $t94, $t95, $t96, $t97, $t98, $t99, $t100, $t101, $t102, $t103, $t104, $t105, $t106, $t107, $t108, $t109, $t110, $t111, $t112, $t113, $t114, $t115, $t116, $t117, $t118, $t119, $t120, $t121, $t122, $t123, $t124, $t125, $t126, $t127, $t128, $t129, $t130, $t131, $t132, $t133, $t134, $t135;
                // Early exit if no font asset was assigned. This should not be needed since LiberationSans SDF will be assigned by default.
                if (this.m_fontAsset == null || this.m_fontAsset.characterLookupTable == null) {
                    UnityEngine.Debug.LogWarning$1("Can't Generate Mesh! No Font Asset has been assigned to Object ID: " + this.GetInstanceID());
                    this.m_IsAutoSizePointSizeSet = true;
                    return;
                }

                // Clear TextInfo
                if (this.m_textInfo != null) {
                    this.m_textInfo.Clear();
                }

                // Early exit if we don't have any Text to generate.
                if (this.m_TextProcessingArray == null || this.m_TextProcessingArray.length === 0 || this.m_TextProcessingArray[0].unicode === 0) {
                    // Clear mesh and upload changes to the mesh.
                    this.ClearMesh();

                    this.m_preferredWidth = 0;
                    this.m_preferredHeight = 0;

                    // Event indicating the text has been regenerated.
                    TMPro.TMPro_EventManager.ON_TEXT_CHANGED(this);
                    this.m_IsAutoSizePointSizeSet = true;
                    return;
                }

                this.m_currentFontAsset = this.m_fontAsset;
                this.m_currentMaterial = this.m_sharedMaterial;
                this.m_currentMaterialIndex = 0;
                TMPro.TMP_Text.m_materialReferenceStack.SetDefault(new TMPro.MaterialReference.$ctor1(this.m_currentMaterialIndex, this.m_currentFontAsset, null, this.m_currentMaterial, this.m_padding));

                this.m_currentSpriteAsset = this.m_spriteAsset;

                // Stop all Sprite Animations
                if (UnityEngine.MonoBehaviour.op_Inequality(this.m_spriteAnimator, null)) {
                    this.m_spriteAnimator.StopAllAnimations();
                }

                // Total character count is computed when the text is parsed.
                var totalCharacterCount = this.m_totalCharacterCount;

                // Calculate the scale of the font based on selected font size and sampling point size.
                // baseScale is calculated using the font asset assigned to the text object.
                var baseScale = this.m_fontSize / this.m_fontAsset.m_FaceInfo.pointSize * this.m_fontAsset.m_FaceInfo.scale * (this.m_isOrthographic ? 1 : 0.1);
                var currentElementScale = baseScale;
                var currentEmScale = this.m_fontSize * 0.01 * (this.m_isOrthographic ? 1 : 0.1);
                this.m_fontScaleMultiplier = 1;

                this.m_currentFontSize = this.m_fontSize;
                this.m_sizeStack.SetDefault(this.m_currentFontSize);
                var fontSizeDelta = 0;

                var charCode = 0; // Holds the character code of the currently being processed character.

                this.m_FontStyleInternal = this.m_fontStyle; // Set the default style.
                this.m_FontWeightInternal = (this.m_FontStyleInternal & TMPro.FontStyles.Bold) === TMPro.FontStyles.Bold ? TMPro.FontWeight.Bold : this.m_fontWeight;
                this.m_FontWeightStack.SetDefault(this.m_FontWeightInternal);
                this.m_fontStyleStack.Clear();

                this.m_lineJustification = this.m_HorizontalAlignment; // m_textAlignment; // Sets the line justification mode to match editor alignment.
                this.m_lineJustificationStack.SetDefault(this.m_lineJustification);

                var padding = 0;
                var style_padding = 0; // Extra padding required to accommodate Bold style.
                var boldSpacingAdjustment = 0;
                //float bold_xAdvance_multiplier = 1; // Used to increase spacing between character when style is bold.

                this.m_baselineOffset = 0; // Used by subscript characters.
                this.m_baselineOffsetStack.Clear();

                // Underline
                var beginUnderline = false;
                var underline_start = pc.Vec3.ZERO.clone(); // Used to track where underline starts & ends.
                var underline_end = pc.Vec3.ZERO.clone();

                // Strike-through
                var beginStrikethrough = false;
                var strikethrough_start = pc.Vec3.ZERO.clone();
                var strikethrough_end = pc.Vec3.ZERO.clone();

                // Text Highlight
                var beginHighlight = false;
                var highlight_start = pc.Vec3.ZERO.clone();
                var highlight_end = pc.Vec3.ZERO.clone();

                var vertexColor = new UnityEngine.Color32();
                this.m_fontColor32.Set(1, 1, 1, 1);
                this.m_fontColor32.MultiplyByColor( this.m_fontColor );
                this.m_htmlColor.Copy( this.m_fontColor32 );
                this.m_underlineColor.Copy( this.m_htmlColor );
                this.m_strikethroughColor.Copy( this.m_htmlColor );

                this.m_colorStack.SetDefault(this.m_htmlColor.$clone());
                this.m_underlineColorStack.SetDefault(this.m_htmlColor.$clone());
                this.m_strikethroughColorStack.SetDefault(this.m_htmlColor.$clone());
                this.m_HighlightStateStack.SetDefault(new TMPro.HighlightState.$ctor1(this.m_htmlColor.$clone(), TMPro.TMP_Offset.zero.$clone()));

                this.m_colorGradientPreset = null;
                this.m_colorGradientStack.SetDefault(null);

                this.m_ItalicAngle = this.m_currentFontAsset.italicStyle;
                this.m_ItalicAngleStack.SetDefault(this.m_ItalicAngle);

                // Clear the Style stack.
                //m_styleStack.Clear();

                // Clear the Action stack.
                this.m_actionStack.Clear();

                this.m_isFXMatrixSet = false;

                this.m_lineOffset = 0; // Amount of space between lines (font line spacing + m_linespacing).
                this.m_lineHeight = TMPro.TMP_Math.FLOAT_UNSET;
                var lineGap = this.m_currentFontAsset.m_FaceInfo.lineHeight - (this.m_currentFontAsset.m_FaceInfo.ascentLine - this.m_currentFontAsset.m_FaceInfo.descentLine);

                this.m_cSpacing = 0; // Amount of space added between characters as a result of the use of the <cspace> tag.
                this.m_monoSpacing = 0;
                this.m_xAdvance = 0; // Used to track the position of each character.

                this.tag_LineIndent = 0; // Used for indentation of text.
                this.tag_Indent = 0;
                this.m_indentStack.SetDefault(0);
                this.tag_NoParsing = false;
                //m_isIgnoringAlignment = false;

                this.m_characterCount = 0; // Total characters in the char[]

                // Tracking of line information
                this.m_firstCharacterOfLine = this.m_firstVisibleCharacter;
                this.m_lastCharacterOfLine = 0;
                this.m_firstVisibleCharacterOfLine = 0;
                this.m_lastVisibleCharacterOfLine = 0;
                this.m_maxLineAscender = TMPro.TMP_Text.k_LargeNegativeFloat;
                this.m_maxLineDescender = TMPro.TMP_Text.k_LargePositiveFloat;
                this.m_lineNumber = 0;
                this.m_startOfLineAscender = 0;
                this.m_startOfLineDescender = 0;
                this.m_lineVisibleCharacterCount = 0;
                var isStartOfNewLine = true;
                this.m_IsDrivenLineSpacing = false;
                this.m_firstOverflowCharacterIndex = -1;

                this.m_pageNumber = 0;
                var pageToDisplay = Math.max(0, Math.min(this.m_pageToDisplay - 1, this.m_textInfo.pageInfo.length - 1));
                this.m_textInfo.ClearPageInfo();

                var margins = this.m_margin.$clone();
                var marginWidth = this.m_marginWidth > 0 ? this.m_marginWidth : 0;
                var marginHeight = this.m_marginHeight > 0 ? this.m_marginHeight : 0;
                this.m_marginLeft = 0;
                this.m_marginRight = 0;
                this.m_width = -1;
                var widthOfTextArea = marginWidth + 0.0001 - this.m_marginLeft - this.m_marginRight;

                // Need to initialize these Extents structures
                this.m_meshExtents.min = TMPro.TMP_Text.k_LargePositiveVector2.$clone();
                this.m_meshExtents.max = TMPro.TMP_Text.k_LargeNegativeVector2.$clone();

                // Initialize lineInfo
                this.m_textInfo.ClearLineInfo();

                // Tracking of the highest Ascender
                this.m_maxCapHeight = 0;
                this.m_maxTextAscender = 0;
                this.m_ElementDescender = 0;
                this.m_PageAscender = 0;
                var maxVisibleDescender = { v : 0 };
                var isMaxVisibleDescenderSet = { v : false };
                this.m_isNewPage = false;

                // Initialize struct to track states of word wrapping
                var isFirstWordOfLine = true;
                this.m_isNonBreakingSpace = false;
                var ignoreNonBreakingSpace = false;
                //bool isLastCharacterCJK = false;
                var lastSoftLineBreak = 0;

                var characterToSubstitute = new TMPro.TMP_Text.CharacterSubstitution.$ctor1(-1, 0);
                var isSoftHyphenIgnored = false;

                // Save character and line state before we begin layout.
                this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedWordWrapState"), -1, -1);
                this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedLineState"), -1, -1);
                this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedEllipsisState"), -1, -1);
                this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedLastValidState"), -1, -1);
                this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedSoftLineBreakState"), -1, -1);

                TMPro.TMP_Text.m_EllipsisInsertionCandidateStack.Clear();

                // Safety Tracker
                var restoreCount = 0;

                var characterInfo = new TMPro.TMP_CharacterInfo();
                var lineInfo = new TMPro.TMP_LineInfo();

                var top_left = pc.Vec3.ZERO.clone();
                var bottom_left = pc.Vec3.ZERO.clone();
                var top_right = pc.Vec3.ZERO.clone();
                var bottom_right = pc.Vec3.ZERO.clone();
                var topShear = pc.Vec3.ZERO.clone();
                var bottomShear = pc.Vec3.ZERO.clone();
                var shearAdjustment = pc.Vec3.ZERO.clone();

                // Parse through Character buffer to read HTML tags and begin creating mesh.
                for (var i = 0; i < this.m_TextProcessingArray.length && this.m_TextProcessingArray[i].unicode !== 0; i++) {
                    charCode = this.m_TextProcessingArray[i].unicode;

                    characterInfo = this.m_textInfo.characterInfo[ this.m_characterCount ];

                    if (restoreCount > 5) {
                        UnityEngine.Debug.LogError$2("Line breaking recursion max threshold hit... Character [" + charCode + "] index: " + i);
                        characterToSubstitute.index = this.m_characterCount;
                        characterToSubstitute.unicode = 3;
                    }

                    // Parse Rich Text Tag


                    if (this.m_isRichText && charCode === 60) {
                        this.m_isParsingText = true;
                        this.m_textElementType = TMPro.TMP_TextElementType.Character;
                        var endTagIndex = { };

                        // Check if Tag is valid. If valid, skip to the end of the validated tag.
                        if (this.ValidateHtmlTag(this.m_TextProcessingArray, i + 1, endTagIndex)) {
                            i = endTagIndex.v;

                            // Continue to next character or handle the sprite element
                            if (this.m_textElementType === TMPro.TMP_TextElementType.Character) {
                                continue;
                            }
                        }
                    } else {
                        this.m_textElementType = ($t = this.m_textInfo.characterInfo)[this.m_characterCount].elementType;
                        this.m_currentMaterialIndex = ($t1 = this.m_textInfo.characterInfo)[this.m_characterCount].materialReferenceIndex;
                        this.m_currentFontAsset = ($t2 = this.m_textInfo.characterInfo)[this.m_characterCount].fontAsset;
                    }


                    var previousMaterialIndex = this.m_currentMaterialIndex;
                    var isUsingAltTypeface = ($t3 = this.m_textInfo.characterInfo)[this.m_characterCount].isUsingAlternateTypeface;

                    this.m_isParsingText = false;

                    // Handle potential character substitutions


                    var isInjectingCharacter = false;

                    if (characterToSubstitute.index === this.m_characterCount) {
                        charCode = characterToSubstitute.unicode;
                        this.m_textElementType = TMPro.TMP_TextElementType.Character;
                        isInjectingCharacter = true;

                        switch (charCode) {
                            case 3: 
                                characterInfo.textElement = this.m_currentFontAsset.characterLookupTable.getItem(3);
                                this.m_isTextTruncated = true;
                                break;
                            case 45: 
                                //
                                break;
                            case 8230: 
                                characterInfo.textElement = this.m_Ellipsis.character;
                                characterInfo.elementType = TMPro.TMP_TextElementType.Character;
                                characterInfo.fontAsset = this.m_Ellipsis.fontAsset;
                                characterInfo.material = this.m_Ellipsis.material;
                                characterInfo.materialReferenceIndex = this.m_Ellipsis.materialIndex;
                                // Indicates the source parsing data has been modified.
                                this.m_isTextTruncated = true;
                                // End Of Text
                                characterToSubstitute.index = this.m_characterCount + 1;
                                characterToSubstitute.unicode = 3;
                                break;
                        }
                    }



                    // When using Linked text, mark character as ignored and skip to next character.


                    if (this.m_characterCount < this.m_firstVisibleCharacter && charCode !== 3) {
                        characterInfo.isVisible = false;
                        characterInfo.character = 8203;
                        characterInfo.lineNumber = 0;
                        this.m_characterCount += 1;
                        continue;
                    }



                    // Handle Font Styles like LowerCase, UpperCase and SmallCaps.


                    var smallCapsMultiplier = 1.0;

                    if (this.m_textElementType === TMPro.TMP_TextElementType.Character) {
                        if ((this.m_FontStyleInternal & TMPro.FontStyles.UpperCase) === TMPro.FontStyles.UpperCase) {
                            // If this character is lowercase, switch to uppercase.
                            if (Bridge.isLower(charCode)) {
                                charCode = String.fromCharCode(charCode).toUpperCase().charCodeAt(0);
                            }
                        } else if ((this.m_FontStyleInternal & TMPro.FontStyles.LowerCase) === TMPro.FontStyles.LowerCase) {
                            // If this character is uppercase, switch to lowercase.
                            if (Bridge.isUpper(charCode)) {
                                charCode = String.fromCharCode(charCode).toLowerCase().charCodeAt(0);
                            }
                        } else if ((this.m_FontStyleInternal & TMPro.FontStyles.SmallCaps) === TMPro.FontStyles.SmallCaps) {
                            if (Bridge.isLower(charCode)) {
                                smallCapsMultiplier = 0.8;
                                charCode = String.fromCharCode(charCode).toUpperCase().charCodeAt(0);
                            }
                        }
                    }



                    // Look up Character Data from Dictionary and cache it.


                    var baselineOffset = 0;
                    var elementAscentLine = 0;
                    var elementDescentLine = 0;
                    if (this.m_textElementType === TMPro.TMP_TextElementType.Sprite) {
                        // If a sprite is used as a fallback then get a reference to it and set the color to white.
                        this.m_currentSpriteAsset = characterInfo.spriteAsset;
                        this.m_spriteIndex = characterInfo.spriteIndex;

                        var sprite = this.m_currentSpriteAsset.spriteCharacterTable.getItem(this.m_spriteIndex);
                        if (sprite == null) {
                            continue;
                        }

                        // Sprites are assigned in the E000 Private Area + sprite Index
                        if (charCode === 60) {
                            charCode = 57344 + this.m_spriteIndex;
                        } else {
                            this.m_spriteColor = TMPro.TMP_Text.s_colorWhite.$clone();
                        }

                        var fontScale = this.m_currentFontSize / this.m_currentFontAsset.faceInfo.pointSize * this.m_currentFontAsset.faceInfo.scale * (this.m_isOrthographic ? 1 : 0.1);

                        // The sprite scale calculations are based on the font asset assigned to the text object.
                        if (this.m_currentSpriteAsset.m_FaceInfo.pointSize > 0) {
                            var spriteScale = this.m_currentFontSize / this.m_currentSpriteAsset.m_FaceInfo.pointSize * this.m_currentSpriteAsset.m_FaceInfo.scale * (this.m_isOrthographic ? 1 : 0.1);
                            currentElementScale = sprite.m_Scale * sprite.m_Glyph.scale * spriteScale;
                            elementAscentLine = this.m_currentSpriteAsset.m_FaceInfo.ascentLine;
                            baselineOffset = this.m_currentSpriteAsset.m_FaceInfo.baseline * fontScale * this.m_fontScaleMultiplier * this.m_currentSpriteAsset.m_FaceInfo.scale;
                            elementDescentLine = this.m_currentSpriteAsset.m_FaceInfo.descentLine;
                        } else {
                            var spriteScale1 = this.m_currentFontSize / this.m_currentFontAsset.m_FaceInfo.pointSize * this.m_currentFontAsset.m_FaceInfo.scale * (this.m_isOrthographic ? 1 : 0.1);
                            currentElementScale = this.m_currentFontAsset.m_FaceInfo.ascentLine / sprite.m_Glyph.metrics.height * sprite.m_Scale * sprite.m_Glyph.scale * spriteScale1;
                            var scaleDelta = spriteScale1 / currentElementScale;
                            elementAscentLine = this.m_currentFontAsset.m_FaceInfo.ascentLine * scaleDelta;
                            baselineOffset = this.m_currentFontAsset.m_FaceInfo.baseline * fontScale * this.m_fontScaleMultiplier * this.m_currentFontAsset.m_FaceInfo.scale;
                            elementDescentLine = this.m_currentFontAsset.m_FaceInfo.descentLine * scaleDelta;
                        }

                        this.m_cached_TextElement = sprite;

                        characterInfo.elementType = TMPro.TMP_TextElementType.Sprite;
                        characterInfo.scale = currentElementScale;
                        characterInfo.spriteAsset = this.m_currentSpriteAsset;
                        characterInfo.fontAsset = this.m_currentFontAsset;
                        characterInfo.materialReferenceIndex = this.m_currentMaterialIndex;

                        this.m_currentMaterialIndex = previousMaterialIndex;

                        padding = 0;
                    } else if (this.m_textElementType === TMPro.TMP_TextElementType.Character) {
                        this.m_cached_TextElement = ($t4 = this.m_textInfo.characterInfo)[this.m_characterCount].textElement;
                        if (this.m_cached_TextElement == null) {
                            continue;
                        }

                        this.m_currentFontAsset = characterInfo.fontAsset;
                        this.m_currentMaterial = characterInfo.material;
                        this.m_currentMaterialIndex = characterInfo.materialReferenceIndex;

                        // Special handling if replaced character was a line feed where in this case we have to use the scale of the previous character.
                        var adjustedScale;
                        if (isInjectingCharacter && this.m_TextProcessingArray[i].unicode === 10 && this.m_characterCount !== this.m_firstCharacterOfLine) {
                            adjustedScale = characterInfo.pointSize * smallCapsMultiplier / this.m_currentFontAsset.m_FaceInfo.pointSize * this.m_currentFontAsset.m_FaceInfo.scale * (this.m_isOrthographic ? 1 : 0.1);
                        } else {
                            adjustedScale = this.m_currentFontSize * smallCapsMultiplier / this.m_currentFontAsset.m_FaceInfo.pointSize * this.m_currentFontAsset.m_FaceInfo.scale * (this.m_isOrthographic ? 1 : 0.1);
                        }

                        // Special handling for injected Ellipsis
                        if (isInjectingCharacter && charCode === 8230) {
                            elementAscentLine = 0;
                            elementDescentLine = 0;
                        } else {
                            elementAscentLine = this.m_currentFontAsset.m_FaceInfo.ascentLine;
                            elementDescentLine = this.m_currentFontAsset.m_FaceInfo.descentLine;
                        }

                        currentElementScale = adjustedScale * this.m_fontScaleMultiplier * this.m_cached_TextElement.m_Scale * this.m_cached_TextElement.m_Glyph.scale;
                        baselineOffset = this.m_currentFontAsset.m_FaceInfo.baseline * adjustedScale * this.m_fontScaleMultiplier * this.m_currentFontAsset.m_FaceInfo.scale;

                        characterInfo.elementType = TMPro.TMP_TextElementType.Character;
                        characterInfo.scale = currentElementScale;

                        padding = this.m_currentMaterialIndex === 0 ? this.m_padding : this.m_subTextObjects[this.m_currentMaterialIndex].padding;
                    }



                    // Handle Soft Hyphen


                    var currentElementUnmodifiedScale = currentElementScale;
                    if (charCode === 173 || charCode === 3) {
                        currentElementScale = 0;
                    }



                    // Store some of the text object's information
                    characterInfo.character = charCode;
                    characterInfo.pointSize = this.m_currentFontSize;
                    characterInfo.style = this.m_FontStyleInternal;

                    
                    characterInfo.color.Copy( this.m_htmlColor );
                    characterInfo.underlineColor.Copy( this.m_underlineColor );
                    characterInfo.strikethroughColor.Copy( this.m_strikethroughColor );
                    characterInfo.highlightState.Copy( this.m_HighlightStateStack.current );
                

                    // Cache glyph metrics
                    var currentGlyphMetrics = this.m_cached_TextElement.m_Glyph.metrics.$clone();

                    // Optimization to avoid calling this more than once per character.
                    var isWhiteSpace = charCode <= 65535 && System.Char.isWhiteSpace(String.fromCharCode(charCode));

                    // Handle Kerning if Enabled.


                    var glyphAdjustments = new TMPro.TMP_GlyphValueRecord.ctor();
                    var characterSpacingAdjustment = this.m_characterSpacing;
                    this.m_GlyphHorizontalAdvanceAdjustment = 0;
                    if (this.m_enableKerning) {
                        var adjustmentPair = { };
                        var baseGlyphIndex = this.m_cached_TextElement.m_GlyphIndex;

                        if (this.m_characterCount < totalCharacterCount - 1) {
                            var nextGlyphIndex = ($t5 = this.m_textInfo.characterInfo)[this.m_characterCount + 1].textElement.m_GlyphIndex;
                            var key = (nextGlyphIndex << 16) | baseGlyphIndex;

                            if (this.m_currentFontAsset.m_FontFeatureTable.m_GlyphPairAdjustmentRecordLookupDictionary.tryGetValue(key, adjustmentPair)) {
                                glyphAdjustments = adjustmentPair.v.m_FirstAdjustmentRecord.m_GlyphValueRecord.$clone();
                                characterSpacingAdjustment = (adjustmentPair.v.m_FeatureLookupFlags & TMPro.FontFeatureLookupFlags.IgnoreSpacingAdjustments) === TMPro.FontFeatureLookupFlags.IgnoreSpacingAdjustments ? 0 : characterSpacingAdjustment;
                            }
                        }

                        if (this.m_characterCount >= 1) {
                            var previousGlyphIndex = ($t6 = this.m_textInfo.characterInfo)[this.m_characterCount - 1].textElement.m_GlyphIndex;
                            var key1 = (baseGlyphIndex << 16) | previousGlyphIndex;

                            if (this.m_currentFontAsset.m_FontFeatureTable.m_GlyphPairAdjustmentRecordLookupDictionary.tryGetValue(key1, adjustmentPair)) {
                                glyphAdjustments = TMPro.TMP_GlyphValueRecord.op_Addition(glyphAdjustments.$clone(), adjustmentPair.v.m_SecondAdjustmentRecord.m_GlyphValueRecord.$clone());
                                characterSpacingAdjustment = (adjustmentPair.v.m_FeatureLookupFlags & TMPro.FontFeatureLookupFlags.IgnoreSpacingAdjustments) === TMPro.FontFeatureLookupFlags.IgnoreSpacingAdjustments ? 0 : characterSpacingAdjustment;
                            }
                        }

                        this.m_GlyphHorizontalAdvanceAdjustment = glyphAdjustments.xAdvance;
                    }



                    // Initial Implementation for RTL support.


                    if (this.m_isRightToLeft) {
                        this.m_xAdvance -= currentGlyphMetrics.horizontalAdvance * (1 - this.m_charWidthAdjDelta) * currentElementScale;

                        if (isWhiteSpace || charCode === 8203) {
                            this.m_xAdvance -= this.m_wordSpacing * currentEmScale;
                        }
                    }



                    // Handle Mono Spacing


                    var monoAdvance = 0;
                    if (this.m_monoSpacing !== 0) {
                        monoAdvance = (this.m_monoSpacing / 2 - (currentGlyphMetrics.width / 2 + currentGlyphMetrics.horizontalBearingX) * currentElementScale) * (1 - this.m_charWidthAdjDelta);
                        this.m_xAdvance += monoAdvance;
                    }



                    // Set Padding based on selected font style


                    if (this.m_textElementType === TMPro.TMP_TextElementType.Character && !isUsingAltTypeface && (this.m_FontStyleInternal & TMPro.FontStyles.Bold) === TMPro.FontStyles.Bold) {
                        if (this.m_currentMaterial != null && this.m_currentMaterial.HasProperty(TMPro.ShaderUtilities.ID_GradientScale)) {
                            var gradientScale = this.m_currentMaterial.GetFloat(TMPro.ShaderUtilities.ID_GradientScale);
                            style_padding = this.m_currentFontAsset.boldStyle / 4.0 * gradientScale * this.m_currentMaterial.GetFloat(TMPro.ShaderUtilities.ID_ScaleRatio_A);

                            // Clamp overall padding to Gradient Scale size.
                            if (style_padding + padding > gradientScale) {
                                padding = gradientScale - style_padding;
                            }
                        } else {
                            style_padding = 0;
                        }

                        boldSpacingAdjustment = this.m_currentFontAsset.boldSpacing;
                    } else {
                        if (this.m_currentMaterial != null && this.m_currentMaterial.HasProperty(TMPro.ShaderUtilities.ID_GradientScale) && this.m_currentMaterial.HasProperty(TMPro.ShaderUtilities.ID_ScaleRatio_A)) {
                            var gradientScale1 = this.m_currentMaterial.GetFloat(TMPro.ShaderUtilities.ID_GradientScale);
                            style_padding = this.m_currentFontAsset.normalStyle / 4.0 * gradientScale1 * this.m_currentMaterial.GetFloat(TMPro.ShaderUtilities.ID_ScaleRatio_A);

                            // Clamp overall padding to Gradient Scale size.
                            if (style_padding + padding > gradientScale1) {
                                padding = gradientScale1 - style_padding;
                            }
                        } else {
                            style_padding = 0;
                        }

                        boldSpacingAdjustment = 0;
                    }



                    // Determine the position of the vertices of the Character or Sprite.


                    top_left.x = this.m_xAdvance + (currentGlyphMetrics.horizontalBearingX - padding - style_padding + glyphAdjustments.m_XPlacement) * currentElementScale * (1 - this.m_charWidthAdjDelta);
                    top_left.y = baselineOffset + (currentGlyphMetrics.horizontalBearingY + padding + glyphAdjustments.m_YPlacement) * currentElementScale - this.m_lineOffset + this.m_baselineOffset;
                    top_left.z = 0;

                    bottom_left.x = top_left.x;
                    bottom_left.y = top_left.y - (currentGlyphMetrics.height + padding * 2) * currentElementScale;
                    bottom_left.z = 0;

                    top_right.x = bottom_left.x + (currentGlyphMetrics.width + padding * 2 + style_padding * 2) * currentElementScale * (1 - this.m_charWidthAdjDelta);
                    top_right.y = top_left.y;
                    top_right.z = 0;

                    bottom_right.x = top_right.x;
                    bottom_right.y = bottom_left.y;
                    bottom_right.z = 0;



                    // Check if we need to Shear the rectangles for Italic styles


                    if (this.m_textElementType === TMPro.TMP_TextElementType.Character && !isUsingAltTypeface && (this.m_FontStyleInternal & TMPro.FontStyles.Italic) === TMPro.FontStyles.Italic) {
                        // Shift Top vertices forward by half (Shear Value * height of character) and Bottom vertices back by same amount.
                        var shear_value = this.m_ItalicAngle * 0.01;

                        topShear.set( shear_value * ((currentGlyphMetrics.horizontalBearingY + padding + style_padding) * currentElementScale), 0, 0 );
                        bottomShear.set( shear_value * ((currentGlyphMetrics.horizontalBearingY - currentGlyphMetrics.height - padding - style_padding) * currentElementScale), 0, 0 );

                        shearAdjustment.set( (topShear.x - bottomShear.x) / 2, 0, 0 );

                        top_left.add( topShear );
                        top_left.sub( shearAdjustment );
                        bottom_left.add( bottomShear );
                        bottom_left.sub( shearAdjustment );
                        top_right.add( topShear );
                        top_right.sub( shearAdjustment );
                        bottom_right.add( bottomShear );
                        bottom_right.sub( shearAdjustment );
                    }



                    // Handle Character Rotation


                    if (this.m_isFXMatrixSet) {
                        // Apply scale matrix when simulating Condensed text.
                        if (this.m_FXMatrix.getScale().x !== 1) {
                            //top_left = m_FXMatrix.MultiplyPoint3x4(top_left);
                            //bottom_left = m_FXMatrix.MultiplyPoint3x4(bottom_left);
                            //top_right = m_FXMatrix.MultiplyPoint3x4(top_right);
                            //bottom_right = m_FXMatrix.MultiplyPoint3x4(bottom_right);
                        }

                        var positionOffset = (top_right.$clone().add( bottom_left )).scale( 1.0 / ( 2 ) );

                        top_left = this.m_FXMatrix.transformPoint( top_left.$clone().sub( positionOffset ) ).add( positionOffset );
                        bottom_left = this.m_FXMatrix.transformPoint( bottom_left.$clone().sub( positionOffset ) ).add( positionOffset );
                        top_right = this.m_FXMatrix.transformPoint( top_right.$clone().sub( positionOffset ) ).add( positionOffset );
                        bottom_right = this.m_FXMatrix.transformPoint( bottom_right.$clone().sub( positionOffset ) ).add( positionOffset );
                    }



                    // Store vertex information for the character or sprite.
                    
                    characterInfo.bottomLeft.copy( bottom_left );
                    characterInfo.topLeft.copy( top_left );
                    characterInfo.topRight.copy( top_right );
                    characterInfo.bottomRight.copy( bottom_right );
                    characterInfo.origin = this.m_xAdvance;
                    characterInfo.baseLine = baselineOffset - this.m_lineOffset + this.m_baselineOffset;
                    characterInfo.aspectRatio = ( top_right.x - bottom_left.x ) / ( top_left.y - bottom_left.y );
                


                    // Compute text metrics


                    // Element Ascender in line space
                    var elementAscender = this.m_textElementType === TMPro.TMP_TextElementType.Character ? elementAscentLine * currentElementScale / smallCapsMultiplier + this.m_baselineOffset : elementAscentLine * currentElementScale + this.m_baselineOffset;

                    // Element Descender in line space
                    var elementDescender = this.m_textElementType === TMPro.TMP_TextElementType.Character ? elementDescentLine * currentElementScale / smallCapsMultiplier + this.m_baselineOffset : elementDescentLine * currentElementScale + this.m_baselineOffset;

                    var adjustedAscender = elementAscender;
                    var adjustedDescender = elementDescender;

                    var isFirstCharacterOfLine = this.m_characterCount === this.m_firstCharacterOfLine;
                    // Max line ascender and descender in line space
                    if (isFirstCharacterOfLine || isWhiteSpace === false) {
                        // Special handling for Superscript and Subscript where we use the unadjusted line ascender and descender
                        if (this.m_baselineOffset !== 0) {
                            adjustedAscender = UnityEngine.Mathf.Max((elementAscender - this.m_baselineOffset) / this.m_fontScaleMultiplier, adjustedAscender);
                            adjustedDescender = UnityEngine.Mathf.Min((elementDescender - this.m_baselineOffset) / this.m_fontScaleMultiplier, adjustedDescender);
                        }

                        this.m_maxLineAscender = UnityEngine.Mathf.Max(adjustedAscender, this.m_maxLineAscender);
                        this.m_maxLineDescender = UnityEngine.Mathf.Min(adjustedDescender, this.m_maxLineDescender);
                    }

                    // Element Ascender and Descender in object space
                    if (isFirstCharacterOfLine || isWhiteSpace === false) {
                        characterInfo.adjustedAscender = adjustedAscender;
                        characterInfo.adjustedDescender = adjustedDescender;

                        this.m_ElementAscender = (characterInfo.ascender = elementAscender - this.m_lineOffset);
                        this.m_ElementDescender = (characterInfo.descender = elementDescender - this.m_lineOffset);
                    } else {
                        characterInfo.adjustedAscender = this.m_maxLineAscender;
                        characterInfo.adjustedDescender = this.m_maxLineDescender;

                        this.m_ElementAscender = (characterInfo.ascender = this.m_maxLineAscender - this.m_lineOffset);
                        this.m_ElementDescender = (characterInfo.descender = this.m_maxLineDescender - this.m_lineOffset);
                    }

                    // Max text object ascender and cap height
                    if (this.m_lineNumber === 0 || this.m_isNewPage) {
                        if (isFirstCharacterOfLine || isWhiteSpace === false) {
                            this.m_maxTextAscender = this.m_maxLineAscender;
                            this.m_maxCapHeight = UnityEngine.Mathf.Max(this.m_maxCapHeight, this.m_currentFontAsset.m_FaceInfo.capLine * currentElementScale / smallCapsMultiplier);
                        }
                    }

                    // Page ascender
                    if (this.m_lineOffset === 0) {
                        if (isFirstCharacterOfLine || isWhiteSpace === false) {
                            this.m_PageAscender = this.m_PageAscender > elementAscender ? this.m_PageAscender : elementAscender;
                        }
                    }



                    // Set Characters to not visible by default.
                    ($t7 = this.m_textInfo.characterInfo)[this.m_characterCount].isVisible = false;

                    var isJustifiedOrFlush = (this.m_lineJustification & TMPro.HorizontalAlignmentOptions.Flush) === TMPro.HorizontalAlignmentOptions.Flush || (this.m_lineJustification & TMPro.HorizontalAlignmentOptions.Justified) === TMPro.HorizontalAlignmentOptions.Justified;

                    // Setup Mesh for visible text elements. ie. not a SPACE / LINEFEED / CARRIAGE RETURN.


                    if (charCode === 9 || isWhiteSpace === false && charCode !== 8203 && charCode !== 173 && charCode !== 3 || charCode === 173 && isSoftHyphenIgnored === false || this.m_textElementType === TMPro.TMP_TextElementType.Sprite) {
                        ($t8 = this.m_textInfo.characterInfo)[this.m_characterCount].isVisible = true;


                        //Vector2 shapedMargins;
                        //if (marginShaper)
                        //{
                        //    shapedMargins = m_marginShaper.GetShapedMargins(m_textInfo.characterInfo[m_characterCount].baseLine);
                        //    if (shapedMargins.x < margins.x)
                        //    {
                        //        shapedMargins.x = m_marginLeft;
                        //    }
                        //    else
                        //    {
                        //        shapedMargins.x += m_marginLeft - margins.x;
                        //    }
                        //    if (shapedMargins.y < margins.z)
                        //    {
                        //        shapedMargins.y = m_marginRight;
                        //    }
                        //    else
                        //    {
                        //        shapedMargins.y += m_marginRight - margins.z;
                        //    }
                        //}
                        //else
                        //{
                        //    shapedMargins.x = m_marginLeft;
                        //    shapedMargins.y = m_marginRight;
                        //}
                        //width = marginWidth + 0.0001f - shapedMargins.x - shapedMargins.y;
                        //if (m_width != -1 && m_width < width)
                        //{
                        //    width = m_width;
                        //}
                        //m_textInfo.lineInfo[m_lineNumber].marginLeft = shapedMargins.x;


                        var marginLeft = this.m_marginLeft;
                        var marginRight = this.m_marginRight;

                        // Injected characters do not override margins
                        if (isInjectingCharacter) {
                            marginLeft = this.m_textInfo.lineInfo[ this.m_lineNumber ].marginLeft;
                            marginRight = this.m_textInfo.lineInfo[ this.m_lineNumber ].marginRight;
                        }

                        widthOfTextArea = this.m_width !== -1 ? UnityEngine.Mathf.Min(marginWidth + 0.0001 - marginLeft - marginRight, this.m_width) : marginWidth + 0.0001 - marginLeft - marginRight;

                        // Calculate the line breaking width of the text.
                        var textWidth = Math.abs(this.m_xAdvance) + (!this.m_isRightToLeft ? currentGlyphMetrics.horizontalAdvance : 0) * (1 - this.m_charWidthAdjDelta) * (charCode === 173 ? currentElementUnmodifiedScale : currentElementScale);
                        var textHeight = this.m_maxTextAscender - (this.m_maxLineDescender - this.m_lineOffset) + (this.m_lineOffset > 0 && this.m_IsDrivenLineSpacing === false ? this.m_maxLineAscender - this.m_startOfLineAscender : 0);

                        var testedCharacterCount = this.m_characterCount;

                        // Handling of current line Vertical Bounds


                        if (textHeight > marginHeight + 0.0001) {
                            // Set isTextOverflowing and firstOverflowCharacterIndex
                            if (this.m_firstOverflowCharacterIndex === -1) {
                                this.m_firstOverflowCharacterIndex = this.m_characterCount;
                            }

                            // Check if Auto-Size is enabled
                            if (this.m_enableAutoSizing) {
                                // Handle Line spacing adjustments


                                if (this.m_lineSpacingDelta > this.m_lineSpacingMax && this.m_lineOffset > 0 && this.m_AutoSizeIterationCount < this.m_AutoSizeMaxIterationCount) {
                                    var adjustmentDelta = (marginHeight - textHeight) / this.m_lineNumber;

                                    this.m_lineSpacingDelta = UnityEngine.Mathf.Max(this.m_lineSpacingDelta + adjustmentDelta / baseScale, this.m_lineSpacingMax);

                                    //Debug.Log("[" + m_AutoSizeIterationCount + "] Reducing Line Spacing. Delta of [" + m_lineSpacingDelta.ToString("f3") + "].");
                                    return;
                                }



                                // Handle Text Auto-sizing resulting from text exceeding vertical bounds.


                                if (this.m_fontSize > this.m_fontSizeMin && this.m_AutoSizeIterationCount < this.m_AutoSizeMaxIterationCount) {
                                    this.m_maxFontSize = this.m_fontSize;

                                    var sizeDelta = UnityEngine.Mathf.Max((this.m_fontSize - this.m_minFontSize) / 2, 0.05);
                                    this.m_fontSize -= sizeDelta;
                                    this.m_fontSize = UnityEngine.Mathf.Max((this.m_fontSize * 20 + 0.5) / 20.0, this.m_fontSizeMin);

                                    //Debug.Log("[" + m_AutoSizeIterationCount + "] Reducing Point Size from [" + m_maxFontSize.ToString("f3") + "] to [" + m_fontSize.ToString("f3") + "] with delta of [" + sizeDelta.ToString("f3") + "].");
                                    return;
                                }

                            }

                            // Handle Vertical Overflow on current line
                            switch (this.m_overflowMode) {
                                case TMPro.TextOverflowModes.Overflow: 
                                case TMPro.TextOverflowModes.ScrollRect: 
                                case TMPro.TextOverflowModes.Masking: 
                                    // Nothing happens as vertical bounds are ignored in this mode.
                                    break;
                                case TMPro.TextOverflowModes.Truncate: 
                                    i = this.RestoreWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedLastValidState"));
                                    characterToSubstitute.index = testedCharacterCount;
                                    characterToSubstitute.unicode = 3;
                                    continue;
                                case TMPro.TextOverflowModes.Ellipsis: 
                                    if (TMPro.TMP_Text.m_EllipsisInsertionCandidateStack.Count === 0) {
                                        i = -1;
                                        this.m_characterCount = 0;
                                        characterToSubstitute.index = 0;
                                        characterToSubstitute.unicode = 3;
                                        this.m_firstCharacterOfLine = 0;
                                        continue;
                                    }
                                    var ellipsisState = { v : TMPro.TMP_Text.m_EllipsisInsertionCandidateStack.Pop().$clone() };
                                    i = this.RestoreWordWrappingState(ellipsisState);
                                    i -= 1;
                                    this.m_characterCount -= 1;
                                    characterToSubstitute.index = this.m_characterCount;
                                    characterToSubstitute.unicode = 8230;
                                    restoreCount += 1;
                                    continue;
                                case TMPro.TextOverflowModes.Linked: 
                                    i = this.RestoreWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedLastValidState"));
                                    if (UnityEngine.MonoBehaviour.op_Inequality(this.m_linkedTextComponent, null)) {
                                        this.m_linkedTextComponent.text = this.text;
                                        this.m_linkedTextComponent.m_inputSource = this.m_inputSource;
                                        this.m_linkedTextComponent.firstVisibleCharacter = this.m_characterCount;
                                        this.m_linkedTextComponent.ForceMeshUpdate();

                                        this.m_isTextTruncated = true;
                                    }
                                    // Truncate remaining text
                                    characterToSubstitute.index = testedCharacterCount;
                                    characterToSubstitute.unicode = 3;
                                    continue;
                                case TMPro.TextOverflowModes.Page: 
                                    // End layout of text if first character / page doesn't fit.
                                    if (i < 0 || testedCharacterCount === 0) {
                                        i = -1;
                                        this.m_characterCount = 0;
                                        characterToSubstitute.index = 0;
                                        characterToSubstitute.unicode = 3;
                                        continue;
                                    } else if (this.m_maxLineAscender - this.m_maxLineDescender > marginHeight + 0.0001) {
                                        // Current line exceeds the height of the text container
                                        // as such we stop on the previous line.
                                        i = this.RestoreWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedLineState"));

                                        characterToSubstitute.index = testedCharacterCount;
                                        characterToSubstitute.unicode = 3;
                                        continue;
                                    }
                                    // Go back to previous line and re-layout
                                    i = this.RestoreWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedLineState"));
                                    this.m_isNewPage = true;
                                    this.m_firstCharacterOfLine = this.m_characterCount;
                                    this.m_maxLineAscender = TMPro.TMP_Text.k_LargeNegativeFloat;
                                    this.m_maxLineDescender = TMPro.TMP_Text.k_LargePositiveFloat;
                                    this.m_startOfLineAscender = 0;
                                    this.m_xAdvance = 0 + this.tag_Indent;
                                    this.m_lineOffset = 0;
                                    this.m_maxTextAscender = 0;
                                    this.m_PageAscender = 0;
                                    this.m_lineNumber += 1;
                                    this.m_pageNumber += 1;
                                    // Should consider saving page data here
                                    continue;
                            }
                        }



                        // Handling of Horizontal Bounds


                        if (textWidth > widthOfTextArea * (isJustifiedOrFlush ? 1.05 : 1.0)) {
                            // Handle Line Breaking (if still possible)
                            if (this.m_enableWordWrapping && this.m_characterCount !== this.m_firstCharacterOfLine) {
                                // Restore state to previous safe line breaking
                                i = this.RestoreWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedWordWrapState"));

                                // Compute potential new line offset in the event a line break is needed.
                                var lineOffsetDelta = 0;
                                if (this.m_lineHeight === TMPro.TMP_Math.FLOAT_UNSET) {
                                    var ascender = characterInfo.adjustedAscender;
                                    lineOffsetDelta = (this.m_lineOffset > 0 && this.m_IsDrivenLineSpacing === false ? this.m_maxLineAscender - this.m_startOfLineAscender : 0) - this.m_maxLineDescender + ascender + (lineGap + this.m_lineSpacingDelta) * baseScale + this.m_lineSpacing * currentEmScale;
                                } else {
                                    lineOffsetDelta = this.m_lineHeight + this.m_lineSpacing * currentEmScale;
                                    this.m_IsDrivenLineSpacing = true;
                                }

                                // Calculate new text height
                                var newTextHeight = this.m_maxTextAscender + lineOffsetDelta + this.m_lineOffset - characterInfo.adjustedDescender;

                                // Replace Soft Hyphen by Hyphen Minus 0x2D


                                if (this.m_textInfo.characterInfo[ this.m_characterCount - 1 ].character === 173 && isSoftHyphenIgnored === false) {
                                    // Only inject Hyphen Minus if new line is possible
                                    if (this.m_overflowMode === TMPro.TextOverflowModes.Overflow || newTextHeight < marginHeight + 0.0001) {
                                        characterToSubstitute.index = this.m_characterCount - 1;
                                        characterToSubstitute.unicode = 45;

                                        i -= 1;
                                        this.m_characterCount -= 1;
                                        continue;
                                    }
                                }

                                isSoftHyphenIgnored = false;

                                // Ignore Soft Hyphen to prevent it from wrapping
                                if (characterInfo.character === 173) {
                                    isSoftHyphenIgnored = true;
                                    continue;
                                }


                                // Adjust character spacing before breaking up word if auto size is enabled
                                if (this.m_enableAutoSizing && isFirstWordOfLine) {
                                    // Handle Character Width Adjustments


                                    if (this.m_charWidthAdjDelta < this.m_charWidthMaxAdj / 100 && this.m_AutoSizeIterationCount < this.m_AutoSizeMaxIterationCount) {
                                        var adjustedTextWidth = textWidth;

                                        // Determine full width of the text
                                        if (this.m_charWidthAdjDelta > 0) {
                                            adjustedTextWidth /= 1.0 - this.m_charWidthAdjDelta;
                                        }

                                        var adjustmentDelta1 = textWidth - (widthOfTextArea - 0.0001) * (isJustifiedOrFlush ? 1.05 : 1.0);
                                        this.m_charWidthAdjDelta += adjustmentDelta1 / adjustedTextWidth;
                                        this.m_charWidthAdjDelta = UnityEngine.Mathf.Min(this.m_charWidthAdjDelta, this.m_charWidthMaxAdj / 100);

                                        //Debug.Log("[" + m_AutoSizeIterationCount + "] Reducing Character Width by " + (m_charWidthAdjDelta * 100) + "%");
                                        return;
                                    }


                                    // Handle Text Auto-sizing resulting from text exceeding vertical bounds.


                                    if (this.m_fontSize > this.m_fontSizeMin && this.m_AutoSizeIterationCount < this.m_AutoSizeMaxIterationCount) {
                                        this.m_maxFontSize = this.m_fontSize;

                                        var sizeDelta1 = UnityEngine.Mathf.Max((this.m_fontSize - this.m_minFontSize) / 2, 0.05);
                                        this.m_fontSize -= sizeDelta1;
                                        this.m_fontSize = UnityEngine.Mathf.Max((this.m_fontSize * 20 + 0.5) / 20.0, this.m_fontSizeMin);

                                        //Debug.Log("[" + m_AutoSizeIterationCount + "] Reducing Point Size from [" + m_maxFontSize.ToString("f3") + "] to [" + m_fontSize.ToString("f3") + "] with delta of [" + sizeDelta.ToString("f3") + "].");
                                        return;
                                    }

                                }


                                // Special handling if first word of line and non breaking space
                                var savedSoftLineBreakingSpace = TMPro.TMP_Text.m_SavedSoftLineBreakState.previous_WordBreak;
                                if (isFirstWordOfLine && savedSoftLineBreakingSpace !== -1) {
                                    if (savedSoftLineBreakingSpace !== lastSoftLineBreak) {
                                        i = this.RestoreWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedSoftLineBreakState"));
                                        lastSoftLineBreak = savedSoftLineBreakingSpace;

                                        // check if soft hyphen
                                        if (this.m_textInfo.characterInfo[ this.m_characterCount - 1 ].character === 173) {
                                            characterToSubstitute.index = this.m_characterCount - 1;
                                            characterToSubstitute.unicode = 45;

                                            i -= 1;
                                            this.m_characterCount -= 1;
                                            continue;
                                        }
                                    }
                                }

                                // Determine if new line of text would exceed the vertical bounds of text container
                                if (newTextHeight > marginHeight + 0.0001) {
                                    // Set isTextOverflowing and firstOverflowCharacterIndex
                                    if (this.m_firstOverflowCharacterIndex === -1) {
                                        this.m_firstOverflowCharacterIndex = this.m_characterCount;
                                    }

                                    // Check if Auto-Size is enabled
                                    if (this.m_enableAutoSizing) {
                                        // Handle Line spacing adjustments


                                        if (this.m_lineSpacingDelta > this.m_lineSpacingMax && this.m_AutoSizeIterationCount < this.m_AutoSizeMaxIterationCount) {
                                            var adjustmentDelta2 = (marginHeight - newTextHeight) / (this.m_lineNumber + 1);

                                            this.m_lineSpacingDelta = UnityEngine.Mathf.Max(this.m_lineSpacingDelta + adjustmentDelta2 / baseScale, this.m_lineSpacingMax);

                                            //Debug.Log("[" + m_AutoSizeIterationCount + "] Reducing Line Spacing. Delta of [" + m_lineSpacingDelta.ToString("f3") + "].");
                                            return;
                                        }


                                        // Handle Character Width Adjustments


                                        if (this.m_charWidthAdjDelta < this.m_charWidthMaxAdj / 100 && this.m_AutoSizeIterationCount < this.m_AutoSizeMaxIterationCount) {
                                            var adjustedTextWidth1 = textWidth;

                                            // Determine full width of the text
                                            if (this.m_charWidthAdjDelta > 0) {
                                                adjustedTextWidth1 /= 1.0 - this.m_charWidthAdjDelta;
                                            }

                                            var adjustmentDelta3 = textWidth - (widthOfTextArea - 0.0001) * (isJustifiedOrFlush ? 1.05 : 1.0);
                                            this.m_charWidthAdjDelta += adjustmentDelta3 / adjustedTextWidth1;
                                            this.m_charWidthAdjDelta = UnityEngine.Mathf.Min(this.m_charWidthAdjDelta, this.m_charWidthMaxAdj / 100);

                                            //Debug.Log("[" + m_AutoSizeIterationCount + "] Reducing Character Width by " + (m_charWidthAdjDelta * 100) + "%");
                                            return;
                                        }


                                        // Handle Text Auto-sizing resulting from text exceeding vertical bounds.


                                        if (this.m_fontSize > this.m_fontSizeMin && this.m_AutoSizeIterationCount < this.m_AutoSizeMaxIterationCount) {
                                            this.m_maxFontSize = this.m_fontSize;

                                            var sizeDelta2 = UnityEngine.Mathf.Max((this.m_fontSize - this.m_minFontSize) / 2, 0.05);
                                            this.m_fontSize -= sizeDelta2;
                                            this.m_fontSize = UnityEngine.Mathf.Max((this.m_fontSize * 20 + 0.5) / 20.0, this.m_fontSizeMin);

                                            //Debug.Log("[" + m_AutoSizeIterationCount + "] Reducing Point Size from [" + m_maxFontSize.ToString("f3") + "] to [" + m_fontSize.ToString("f3") + "] with delta of [" + sizeDelta.ToString("f3") + "].");
                                            return;
                                        }

                                    }

                                    // Check Text Overflow Modes
                                    switch (this.m_overflowMode) {
                                        case TMPro.TextOverflowModes.Overflow: 
                                        case TMPro.TextOverflowModes.ScrollRect: 
                                        case TMPro.TextOverflowModes.Masking: 
                                            this.InsertNewLine(i, baseScale, currentElementScale, currentEmScale, this.m_GlyphHorizontalAdvanceAdjustment, boldSpacingAdjustment, characterSpacingAdjustment, widthOfTextArea, lineGap, isMaxVisibleDescenderSet, maxVisibleDescender);
                                            isStartOfNewLine = true;
                                            isFirstWordOfLine = true;
                                            continue;
                                        case TMPro.TextOverflowModes.Truncate: 
                                            i = this.RestoreWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedLastValidState"));
                                            characterToSubstitute.index = testedCharacterCount;
                                            characterToSubstitute.unicode = 3;
                                            continue;
                                        case TMPro.TextOverflowModes.Ellipsis: 
                                            if (TMPro.TMP_Text.m_EllipsisInsertionCandidateStack.Count === 0) {
                                                i = -1;
                                                this.m_characterCount = 0;
                                                characterToSubstitute.index = 0;
                                                characterToSubstitute.unicode = 3;
                                                this.m_firstCharacterOfLine = 0;
                                                continue;
                                            }
                                            var ellipsisState1 = { v : TMPro.TMP_Text.m_EllipsisInsertionCandidateStack.Pop().$clone() };
                                            i = this.RestoreWordWrappingState(ellipsisState1);
                                            i -= 1;
                                            this.m_characterCount -= 1;
                                            characterToSubstitute.index = this.m_characterCount;
                                            characterToSubstitute.unicode = 8230;
                                            restoreCount += 1;
                                            continue;
                                        case TMPro.TextOverflowModes.Linked: 
                                            if (UnityEngine.MonoBehaviour.op_Inequality(this.m_linkedTextComponent, null)) {
                                                this.m_linkedTextComponent.text = this.text;
                                                this.m_linkedTextComponent.m_inputSource = this.m_inputSource;
                                                this.m_linkedTextComponent.firstVisibleCharacter = this.m_characterCount;
                                                this.m_linkedTextComponent.ForceMeshUpdate();

                                                this.m_isTextTruncated = true;
                                            }
                                            // Truncate remaining text
                                            characterToSubstitute.index = this.m_characterCount;
                                            characterToSubstitute.unicode = 3;
                                            continue;
                                        case TMPro.TextOverflowModes.Page: 
                                            // Add new page
                                            this.m_isNewPage = true;
                                            this.InsertNewLine(i, baseScale, currentElementScale, currentEmScale, this.m_GlyphHorizontalAdvanceAdjustment, boldSpacingAdjustment, characterSpacingAdjustment, widthOfTextArea, lineGap, isMaxVisibleDescenderSet, maxVisibleDescender);
                                            this.m_startOfLineAscender = 0;
                                            this.m_lineOffset = 0;
                                            this.m_maxTextAscender = 0;
                                            this.m_PageAscender = 0;
                                            this.m_pageNumber += 1;
                                            isStartOfNewLine = true;
                                            isFirstWordOfLine = true;
                                            continue;
                                    }
                                } else {
                                    //if (m_enableAutoSizing && isFirstWordOfLine)
                                    //{
                                    //    // Handle Character Width Adjustments
                                    //    #region Character Width Adjustments
                                    //    if (m_charWidthAdjDelta < m_charWidthMaxAdj / 100 && m_AutoSizeIterationCount < m_AutoSizeMaxIterationCount)
                                    //    {
                                    //        //m_AutoSizeIterationCount = 0;
                                    //        float adjustedTextWidth = textWidth;

                                    //        // Determine full width of the text
                                    //        if (m_charWidthAdjDelta > 0)
                                    //            adjustedTextWidth /= 1f - m_charWidthAdjDelta;

                                    //        float adjustmentDelta = textWidth - (widthOfTextArea - 0.0001f) * (isJustifiedOrFlush ? 1.05f : 1.0f);
                                    //        m_charWidthAdjDelta += adjustmentDelta / adjustedTextWidth;
                                    //        m_charWidthAdjDelta = Mathf.Min(m_charWidthAdjDelta, m_charWidthMaxAdj / 100);

                                    //        //Debug.Log("[" + m_AutoSizeIterationCount + "] Reducing Character Width by " + (m_charWidthAdjDelta * 100) + "%");

                                    //        GenerateTextMesh();
                                    //        return;
                                    //    }
                                    //    #endregion
                                    //}

                                    // New line of text does not exceed vertical bounds of text container
                                    this.InsertNewLine(i, baseScale, currentElementScale, currentEmScale, this.m_GlyphHorizontalAdvanceAdjustment, boldSpacingAdjustment, characterSpacingAdjustment, widthOfTextArea, lineGap, isMaxVisibleDescenderSet, maxVisibleDescender);
                                    isStartOfNewLine = true;
                                    isFirstWordOfLine = true;
                                    continue;
                                }
                            } else {
                                if (this.m_enableAutoSizing && this.m_AutoSizeIterationCount < this.m_AutoSizeMaxIterationCount) {
                                    // Handle Character Width Adjustments


                                    if (this.m_charWidthAdjDelta < this.m_charWidthMaxAdj / 100) {
                                        var adjustedTextWidth2 = textWidth;

                                        // Determine full width of the text
                                        if (this.m_charWidthAdjDelta > 0) {
                                            adjustedTextWidth2 /= 1.0 - this.m_charWidthAdjDelta;
                                        }

                                        var adjustmentDelta4 = textWidth - (widthOfTextArea - 0.0001) * (isJustifiedOrFlush ? 1.05 : 1.0);
                                        this.m_charWidthAdjDelta += adjustmentDelta4 / adjustedTextWidth2;
                                        this.m_charWidthAdjDelta = UnityEngine.Mathf.Min(this.m_charWidthAdjDelta, this.m_charWidthMaxAdj / 100);

                                        //Debug.Log("[" + m_AutoSizeIterationCount + "] Reducing Character Width by " + (m_charWidthAdjDelta * 100) + "%");
                                        return;
                                    }


                                    // Handle Text Auto-sizing resulting from text exceeding horizontal bounds.


                                    if (this.m_fontSize > this.m_fontSizeMin) {
                                        // Reset character width adjustment delta
                                        //m_charWidthAdjDelta = 0;

                                        // Adjust Point Size
                                        this.m_maxFontSize = this.m_fontSize;

                                        var sizeDelta3 = UnityEngine.Mathf.Max((this.m_fontSize - this.m_minFontSize) / 2, 0.05);
                                        this.m_fontSize -= sizeDelta3;
                                        this.m_fontSize = UnityEngine.Mathf.Max((this.m_fontSize * 20 + 0.5) / 20.0, this.m_fontSizeMin);

                                        //Debug.Log("[" + m_AutoSizeIterationCount + "] Reducing Point Size from [" + m_maxFontSize.ToString("f3") + "] to [" + m_fontSize.ToString("f3") + "] with delta of [" + sizeDelta.ToString("f3") + "].");
                                        return;
                                    }

                                }

                                // Check Text Overflow Modes
                                switch (this.m_overflowMode) {
                                    case TMPro.TextOverflowModes.Overflow: 
                                    case TMPro.TextOverflowModes.ScrollRect: 
                                    case TMPro.TextOverflowModes.Masking: 
                                        // Nothing happens as horizontal bounds are ignored in this mode.
                                        break;
                                    case TMPro.TextOverflowModes.Truncate: 
                                        i = this.RestoreWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedWordWrapState"));
                                        characterToSubstitute.index = testedCharacterCount;
                                        characterToSubstitute.unicode = 3;
                                        continue;
                                    case TMPro.TextOverflowModes.Ellipsis: 
                                        if (TMPro.TMP_Text.m_EllipsisInsertionCandidateStack.Count === 0) {
                                            i = -1;
                                            this.m_characterCount = 0;
                                            characterToSubstitute.index = 0;
                                            characterToSubstitute.unicode = 3;
                                            this.m_firstCharacterOfLine = 0;
                                            continue;
                                        }
                                        var ellipsisState2 = { v : TMPro.TMP_Text.m_EllipsisInsertionCandidateStack.Pop().$clone() };
                                        i = this.RestoreWordWrappingState(ellipsisState2);
                                        i -= 1;
                                        this.m_characterCount -= 1;
                                        characterToSubstitute.index = this.m_characterCount;
                                        characterToSubstitute.unicode = 8230;
                                        restoreCount += 1;
                                        continue;
                                    case TMPro.TextOverflowModes.Linked: 
                                        i = this.RestoreWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedWordWrapState"));
                                        if (UnityEngine.MonoBehaviour.op_Inequality(this.m_linkedTextComponent, null)) {
                                            this.m_linkedTextComponent.text = this.text;
                                            this.m_linkedTextComponent.m_inputSource = this.m_inputSource;
                                            this.m_linkedTextComponent.firstVisibleCharacter = this.m_characterCount;
                                            this.m_linkedTextComponent.ForceMeshUpdate();

                                            this.m_isTextTruncated = true;
                                        }
                                        // Truncate text the overflows the vertical bounds
                                        characterToSubstitute.index = this.m_characterCount;
                                        characterToSubstitute.unicode = 3;
                                        continue;
                                }
                            }
                        }



                        // Special handling of characters that are not ignored at the end of a line.
                        if (charCode === 9) {
                            characterInfo.isVisible = false;
                            this.m_lastVisibleCharacterOfLine = this.m_characterCount;
                            this.m_textInfo.lineInfo[ this.m_lineNumber ].spaceCount += 1;
                            this.m_textInfo.spaceCount += 1;
                        } else if (charCode === 173) {
                            characterInfo.isVisible = false;
                        } else {
                            // Determine Vertex Color
                            if (this.m_overrideHtmlColors) {
                                vertexColor = this.m_fontColor32.$clone();
                            } else {
                                vertexColor = this.m_htmlColor.$clone();
                            }

                            // Store Character & Sprite Vertex Information
                            if (this.m_textElementType === TMPro.TMP_TextElementType.Character) {
                                // Save Character Vertex Data
                                this.SaveGlyphVertexInfo(padding, style_padding, vertexColor.$clone());
                            } else if (this.m_textElementType === TMPro.TMP_TextElementType.Sprite) {
                                this.SaveSpriteVertexInfo(vertexColor.$clone());
                            }

                            if (isStartOfNewLine) {
                                isStartOfNewLine = false;
                                this.m_firstVisibleCharacterOfLine = this.m_characterCount;
                            }

                            this.m_lineVisibleCharacterCount += 1;
                            this.m_lastVisibleCharacterOfLine = this.m_characterCount;
                            this.m_textInfo.lineInfo[ this.m_lineNumber ].marginLeft = marginLeft;
                            this.m_textInfo.lineInfo[ this.m_lineNumber ].marginRight = marginRight;
                        }
                    } else {
                        // Special handling for text overflow linked mode


                        if (this.m_overflowMode === TMPro.TextOverflowModes.Linked && (charCode === 10 || charCode === 11)) {
                            var textHeight1 = this.m_maxTextAscender - (this.m_maxLineDescender - this.m_lineOffset) + (this.m_lineOffset > 0 && this.m_IsDrivenLineSpacing === false ? this.m_maxLineAscender - this.m_startOfLineAscender : 0);

                            var testedCharacterCount1 = this.m_characterCount;

                            if (textHeight1 > marginHeight + 0.0001) {
                                // Set isTextOverflowing and firstOverflowCharacterIndex
                                if (this.m_firstOverflowCharacterIndex === -1) {
                                    this.m_firstOverflowCharacterIndex = this.m_characterCount;
                                }

                                i = this.RestoreWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedLastValidState"));

                                if (UnityEngine.MonoBehaviour.op_Inequality(this.m_linkedTextComponent, null)) {
                                    this.m_linkedTextComponent.text = this.text;
                                    this.m_linkedTextComponent.m_inputSource = this.m_inputSource;
                                    this.m_linkedTextComponent.firstVisibleCharacter = this.m_characterCount;
                                    this.m_linkedTextComponent.ForceMeshUpdate();

                                    this.m_isTextTruncated = true;
                                }

                                // Truncate remaining text
                                characterToSubstitute.index = testedCharacterCount1;
                                characterToSubstitute.unicode = 3;
                                continue;
                            }
                        }


                        // Track # of spaces per line which is used for line justification.
                        if ((charCode === 10 || charCode === 11 || charCode === 160 || charCode === 8199 || charCode === 8232 || charCode === 8233 || System.Char.isSeparator(charCode)) && charCode !== 173 && charCode !== 8203 && charCode !== 8288) {
                            this.m_textInfo.lineInfo[ this.m_lineNumber ].spaceCount += 1;
                            this.m_textInfo.spaceCount += 1;
                        }

                        if (charCode === 160) {
                            this.m_textInfo.lineInfo[ this.m_lineNumber ].controlCharacterCount += 1;
                        }
                    }



                    // Tracking of potential insertion positions for Ellipsis character


                    if (this.m_overflowMode === TMPro.TextOverflowModes.Ellipsis && (isInjectingCharacter === false || charCode === 45)) {
                        var fontScale1 = this.m_currentFontSize / this.m_Ellipsis.fontAsset.m_FaceInfo.pointSize * this.m_Ellipsis.fontAsset.m_FaceInfo.scale * (this.m_isOrthographic ? 1 : 0.1);
                        var scale = fontScale1 * this.m_fontScaleMultiplier * this.m_Ellipsis.character.m_Scale * this.m_Ellipsis.character.m_Glyph.scale;
                        var marginLeft1 = this.m_marginLeft;
                        var marginRight1 = this.m_marginRight;

                        // Use the scale and margins of the previous character if Line Feed (LF) is not the first character of a line.
                        if (charCode === 10 && this.m_characterCount !== this.m_firstCharacterOfLine) {
                            fontScale1 = this.m_textInfo.characterInfo[ this.m_characterCount - 1 ].pointSize / this.m_Ellipsis.fontAsset.m_FaceInfo.pointSize * this.m_Ellipsis.fontAsset.m_FaceInfo.scale * (this.m_isOrthographic ? 1 : 0.1);
                            scale = fontScale1 * this.m_fontScaleMultiplier * this.m_Ellipsis.character.m_Scale * this.m_Ellipsis.character.m_Glyph.scale;
                            marginLeft1 = this.m_textInfo.lineInfo[ this.m_lineNumber ].marginLeft;
                            marginRight1 = this.m_textInfo.lineInfo[ this.m_lineNumber ].marginRight;
                        }

                        var textHeight2 = this.m_maxTextAscender - (this.m_maxLineDescender - this.m_lineOffset) + (this.m_lineOffset > 0 && this.m_IsDrivenLineSpacing === false ? this.m_maxLineAscender - this.m_startOfLineAscender : 0);
                        var textWidth1 = Math.abs(this.m_xAdvance) + (!this.m_isRightToLeft ? this.m_Ellipsis.character.m_Glyph.metrics.horizontalAdvance : 0) * (1 - this.m_charWidthAdjDelta) * scale;
                        var widthOfTextAreaForEllipsis = this.m_width !== -1 ? UnityEngine.Mathf.Min(marginWidth + 0.0001 - marginLeft1 - marginRight1, this.m_width) : marginWidth + 0.0001 - marginLeft1 - marginRight1;

                        if (textWidth1 < widthOfTextAreaForEllipsis * (isJustifiedOrFlush ? 1.05 : 1.0) && textHeight2 < marginHeight + 0.0001) {
                            this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedEllipsisState"), i, this.m_characterCount);
                            TMPro.TMP_Text.m_EllipsisInsertionCandidateStack.Push(TMPro.TMP_Text.m_SavedEllipsisState.$clone());
                        }
                    }



                    // Store Rectangle positions for each Character.


                    characterInfo.lineNumber = this.m_lineNumber;
                    characterInfo.pageNumber = this.m_pageNumber;

                    if (charCode !== 10 && charCode !== 11 && charCode !== 13 && isInjectingCharacter === false || this.m_textInfo.lineInfo[ this.m_lineNumber ].characterCount === 1) {
                        this.m_textInfo.lineInfo[ this.m_lineNumber ].alignment = this.m_lineJustification;
                    }



                    // Handle xAdvance & Tabulation Stops. Tab stops at every 25% of Font Size.


                    if (charCode === 9) {
                        var tabSize = this.m_currentFontAsset.m_FaceInfo.tabWidth * this.m_currentFontAsset.tabSize * currentElementScale;
                        var tabs = Math.ceil(this.m_xAdvance / tabSize) * tabSize;
                        this.m_xAdvance = tabs > this.m_xAdvance ? tabs : this.m_xAdvance + tabSize;
                    } else if (this.m_monoSpacing !== 0) {
                        this.m_xAdvance += (this.m_monoSpacing - monoAdvance + (this.m_currentFontAsset.normalSpacingOffset + characterSpacingAdjustment) * currentEmScale + this.m_cSpacing) * (1 - this.m_charWidthAdjDelta);

                        if (isWhiteSpace || charCode === 8203) {
                            this.m_xAdvance += this.m_wordSpacing * currentEmScale;
                        }
                    } else if (this.m_isRightToLeft) {
                        this.m_xAdvance -= (glyphAdjustments.m_XAdvance * currentElementScale + (this.m_currentFontAsset.normalSpacingOffset + characterSpacingAdjustment + boldSpacingAdjustment) * currentEmScale + this.m_cSpacing) * (1 - this.m_charWidthAdjDelta);

                        if (isWhiteSpace || charCode === 8203) {
                            this.m_xAdvance -= this.m_wordSpacing * currentEmScale;
                        }
                    } else {
                        var scaleFXMultiplier = 1;
                        if (this.m_isFXMatrixSet) {
                            scaleFXMultiplier = this.m_FXMatrix.getScale().x;
                        }

                        this.m_xAdvance += ((currentGlyphMetrics.horizontalAdvance * scaleFXMultiplier + glyphAdjustments.m_XAdvance) * currentElementScale + (this.m_currentFontAsset.normalSpacingOffset + characterSpacingAdjustment + boldSpacingAdjustment) * currentEmScale + this.m_cSpacing) * (1 - this.m_charWidthAdjDelta);

                        if (isWhiteSpace || charCode === 8203) {
                            this.m_xAdvance += this.m_wordSpacing * currentEmScale;
                        }
                    }

                    // Store xAdvance information
                    characterInfo.xAdvance = this.m_xAdvance;



                    // Handle Carriage Return


                    if (charCode === 13) {
                        this.m_xAdvance = 0 + this.tag_Indent;
                    }



                    // Handle Line Spacing Adjustments + Word Wrapping & special case for last line.


                    if (charCode === 10 || charCode === 11 || charCode === 3 || charCode === 8232 || charCode === 8233 || charCode === 45 && isInjectingCharacter || this.m_characterCount === totalCharacterCount - 1) {
                        // Adjust current line spacing (if necessary) before inserting new line
                        var baselineAdjustmentDelta = this.m_maxLineAscender - this.m_startOfLineAscender;
                        if (this.m_lineOffset > 0 && Math.abs(baselineAdjustmentDelta) > 0.01 && this.m_IsDrivenLineSpacing === false && !this.m_isNewPage) {
                            //Debug.Log("Line Feed - Adjusting Line Spacing on line #" + m_lineNumber);
                            this.AdjustLineOffset(this.m_firstCharacterOfLine, this.m_characterCount, baselineAdjustmentDelta);
                            this.m_ElementDescender -= baselineAdjustmentDelta;
                            this.m_lineOffset += baselineAdjustmentDelta;

                            // Adjust saved ellipsis state only if we are adjusting the same line number
                            if (TMPro.TMP_Text.m_SavedEllipsisState.lineNumber === this.m_lineNumber) {
                                TMPro.TMP_Text.m_SavedEllipsisState = TMPro.TMP_Text.m_EllipsisInsertionCandidateStack.Pop().$clone();
                                TMPro.TMP_Text.m_SavedEllipsisState.startOfLineAscender += baselineAdjustmentDelta;
                                TMPro.TMP_Text.m_SavedEllipsisState.lineOffset += baselineAdjustmentDelta;
                                TMPro.TMP_Text.m_EllipsisInsertionCandidateStack.Push(TMPro.TMP_Text.m_SavedEllipsisState.$clone());
                            }
                        }

                        this.m_isNewPage = false;

                        // Calculate lineAscender & make sure if last character is superscript or subscript that we check that as well.
                        var lineAscender = this.m_maxLineAscender - this.m_lineOffset;
                        var lineDescender = this.m_maxLineDescender - this.m_lineOffset;

                        // Update maxDescender and maxVisibleDescender
                        this.m_ElementDescender = this.m_ElementDescender < lineDescender ? this.m_ElementDescender : lineDescender;
                        if (!isMaxVisibleDescenderSet.v) {
                            maxVisibleDescender.v = this.m_ElementDescender;
                        }

                        if (this.m_useMaxVisibleDescender && (this.m_characterCount >= this.m_maxVisibleCharacters || this.m_lineNumber >= this.m_maxVisibleLines)) {
                            isMaxVisibleDescenderSet.v = true;
                        }

                        // Save Line Information
                        lineInfo = this.m_textInfo.lineInfo[ this.m_lineNumber ];

                        lineInfo.firstCharacterIndex = this.m_firstCharacterOfLine;
                        lineInfo.firstVisibleCharacterIndex = (this.m_firstVisibleCharacterOfLine = this.m_firstCharacterOfLine > this.m_firstVisibleCharacterOfLine ? this.m_firstCharacterOfLine : this.m_firstVisibleCharacterOfLine);
                        lineInfo.lastCharacterIndex = (this.m_lastCharacterOfLine = this.m_characterCount);
                        lineInfo.lastVisibleCharacterIndex = (this.m_lastVisibleCharacterOfLine = this.m_lastVisibleCharacterOfLine < this.m_firstVisibleCharacterOfLine ? this.m_firstVisibleCharacterOfLine : this.m_lastVisibleCharacterOfLine);
                        lineInfo.characterCount = ($t9 = this.m_textInfo.lineInfo)[this.m_lineNumber].lastCharacterIndex - ($t10 = this.m_textInfo.lineInfo)[this.m_lineNumber].firstCharacterIndex + 1;
                        lineInfo.visibleCharacterCount = this.m_lineVisibleCharacterCount;

                        lineInfo.lineExtents.min.set( ($t11 = this.m_textInfo.characterInfo)[this.m_firstVisibleCharacterOfLine].bottomLeft.x, lineDescender );
                        lineInfo.lineExtents.max.set( ($t12 = this.m_textInfo.characterInfo)[this.m_lastVisibleCharacterOfLine].topRight.x, lineAscender );
                        lineInfo.length = lineInfo.lineExtents.max.x - padding * currentElementScale;

                        lineInfo.width = widthOfTextArea;

                        if (lineInfo.characterCount === 1) {
                            lineInfo.alignment = this.m_lineJustification;
                        }

                        var maxAdvanceOffset = (boldSpacingAdjustment * currentElementScale + (this.m_currentFontAsset.normalSpacingOffset + characterSpacingAdjustment) * currentEmScale - this.m_cSpacing) * (1 - this.m_charWidthAdjDelta);
                        if (($t13 = this.m_textInfo.characterInfo)[this.m_lastVisibleCharacterOfLine].isVisible) {
                            lineInfo.maxAdvance = ($t14 = this.m_textInfo.characterInfo)[this.m_lastVisibleCharacterOfLine].xAdvance + (this.m_isRightToLeft ? maxAdvanceOffset : -maxAdvanceOffset);
                        } else {
                            lineInfo.maxAdvance = ($t15 = this.m_textInfo.characterInfo)[this.m_lastCharacterOfLine].xAdvance + (this.m_isRightToLeft ? maxAdvanceOffset : -maxAdvanceOffset);
                        }

                        lineInfo.baseline = 0 - this.m_lineOffset;
                        lineInfo.ascender = lineAscender;
                        lineInfo.descender = lineDescender;
                        lineInfo.lineHeight = lineAscender - lineDescender + lineGap * baseScale;

                        // Add new line if not last line or character.
                        if (charCode === 10 || charCode === 11 || charCode === 45 || charCode === 8232 || charCode === 8233) {
                            // Store the state of the line before starting on the new line.
                            this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedLineState"), i, this.m_characterCount);

                            this.m_lineNumber += 1;
                            isStartOfNewLine = true;
                            ignoreNonBreakingSpace = false;
                            isFirstWordOfLine = true;

                            this.m_firstCharacterOfLine = this.m_characterCount + 1;
                            this.m_lineVisibleCharacterCount = 0;

                            // Check to make sure Array is large enough to hold a new line.
                            if (this.m_lineNumber >= this.m_textInfo.lineInfo.length) {
                                this.ResizeLineExtents(this.m_lineNumber);
                            }

                            var lastVisibleAscender = ($t16 = this.m_textInfo.characterInfo)[this.m_characterCount].adjustedAscender;

                            // Apply Line Spacing with special handling for VT char(11)
                            if (this.m_lineHeight === TMPro.TMP_Math.FLOAT_UNSET) {
                                var lineOffsetDelta1 = 0 - this.m_maxLineDescender + lastVisibleAscender + (lineGap + this.m_lineSpacingDelta) * baseScale + (this.m_lineSpacing + (charCode === 10 || charCode === 8233 ? this.m_paragraphSpacing : 0)) * currentEmScale;
                                this.m_lineOffset += lineOffsetDelta1;
                                this.m_IsDrivenLineSpacing = false;
                            } else {
                                this.m_lineOffset += this.m_lineHeight + (this.m_lineSpacing + (charCode === 10 || charCode === 8233 ? this.m_paragraphSpacing : 0)) * currentEmScale;
                                this.m_IsDrivenLineSpacing = true;
                            }

                            this.m_maxLineAscender = TMPro.TMP_Text.k_LargeNegativeFloat;
                            this.m_maxLineDescender = TMPro.TMP_Text.k_LargePositiveFloat;
                            this.m_startOfLineAscender = lastVisibleAscender;

                            this.m_xAdvance = 0 + this.tag_LineIndent + this.tag_Indent;

                            this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedWordWrapState"), i, this.m_characterCount);
                            this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedLastValidState"), i, this.m_characterCount);

                            this.m_characterCount += 1;

                            continue;
                        }

                        // If End of Text
                        if (charCode === 3) {
                            i = this.m_TextProcessingArray.length;
                        }
                    }



                    // Store Rectangle positions for each Character.


                    // Determine the bounds of the Mesh.
                    if (($t17 = this.m_textInfo.characterInfo)[this.m_characterCount].isVisible) {
                        this.m_meshExtents.min.x = UnityEngine.Mathf.Min(this.m_meshExtents.min.x, ($t18 = this.m_textInfo.characterInfo)[this.m_characterCount].bottomLeft.x);
                        this.m_meshExtents.min.y = UnityEngine.Mathf.Min(this.m_meshExtents.min.y, ($t19 = this.m_textInfo.characterInfo)[this.m_characterCount].bottomLeft.y);

                        this.m_meshExtents.max.x = UnityEngine.Mathf.Max(this.m_meshExtents.max.x, ($t20 = this.m_textInfo.characterInfo)[this.m_characterCount].topRight.x);
                        this.m_meshExtents.max.y = UnityEngine.Mathf.Max(this.m_meshExtents.max.y, ($t21 = this.m_textInfo.characterInfo)[this.m_characterCount].topRight.y);

                        //m_meshExtents.min = new Vector2(Mathf.Min(m_meshExtents.min.x, m_textInfo.characterInfo[m_characterCount].bottomLeft.x), Mathf.Min(m_meshExtents.min.y, m_textInfo.characterInfo[m_characterCount].bottomLeft.y));
                        //m_meshExtents.max = new Vector2(Mathf.Max(m_meshExtents.max.x, m_textInfo.characterInfo[m_characterCount].topRight.x), Mathf.Max(m_meshExtents.max.y, m_textInfo.characterInfo[m_characterCount].topRight.y));
                    }


                    // Save pageInfo Data
                    if (this.m_overflowMode === TMPro.TextOverflowModes.Page && charCode !== 10 && charCode !== 11 && charCode !== 13 && charCode !== 8232 && charCode !== 8233) {
                        // Check if we need to increase allocations for the pageInfo array.
                        if (this.m_pageNumber + 1 > this.m_textInfo.pageInfo.length) {
                            TMPro.TMP_TextInfo.Resize$1(TMPro.TMP_PageInfo, Bridge.ref(this.m_textInfo, "pageInfo"), this.m_pageNumber + 1, true);
                        }

                        ($t22 = this.m_textInfo.pageInfo)[this.m_pageNumber].ascender = this.m_PageAscender;
                        ($t23 = this.m_textInfo.pageInfo)[this.m_pageNumber].descender = this.m_ElementDescender < ($t24 = this.m_textInfo.pageInfo)[this.m_pageNumber].descender ? this.m_ElementDescender : ($t25 = this.m_textInfo.pageInfo)[this.m_pageNumber].descender;

                        if (this.m_pageNumber === 0 && this.m_characterCount === 0) {
                            ($t26 = this.m_textInfo.pageInfo)[this.m_pageNumber].firstCharacterIndex = this.m_characterCount;
                        } else if (this.m_characterCount > 0 && this.m_pageNumber !== ($t27 = this.m_textInfo.characterInfo)[this.m_characterCount - 1].pageNumber) {
                            ($t28 = this.m_textInfo.pageInfo)[this.m_pageNumber - 1].lastCharacterIndex = this.m_characterCount - 1;
                            ($t29 = this.m_textInfo.pageInfo)[this.m_pageNumber].firstCharacterIndex = this.m_characterCount;
                        } else if (this.m_characterCount === totalCharacterCount - 1) {
                            ($t30 = this.m_textInfo.pageInfo)[this.m_pageNumber].lastCharacterIndex = this.m_characterCount;
                        }
                    }



                    // Save State of Mesh Creation for handling of Word Wrapping


                    if (this.m_enableWordWrapping || this.m_overflowMode === TMPro.TextOverflowModes.Truncate || this.m_overflowMode === TMPro.TextOverflowModes.Ellipsis || this.m_overflowMode === TMPro.TextOverflowModes.Linked) {
                        if ((isWhiteSpace || charCode === 8203 || charCode === 45 || charCode === 173) && (!this.m_isNonBreakingSpace || ignoreNonBreakingSpace) && charCode !== 160 && charCode !== 8199 && charCode !== 8209 && charCode !== 8239 && charCode !== 8288) {
                            // We store the state of numerous variables for the most recent Space, LineFeed or Carriage Return to enable them to be restored
                            // for Word Wrapping.
                            this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedWordWrapState"), i, this.m_characterCount);
                            isFirstWordOfLine = false;
                            //isLastCharacterCJK = false;

                            // Reset soft line breaking point since we now have a valid hard break point.
                            TMPro.TMP_Text.m_SavedSoftLineBreakState.previous_WordBreak = -1;
                        } else if (this.m_isNonBreakingSpace === false && ((charCode > 4352 && charCode < 4607 || charCode > 43360 && charCode < 43391 || charCode > 44032 && charCode < 55295) && TMPro.TMP_Settings.useModernHangulLineBreakingRules === false || charCode > 11904 && charCode < 40959 || charCode > 63744 && charCode < 64255 || charCode > 65072 && charCode < 65103 || charCode > 65280 && charCode < 65519)) {
                            var isCurrentLeadingCharacter = TMPro.TMP_Settings.linebreakingRules.leadingCharacters.containsKey(charCode);
                            var isNextFollowingCharacter = this.m_characterCount < totalCharacterCount - 1 && TMPro.TMP_Settings.linebreakingRules.followingCharacters.containsKey(($t31 = this.m_textInfo.characterInfo)[this.m_characterCount + 1].character);

                            if (isCurrentLeadingCharacter === false) {
                                if (isNextFollowingCharacter === false) {
                                    this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedWordWrapState"), i, this.m_characterCount);
                                    isFirstWordOfLine = false;
                                }

                                if (isFirstWordOfLine) {
                                    // Special handling for non-breaking space and soft line breaks
                                    if (isWhiteSpace) {
                                        this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedSoftLineBreakState"), i, this.m_characterCount);
                                    }

                                    this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedWordWrapState"), i, this.m_characterCount);
                                }
                            } else {
                                if (isFirstWordOfLine && isFirstCharacterOfLine) {
                                    // Special handling for non-breaking space and soft line breaks
                                    if (isWhiteSpace) {
                                        this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedSoftLineBreakState"), i, this.m_characterCount);
                                    }

                                    this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedWordWrapState"), i, this.m_characterCount);
                                }
                            }

                            //isLastCharacterCJK = true;
                        } else if (isFirstWordOfLine) {
                            // Special handling for non-breaking space and soft line breaks
                            if (isWhiteSpace || charCode === 173 && isSoftHyphenIgnored === false) {
                                this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedSoftLineBreakState"), i, this.m_characterCount);
                            }

                            this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedWordWrapState"), i, this.m_characterCount);
                            //isLastCharacterCJK = false;
                        }
                    }


                    this.SaveWordWrappingState(Bridge.ref(TMPro.TMP_Text, "m_SavedLastValidState"), i, this.m_characterCount);

                    this.m_characterCount += 1;
                }

                // Check Auto Sizing and increase font size to fill text container.


                fontSizeDelta = this.m_maxFontSize - this.m_minFontSize;
                if (this.m_enableAutoSizing && fontSizeDelta > 0.051 && this.m_fontSize < this.m_fontSizeMax && this.m_AutoSizeIterationCount < this.m_AutoSizeMaxIterationCount) {
                    // Reset character width adjustment delta
                    if (this.m_charWidthAdjDelta < this.m_charWidthMaxAdj / 100) {
                        this.m_charWidthAdjDelta = 0;
                    }

                    this.m_minFontSize = this.m_fontSize;

                    var sizeDelta4 = UnityEngine.Mathf.Max((this.m_maxFontSize - this.m_fontSize) / 2, 0.05);
                    this.m_fontSize += sizeDelta4;
                    this.m_fontSize = UnityEngine.Mathf.Min((this.m_fontSize * 20 + 0.5) / 20.0, this.m_fontSizeMax);

                    //Debug.Log("[" + m_AutoSizeIterationCount + "] Increasing Point Size from [" + m_minFontSize.ToString("f3") + "] to [" + m_fontSize.ToString("f3") + "] with delta of [" + sizeDelta.ToString("f3") + "].");
                    return;
                }


                this.m_IsAutoSizePointSizeSet = true;

                if (this.m_AutoSizeIterationCount >= this.m_AutoSizeMaxIterationCount) {
                    UnityEngine.Debug.Log$1("Auto Size Iteration Count: " + this.m_AutoSizeIterationCount + ". Final Point Size: " + System.Single.format(this.m_fontSize));
                }

                // If there are no visible characters or only character is End of Text (0x03)... no need to continue
                if (this.m_characterCount === 0 || this.m_characterCount === 1 && charCode === 3) {
                    this.ClearMesh();

                    // Event indicating the text has been regenerated.
                    TMPro.TMPro_EventManager.ON_TEXT_CHANGED(this);
                    return;
                }

                // End Sampling of Phase I

                // *** PHASE II of Text Generation ***
                var last_vert_index = { v : TMPro.TMP_Text.m_materialReferences[this.m_Underline.materialIndex].referenceCount * 4 };

                // Partial clear of the vertices array to mark unused vertices as degenerate.
                ($t32 = this.m_textInfo.meshInfo)[0].Clear$1(false);

                // Handle Text Alignment


                var anchorOffset = pc.Vec3.ZERO.clone();
                var corners = this.m_RectTransformCorners; // GetTextContainerLocalCorners();

                // Handle Vertical Text Alignment
                switch (this.m_VerticalAlignment) {
                    case TMPro.VerticalAlignmentOptions.Top: 
                        if (this.m_overflowMode !== TMPro.TextOverflowModes.Page) {
                            anchorOffset = corners[1].$clone().add( new pc.Vec3( 0 + margins.x, 0 - this.m_maxTextAscender - margins.y, 0 ) );
                        } else {
                            anchorOffset = corners[1].$clone().add( new pc.Vec3( 0 + margins.x, 0 - ($t33 = this.m_textInfo.pageInfo)[pageToDisplay].ascender - margins.y, 0 ) );
                        }
                        break;
                    case TMPro.VerticalAlignmentOptions.Middle: 
                        if (this.m_overflowMode !== TMPro.TextOverflowModes.Page) {
                            anchorOffset = (corners[0].$clone().add( corners[1] )).scale( 1.0 / ( 2 ) ).add( new pc.Vec3( 0 + margins.x, 0 - (this.m_maxTextAscender + margins.y + maxVisibleDescender.v - margins.w) / 2, 0 ) );
                        } else {
                            anchorOffset = (corners[0].$clone().add( corners[1] )).scale( 1.0 / ( 2 ) ).add( new pc.Vec3( 0 + margins.x, 0 - (($t34 = this.m_textInfo.pageInfo)[pageToDisplay].ascender + margins.y + ($t35 = this.m_textInfo.pageInfo)[pageToDisplay].descender - margins.w) / 2, 0 ) );
                        }
                        break;
                    case TMPro.VerticalAlignmentOptions.Bottom: 
                        if (this.m_overflowMode !== TMPro.TextOverflowModes.Page) {
                            anchorOffset = corners[0].$clone().add( new pc.Vec3( 0 + margins.x, 0 - maxVisibleDescender.v + margins.w, 0 ) );
                        } else {
                            anchorOffset = corners[0].$clone().add( new pc.Vec3( 0 + margins.x, 0 - ($t36 = this.m_textInfo.pageInfo)[pageToDisplay].descender + margins.w, 0 ) );
                        }
                        break;
                    case TMPro.VerticalAlignmentOptions.Baseline: 
                        anchorOffset = (corners[0].$clone().add( corners[1] )).scale( 1.0 / ( 2 ) ).add( new pc.Vec3( 0 + margins.x, 0, 0 ) );
                        break;
                    case TMPro.VerticalAlignmentOptions.Geometry: 
                        anchorOffset = (corners[0].$clone().add( corners[1] )).scale( 1.0 / ( 2 ) ).add( new pc.Vec3( 0 + margins.x, 0 - (this.m_meshExtents.max.y + margins.y + this.m_meshExtents.min.y - margins.w) / 2, 0 ) );
                        break;
                    case TMPro.VerticalAlignmentOptions.Capline: 
                        anchorOffset = (corners[0].$clone().add( corners[1] )).scale( 1.0 / ( 2 ) ).add( new pc.Vec3( 0 + margins.x, 0 - (this.m_maxCapHeight - margins.y - margins.w) / 2, 0 ) );
                        break;
                }



                // Initialization for Second Pass
                var justificationOffset = pc.Vec3.ZERO.clone();
                var offset = pc.Vec3.ZERO.clone();
                var vert_index_X4 = 0;
                var sprite_index_X4 = 0;

                var wordCount = 0;
                var lineCount = 0;
                var lastLine = 0;
                var isFirstSeperator = false;

                var isStartOfWord = false;
                var wordFirstChar = 0;
                var wordLastChar = 0;

                // Second Pass : Line Justification, UV Mapping, Character & Line Visibility & more.
                // Variables used to handle Canvas Render Modes and SDF Scaling
                var isCameraAssigned = UnityEngine.Component.op_Equality(this.m_canvas.worldCamera, null) ? false : true;
                var lossyScale = (this.m_previousLossyScaleY = this.transform$1.lossyScale.y);
                var canvasRenderMode = this.m_canvas.renderMode;
                var canvasScaleFactor = this.m_canvas.scaleFactor;

                var underlineColor = UnityEngine.Color32.op_Implicit$1(new pc.Color( 1, 1, 1, 1 ));
                var strikethroughColor = UnityEngine.Color32.op_Implicit$1(new pc.Color( 1, 1, 1, 1 ));
                var highlightState = new TMPro.HighlightState.$ctor1(new UnityEngine.Color32.$ctor1(255, 255, 0, 64), TMPro.TMP_Offset.zero.$clone());
                var xScale = 0;
                var xScaleMax = 0;
                var underlineStartScale = 0;
                var underlineEndScale = 0;
                var underlineMaxScale = 0;
                var underlineBaseLine = TMPro.TMP_Text.k_LargePositiveFloat;
                var lastPage = 0;

                var strikethroughPointSize = 0;
                var strikethroughScale = 0;
                var strikethroughBaseline = 0;

                var characterInfos = this.m_textInfo.characterInfo;


                for (var i1 = 0; i1 < this.m_characterCount; i1++) {
                    var counter = i1;
                    characterInfo = characterInfos[ counter ];

                    var currentFontAsset = characterInfos[i1].fontAsset;

                    var unicode = characterInfos[i1].character;

                    var currentLine = characterInfos[i1].lineNumber;
                    lineInfo = this.m_textInfo.lineInfo[ currentLine ];
                    lineCount = currentLine + 1;

                    var lineAlignment = lineInfo.alignment;

                    // Process Line Justification


                    switch (lineAlignment) {
                        case TMPro.HorizontalAlignmentOptions.Left: 
                            if (!this.m_isRightToLeft) {
                                justificationOffset.set( 0 + lineInfo.marginLeft, 0, 0 );
                            } else {
                                justificationOffset.set( 0 - lineInfo.maxAdvance, 0, 0 );
                            }
                            break;
                        case TMPro.HorizontalAlignmentOptions.Center: 
                            justificationOffset.set( lineInfo.marginLeft + lineInfo.width / 2 - lineInfo.maxAdvance / 2, 0, 0 );
                            break;
                        case TMPro.HorizontalAlignmentOptions.Geometry: 
                            justificationOffset.set( lineInfo.marginLeft + lineInfo.width / 2 - (lineInfo.lineExtents.min.x + lineInfo.lineExtents.max.x) / 2, 0, 0 );
                            break;
                        case TMPro.HorizontalAlignmentOptions.Right: 
                            if (!this.m_isRightToLeft) {
                                justificationOffset.set( lineInfo.marginLeft + lineInfo.width - lineInfo.maxAdvance, 0, 0 );
                            } else {
                                justificationOffset.set( lineInfo.marginLeft + lineInfo.width, 0, 0 );
                            }
                            break;
                        case TMPro.HorizontalAlignmentOptions.Justified: 
                        case TMPro.HorizontalAlignmentOptions.Flush: 
                            // Skip Zero Width Characters
                            if (unicode === 10 || unicode === 173 || unicode === 8203 || unicode === 8288 || unicode === 3) {
                                break;
                            }
                            var lastCharOfCurrentLine = characterInfos[lineInfo.lastCharacterIndex].character;
                            var isFlush = (lineAlignment & TMPro.HorizontalAlignmentOptions.Flush) === TMPro.HorizontalAlignmentOptions.Flush;
                            // In Justified mode, all lines are justified except the last one.
                            // In Flush mode, all lines are justified.
                            if (System.Char.isControl(lastCharOfCurrentLine) === false && currentLine < this.m_lineNumber || isFlush || lineInfo.maxAdvance > lineInfo.width) {
                                // First character of each line.
                                if (currentLine !== lastLine || i1 === 0 || i1 === this.m_firstVisibleCharacter) {
                                    if (!this.m_isRightToLeft) {
                                        justificationOffset.set( lineInfo.marginLeft, 0, 0 );
                                    } else {
                                        justificationOffset.set( lineInfo.marginLeft + lineInfo.width, 0, 0 );
                                    }

                                    if (System.Char.isSeparator(unicode)) {
                                        isFirstSeperator = true;
                                    } else {
                                        isFirstSeperator = false;
                                    }
                                } else {
                                    var gap = !this.m_isRightToLeft ? lineInfo.width - lineInfo.maxAdvance : lineInfo.width + lineInfo.maxAdvance;

                                    var visibleCount = lineInfo.visibleCharacterCount - 1 + lineInfo.controlCharacterCount;

                                    // Get the number of spaces for each line ignoring the last character if it is not visible (ie. a space or linefeed).
                                    var spaces = (characterInfos[lineInfo.lastCharacterIndex].isVisible ? lineInfo.spaceCount : lineInfo.spaceCount - 1) - lineInfo.controlCharacterCount;

                                    if (isFirstSeperator) {
                                        spaces -= 1;
                                        visibleCount += 1;
                                    }

                                    var ratio = spaces > 0 ? this.m_wordWrappingRatios : 1;

                                    if (spaces < 1) {
                                        spaces = 1;
                                    }

                                    if (unicode !== 160 && (unicode === 9 || System.Char.isSeparator(unicode))) {
                                        if (!this.m_isRightToLeft) {
                                            justificationOffset.x += gap * (1 - ratio) / spaces;
                                        } else {
                                            justificationOffset.x -= gap * (1 - ratio) / spaces;
                                        }
                                    } else {
                                        if (!this.m_isRightToLeft) {
                                            justificationOffset.x += gap * ratio / visibleCount;
                                        } else {
                                            justificationOffset.x -= gap * ratio / visibleCount;
                                        }
                                    }
                                }
                            } else {
                                if (!this.m_isRightToLeft) {
                                    justificationOffset.set( lineInfo.marginLeft, 0, 0 ); // Keep last line left justified.
                                } else {
                                    justificationOffset.set( lineInfo.marginLeft + lineInfo.width, 0, 0 ); // Keep last line right justified.
                                }
                            }
                            //Debug.Log("Char [" + (char)charCode + "] Code:" + charCode + "  Line # " + currentLine + "  Offset:" + justificationOffset + "  # Spaces:" + lineInfo.spaceCount + "  # Characters:" + lineInfo.characterCount);
                            break;
                    }


                    offset.copy( anchorOffset ).add( justificationOffset );

                    // Handle UV2 mapping options and packing of scale information into UV2.


                    var isCharacterVisible = characterInfos[i1].isVisible;
                    if (isCharacterVisible) {
                        var elementType = characterInfos[i1].elementType;
                        switch (elementType) {
                            case TMPro.TMP_TextElementType.Character: 
                                var lineExtents = lineInfo.lineExtents.$clone();
                                var uvOffset = this.m_uvLineOffset * currentLine % 1; // + m_uvOffset.x;
                                // Setup UV2 based on Character Mapping Options Selected
                                switch (this.m_horizontalMapping) {
                                    case TMPro.TextureMappingOptions.Character: 
                                        characterInfos[i1].vertex_BL.uv2.x = 0; //+ m_uvOffset.x;
                                        characterInfos[i1].vertex_TL.uv2.x = 0; //+ m_uvOffset.x;
                                        characterInfos[i1].vertex_TR.uv2.x = 1; //+ m_uvOffset.x;
                                        characterInfos[i1].vertex_BR.uv2.x = 1; //+ m_uvOffset.x;
                                        break;
                                    case TMPro.TextureMappingOptions.Line: 
                                        if (this.m_textAlignment !== TMPro.TextAlignmentOptions.Justified) {
                                            characterInfos[i1].vertex_BL.uv2.x = (characterInfos[i1].vertex_BL.position.x - lineExtents.min.x) / (lineExtents.max.x - lineExtents.min.x) + uvOffset;
                                            characterInfos[i1].vertex_TL.uv2.x = (characterInfos[i1].vertex_TL.position.x - lineExtents.min.x) / (lineExtents.max.x - lineExtents.min.x) + uvOffset;
                                            characterInfos[i1].vertex_TR.uv2.x = (characterInfos[i1].vertex_TR.position.x - lineExtents.min.x) / (lineExtents.max.x - lineExtents.min.x) + uvOffset;
                                            characterInfos[i1].vertex_BR.uv2.x = (characterInfos[i1].vertex_BR.position.x - lineExtents.min.x) / (lineExtents.max.x - lineExtents.min.x) + uvOffset;
                                            break;
                                        } else {
                                            characterInfos[i1].vertex_BL.uv2.x = (characterInfos[i1].vertex_BL.position.x + justificationOffset.x - this.m_meshExtents.min.x) / (this.m_meshExtents.max.x - this.m_meshExtents.min.x) + uvOffset;
                                            characterInfos[i1].vertex_TL.uv2.x = (characterInfos[i1].vertex_TL.position.x + justificationOffset.x - this.m_meshExtents.min.x) / (this.m_meshExtents.max.x - this.m_meshExtents.min.x) + uvOffset;
                                            characterInfos[i1].vertex_TR.uv2.x = (characterInfos[i1].vertex_TR.position.x + justificationOffset.x - this.m_meshExtents.min.x) / (this.m_meshExtents.max.x - this.m_meshExtents.min.x) + uvOffset;
                                            characterInfos[i1].vertex_BR.uv2.x = (characterInfos[i1].vertex_BR.position.x + justificationOffset.x - this.m_meshExtents.min.x) / (this.m_meshExtents.max.x - this.m_meshExtents.min.x) + uvOffset;
                                            break;
                                        }
                                    case TMPro.TextureMappingOptions.Paragraph: 
                                        characterInfos[i1].vertex_BL.uv2.x = (characterInfos[i1].vertex_BL.position.x + justificationOffset.x - this.m_meshExtents.min.x) / (this.m_meshExtents.max.x - this.m_meshExtents.min.x) + uvOffset;
                                        characterInfos[i1].vertex_TL.uv2.x = (characterInfos[i1].vertex_TL.position.x + justificationOffset.x - this.m_meshExtents.min.x) / (this.m_meshExtents.max.x - this.m_meshExtents.min.x) + uvOffset;
                                        characterInfos[i1].vertex_TR.uv2.x = (characterInfos[i1].vertex_TR.position.x + justificationOffset.x - this.m_meshExtents.min.x) / (this.m_meshExtents.max.x - this.m_meshExtents.min.x) + uvOffset;
                                        characterInfos[i1].vertex_BR.uv2.x = (characterInfos[i1].vertex_BR.position.x + justificationOffset.x - this.m_meshExtents.min.x) / (this.m_meshExtents.max.x - this.m_meshExtents.min.x) + uvOffset;
                                        break;
                                    case TMPro.TextureMappingOptions.MatchAspect: 
                                        switch (this.m_verticalMapping) {
                                            case TMPro.TextureMappingOptions.Character: 
                                                characterInfos[i1].vertex_BL.uv2.y = 0; // + m_uvOffset.y;
                                                characterInfos[i1].vertex_TL.uv2.y = 1; // + m_uvOffset.y;
                                                characterInfos[i1].vertex_TR.uv2.y = 0; // + m_uvOffset.y;
                                                characterInfos[i1].vertex_BR.uv2.y = 1; // + m_uvOffset.y;
                                                break;
                                            case TMPro.TextureMappingOptions.Line: 
                                                characterInfos[i1].vertex_BL.uv2.y = (characterInfos[i1].vertex_BL.position.y - lineExtents.min.y) / (lineExtents.max.y - lineExtents.min.y) + uvOffset;
                                                characterInfos[i1].vertex_TL.uv2.y = (characterInfos[i1].vertex_TL.position.y - lineExtents.min.y) / (lineExtents.max.y - lineExtents.min.y) + uvOffset;
                                                characterInfos[i1].vertex_TR.uv2.y = characterInfos[i1].vertex_BL.uv2.y;
                                                characterInfos[i1].vertex_BR.uv2.y = characterInfos[i1].vertex_TL.uv2.y;
                                                break;
                                            case TMPro.TextureMappingOptions.Paragraph: 
                                                characterInfos[i1].vertex_BL.uv2.y = (characterInfos[i1].vertex_BL.position.y - this.m_meshExtents.min.y) / (this.m_meshExtents.max.y - this.m_meshExtents.min.y) + uvOffset;
                                                characterInfos[i1].vertex_TL.uv2.y = (characterInfos[i1].vertex_TL.position.y - this.m_meshExtents.min.y) / (this.m_meshExtents.max.y - this.m_meshExtents.min.y) + uvOffset;
                                                characterInfos[i1].vertex_TR.uv2.y = characterInfos[i1].vertex_BL.uv2.y;
                                                characterInfos[i1].vertex_BR.uv2.y = characterInfos[i1].vertex_TL.uv2.y;
                                                break;
                                            case TMPro.TextureMappingOptions.MatchAspect: 
                                                UnityEngine.Debug.Log$1("ERROR: Cannot Match both Vertical & Horizontal.");
                                                break;
                                        }
                                        //float xDelta = 1 - (_uv2s[vert_index + 0].y * textMeshCharacterInfo[i].AspectRatio); // Left aligned
                                        var xDelta = (1 - (characterInfos[i1].vertex_BL.uv2.y + characterInfos[i1].vertex_TL.uv2.y) * characterInfos[i1].aspectRatio) / 2; // Center of Rectangle
                                        characterInfos[i1].vertex_BL.uv2.x = characterInfos[i1].vertex_BL.uv2.y * characterInfos[i1].aspectRatio + xDelta + uvOffset;
                                        characterInfos[i1].vertex_TL.uv2.x = characterInfos[i1].vertex_BL.uv2.x;
                                        characterInfos[i1].vertex_TR.uv2.x = characterInfos[i1].vertex_TL.uv2.y * characterInfos[i1].aspectRatio + xDelta + uvOffset;
                                        characterInfos[i1].vertex_BR.uv2.x = characterInfos[i1].vertex_TR.uv2.x;
                                        break;
                                }
                                switch (this.m_verticalMapping) {
                                    case TMPro.TextureMappingOptions.Character: 
                                        characterInfos[i1].vertex_BL.uv2.y = 0; // + m_uvOffset.y;
                                        characterInfos[i1].vertex_TL.uv2.y = 1; // + m_uvOffset.y;
                                        characterInfos[i1].vertex_TR.uv2.y = 1; // + m_uvOffset.y;
                                        characterInfos[i1].vertex_BR.uv2.y = 0; // + m_uvOffset.y;
                                        break;
                                    case TMPro.TextureMappingOptions.Line: 
                                        characterInfos[i1].vertex_BL.uv2.y = (characterInfos[i1].vertex_BL.position.y - lineInfo.descender) / (lineInfo.ascender - lineInfo.descender); // + m_uvOffset.y;
                                        characterInfos[i1].vertex_TL.uv2.y = (characterInfos[i1].vertex_TL.position.y - lineInfo.descender) / (lineInfo.ascender - lineInfo.descender); // + m_uvOffset.y;
                                        characterInfos[i1].vertex_TR.uv2.y = characterInfos[i1].vertex_TL.uv2.y;
                                        characterInfos[i1].vertex_BR.uv2.y = characterInfos[i1].vertex_BL.uv2.y;
                                        break;
                                    case TMPro.TextureMappingOptions.Paragraph: 
                                        characterInfos[i1].vertex_BL.uv2.y = (characterInfos[i1].vertex_BL.position.y - this.m_meshExtents.min.y) / (this.m_meshExtents.max.y - this.m_meshExtents.min.y); // + m_uvOffset.y;
                                        characterInfos[i1].vertex_TL.uv2.y = (characterInfos[i1].vertex_TL.position.y - this.m_meshExtents.min.y) / (this.m_meshExtents.max.y - this.m_meshExtents.min.y); // + m_uvOffset.y;
                                        characterInfos[i1].vertex_TR.uv2.y = characterInfos[i1].vertex_TL.uv2.y;
                                        characterInfos[i1].vertex_BR.uv2.y = characterInfos[i1].vertex_BL.uv2.y;
                                        break;
                                    case TMPro.TextureMappingOptions.MatchAspect: 
                                        var yDelta = (1 - (characterInfos[i1].vertex_BL.uv2.x + characterInfos[i1].vertex_TR.uv2.x) / characterInfos[i1].aspectRatio) / 2; // Center of Rectangle
                                        characterInfos[i1].vertex_BL.uv2.y = yDelta + characterInfos[i1].vertex_BL.uv2.x / characterInfos[i1].aspectRatio; // + m_uvOffset.y;
                                        characterInfos[i1].vertex_TL.uv2.y = yDelta + characterInfos[i1].vertex_TR.uv2.x / characterInfos[i1].aspectRatio; // + m_uvOffset.y;
                                        characterInfos[i1].vertex_BR.uv2.y = characterInfos[i1].vertex_BL.uv2.y;
                                        characterInfos[i1].vertex_TR.uv2.y = characterInfos[i1].vertex_TL.uv2.y;
                                        break;
                                }
                                // Pack UV's so that we can pass Xscale needed for Shader to maintain 1:1 ratio.
                                xScale = characterInfos[i1].scale * (1 - this.m_charWidthAdjDelta);
                                if (!characterInfos[i1].isUsingAlternateTypeface && (characterInfos[i1].style & TMPro.FontStyles.Bold) === TMPro.FontStyles.Bold) {
                                    xScale *= -1;
                                }
                                switch (canvasRenderMode) {
                                    case UnityEngine.RenderMode.ScreenSpaceOverlay: 
                                        xScale *= Math.abs(lossyScale) / canvasScaleFactor;
                                        break;
                                    case UnityEngine.RenderMode.ScreenSpaceCamera: 
                                        xScale *= isCameraAssigned ? Math.abs(lossyScale) : 1;
                                        break;
                                    case UnityEngine.RenderMode.WorldSpace: 
                                        xScale *= Math.abs(lossyScale);
                                        break;
                                }
                                // isBold is encoded in the X value and SDF Scale in Y.
                                //Vector2 vertexData = new Vector2((characterInfos[i].style & FontStyles.Bold) == FontStyles.Bold ? 1 : 0, xScale);
                                //characterInfos[i].vertex_BL.uv2 = vertexData;
                                //characterInfos[i].vertex_TL.uv2 = vertexData;
                                //characterInfos[i].vertex_TR.uv2 = vertexData;
                                //characterInfos[i].vertex_BR.uv2 = vertexData;
                                var x0 = characterInfos[i1].vertex_BL.uv2.x;
                                var y0 = characterInfos[i1].vertex_BL.uv2.y;
                                var x1 = characterInfos[i1].vertex_TR.uv2.x;
                                var y1 = characterInfos[i1].vertex_TR.uv2.y;
                                var dx = x0;
                                var dy = y0;
                                x0 = x0 - dx;
                                x1 = x1 - dx;
                                y0 = y0 - dy;
                                y1 = y1 - dy;
                                // Optimization to avoid having a vector2 returned from the Pack UV function.
                                characterInfos[i1].vertex_BL.uv2.x = this.PackUV(x0, y0);
                                characterInfos[i1].vertex_BL.uv2.y = xScale;
                                characterInfos[i1].vertex_TL.uv2.x = this.PackUV(x0, y1);
                                characterInfos[i1].vertex_TL.uv2.y = xScale;
                                characterInfos[i1].vertex_TR.uv2.x = this.PackUV(x1, y1);
                                characterInfos[i1].vertex_TR.uv2.y = xScale;
                                characterInfos[i1].vertex_BR.uv2.x = this.PackUV(x1, y0);
                                characterInfos[i1].vertex_BR.uv2.y = xScale;
                                break;
                            case TMPro.TMP_TextElementType.Sprite: 
                                // Nothing right now
                                break;
                        }

                        // Handle maxVisibleCharacters, maxVisibleLines and Overflow Page Mode.


                        if (i1 < this.m_maxVisibleCharacters && wordCount < this.m_maxVisibleWords && currentLine < this.m_maxVisibleLines && this.m_overflowMode !== TMPro.TextOverflowModes.Page) {
                            characterInfo.vertex_BL.position.add( offset );
                            characterInfo.vertex_TL.position.add( offset );
                            characterInfo.vertex_TR.position.add( offset );
                            characterInfo.vertex_BR.position.add( offset );
                        } else if (i1 < this.m_maxVisibleCharacters && wordCount < this.m_maxVisibleWords && currentLine < this.m_maxVisibleLines && this.m_overflowMode === TMPro.TextOverflowModes.Page && characterInfo.pageNumber === pageToDisplay) {
                            characterInfo.vertex_BL.position.add( offset );
                            characterInfo.vertex_TL.position.add( offset );
                            characterInfo.vertex_TR.position.add( offset );
                            characterInfo.vertex_BR.position.add( offset );
                        } else {
                            characterInfo.vertex_BL.position.set( 0, 0, 0 );
                            characterInfo.vertex_TL.position.set( 0, 0, 0 );
                            characterInfo.vertex_TR.position.set( 0, 0, 0 );
                            characterInfo.vertex_BR.position.set( 0, 0, 0 );
                            characterInfo.isVisible = false;
                        }



                        // Fill Vertex Buffers for the various types of element
                        if (elementType === TMPro.TMP_TextElementType.Character) {
                            this.FillCharacterVertexBuffers(i1, vert_index_X4);
                        } else if (elementType === TMPro.TMP_TextElementType.Sprite) {
                            this.FillSpriteVertexBuffers(i1, sprite_index_X4);
                        }
                    }


                    // Apply Alignment and Justification Offset
                    characterInfo.bottomLeft.add( offset );
                    characterInfo.topLeft.add( offset );
                    characterInfo.topRight.add( offset );
                    characterInfo.bottomRight.add( offset );

                    characterInfo.origin += offset.x;
                    characterInfo.xAdvance += offset.x;

                    characterInfo.ascender += offset.y;
                    characterInfo.descender += offset.y;
                    characterInfo.baseLine += offset.y;

                    // Update MeshExtents
                    if (isCharacterVisible) {
                        //m_meshExtents.min = new Vector2(Mathf.Min(m_meshExtents.min.x, m_textInfo.characterInfo[i].bottomLeft.x), Mathf.Min(m_meshExtents.min.y, m_textInfo.characterInfo[i].bottomLeft.y));
                        //m_meshExtents.max = new Vector2(Mathf.Max(m_meshExtents.max.x, m_textInfo.characterInfo[i].topRight.x), Mathf.Max(m_meshExtents.max.y, m_textInfo.characterInfo[i].topLeft.y));
                    }

                    // Need to recompute lineExtent to account for the offset from justification.


                    if (currentLine !== lastLine || i1 === this.m_characterCount - 1) {
                        // Update the previous line's extents
                        if (currentLine !== lastLine) {
                            ($t37 = this.m_textInfo.lineInfo)[lastLine].baseline += offset.y;
                            ($t38 = this.m_textInfo.lineInfo)[lastLine].ascender += offset.y;
                            ($t39 = this.m_textInfo.lineInfo)[lastLine].descender += offset.y;

                            ($t40 = this.m_textInfo.lineInfo)[lastLine].maxAdvance += offset.x;

                            ($t41 = this.m_textInfo.lineInfo)[lastLine].lineExtents.min.set( ($t42 = this.m_textInfo.characterInfo)[($t43 = this.m_textInfo.lineInfo)[lastLine].firstCharacterIndex].bottomLeft.x, ($t44 = this.m_textInfo.lineInfo)[lastLine].descender );
                            ($t45 = this.m_textInfo.lineInfo)[lastLine].lineExtents.max.set( ($t46 = this.m_textInfo.characterInfo)[($t47 = this.m_textInfo.lineInfo)[lastLine].lastVisibleCharacterIndex].topRight.x, ($t48 = this.m_textInfo.lineInfo)[lastLine].ascender );
                        }

                        // Update the current line's extents
                        if (i1 === this.m_characterCount - 1) {
                            ($t49 = this.m_textInfo.lineInfo)[currentLine].baseline += offset.y;
                            ($t50 = this.m_textInfo.lineInfo)[currentLine].ascender += offset.y;
                            ($t51 = this.m_textInfo.lineInfo)[currentLine].descender += offset.y;

                            ($t52 = this.m_textInfo.lineInfo)[currentLine].maxAdvance += offset.x;

                            ($t53 = this.m_textInfo.lineInfo)[currentLine].lineExtents.min.set( ($t54 = this.m_textInfo.characterInfo)[($t55 = this.m_textInfo.lineInfo)[currentLine].firstCharacterIndex].bottomLeft.x, ($t56 = this.m_textInfo.lineInfo)[currentLine].descender );
                            ($t57 = this.m_textInfo.lineInfo)[currentLine].lineExtents.max.set( ($t58 = this.m_textInfo.characterInfo)[($t59 = this.m_textInfo.lineInfo)[currentLine].lastVisibleCharacterIndex].topRight.x, ($t60 = this.m_textInfo.lineInfo)[currentLine].ascender );
                        }
                    }



                    // Track Word Count per line and for the object


                    if ((System.Char.isDigit(unicode) || System.Char.isLetter(unicode)) || unicode === 45 || unicode === 173 || unicode === 8208 || unicode === 8209) {
                        if (isStartOfWord === false) {
                            isStartOfWord = true;
                            wordFirstChar = i1;
                        }

                        // If last character is a word
                        if (isStartOfWord && i1 === this.m_characterCount - 1) {
                            var size = this.m_textInfo.wordInfo.length;
                            var index = this.m_textInfo.wordCount;

                            if (this.m_textInfo.wordCount + 1 > size) {
                                TMPro.TMP_TextInfo.Resize(TMPro.TMP_WordInfo, Bridge.ref(this.m_textInfo, "wordInfo"), size + 1);
                            }

                            wordLastChar = i1;

                            ($t61 = this.m_textInfo.wordInfo)[index].firstCharacterIndex = wordFirstChar;
                            ($t62 = this.m_textInfo.wordInfo)[index].lastCharacterIndex = wordLastChar;
                            ($t63 = this.m_textInfo.wordInfo)[index].characterCount = wordLastChar - wordFirstChar + 1;
                            ($t64 = this.m_textInfo.wordInfo)[index].textComponent = this;

                            wordCount += 1;
                            this.m_textInfo.wordCount += 1;
                            ($t65 = this.m_textInfo.lineInfo)[currentLine].wordCount += 1;
                        }
                    } else if (isStartOfWord || i1 === 0 && (!System.Char.isPunctuation(unicode) || System.Char.isWhiteSpace(String.fromCharCode(unicode)) || unicode === 8203 || i1 === this.m_characterCount - 1)) {
                        if (i1 > 0 && i1 < characterInfos.length - 1 && i1 < this.m_characterCount && (unicode === 39 || unicode === 8217) && ($t66 = characterInfos[i1 - 1].character, (System.Char.isDigit($t66) || System.Char.isLetter($t66))) && ($t67 = characterInfos[i1 + 1].character, (System.Char.isDigit($t67) || System.Char.isLetter($t67)))) {
                        } else {
                            wordLastChar = i1 === this.m_characterCount - 1 && (System.Char.isDigit(unicode) || System.Char.isLetter(unicode)) ? i1 : i1 - 1;
                            isStartOfWord = false;

                            var size1 = this.m_textInfo.wordInfo.length;
                            var index1 = this.m_textInfo.wordCount;

                            if (this.m_textInfo.wordCount + 1 > size1) {
                                TMPro.TMP_TextInfo.Resize(TMPro.TMP_WordInfo, Bridge.ref(this.m_textInfo, "wordInfo"), size1 + 1);
                            }

                            ($t68 = this.m_textInfo.wordInfo)[index1].firstCharacterIndex = wordFirstChar;
                            ($t69 = this.m_textInfo.wordInfo)[index1].lastCharacterIndex = wordLastChar;
                            ($t70 = this.m_textInfo.wordInfo)[index1].characterCount = wordLastChar - wordFirstChar + 1;
                            ($t71 = this.m_textInfo.wordInfo)[index1].textComponent = this;

                            wordCount += 1;
                            this.m_textInfo.wordCount += 1;
                            ($t72 = this.m_textInfo.lineInfo)[currentLine].wordCount += 1;
                        }
                    }



                    // Setup & Handle Underline


                    // NOTE: Need to figure out how underline will be handled with multiple fonts and which font will be used for the underline.
                    var isUnderline = (($t73 = this.m_textInfo.characterInfo)[i1].style & TMPro.FontStyles.Underline) === TMPro.FontStyles.Underline;
                    if (isUnderline) {
                        var isUnderlineVisible = true;
                        var currentPage = ($t74 = this.m_textInfo.characterInfo)[i1].pageNumber;
                        ($t75 = this.m_textInfo.characterInfo)[i1].underlineVertexIndex = last_vert_index.v;

                        if (i1 > this.m_maxVisibleCharacters || currentLine > this.m_maxVisibleLines || this.m_overflowMode === TMPro.TextOverflowModes.Page && currentPage + 1 !== this.m_pageToDisplay) {
                            isUnderlineVisible = false;
                        }

                        // We only use the scale of visible characters.
                        if (!System.Char.isWhiteSpace(String.fromCharCode(unicode)) && unicode !== 8203) {
                            underlineMaxScale = UnityEngine.Mathf.Max(underlineMaxScale, ($t76 = this.m_textInfo.characterInfo)[i1].scale);
                            xScaleMax = UnityEngine.Mathf.Max(xScaleMax, Math.abs(xScale));
                            underlineBaseLine = UnityEngine.Mathf.Min(currentPage === lastPage ? underlineBaseLine : TMPro.TMP_Text.k_LargePositiveFloat, ($t77 = this.m_textInfo.characterInfo)[i1].baseLine + this.font.m_FaceInfo.underlineOffset * underlineMaxScale);
                            lastPage = currentPage; // Need to track pages to ensure we reset baseline for the new pages.
                        }

                        if (beginUnderline === false && isUnderlineVisible === true && i1 <= lineInfo.lastVisibleCharacterIndex && unicode !== 10 && unicode !== 11 && unicode !== 13) {
                            if (i1 === lineInfo.lastVisibleCharacterIndex && System.Char.isSeparator(unicode)) {
                            } else {
                                beginUnderline = true;
                                underlineStartScale = ($t78 = this.m_textInfo.characterInfo)[i1].scale;
                                if (underlineMaxScale === 0) {
                                    underlineMaxScale = underlineStartScale;
                                    xScaleMax = xScale;
                                }

                                underline_start = new pc.Vec3( ($t79 = this.m_textInfo.characterInfo)[i1].bottomLeft.x, underlineBaseLine, 0 );
                                underlineColor = ($t80 = this.m_textInfo.characterInfo)[i1].underlineColor.$clone();
                            }
                        }

                        // End Underline if text only contains one character.
                        if (beginUnderline && this.m_characterCount === 1) {
                            beginUnderline = false;
                            underline_end = new pc.Vec3( ($t81 = this.m_textInfo.characterInfo)[i1].topRight.x, underlineBaseLine, 0 );
                            underlineEndScale = ($t82 = this.m_textInfo.characterInfo)[i1].scale;

                            this.DrawUnderlineMesh(underline_start.$clone(), underline_end.$clone(), last_vert_index, underlineStartScale, underlineEndScale, underlineMaxScale, xScaleMax, underlineColor.$clone());
                            underlineMaxScale = 0;
                            xScaleMax = 0;
                            underlineBaseLine = TMPro.TMP_Text.k_LargePositiveFloat;
                        } else if (beginUnderline && (i1 === lineInfo.lastCharacterIndex || i1 >= lineInfo.lastVisibleCharacterIndex)) {
                            // Terminate underline at previous visible character if space or carriage return.
                            if (System.Char.isWhiteSpace(String.fromCharCode(unicode)) || unicode === 8203) {
                                var lastVisibleCharacterIndex = lineInfo.lastVisibleCharacterIndex;
                                underline_end = new pc.Vec3( ($t83 = this.m_textInfo.characterInfo)[lastVisibleCharacterIndex].topRight.x, underlineBaseLine, 0 );
                                underlineEndScale = ($t84 = this.m_textInfo.characterInfo)[lastVisibleCharacterIndex].scale;
                            } else {
                                // End underline if last character of the line.
                                underline_end = new pc.Vec3( ($t85 = this.m_textInfo.characterInfo)[i1].topRight.x, underlineBaseLine, 0 );
                                underlineEndScale = ($t86 = this.m_textInfo.characterInfo)[i1].scale;
                            }

                            beginUnderline = false;
                            this.DrawUnderlineMesh(underline_start.$clone(), underline_end.$clone(), last_vert_index, underlineStartScale, underlineEndScale, underlineMaxScale, xScaleMax, underlineColor.$clone());
                            underlineMaxScale = 0;
                            xScaleMax = 0;
                            underlineBaseLine = TMPro.TMP_Text.k_LargePositiveFloat;
                        } else if (beginUnderline && !isUnderlineVisible) {
                            beginUnderline = false;
                            underline_end = new pc.Vec3( ($t87 = this.m_textInfo.characterInfo)[i1 - 1].topRight.x, underlineBaseLine, 0 );
                            underlineEndScale = ($t88 = this.m_textInfo.characterInfo)[i1 - 1].scale;

                            this.DrawUnderlineMesh(underline_start.$clone(), underline_end.$clone(), last_vert_index, underlineStartScale, underlineEndScale, underlineMaxScale, xScaleMax, underlineColor.$clone());
                            underlineMaxScale = 0;
                            xScaleMax = 0;
                            underlineBaseLine = TMPro.TMP_Text.k_LargePositiveFloat;
                        } else if (beginUnderline && i1 < this.m_characterCount - 1 && !TMPro.TMPro_ExtensionMethods.Compare$1(underlineColor, ($t89 = this.m_textInfo.characterInfo)[i1 + 1].underlineColor.$clone())) {
                            // End underline if underline color has changed.
                            beginUnderline = false;
                            underline_end = new pc.Vec3( ($t90 = this.m_textInfo.characterInfo)[i1].topRight.x, underlineBaseLine, 0 );
                            underlineEndScale = ($t91 = this.m_textInfo.characterInfo)[i1].scale;

                            this.DrawUnderlineMesh(underline_start.$clone(), underline_end.$clone(), last_vert_index, underlineStartScale, underlineEndScale, underlineMaxScale, xScaleMax, underlineColor.$clone());
                            underlineMaxScale = 0;
                            xScaleMax = 0;
                            underlineBaseLine = TMPro.TMP_Text.k_LargePositiveFloat;
                        }
                    } else {
                        // End Underline
                        if (beginUnderline === true) {
                            beginUnderline = false;
                            underline_end = new pc.Vec3( ($t92 = this.m_textInfo.characterInfo)[i1 - 1].topRight.x, underlineBaseLine, 0 );
                            underlineEndScale = ($t93 = this.m_textInfo.characterInfo)[i1 - 1].scale;

                            this.DrawUnderlineMesh(underline_start.$clone(), underline_end.$clone(), last_vert_index, underlineStartScale, underlineEndScale, underlineMaxScale, xScaleMax, underlineColor.$clone());
                            underlineMaxScale = 0;
                            xScaleMax = 0;
                            underlineBaseLine = TMPro.TMP_Text.k_LargePositiveFloat;
                        }
                    }



                    // Setup & Handle Strikethrough


                    // NOTE: Need to figure out how underline will be handled with multiple fonts and which font will be used for the underline.
                    var isStrikethrough = (($t94 = this.m_textInfo.characterInfo)[i1].style & TMPro.FontStyles.Strikethrough) === TMPro.FontStyles.Strikethrough;
                    var strikethroughOffset = currentFontAsset.m_FaceInfo.strikethroughOffset;

                    if (isStrikethrough) {
                        var isStrikeThroughVisible = true;
                        ($t95 = this.m_textInfo.characterInfo)[i1].strikethroughVertexIndex = last_vert_index.v;

                        if (i1 > this.m_maxVisibleCharacters || currentLine > this.m_maxVisibleLines || this.m_overflowMode === TMPro.TextOverflowModes.Page && ($t96 = this.m_textInfo.characterInfo)[i1].pageNumber + 1 !== this.m_pageToDisplay) {
                            isStrikeThroughVisible = false;
                        }

                        if (beginStrikethrough === false && isStrikeThroughVisible && i1 <= lineInfo.lastVisibleCharacterIndex && unicode !== 10 && unicode !== 11 && unicode !== 13) {
                            if (i1 === lineInfo.lastVisibleCharacterIndex && System.Char.isSeparator(unicode)) {
                            } else {
                                beginStrikethrough = true;
                                strikethroughPointSize = ($t97 = this.m_textInfo.characterInfo)[i1].pointSize;
                                strikethroughScale = ($t98 = this.m_textInfo.characterInfo)[i1].scale;
                                strikethrough_start = new pc.Vec3( ($t99 = this.m_textInfo.characterInfo)[i1].bottomLeft.x, ($t100 = this.m_textInfo.characterInfo)[i1].baseLine + strikethroughOffset * strikethroughScale, 0 );
                                strikethroughColor = ($t101 = this.m_textInfo.characterInfo)[i1].strikethroughColor.$clone();
                                strikethroughBaseline = ($t102 = this.m_textInfo.characterInfo)[i1].baseLine;
                                //Debug.Log("Char [" + currentCharacter + "] Start Strikethrough POS: " + strikethrough_start);
                            }
                        }

                        // End Strikethrough if text only contains one character.
                        if (beginStrikethrough && this.m_characterCount === 1) {
                            beginStrikethrough = false;
                            strikethrough_end = new pc.Vec3( ($t103 = this.m_textInfo.characterInfo)[i1].topRight.x, ($t104 = this.m_textInfo.characterInfo)[i1].baseLine + strikethroughOffset * strikethroughScale, 0 );

                            this.DrawUnderlineMesh(strikethrough_start.$clone(), strikethrough_end.$clone(), last_vert_index, strikethroughScale, strikethroughScale, strikethroughScale, xScale, strikethroughColor.$clone());
                        } else if (beginStrikethrough && i1 === lineInfo.lastCharacterIndex) {
                            // Terminate Strikethrough at previous visible character if space or carriage return.
                            if (System.Char.isWhiteSpace(String.fromCharCode(unicode)) || unicode === 8203) {
                                var lastVisibleCharacterIndex1 = lineInfo.lastVisibleCharacterIndex;
                                strikethrough_end = new pc.Vec3( ($t105 = this.m_textInfo.characterInfo)[lastVisibleCharacterIndex1].topRight.x, ($t106 = this.m_textInfo.characterInfo)[lastVisibleCharacterIndex1].baseLine + strikethroughOffset * strikethroughScale, 0 );
                            } else {
                                // Terminate Strikethrough at last character of line.
                                strikethrough_end = new pc.Vec3( ($t107 = this.m_textInfo.characterInfo)[i1].topRight.x, ($t108 = this.m_textInfo.characterInfo)[i1].baseLine + strikethroughOffset * strikethroughScale, 0 );
                            }

                            beginStrikethrough = false;
                            this.DrawUnderlineMesh(strikethrough_start.$clone(), strikethrough_end.$clone(), last_vert_index, strikethroughScale, strikethroughScale, strikethroughScale, xScale, strikethroughColor.$clone());
                        } else if (beginStrikethrough && i1 < this.m_characterCount && (($t109 = this.m_textInfo.characterInfo)[i1 + 1].pointSize !== strikethroughPointSize || !TMPro.TMP_Math.Approximately(($t110 = this.m_textInfo.characterInfo)[i1 + 1].baseLine + offset.y, strikethroughBaseline))) {
                            // Terminate Strikethrough if scale changes.
                            beginStrikethrough = false;

                            var lastVisibleCharacterIndex2 = lineInfo.lastVisibleCharacterIndex;
                            if (i1 > lastVisibleCharacterIndex2) {
                                strikethrough_end = new pc.Vec3( ($t111 = this.m_textInfo.characterInfo)[lastVisibleCharacterIndex2].topRight.x, ($t112 = this.m_textInfo.characterInfo)[lastVisibleCharacterIndex2].baseLine + strikethroughOffset * strikethroughScale, 0 );
                            } else {
                                strikethrough_end = new pc.Vec3( ($t113 = this.m_textInfo.characterInfo)[i1].topRight.x, ($t114 = this.m_textInfo.characterInfo)[i1].baseLine + strikethroughOffset * strikethroughScale, 0 );
                            }

                            this.DrawUnderlineMesh(strikethrough_start.$clone(), strikethrough_end.$clone(), last_vert_index, strikethroughScale, strikethroughScale, strikethroughScale, xScale, strikethroughColor.$clone());
                            //Debug.Log("Char [" + currentCharacter + "] at Index: " + i + "  End Strikethrough POS: " + strikethrough_end + "  Baseline: " + m_textInfo.characterInfo[i].baseLine.ToString("f3"));
                        } else if (beginStrikethrough && i1 < this.m_characterCount && currentFontAsset.GetInstanceID() !== characterInfos[i1 + 1].fontAsset.GetInstanceID()) {
                            // Terminate Strikethrough if font asset changes.
                            beginStrikethrough = false;
                            strikethrough_end = new pc.Vec3( ($t115 = this.m_textInfo.characterInfo)[i1].topRight.x, ($t116 = this.m_textInfo.characterInfo)[i1].baseLine + strikethroughOffset * strikethroughScale, 0 );

                            this.DrawUnderlineMesh(strikethrough_start.$clone(), strikethrough_end.$clone(), last_vert_index, strikethroughScale, strikethroughScale, strikethroughScale, xScale, strikethroughColor.$clone());
                        } else if (beginStrikethrough && !isStrikeThroughVisible) {
                            // Terminate Strikethrough if character is not visible.
                            beginStrikethrough = false;
                            strikethrough_end = new pc.Vec3( ($t117 = this.m_textInfo.characterInfo)[i1 - 1].topRight.x, ($t118 = this.m_textInfo.characterInfo)[i1 - 1].baseLine + strikethroughOffset * strikethroughScale, 0 );

                            this.DrawUnderlineMesh(strikethrough_start.$clone(), strikethrough_end.$clone(), last_vert_index, strikethroughScale, strikethroughScale, strikethroughScale, xScale, strikethroughColor.$clone());
                        }
                    } else {
                        // End Strikethrough
                        if (beginStrikethrough === true) {
                            beginStrikethrough = false;
                            strikethrough_end = new pc.Vec3( ($t119 = this.m_textInfo.characterInfo)[i1 - 1].topRight.x, ($t120 = this.m_textInfo.characterInfo)[i1 - 1].baseLine + strikethroughOffset * strikethroughScale, 0 );

                            this.DrawUnderlineMesh(strikethrough_start.$clone(), strikethrough_end.$clone(), last_vert_index, strikethroughScale, strikethroughScale, strikethroughScale, xScale, strikethroughColor.$clone());
                        }
                    }



                    // HANDLE TEXT HIGHLIGHTING


                    var isHighlight = (($t121 = this.m_textInfo.characterInfo)[i1].style & TMPro.FontStyles.Highlight) === TMPro.FontStyles.Highlight;
                    if (isHighlight) {
                        var isHighlightVisible = true;
                        var currentPage1 = ($t122 = this.m_textInfo.characterInfo)[i1].pageNumber;

                        if (i1 > this.m_maxVisibleCharacters || currentLine > this.m_maxVisibleLines || this.m_overflowMode === TMPro.TextOverflowModes.Page && currentPage1 + 1 !== this.m_pageToDisplay) {
                            isHighlightVisible = false;
                        }

                        if (beginHighlight === false && isHighlightVisible === true && i1 <= lineInfo.lastVisibleCharacterIndex && unicode !== 10 && unicode !== 11 && unicode !== 13) {
                            if (i1 === lineInfo.lastVisibleCharacterIndex && System.Char.isSeparator(unicode)) {
                            } else {
                                beginHighlight = true;
                                highlight_start = UnityEngine.Vector3.FromVector2(TMPro.TMP_Text.k_LargePositiveVector2.$clone());
                                highlight_end = UnityEngine.Vector3.FromVector2(TMPro.TMP_Text.k_LargeNegativeVector2.$clone());
                                highlightState = ($t123 = this.m_textInfo.characterInfo)[i1].highlightState.$clone();
                            }
                        }

                        if (beginHighlight) {
                            var currentCharacter = ($t124 = this.m_textInfo.characterInfo)[i1].$clone();
                            var currentState = currentCharacter.highlightState.$clone();

                            var isColorTransition = false;

                            // Handle Highlight color changes
                            if (TMPro.HighlightState.op_Inequality(highlightState.$clone(), currentCharacter.highlightState.$clone())) {
                                // Adjust previous highlight section to prevent a gaps between sections.
                                highlight_end.x = (highlight_end.x - highlightState.padding.right + currentCharacter.bottomLeft.x) / 2;

                                highlight_start.y = UnityEngine.Mathf.Min(highlight_start.y, currentCharacter.descender);
                                highlight_end.y = UnityEngine.Mathf.Max(highlight_end.y, currentCharacter.ascender);

                                this.DrawTextHighlight(highlight_start.$clone(), highlight_end.$clone(), last_vert_index, highlightState.color.$clone());

                                beginHighlight = true;
                                highlight_start.set( highlight_end.x, currentCharacter.descender - currentState.padding.bottom, 0 );
                                highlight_end.set( currentCharacter.topRight.x + currentState.padding.right, currentCharacter.ascender + currentState.padding.top, 0 );

                                highlightState = currentCharacter.highlightState.$clone();

                                isColorTransition = true;
                            }

                            if (!isColorTransition) {
                                // Use the Min / Max Extents of the Highlight area to handle different character sizes and fonts.
                                highlight_start.x = UnityEngine.Mathf.Min(highlight_start.x, currentCharacter.bottomLeft.x - highlightState.padding.left);
                                highlight_start.y = UnityEngine.Mathf.Min(highlight_start.y, currentCharacter.descender - highlightState.padding.bottom);

                                highlight_end.x = UnityEngine.Mathf.Max(highlight_end.x, currentCharacter.topRight.x + highlightState.padding.right);
                                highlight_end.y = UnityEngine.Mathf.Max(highlight_end.y, currentCharacter.ascender + highlightState.padding.top);
                            }
                        }

                        // End Highlight if text only contains one character.
                        if (beginHighlight && this.m_characterCount === 1) {
                            beginHighlight = false;

                            this.DrawTextHighlight(highlight_start.$clone(), highlight_end.$clone(), last_vert_index, highlightState.color.$clone());
                        } else if (beginHighlight && (i1 === lineInfo.lastCharacterIndex || i1 >= lineInfo.lastVisibleCharacterIndex)) {
                            beginHighlight = false;
                            this.DrawTextHighlight(highlight_start.$clone(), highlight_end.$clone(), last_vert_index, highlightState.color.$clone());
                        } else if (beginHighlight && !isHighlightVisible) {
                            beginHighlight = false;
                            this.DrawTextHighlight(highlight_start.$clone(), highlight_end.$clone(), last_vert_index, highlightState.color.$clone());
                        }
                    } else {
                        // End Highlight
                        if (beginHighlight === true) {
                            beginHighlight = false;
                            this.DrawTextHighlight(highlight_start.$clone(), highlight_end.$clone(), last_vert_index, highlightState.color.$clone());
                        }
                    }


                    lastLine = currentLine;
                }


                // Set vertex count for Underline geometry
                //m_textInfo.meshInfo[m_Underline.materialIndex].vertexCount = last_vert_index;

                // METRICS ABOUT THE TEXT OBJECT
                this.m_textInfo.characterCount = this.m_characterCount;
                this.m_textInfo.spriteCount = this.m_spriteCount;
                this.m_textInfo.lineCount = lineCount;
                this.m_textInfo.wordCount = wordCount !== 0 && this.m_characterCount > 0 ? wordCount : 1;
                this.m_textInfo.pageCount = this.m_pageNumber + 1;

                // End Sampling of Phase II

                // Phase III - Update Mesh Vertex Data

                if (this.m_renderMode === TMPro.TextRenderFlags.Render && this.IsActive()) {
                    // Event to allow users to modify the content of the text info before the text is rendered.
                    !Bridge.staticEquals(this.OnPreRenderText, null) ? this.OnPreRenderText(this.m_textInfo) : null;

                    // Must ensure the Canvas support the additional vertex attributes used by TMP.
                    // This could be optimized based on canvas render mode settings but gets complicated to handle with multiple text objects using different material presets.
                    if (this.m_canvas.additionalShaderChannels !== 25) {
                        this.m_canvas.additionalShaderChannels |= 25;
                    }

                    // Sort the geometry of the text object if needed.
                    if (this.m_geometrySortingOrder !== TMPro.VertexSortingOrder.Normal) {
                        ($t125 = this.m_textInfo.meshInfo)[0].SortGeometry$1(TMPro.VertexSortingOrder.Reverse);
                    }

                    // Upload Mesh Data
                    this.m_mesh.MarkDynamic();
                    this.m_mesh.vertices = ($t126 = this.m_textInfo.meshInfo)[0].vertices;
                    this.m_mesh.uv = ($t127 = this.m_textInfo.meshInfo)[0].uvs0;
                    this.m_mesh.uv2 = ($t128 = this.m_textInfo.meshInfo)[0].uvs2;
                    //m_mesh.uv4 = m_textInfo.meshInfo[0].uvs4;
                    this.m_mesh.colors32 = ($t129 = this.m_textInfo.meshInfo)[0].colors32;

                    // Compute Bounds for the mesh. Manual computation is more efficient then using Mesh.RecalcualteBounds.
                    this.m_mesh.RecalculateBounds();
                    //m_mesh.bounds = new Bounds(new Vector3((m_meshExtents.max.x + m_meshExtents.min.x) / 2, (m_meshExtents.max.y + m_meshExtents.min.y) / 2, 0) + offset, new Vector3(m_meshExtents.max.x - m_meshExtents.min.x, m_meshExtents.max.y - m_meshExtents.min.y, 0));

                    this.m_canvasRenderer.SetMesh(this.m_mesh);

                    // Cache CanvasRenderer color of the parent text object.
                    var parentBaseColor = this.m_canvasRenderer.GetColor();

                    var isCullTransparentMeshEnabled = this.m_canvasRenderer.cullTransparentMesh;

                    for (var i2 = 1; i2 < this.m_textInfo.materialCount; i2++) {
                        // Clear unused vertices
                        ($t130 = this.m_textInfo.meshInfo)[i2].ClearUnusedVertices();

                        if (UnityEngine.MonoBehaviour.op_Equality(this.m_subTextObjects[i2], null)) {
                            continue;
                        }

                        // Sort the geometry of the sub-text objects if needed.
                        if (this.m_geometrySortingOrder !== TMPro.VertexSortingOrder.Normal) {
                            ($t131 = this.m_textInfo.meshInfo)[i2].SortGeometry$1(TMPro.VertexSortingOrder.Reverse);
                        }

                        //m_subTextObjects[i].mesh.MarkDynamic();
                        this.m_subTextObjects[i2].mesh.vertices = ($t132 = this.m_textInfo.meshInfo)[i2].vertices;
                        this.m_subTextObjects[i2].mesh.uv = ($t133 = this.m_textInfo.meshInfo)[i2].uvs0;
                        this.m_subTextObjects[i2].mesh.uv2 = ($t134 = this.m_textInfo.meshInfo)[i2].uvs2;
                        //m_subTextObjects[i].mesh.uv4 = m_textInfo.meshInfo[i].uvs4;
                        this.m_subTextObjects[i2].mesh.colors32 = ($t135 = this.m_textInfo.meshInfo)[i2].colors32;

                        this.m_subTextObjects[i2].mesh.RecalculateBounds();

                        this.m_subTextObjects[i2].canvasRenderer.SetMesh(this.m_subTextObjects[i2].mesh);

                        // Set CanvasRenderer color to match the parent text object.
                        this.m_subTextObjects[i2].canvasRenderer.SetColor(parentBaseColor.$clone());

                        // Make sure Cull Transparent Mesh of the sub objects matches the parent
                        this.m_subTextObjects[i2].canvasRenderer.cullTransparentMesh = isCullTransparentMeshEnabled;

                        // Sync RaycastTarget property with parent text object
                        this.m_subTextObjects[i2].raycastTarget = this.raycastTarget;
                    }
                }

                // Event indicating the text has been regenerated.
                TMPro.TMPro_EventManager.ON_TEXT_CHANGED(this);

                //Debug.Log("***** Done rendering text object ID " + GetInstanceID() + ". *****");

                // End Sampling
            },
            /*TMPro.TextMeshProUGUI.GenerateTextMesh end.*/

            /*TMPro.TextMeshProUGUI.GetTextContainerLocalCorners start.*/
            /**
             * Method to return the local corners of the Text Container or RectTransform.
             *
             * @instance
             * @protected
             * @override
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @return  {Array.<UnityEngine.Vector3>}
             */
            GetTextContainerLocalCorners: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#GetTextContainerLocalCorners", this ); }

                if (UnityEngine.Component.op_Equality(this.m_rectTransform, null)) {
                    this.m_rectTransform = this.rectTransform$1;
                }

                this.m_rectTransform.GetLocalCorners(this.m_RectTransformCorners);

                return this.m_RectTransformCorners;
            },
            /*TMPro.TextMeshProUGUI.GetTextContainerLocalCorners end.*/

            /*TMPro.TextMeshProUGUI.SetActiveSubMeshes start.*/
            /**
             * Method to Enable or Disable child SubMesh objects.
             *
             * @instance
             * @protected
             * @override
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @param   {boolean}    state
             * @return  {void}
             */
            SetActiveSubMeshes: function (state) {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#SetActiveSubMeshes", this ); }

                for (var i = 1; i < this.m_subTextObjects.length && UnityEngine.MonoBehaviour.op_Inequality(this.m_subTextObjects[i], null); i++) {
                    if (this.m_subTextObjects[i].enabled !== state) {
                        this.m_subTextObjects[i].enabled = state;
                    }
                }
            },
            /*TMPro.TextMeshProUGUI.SetActiveSubMeshes end.*/

            /*TMPro.TextMeshProUGUI.DestroySubMeshObjects start.*/
            /**
             * Destroy Sub Mesh Objects
             *
             * @instance
             * @protected
             * @override
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @return  {void}
             */
            DestroySubMeshObjects: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#DestroySubMeshObjects", this ); }

                for (var i = 1; i < this.m_subTextObjects.length && UnityEngine.MonoBehaviour.op_Inequality(this.m_subTextObjects[i], null); i++) {
                    UnityEngine.Object.DestroyImmediate(this.m_subTextObjects[i]);
                }
            },
            /*TMPro.TextMeshProUGUI.DestroySubMeshObjects end.*/

            /*TMPro.TextMeshProUGUI.GetCompoundBounds start.*/
            /**
             * Method returning the compound bounds of the text object and child sub objects.
             *
             * @instance
             * @protected
             * @override
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @return  {UnityEngine.Bounds}
             */
            GetCompoundBounds: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#GetCompoundBounds", this ); }

                var mainBounds = this.m_mesh.bounds;
                var min = mainBounds.min.$clone();
                var max = mainBounds.max.$clone();

                for (var i = 1; i < this.m_subTextObjects.length && UnityEngine.MonoBehaviour.op_Inequality(this.m_subTextObjects[i], null); i++) {
                    var subBounds = this.m_subTextObjects[i].mesh.bounds;
                    min.x = min.x < subBounds.min.x ? min.x : subBounds.min.x;
                    min.y = min.y < subBounds.min.y ? min.y : subBounds.min.y;

                    max.x = max.x > subBounds.max.x ? max.x : subBounds.max.x;
                    max.y = max.y > subBounds.max.y ? max.y : subBounds.max.y;
                }

                var center = (min.$clone().add( max )).scale( 1.0 / ( 2 ) );
                var size = UnityEngine.Vector2.FromVector3(max.$clone().sub( min ));
                return new pc.BoundingBox( center.$clone(), UnityEngine.Vector3.FromVector2(size.$clone()).scale( 0.5 ) );
            },
            /*TMPro.TextMeshProUGUI.GetCompoundBounds end.*/

            /*TMPro.TextMeshProUGUI.GetCanvasSpaceClippingRect start.*/
            GetCanvasSpaceClippingRect: function () {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#GetCanvasSpaceClippingRect", this ); }

                if (UnityEngine.Component.op_Equality(this.m_canvas, null) || UnityEngine.Component.op_Equality(this.m_canvas.rootCanvas, null) || this.m_mesh == null) {
                    return UnityEngine.Rect.zero.$clone();
                }

                var rootCanvasTransform = this.m_canvas.rootCanvas.transform;
                var compoundBounds = this.GetCompoundBounds();

                var position = UnityEngine.Vector2.FromVector3(rootCanvasTransform.InverseTransformPoint(this.m_rectTransform.position));

                var canvasLossyScale = UnityEngine.Vector2.FromVector3(rootCanvasTransform.lossyScale.$clone());
                var lossyScale = UnityEngine.Vector2.FromVector3(this.m_rectTransform.lossyScale.$clone().mulScalars( 1.0 / canvasLossyScale.x, 1.0 / canvasLossyScale.y, 0 ));

                return new UnityEngine.Rect.$ctor3(position.$clone().add( UnityEngine.Vector2.FromVector3(compoundBounds.min.$clone()).mul( lossyScale ) ), UnityEngine.Vector2.FromVector3(compoundBounds.halfExtents.$clone().scale( 2 ).$clone()).mul( lossyScale ));
            },
            /*TMPro.TextMeshProUGUI.GetCanvasSpaceClippingRect end.*/

            /*TMPro.TextMeshProUGUI.UpdateSDFScale start.*/
            /**
             * Method to Update Scale in UV2
             * Method to update the SDF Scale in UV2.
             *
             * @instance
             * @private
             * @this TMPro.TextMeshProUGUI
             * @memberof TMPro.TextMeshProUGUI
             * @param   {number}    scaleDelta
             * @return  {void}
             */
            UpdateSDFScale: function (scaleDelta) {
if ( TRACE ) { TRACE( "TMPro.TextMeshProUGUI#UpdateSDFScale", this ); }

                var $t, $t1, $t2;
                if (scaleDelta === 0 || scaleDelta === Number.POSITIVE_INFINITY || scaleDelta === Number.NEGATIVE_INFINITY) {
                    this.m_havePropertiesChanged = true;
                    this.OnPreRenderCanvas();
                    return;
                }

                for (var materialIndex = 0; materialIndex < this.m_textInfo.materialCount; materialIndex++) {
                    var meshInfo = ($t = this.m_textInfo.meshInfo)[materialIndex].$clone();

                    for (var i = 0; i < meshInfo.uvs2.length; i++) {
                        meshInfo.uvs2[i].y *= Math.abs(scaleDelta);
                    }
                }

                // Push the updated uv2 scale information to the meshes.
                for (var i1 = 0; i1 < this.m_textInfo.materialCount; i1++) {
                    if (i1 === 0) {
                        this.m_mesh.uv2 = ($t1 = this.m_textInfo.meshInfo)[0].uvs2;
                        this.m_canvasRenderer.SetMesh(this.m_mesh);
                    } else {
                        this.m_subTextObjects[i1].mesh.uv2 = ($t2 = this.m_textInfo.meshInfo)[i1].uvs2;
                        this.m_subTextObjects[i1].canvasRenderer.SetMesh(this.m_subTextObjects[i1].mesh);
                    }
                }
            },
            /*TMPro.TextMeshProUGUI.UpdateSDFScale end.*/


        },
        overloads: {
            "UpdateGeometry(Mesh, int)": "UpdateGeometry$1",
            "UpdateVertexData(TMP_VertexDataUpdateFlags)": "UpdateVertexData$1"
        }
    });
    /*TMPro.TextMeshProUGUI end.*/

    /*TMPro.TMP_Character start.*/
    /**
     * A basic element of text.
     *
     * @public
     * @class TMPro.TMP_Character
     * @augments TMPro.TMP_TextElement
     */
    Bridge.define("TMPro.TMP_Character", {
        inherits: [TMPro.TMP_TextElement],
        ctors: {
            /**
             * Default constructor.
             *
             * @instance
             * @public
             * @this TMPro.TMP_Character
             * @memberof TMPro.TMP_Character
             * @return  {void}
             */
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Character#ctor", this ); }

                this.$initialize();
                TMPro.TMP_TextElement.ctor.call(this);
                this.m_ElementType = TMPro.TextElementType.Character;
                this.scale = 1.0;
            },
            /**
             * Constructor for new character
             *
             * @instance
             * @public
             * @this TMPro.TMP_Character
             * @memberof TMPro.TMP_Character
             * @param   {number}                        unicode    Unicode value.
             * @param   {UnityEngine.TextCore.Glyph}    glyph      Glyph
             * @return  {void}
             */
            $ctor3: function (unicode, glyph) {
if ( TRACE ) { TRACE( "TMPro.TMP_Character#$ctor3", this ); }

                this.$initialize();
                TMPro.TMP_TextElement.ctor.call(this);
                this.m_ElementType = TMPro.TextElementType.Character;

                this.unicode = unicode;
                this.textAsset = null;
                this.glyph = glyph;
                this.glyphIndex = glyph.index;
                this.scale = 1.0;
            },
            /**
             * Constructor for new character
             *
             * @instance
             * @public
             * @this TMPro.TMP_Character
             * @memberof TMPro.TMP_Character
             * @param   {number}                        unicode      Unicode value.
             * @param   {TMPro.TMP_FontAsset}           fontAsset    The font asset to which this character belongs.
             * @param   {UnityEngine.TextCore.Glyph}    glyph        Glyph
             * @return  {void}
             */
            $ctor2: function (unicode, fontAsset, glyph) {
if ( TRACE ) { TRACE( "TMPro.TMP_Character#$ctor2", this ); }

                this.$initialize();
                TMPro.TMP_TextElement.ctor.call(this);
                this.m_ElementType = TMPro.TextElementType.Character;

                this.unicode = unicode;
                this.textAsset = fontAsset;
                this.glyph = glyph;
                this.glyphIndex = glyph.index;
                this.scale = 1.0;
            },
            /**
             * Constructor for new character
             *
             * @instance
             * @this TMPro.TMP_Character
             * @memberof TMPro.TMP_Character
             * @param   {number}    unicode       Unicode value.
             * @param   {number}    glyphIndex    Glyph index.
             * @return  {void}
             */
            $ctor1: function (unicode, glyphIndex) {
if ( TRACE ) { TRACE( "TMPro.TMP_Character#$ctor1", this ); }

                this.$initialize();
                TMPro.TMP_TextElement.ctor.call(this);
                this.m_ElementType = TMPro.TextElementType.Character;

                this.unicode = unicode;
                this.textAsset = null;
                this.glyph = null;
                this.glyphIndex = glyphIndex;
                this.scale = 1.0;
            }
        }
    });
    /*TMPro.TMP_Character end.*/

    /*TMPro.TMP_FontAsset start.*/
    Bridge.define("TMPro.TMP_FontAsset", {
        inherits: [TMPro.TMP_Asset],
        statics: {
            fields: {
                s_DefaultMaterialSuffix: null,
                /**
                 * HashSet of font asset instance ID used in the process of searching for through fallback font assets for a given character or characters.
                 *
                 * @static
                 * @private
                 * @memberof TMPro.TMP_FontAsset
                 * @type System.Collections.Generic.HashSet$1
                 */
                k_SearchedFontAssetLookup: null,
                k_FontAssets_FontFeaturesUpdateQueue: null,
                k_FontAssets_FontFeaturesUpdateQueueLookup: null,
                k_FontAssets_AtlasTexturesUpdateQueue: null,
                k_FontAssets_AtlasTexturesUpdateQueueLookup: null,
                /**
                 * Internal static array used to avoid allocations when using the GetGlyphPairAdjustmentTable().
                 *
                 * @static
                 * @memberof TMPro.TMP_FontAsset
                 * @type Array.<number>
                 */
                k_GlyphIndexArray: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#init", this ); }

                    this.s_DefaultMaterialSuffix = " Atlas Material";
                    this.k_FontAssets_FontFeaturesUpdateQueue = new (System.Collections.Generic.List$1(TMPro.TMP_FontAsset)).ctor();
                    this.k_FontAssets_FontFeaturesUpdateQueueLookup = new (System.Collections.Generic.HashSet$1(System.Int32)).ctor();
                    this.k_FontAssets_AtlasTexturesUpdateQueue = new (System.Collections.Generic.List$1(TMPro.TMP_FontAsset)).ctor();
                    this.k_FontAssets_AtlasTexturesUpdateQueueLookup = new (System.Collections.Generic.HashSet$1(System.Int32)).ctor();
                }
            },
            methods: {
                /*TMPro.TMP_FontAsset.CreateFontAsset:static start.*/
                /**
                 * Create new instance of a font asset using default settings.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_FontAsset
                 * @memberof TMPro.TMP_FontAsset
                 * @param   {UnityEngine.Font}       font
                 * @return  {TMPro.TMP_FontAsset}
                 */
                CreateFontAsset: function (font) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#CreateFontAsset", this ); }

                    return TMPro.TMP_FontAsset.CreateFontAsset$1(font, 90, 9, UnityEngine.TextCore.LowLevel.GlyphRenderMode.SDFAA, 1024, 1024, TMPro.AtlasPopulationMode.Dynamic);
                },
                /*TMPro.TMP_FontAsset.CreateFontAsset:static end.*/

                /*TMPro.TMP_FontAsset.CreateFontAsset$1:static start.*/
                /**
                 * Create new instance of a font asset.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_FontAsset
                 * @memberof TMPro.TMP_FontAsset
                 * @param   {UnityEngine.Font}                                 font                       The source font file.
                 * @param   {number}                                           samplingPointSize          The sampling point size.
                 * @param   {number}                                           atlasPadding               The padding / spread between individual glyphs in the font asset.
                 * @param   {UnityEngine.TextCore.LowLevel.GlyphRenderMode}    renderMode                 
                 * @param   {number}                                           atlasWidth                 The atlas texture width.
                 * @param   {number}                                           atlasHeight                The atlas texture height.
                 * @param   {TMPro.AtlasPopulationMode}                        atlasPopulationMode        
                 * @param   {boolean}                                          enableMultiAtlasSupport
                 * @return  {TMPro.TMP_FontAsset}
                 */
                CreateFontAsset$1: function (font, samplingPointSize, atlasPadding, renderMode, atlasWidth, atlasHeight, atlasPopulationMode, enableMultiAtlasSupport) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#CreateFontAsset$1", this ); }

                    var $t;
                    if (atlasPopulationMode === void 0) { atlasPopulationMode = 1; }
                    if (enableMultiAtlasSupport === void 0) { enableMultiAtlasSupport = true; }
                    // Initialize FontEngine
                    UnityEngine.TextCore.LowLevel.FontEngine.InitializeFontEngine();

                    // Load Font Face
                    if (UnityEngine.TextCore.LowLevel.FontEngine.LoadFontFace$5(font, samplingPointSize) !== UnityEngine.TextCore.LowLevel.FontEngineError.Success) {
                        UnityEngine.Debug.LogWarning$1("Unable to load font face for [" + (font.name || "") + "]. Make sure \"Include Font Data\" is enabled in the Font Import Settings.", font);
                        return null;
                    }

                    // Create new font asset
                    var fontAsset = UnityEngine.ScriptableObject.CreateInstance(TMPro.TMP_FontAsset);

                    fontAsset.m_Version = "1.1.0";
                    fontAsset.faceInfo = UnityEngine.TextCore.LowLevel.FontEngine.GetFaceInfo();

                    // Set font reference and GUID
                    if (atlasPopulationMode === TMPro.AtlasPopulationMode.Dynamic) {
                        fontAsset.sourceFontFile = font;
                    }

                    // Set persistent reference to source font file in the Editor only.

                    fontAsset.atlasPopulationMode = atlasPopulationMode;

                    fontAsset.atlasWidth = atlasWidth;
                    fontAsset.atlasHeight = atlasHeight;
                    fontAsset.atlasPadding = atlasPadding;
                    fontAsset.atlasRenderMode = renderMode;

                    // Initialize array for the font atlas textures.
                    fontAsset.atlasTextures = System.Array.init(1, null, UnityEngine.Texture2D);

                    // Create and add font atlas texture.
                    var texture = new UnityEngine.Texture2D.$ctor2(0, 0, UnityEngine.TextureFormat.Alpha8, false);
                    ($t = fontAsset.atlasTextures)[0] = texture;

                    fontAsset.isMultiAtlasTexturesEnabled = enableMultiAtlasSupport;

                    // Add free rectangle of the size of the texture.
                    var packingModifier;
                    if ((renderMode & UnityEngine.TextCore.LowLevel.GlyphRasterModes.RASTER_MODE_BITMAP) === UnityEngine.TextCore.LowLevel.GlyphRasterModes.RASTER_MODE_BITMAP) {
                        packingModifier = 0;

                        // Optimize by adding static ref to shader.
                        var tmp_material = new UnityEngine.Material.$ctor2(TMPro.ShaderUtilities.ShaderRef_MobileBitmap);

                        //tmp_material.name = texture.name + " Material";
                        tmp_material.SetTexture(TMPro.ShaderUtilities.ID_MainTex, texture);
                        tmp_material.SetFloat(TMPro.ShaderUtilities.ID_TextureWidth, atlasWidth);
                        tmp_material.SetFloat(TMPro.ShaderUtilities.ID_TextureHeight, atlasHeight);

                        fontAsset.material = tmp_material;
                    } else {
                        packingModifier = 1;

                        // Optimize by adding static ref to shader.
                        var tmp_material1 = new UnityEngine.Material.$ctor2(TMPro.ShaderUtilities.ShaderRef_MobileSDF);

                        //tmp_material.name = texture.name + " Material";
                        tmp_material1.SetTexture(TMPro.ShaderUtilities.ID_MainTex, texture);
                        tmp_material1.SetFloat(TMPro.ShaderUtilities.ID_TextureWidth, atlasWidth);
                        tmp_material1.SetFloat(TMPro.ShaderUtilities.ID_TextureHeight, atlasHeight);

                        tmp_material1.SetFloat(TMPro.ShaderUtilities.ID_GradientScale, atlasPadding + packingModifier);

                        tmp_material1.SetFloat(TMPro.ShaderUtilities.ID_WeightNormal, fontAsset.normalStyle);
                        tmp_material1.SetFloat(TMPro.ShaderUtilities.ID_WeightBold, fontAsset.boldStyle);

                        fontAsset.material = tmp_material1;
                    }

                    fontAsset.freeGlyphRects = function (_o1) {
                            _o1.add(new UnityEngine.TextCore.GlyphRect.$ctor1(0, 0, atlasWidth - packingModifier, atlasHeight - packingModifier));
                            return _o1;
                        }(new (System.Collections.Generic.List$1(UnityEngine.TextCore.GlyphRect)).$ctor2(8));
                    fontAsset.usedGlyphRects = new (System.Collections.Generic.List$1(UnityEngine.TextCore.GlyphRect)).$ctor2(8);

                    // TODO: Consider adding support for extracting glyph positioning data

                    fontAsset.ReadFontAssetDefinition();

                    return fontAsset;
                },
                /*TMPro.TMP_FontAsset.CreateFontAsset$1:static end.*/

                /*TMPro.TMP_FontAsset.GetCharacters:static start.*/
                /**
                 * Function to extract all the characters from a font asset.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_FontAsset
                 * @memberof TMPro.TMP_FontAsset
                 * @param   {TMPro.TMP_FontAsset}    fontAsset
                 * @return  {string}
                 */
                GetCharacters: function (fontAsset) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#GetCharacters", this ); }

                    var characters = "";

                    for (var i = 0; i < fontAsset.characterTable.Count; i++) {
                        characters = (characters || "") + String.fromCharCode(fontAsset.characterTable.getItem(i).unicode);
                    }

                    return characters;
                },
                /*TMPro.TMP_FontAsset.GetCharacters:static end.*/

                /*TMPro.TMP_FontAsset.GetCharactersArray:static start.*/
                /**
                 * Function which returns an array that contains all the characters from a font asset.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_FontAsset
                 * @memberof TMPro.TMP_FontAsset
                 * @param   {TMPro.TMP_FontAsset}    fontAsset
                 * @return  {Array.<number>}
                 */
                GetCharactersArray: function (fontAsset) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#GetCharactersArray", this ); }

                    var characters = System.Array.init(fontAsset.characterTable.Count, 0, System.Int32);

                    for (var i = 0; i < fontAsset.characterTable.Count; i++) {
                        characters[i] = fontAsset.characterTable.getItem(i).unicode;
                    }

                    return characters;
                },
                /*TMPro.TMP_FontAsset.GetCharactersArray:static end.*/

                /*TMPro.TMP_FontAsset.RegisterFontAssetForFontFeatureUpdate:static start.*/
                /**
                 * @static
                 * @this TMPro.TMP_FontAsset
                 * @memberof TMPro.TMP_FontAsset
                 * @param   {TMPro.TMP_FontAsset}    fontAsset
                 * @return  {void}
                 */
                RegisterFontAssetForFontFeatureUpdate: function (fontAsset) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#RegisterFontAssetForFontFeatureUpdate", this ); }

                    var instanceID = fontAsset.instanceID;

                    if (TMPro.TMP_FontAsset.k_FontAssets_FontFeaturesUpdateQueueLookup.add(instanceID)) {
                        TMPro.TMP_FontAsset.k_FontAssets_FontFeaturesUpdateQueue.add(fontAsset);
                    }
                },
                /*TMPro.TMP_FontAsset.RegisterFontAssetForFontFeatureUpdate:static end.*/

                /*TMPro.TMP_FontAsset.UpdateFontFeaturesForFontAssetsInQueue:static start.*/
                /**
                 * Function called to update the font atlas texture and character data of font assets to which
                 new characters were added.
                 *
                 * @static
                 * @this TMPro.TMP_FontAsset
                 * @memberof TMPro.TMP_FontAsset
                 * @return  {void}
                 */
                UpdateFontFeaturesForFontAssetsInQueue: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#UpdateFontFeaturesForFontAssetsInQueue", this ); }

                    var count = TMPro.TMP_FontAsset.k_FontAssets_FontFeaturesUpdateQueue.Count;

                    for (var i = 0; i < count; i++) {
                        TMPro.TMP_FontAsset.k_FontAssets_FontFeaturesUpdateQueue.getItem(i).UpdateGlyphAdjustmentRecords();
                    }

                    if (count > 0) {
                        TMPro.TMP_FontAsset.k_FontAssets_FontFeaturesUpdateQueue.clear();
                        TMPro.TMP_FontAsset.k_FontAssets_FontFeaturesUpdateQueueLookup.clear();
                    }
                },
                /*TMPro.TMP_FontAsset.UpdateFontFeaturesForFontAssetsInQueue:static end.*/

                /*TMPro.TMP_FontAsset.RegisterFontAssetForAtlasTextureUpdate:static start.*/
                /**
                 * @static
                 * @this TMPro.TMP_FontAsset
                 * @memberof TMPro.TMP_FontAsset
                 * @param   {TMPro.TMP_FontAsset}    fontAsset
                 * @return  {void}
                 */
                RegisterFontAssetForAtlasTextureUpdate: function (fontAsset) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#RegisterFontAssetForAtlasTextureUpdate", this ); }

                    var instanceID = fontAsset.instanceID;

                    if (TMPro.TMP_FontAsset.k_FontAssets_AtlasTexturesUpdateQueueLookup.add(instanceID)) {
                        TMPro.TMP_FontAsset.k_FontAssets_AtlasTexturesUpdateQueue.add(fontAsset);
                    }
                },
                /*TMPro.TMP_FontAsset.RegisterFontAssetForAtlasTextureUpdate:static end.*/

                /*TMPro.TMP_FontAsset.UpdateAtlasTexturesForFontAssetsInQueue:static start.*/
                /**
                 * @static
                 * @this TMPro.TMP_FontAsset
                 * @memberof TMPro.TMP_FontAsset
                 * @return  {void}
                 */
                UpdateAtlasTexturesForFontAssetsInQueue: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#UpdateAtlasTexturesForFontAssetsInQueue", this ); }

                    var count = TMPro.TMP_FontAsset.k_FontAssets_AtlasTexturesUpdateQueueLookup.Count;

                    for (var i = 0; i < count; i++) {
                        TMPro.TMP_FontAsset.k_FontAssets_AtlasTexturesUpdateQueue.getItem(i).TryAddGlyphsToAtlasTextures();
                    }

                    if (count > 0) {
                        TMPro.TMP_FontAsset.k_FontAssets_AtlasTexturesUpdateQueue.clear();
                        TMPro.TMP_FontAsset.k_FontAssets_AtlasTexturesUpdateQueueLookup.clear();
                    }
                },
                /*TMPro.TMP_FontAsset.UpdateAtlasTexturesForFontAssetsInQueue:static end.*/


            }
        },
        fields: {
            m_Version: null,
            /**
             * This field is set when the font asset is first created.
             *
             * @instance
             * @memberof TMPro.TMP_FontAsset
             * @type string
             */
            m_SourceFontFileGUID: null,
            m_SourceFontFile: null,
            m_AtlasPopulationMode: 0,
            m_FaceInfo: null,
            m_GlyphTable: null,
            m_GlyphLookupDictionary: null,
            m_CharacterTable: null,
            m_CharacterLookupDictionary: null,
            m_AtlasTexture: null,
            m_AtlasTextures: null,
            /**
             * Index of the font atlas texture that still has available space to add new glyphs.
             *
             * @instance
             * @memberof TMPro.TMP_FontAsset
             * @type number
             */
            m_AtlasTextureIndex: 0,
            m_IsMultiAtlasTexturesEnabled: false,
            m_ClearDynamicDataOnBuild: false,
            m_UsedGlyphRects: null,
            m_FreeGlyphRects: null,
            m_fontInfo: null,
            /**
             * @instance
             * @public
             * @memberof TMPro.TMP_FontAsset
             * @type UnityEngine.Texture2D
             */
            atlas: null,
            m_AtlasWidth: 0,
            m_AtlasHeight: 0,
            m_AtlasPadding: 0,
            m_AtlasRenderMode: 0,
            m_glyphInfoList: null,
            m_KerningTable: null,
            m_FontFeatureTable: null,
            fallbackFontAssets: null,
            m_FallbackFontAssetTable: null,
            m_CreationSettings: null,
            m_FontWeightTable: null,
            /**
             * Font weights used by font asset prior to version 1.1.0.
             This is legacy and will be removed at some point in the future.
             *
             * @instance
             * @private
             * @memberof TMPro.TMP_FontAsset
             * @type Array.<TMPro.TMP_FontWeightPair>
             */
            fontWeights: null,
            /**
             * Defines the dilation of the text when using regular style.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_FontAsset
             * @default 0
             * @type number
             */
            normalStyle: 0,
            /**
             * The spacing between characters when using regular style.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_FontAsset
             * @default 0
             * @type number
             */
            normalSpacingOffset: 0,
            /**
             * Defines the dilation of the text when using bold style.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_FontAsset
             * @default 0.75
             * @type number
             */
            boldStyle: 0,
            /**
             * The spacing between characters when using regular style.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_FontAsset
             * @default 7.0
             * @type number
             */
            boldSpacing: 0,
            /**
             * Defines the slant of the text when using italic style.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_FontAsset
             * @default 35
             * @type number
             */
            italicStyle: 0,
            tabSize: 0,
            IsFontAssetLookupTablesDirty: false,
            FallbackSearchQueryLookup: null,
            /**
             * 
             * List of glyphs that need to be rendered and added to an atlas texture.
             *
             * @instance
             * @private
             * @memberof TMPro.TMP_FontAsset
             * @type System.Collections.Generic.List$1
             */
            m_GlyphsToRender: null,
            /**
             * List of glyphs that we just rendered and added to an atlas texture.
             *
             * @instance
             * @private
             * @memberof TMPro.TMP_FontAsset
             * @type System.Collections.Generic.List$1
             */
            m_GlyphsRendered: null,
            /**
             * List of all the glyph indexes contained in the font asset.
             *
             * @instance
             * @private
             * @memberof TMPro.TMP_FontAsset
             * @type System.Collections.Generic.List$1
             */
            m_GlyphIndexList: null,
            /**
             * List of glyph indexes newly added to the font asset.
             This list is used in the process of retrieving font features.
             *
             * @instance
             * @private
             * @memberof TMPro.TMP_FontAsset
             * @type System.Collections.Generic.List$1
             */
            m_GlyphIndexListNewlyAdded: null,
            /**
             * @instance
             * @memberof TMPro.TMP_FontAsset
             * @type System.Collections.Generic.List$1
             */
            m_GlyphsToAdd: null,
            m_GlyphsToAddLookup: null,
            m_CharactersToAdd: null,
            m_CharactersToAddLookup: null,
            /**
             * Internal list used to track characters that could not be added to the font asset.
             *
             * @instance
             * @memberof TMPro.TMP_FontAsset
             * @type System.Collections.Generic.List$1
             */
            s_MissingCharacterList: null,
            /**
             * Hash table used to track characters that are known to be missing from the font file.
             *
             * @instance
             * @memberof TMPro.TMP_FontAsset
             * @type System.Collections.Generic.HashSet$1
             */
            m_MissingUnicodesFromFontFile: null
        },
        props: {
            /**
             * The version of the font asset class.
             Version 1.1.0 adds support for the new TextCore.FontEngine and Dynamic SDF system.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_FontAsset
             * @function version
             * @type string
             */
            version: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#version#get", this ); }

                    return this.m_Version;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#version#set", this ); }

                    this.m_Version = value;
                }
            },
            /**
             * Source font file when atlas population mode is set to dynamic. Null when the atlas population mode is set to static.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_FontAsset
             * @function sourceFontFile
             * @type UnityEngine.Font
             */
            sourceFontFile: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#sourceFontFile#get", this ); }

                    return this.m_SourceFontFile;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#sourceFontFile#set", this ); }

                    this.m_SourceFontFile = value;
                }
            },
            atlasPopulationMode: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#atlasPopulationMode#get", this ); }

                    return this.m_AtlasPopulationMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#atlasPopulationMode#set", this ); }

                    this.m_AtlasPopulationMode = value;

                }
            },
            /**
             * Information about the font's face.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_FontAsset
             * @function faceInfo
             * @type UnityEngine.TextCore.FaceInfo
             */
            faceInfo: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#faceInfo#get", this ); }

                    return this.m_FaceInfo.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#faceInfo#set", this ); }

                    this.m_FaceInfo = value.$clone();
                }
            },
            /**
             * List of glyphs contained in the font asset.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_FontAsset
             * @function glyphTable
             * @type System.Collections.Generic.List$1
             */
            glyphTable: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#glyphTable#get", this ); }

                    return this.m_GlyphTable;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#glyphTable#set", this ); }

                    this.m_GlyphTable = value;
                }
            },
            /**
             * Dictionary used to lookup glyphs contained in the font asset by their index.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_FontAsset
             * @function glyphLookupTable
             * @type System.Collections.Generic.Dictionary$2
             */
            glyphLookupTable: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#glyphLookupTable#get", this ); }

                    if (this.m_GlyphLookupDictionary == null) {
                        this.ReadFontAssetDefinition();
                    }

                    return this.m_GlyphLookupDictionary;
                }
            },
            /**
             * List containing the characters of the given font asset.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_FontAsset
             * @function characterTable
             * @type System.Collections.Generic.List$1
             */
            characterTable: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#characterTable#get", this ); }

                    return this.m_CharacterTable;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#characterTable#set", this ); }

                    this.m_CharacterTable = value;
                }
            },
            /**
             * Dictionary used to lookup characters contained in the font asset by their unicode values.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_FontAsset
             * @function characterLookupTable
             * @type System.Collections.Generic.Dictionary$2
             */
            characterLookupTable: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#characterLookupTable#get", this ); }

                    if (this.m_CharacterLookupDictionary == null) {
                        this.ReadFontAssetDefinition();
                    }


                    return this.m_CharacterLookupDictionary;
                }
            },
            /**
             * Determines if the font asset is using a shared atlas texture(s)
             * The font atlas used by this font asset.
             This is always the texture at index [0] of the fontAtlasTextures.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_FontAsset
             * @function atlasTexture
             * @type UnityEngine.Texture2D
             */
            atlasTexture: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#atlasTexture#get", this ); }

                    var $t;
                    if (this.m_AtlasTexture == null) {
                        this.m_AtlasTexture = ($t = this.atlasTextures)[0];
                    }

                    return this.m_AtlasTexture;
                }
            },
            /**
             * Array of atlas textures that contain the glyphs used by this font asset.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_FontAsset
             * @function atlasTextures
             * @type Array.<UnityEngine.Texture2D>
             */
            atlasTextures: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#atlasTextures#get", this ); }

                    if (this.m_AtlasTextures == null) {
                        //
                    }

                    //if (m_IsUsingDynamicTextures)
                    //    return TMP_DynamicAtlasTextureGroup.managedDynamicTextures;
                    return this.m_AtlasTextures;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#atlasTextures#set", this ); }

                    this.m_AtlasTextures = value;
                }
            },
            /**
             * Number of atlas textures used by this font asset.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_FontAsset
             * @function atlasTextureCount
             * @type number
             */
            atlasTextureCount: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#atlasTextureCount#get", this ); }

                    return this.m_AtlasTextureIndex + 1;
                }
            },
            /**
             * Enables the font asset to create additional atlas textures as needed.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_FontAsset
             * @function isMultiAtlasTexturesEnabled
             * @type boolean
             */
            isMultiAtlasTexturesEnabled: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#isMultiAtlasTexturesEnabled#get", this ); }

                    return this.m_IsMultiAtlasTexturesEnabled;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#isMultiAtlasTexturesEnabled#set", this ); }

                    this.m_IsMultiAtlasTexturesEnabled = value;
                }
            },
            /**
             * Determines if dynamic font asset data should be cleared before builds.
             *
             * @instance
             * @memberof TMPro.TMP_FontAsset
             * @function clearDynamicDataOnBuild
             * @type boolean
             */
            clearDynamicDataOnBuild: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#clearDynamicDataOnBuild#get", this ); }

                    return this.m_ClearDynamicDataOnBuild;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#clearDynamicDataOnBuild#set", this ); }

                    this.m_ClearDynamicDataOnBuild = value;
                }
            },
            /**
             * List of spaces occupied by glyphs in a given texture.
             *
             * @instance
             * @memberof TMPro.TMP_FontAsset
             * @function usedGlyphRects
             * @type System.Collections.Generic.List$1
             */
            usedGlyphRects: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#usedGlyphRects#get", this ); }

                    return this.m_UsedGlyphRects;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#usedGlyphRects#set", this ); }

                    this.m_UsedGlyphRects = value;
                }
            },
            /**
             * List of spaces available in a given texture to add new glyphs.
             *
             * @instance
             * @memberof TMPro.TMP_FontAsset
             * @function freeGlyphRects
             * @type System.Collections.Generic.List$1
             */
            freeGlyphRects: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#freeGlyphRects#get", this ); }

                    return this.m_FreeGlyphRects;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#freeGlyphRects#set", this ); }

                    this.m_FreeGlyphRects = value;
                }
            },
            /**
             * The general information about the font.
             This property and FaceInfo_Legacy type are no longer used in version 1.1.0 of the font asset.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_FontAsset
             * @function fontInfo
             * @type TMPro.FaceInfo_Legacy
             */
            fontInfo: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#fontInfo#get", this ); }

                    return this.m_fontInfo;
                }
            },
            /**
             * The width of the atlas texture(s) used by this font asset.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_FontAsset
             * @function atlasWidth
             * @type number
             */
            atlasWidth: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#atlasWidth#get", this ); }

                    return this.m_AtlasWidth;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#atlasWidth#set", this ); }

                    this.m_AtlasWidth = value;
                }
            },
            /**
             * The height of the atlas texture(s) used by this font asset.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_FontAsset
             * @function atlasHeight
             * @type number
             */
            atlasHeight: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#atlasHeight#get", this ); }

                    return this.m_AtlasHeight;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#atlasHeight#set", this ); }

                    this.m_AtlasHeight = value;
                }
            },
            /**
             * The padding used between glyphs contained in the atlas texture(s) used by this font asset.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_FontAsset
             * @function atlasPadding
             * @type number
             */
            atlasPadding: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#atlasPadding#get", this ); }

                    return this.m_AtlasPadding;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#atlasPadding#set", this ); }

                    this.m_AtlasPadding = value;
                }
            },
            atlasRenderMode: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#atlasRenderMode#get", this ); }

                    return this.m_AtlasRenderMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#atlasRenderMode#set", this ); }

                    this.m_AtlasRenderMode = value;
                }
            },
            /**
             * Table containing the various font features of this font asset.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_FontAsset
             * @function fontFeatureTable
             * @type TMPro.TMP_FontFeatureTable
             */
            fontFeatureTable: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#fontFeatureTable#get", this ); }

                    return this.m_FontFeatureTable;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#fontFeatureTable#set", this ); }

                    this.m_FontFeatureTable = value;
                }
            },
            /**
             * List containing the Fallback font assets for this font.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_FontAsset
             * @function fallbackFontAssetTable
             * @type System.Collections.Generic.List$1
             */
            fallbackFontAssetTable: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#fallbackFontAssetTable#get", this ); }

                    return this.m_FallbackFontAssetTable;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#fallbackFontAssetTable#set", this ); }

                    this.m_FallbackFontAssetTable = value;
                }
            },
            /**
             * The settings used in the Font Asset Creator when this font asset was created or edited.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_FontAsset
             * @function creationSettings
             * @type TMPro.FontAssetCreationSettings
             */
            creationSettings: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#creationSettings#get", this ); }

                    return this.m_CreationSettings.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#creationSettings#set", this ); }

                    this.m_CreationSettings = value.$clone();
                }
            },
            /**
             * Array containing font assets to be used as alternative typefaces for the various potential font weights of this font asset.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_FontAsset
             * @function fontWeightTable
             * @type Array.<TMPro.TMP_FontWeightPair>
             */
            fontWeightTable: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#fontWeightTable#get", this ); }

                    return this.m_FontWeightTable;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#fontWeightTable#set", this ); }

                    this.m_FontWeightTable = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#init", this ); }

                this.m_FaceInfo = new UnityEngine.TextCore.FaceInfo();
                this.m_CreationSettings = new TMPro.FontAssetCreationSettings();
                this.m_GlyphTable = new (System.Collections.Generic.List$1(UnityEngine.TextCore.Glyph)).ctor();
                this.m_CharacterTable = new (System.Collections.Generic.List$1(TMPro.TMP_Character)).ctor();
                this.m_KerningTable = new TMPro.KerningTable();
                this.m_FontFeatureTable = new TMPro.TMP_FontFeatureTable();
                this.m_FontWeightTable = System.Array.init(10, function (){
                    return new TMPro.TMP_FontWeightPair();
                }, TMPro.TMP_FontWeightPair);
                this.normalStyle = 0;
                this.normalSpacingOffset = 0;
                this.boldStyle = 0.75;
                this.boldSpacing = 7.0;
                this.italicStyle = 35;
                this.tabSize = 10;
                this.FallbackSearchQueryLookup = new (System.Collections.Generic.HashSet$1(System.Int32)).ctor();
                this.m_GlyphsToRender = new (System.Collections.Generic.List$1(UnityEngine.TextCore.Glyph)).ctor();
                this.m_GlyphsRendered = new (System.Collections.Generic.List$1(UnityEngine.TextCore.Glyph)).ctor();
                this.m_GlyphIndexList = new (System.Collections.Generic.List$1(System.UInt32)).ctor();
                this.m_GlyphIndexListNewlyAdded = new (System.Collections.Generic.List$1(System.UInt32)).ctor();
                this.m_GlyphsToAdd = new (System.Collections.Generic.List$1(System.UInt32)).ctor();
                this.m_GlyphsToAddLookup = new (System.Collections.Generic.HashSet$1(System.UInt32)).ctor();
                this.m_CharactersToAdd = new (System.Collections.Generic.List$1(TMPro.TMP_Character)).ctor();
                this.m_CharactersToAddLookup = new (System.Collections.Generic.HashSet$1(System.UInt32)).ctor();
                this.s_MissingCharacterList = new (System.Collections.Generic.List$1(System.UInt32)).ctor();
                this.m_MissingUnicodesFromFontFile = new (System.Collections.Generic.HashSet$1(System.UInt32)).ctor();
            }
        },
        methods: {
            /*TMPro.TMP_FontAsset.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#Awake", this ); }

                // Check version number of font asset to see if it needs to be upgraded.
                if (this.material != null && System.String.isNullOrEmpty(this.m_Version)) {
                    this.UpgradeFontAsset();
                }
            },
            /*TMPro.TMP_FontAsset.Awake end.*/

            /*TMPro.TMP_FontAsset.ReadFontAssetDefinition start.*/
            ReadFontAssetDefinition: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#ReadFontAssetDefinition", this ); }

                //Debug.Log("Reading Font Asset Definition for " + this.name + ".");

                // Check version number of font asset to see if it needs to be upgraded.
                if (this.material != null && System.String.isNullOrEmpty(this.m_Version)) {
                    this.UpgradeFontAsset();
                }

                // Initialize lookup tables for characters and glyphs.
                this.InitializeDictionaryLookupTables();

                // Add synthesized characters and adjust face metrics
                this.AddSynthesizedCharactersAndFaceMetrics();

                // Adjust Font Scale for compatibility reasons
                if (this.m_FaceInfo.scale === 0) {
                    this.m_FaceInfo.scale = 1.0;
                }

                // Set Strikethrough Offset (if needed)
                if (this.m_FaceInfo.strikethroughOffset === 0) {
                    this.m_FaceInfo.strikethroughOffset = this.m_FaceInfo.capLine / 2.5;
                }

                // Set Padding value for legacy font assets.
                if (this.m_AtlasPadding === 0) {
                    if (this.material.HasProperty(TMPro.ShaderUtilities.ID_GradientScale)) {
                        this.m_AtlasPadding = this.material.GetFloat(TMPro.ShaderUtilities.ID_GradientScale) - 1;
                    }
                }

                // Compute Hashcode for the font asset name
                this.hashCode = TMPro.TMP_TextUtilities.GetSimpleHashCode(this.name);

                // Compute Hashcode for the material name
                this.materialHashCode = TMPro.TMP_TextUtilities.GetSimpleHashCode((this.name || "") + (TMPro.TMP_FontAsset.s_DefaultMaterialSuffix || ""));

                // Add reference to font asset in TMP Resource Manager
                //TMP_ResourceManager.AddFontAsset(this);

                this.IsFontAssetLookupTablesDirty = false;
            },
            /*TMPro.TMP_FontAsset.ReadFontAssetDefinition end.*/

            /*TMPro.TMP_FontAsset.InitializeDictionaryLookupTables start.*/
            /**
             * Read the various data tables of the font asset to populate its different dictionaries to allow for faster lookup of related font asset data.
             *
             * @instance
             * @this TMPro.TMP_FontAsset
             * @memberof TMPro.TMP_FontAsset
             * @return  {void}
             */
            InitializeDictionaryLookupTables: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#InitializeDictionaryLookupTables", this ); }

                // Initialize and populate glyph lookup dictionary
                this.InitializeGlyphLookupDictionary();

                // Initialize and populate character lookup dictionary
                this.InitializeCharacterLookupDictionary();

                // Initialize and populate character lookup dictionary
                this.InitializeGlyphPaidAdjustmentRecordsLookupDictionary();
            },
            /*TMPro.TMP_FontAsset.InitializeDictionaryLookupTables end.*/

            /*TMPro.TMP_FontAsset.InitializeGlyphLookupDictionary start.*/
            InitializeGlyphLookupDictionary: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#InitializeGlyphLookupDictionary", this ); }

                // Create new instance of the glyph lookup dictionary or clear the existing one.
                if (this.m_GlyphLookupDictionary == null) {
                    this.m_GlyphLookupDictionary = new (System.Collections.Generic.Dictionary$2(System.UInt32,UnityEngine.TextCore.Glyph)).ctor();
                } else {
                    this.m_GlyphLookupDictionary.clear();
                }

                // Initialize or clear list of glyph indexes.
                if (this.m_GlyphIndexList == null) {
                    this.m_GlyphIndexList = new (System.Collections.Generic.List$1(System.UInt32)).ctor();
                } else {
                    this.m_GlyphIndexList.clear();
                }

                // Initialize or clear list of glyph indexes.
                if (this.m_GlyphIndexListNewlyAdded == null) {
                    this.m_GlyphIndexListNewlyAdded = new (System.Collections.Generic.List$1(System.UInt32)).ctor();
                } else {
                    this.m_GlyphIndexListNewlyAdded.clear();
                }

                //
                var glyphCount = this.m_GlyphTable.Count;

                // Add glyphs contained in the glyph table to dictionary for faster lookup.
                for (var i = 0; i < glyphCount; i++) {
                    var glyph = this.m_GlyphTable.getItem(i);

                    var index = glyph.index;

                    // TODO: Not sure it is necessary to check here.
                    if (this.m_GlyphLookupDictionary.containsKey(index) === false) {
                        this.m_GlyphLookupDictionary.add(index, glyph);
                        this.m_GlyphIndexList.add(index);
                    }
                }
            },
            /*TMPro.TMP_FontAsset.InitializeGlyphLookupDictionary end.*/

            /*TMPro.TMP_FontAsset.InitializeCharacterLookupDictionary start.*/
            InitializeCharacterLookupDictionary: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#InitializeCharacterLookupDictionary", this ); }

                // Create new instance of the character lookup dictionary or clear the existing one.
                if (this.m_CharacterLookupDictionary == null) {
                    this.m_CharacterLookupDictionary = new (System.Collections.Generic.Dictionary$2(System.UInt32,TMPro.TMP_Character)).ctor();
                } else {
                    this.m_CharacterLookupDictionary.clear();
                }

                // Add the characters contained in the character table to the dictionary for faster lookup.
                for (var i = 0; i < this.m_CharacterTable.Count; i++) {
                    var character = this.m_CharacterTable.getItem(i);

                    var unicode = character.unicode;
                    var glyphIndex = character.glyphIndex;

                    // Add character along with reference to text asset and glyph
                    if (this.m_CharacterLookupDictionary.containsKey(unicode) === false) {
                        this.m_CharacterLookupDictionary.add(unicode, character);
                        character.textAsset = this;
                        character.glyph = this.m_GlyphLookupDictionary.getItem(glyphIndex);
                    }
                }

                // Clear internal fallback references
                if (this.FallbackSearchQueryLookup == null) {
                    this.FallbackSearchQueryLookup = new (System.Collections.Generic.HashSet$1(System.Int32)).ctor();
                } else {
                    this.FallbackSearchQueryLookup.clear();
                }
            },
            /*TMPro.TMP_FontAsset.InitializeCharacterLookupDictionary end.*/

            /*TMPro.TMP_FontAsset.InitializeGlyphPaidAdjustmentRecordsLookupDictionary start.*/
            InitializeGlyphPaidAdjustmentRecordsLookupDictionary: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#InitializeGlyphPaidAdjustmentRecordsLookupDictionary", this ); }

                // Upgrade Glyph Adjustment Table to the new Font Feature table and Glyph Pair Adjustment Records
                if (this.m_KerningTable != null && this.m_KerningTable.kerningPairs != null && this.m_KerningTable.kerningPairs.Count > 0) {
                    this.UpgradeGlyphAdjustmentTableToFontFeatureTable();
                }

                // Read Font Features which will include kerning data.
                if (this.m_FontFeatureTable.m_GlyphPairAdjustmentRecordLookupDictionary == null) {
                    this.m_FontFeatureTable.m_GlyphPairAdjustmentRecordLookupDictionary = new (System.Collections.Generic.Dictionary$2(System.UInt32,TMPro.TMP_GlyphPairAdjustmentRecord)).ctor();
                } else {
                    this.m_FontFeatureTable.m_GlyphPairAdjustmentRecordLookupDictionary.clear();
                }

                var glyphPairAdjustmentRecords = this.m_FontFeatureTable.m_GlyphPairAdjustmentRecords;
                if (glyphPairAdjustmentRecords != null) {
                    for (var i = 0; i < glyphPairAdjustmentRecords.Count; i++) {
                        var record = glyphPairAdjustmentRecords.getItem(i);

                        var key = new TMPro.GlyphPairKey.$ctor2(record).key;

                        if (!this.m_FontFeatureTable.m_GlyphPairAdjustmentRecordLookupDictionary.containsKey(key)) {
                            this.m_FontFeatureTable.m_GlyphPairAdjustmentRecordLookupDictionary.add(key, record);
                        }
                    }
                }
            },
            /*TMPro.TMP_FontAsset.InitializeGlyphPaidAdjustmentRecordsLookupDictionary end.*/

            /*TMPro.TMP_FontAsset.AddSynthesizedCharactersAndFaceMetrics start.*/
            AddSynthesizedCharactersAndFaceMetrics: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#AddSynthesizedCharactersAndFaceMetrics", this ); }

                var isFontFaceLoaded = false;

                if (this.m_AtlasPopulationMode === TMPro.AtlasPopulationMode.Dynamic) {
                    isFontFaceLoaded = UnityEngine.TextCore.LowLevel.FontEngine.LoadFontFace$5(this.sourceFontFile, this.m_FaceInfo.pointSize) === UnityEngine.TextCore.LowLevel.FontEngineError.Success;
                }

                // Only characters not present in the source font file will be synthesized.

                // Non visible and control characters with no metrics
                // Add End of Text \u0003
                this.AddSynthesizedCharacter(3, isFontFaceLoaded, true);

                // Add Tab \u0009
                this.AddSynthesizedCharacter(9, isFontFaceLoaded, true);

                // Add Line Feed (LF) \u000A
                this.AddSynthesizedCharacter(10, isFontFaceLoaded);

                // Add Vertical Tab (VT) \u000B
                this.AddSynthesizedCharacter(11, isFontFaceLoaded);

                // Add Carriage Return (CR) \u000D
                this.AddSynthesizedCharacter(13, isFontFaceLoaded);

                // Add Arabic Letter Mark \u061C
                this.AddSynthesizedCharacter(1564, isFontFaceLoaded);

                // Add Zero Width Space <ZWSP> \u2000B
                this.AddSynthesizedCharacter(8203, isFontFaceLoaded);

                // Add Left-To-Right Mark \u200E
                this.AddSynthesizedCharacter(8206, isFontFaceLoaded);

                // Add Right-To-Left Mark \u200F
                this.AddSynthesizedCharacter(8207, isFontFaceLoaded);

                // Add Line Separator \u2028
                this.AddSynthesizedCharacter(8232, isFontFaceLoaded);

                // Add Paragraph Separator \u2029
                this.AddSynthesizedCharacter(8233, isFontFaceLoaded);

                // Add Word Joiner <WJ> / Zero Width Non-Breaking Space \u2060
                this.AddSynthesizedCharacter(8288, isFontFaceLoaded);

                // Set Cap Line using the capital letter 'X'
                if (this.m_FaceInfo.capLine === 0 && this.m_CharacterLookupDictionary.containsKey(88)) {
                    var glyphIndex = this.m_CharacterLookupDictionary.getItem(88).glyphIndex;
                    this.m_FaceInfo.capLine = this.m_GlyphLookupDictionary.getItem(glyphIndex).metrics.horizontalBearingY;
                }

                // Set Mean Line using the lowercase letter 'x'
                if (this.m_FaceInfo.meanLine === 0 && this.m_CharacterLookupDictionary.containsKey(120)) {
                    var glyphIndex1 = this.m_CharacterLookupDictionary.getItem(120).glyphIndex;
                    this.m_FaceInfo.meanLine = this.m_GlyphLookupDictionary.getItem(glyphIndex1).metrics.horizontalBearingY;
                }
            },
            /*TMPro.TMP_FontAsset.AddSynthesizedCharactersAndFaceMetrics end.*/

            /*TMPro.TMP_FontAsset.AddSynthesizedCharacter start.*/
            AddSynthesizedCharacter: function (unicode, isFontFaceLoaded, addImmediately) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#AddSynthesizedCharacter", this ); }

                if (addImmediately === void 0) { addImmediately = false; }
                // Check if unicode is already present in the font asset
                if (this.m_CharacterLookupDictionary.containsKey(unicode)) {
                    return;
                }

                var glyph = { };

                if (isFontFaceLoaded) {
                    // Check if unicode is present in font file
                    if (UnityEngine.TextCore.LowLevel.FontEngine.GetGlyphIndex(unicode) !== 0) {
                        if (addImmediately === false) {
                            return;
                        }

                        //Debug.Log("Adding Unicode [" + unicode.ToString("X4") + "].");

                        var glyphLoadFlags = (this.m_AtlasRenderMode & UnityEngine.TextCore.LowLevel.GlyphRasterModes.RASTER_MODE_NO_HINTING) === UnityEngine.TextCore.LowLevel.GlyphRasterModes.RASTER_MODE_NO_HINTING ? 10 : UnityEngine.TextCore.LowLevel.GlyphLoadFlags.LOAD_NO_BITMAP;

                        if (UnityEngine.TextCore.LowLevel.FontEngine.TryGetGlyphWithUnicodeValue(unicode, glyphLoadFlags, glyph)) {
                            this.m_CharacterLookupDictionary.add(unicode, new TMPro.TMP_Character.$ctor2(unicode, this, glyph.v));
                        }

                        return;
                    }
                }

                //Debug.Log("Synthesizing Unicode [" + unicode.ToString("X4") + "].");

                // Synthesize and add missing glyph and character
                glyph.v = new UnityEngine.TextCore.Glyph.$ctor2(0, new UnityEngine.TextCore.GlyphMetrics.$ctor1(0, 0, 0, 0, 0), UnityEngine.TextCore.GlyphRect.zero.$clone(), 1.0, 0);
                this.m_CharacterLookupDictionary.add(unicode, new TMPro.TMP_Character.$ctor2(unicode, this, glyph.v));
            },
            /*TMPro.TMP_FontAsset.AddSynthesizedCharacter end.*/

            /*TMPro.TMP_FontAsset.AddCharacterToLookupCache start.*/
            AddCharacterToLookupCache: function (unicode, character) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#AddCharacterToLookupCache", this ); }

                this.m_CharacterLookupDictionary.add(unicode, character);

                // Add font asset to fallback references.
                this.FallbackSearchQueryLookup.add(character.textAsset.instanceID);
            },
            /*TMPro.TMP_FontAsset.AddCharacterToLookupCache end.*/

            /*TMPro.TMP_FontAsset.SortCharacterTable start.*/
            /**
             * Sort the Character table by Unicode values.
             *
             * @instance
             * @this TMPro.TMP_FontAsset
             * @memberof TMPro.TMP_FontAsset
             * @return  {void}
             */
            SortCharacterTable: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#SortCharacterTable", this ); }

                if (this.m_CharacterTable != null && this.m_CharacterTable.Count > 0) {
                    this.m_CharacterTable = System.Linq.Enumerable.from(this.m_CharacterTable, TMPro.TMP_Character).orderBy(function (c) {
                            return c.unicode;
                        }).toList(TMPro.TMP_Character);
                }
            },
            /*TMPro.TMP_FontAsset.SortCharacterTable end.*/

            /*TMPro.TMP_FontAsset.SortGlyphTable start.*/
            /**
             * Sort the Glyph table by index values.
             *
             * @instance
             * @this TMPro.TMP_FontAsset
             * @memberof TMPro.TMP_FontAsset
             * @return  {void}
             */
            SortGlyphTable: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#SortGlyphTable", this ); }

                if (this.m_GlyphTable != null && this.m_GlyphTable.Count > 0) {
                    this.m_GlyphTable = System.Linq.Enumerable.from(this.m_GlyphTable, UnityEngine.TextCore.Glyph).orderBy(function (c) {
                            return c.index;
                        }).toList(UnityEngine.TextCore.Glyph);
                }
            },
            /*TMPro.TMP_FontAsset.SortGlyphTable end.*/

            /*TMPro.TMP_FontAsset.SortFontFeatureTable start.*/
            SortFontFeatureTable: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#SortFontFeatureTable", this ); }

                this.m_FontFeatureTable.SortGlyphPairAdjustmentRecords();
            },
            /*TMPro.TMP_FontAsset.SortFontFeatureTable end.*/

            /*TMPro.TMP_FontAsset.SortAllTables start.*/
            /**
             * Sort both glyph and character tables.
             *
             * @instance
             * @this TMPro.TMP_FontAsset
             * @memberof TMPro.TMP_FontAsset
             * @return  {void}
             */
            SortAllTables: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#SortAllTables", this ); }

                this.SortGlyphTable();
                this.SortCharacterTable();
                this.SortFontFeatureTable();
            },
            /*TMPro.TMP_FontAsset.SortAllTables end.*/

            /*TMPro.TMP_FontAsset.HasCharacter$1 start.*/
            /**
             * Function to check if a certain character exists in the font asset.
             *
             * @instance
             * @public
             * @this TMPro.TMP_FontAsset
             * @memberof TMPro.TMP_FontAsset
             * @param   {number}     character
             * @return  {boolean}
             */
            HasCharacter$1: function (character) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#HasCharacter$1", this ); }

                if (this.m_CharacterLookupDictionary == null) {
                    return false;
                }

                return this.m_CharacterLookupDictionary.containsKey(character);
            },
            /*TMPro.TMP_FontAsset.HasCharacter$1 end.*/

            /*TMPro.TMP_FontAsset.HasCharacter start.*/
            /**
             * Function to check if a character is contained in the font asset with the option to also check potential local fallbacks.
             *
             * @instance
             * @public
             * @this TMPro.TMP_FontAsset
             * @memberof TMPro.TMP_FontAsset
             * @param   {number}     character          
             * @param   {boolean}    searchFallbacks    
             * @param   {boolean}    tryAddCharacter
             * @return  {boolean}
             */
            HasCharacter: function (character, searchFallbacks, tryAddCharacter) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#HasCharacter", this ); }

                if (searchFallbacks === void 0) { searchFallbacks = false; }
                if (tryAddCharacter === void 0) { tryAddCharacter = false; }
                // Read font asset definition if it hasn't already been done.
                if (this.m_CharacterLookupDictionary == null) {
                    this.ReadFontAssetDefinition();

                    if (this.m_CharacterLookupDictionary == null) {
                        return false;
                    }
                }

                // Check font asset
                if (this.m_CharacterLookupDictionary.containsKey(character)) {
                    return true;
                }

                // Check if font asset is dynamic and if so try to add the requested character to it.
                if (tryAddCharacter && this.m_AtlasPopulationMode === TMPro.AtlasPopulationMode.Dynamic) {
                    var returnedCharacter = { };

                    if (this.TryAddCharacterInternal(character, returnedCharacter)) {
                        return true;
                    }
                }

                if (searchFallbacks) {
                    // Initialize or clear font asset lookup
                    if (TMPro.TMP_FontAsset.k_SearchedFontAssetLookup == null) {
                        TMPro.TMP_FontAsset.k_SearchedFontAssetLookup = new (System.Collections.Generic.HashSet$1(System.Int32)).ctor();
                    } else {
                        TMPro.TMP_FontAsset.k_SearchedFontAssetLookup.clear();
                    }

                    // Add current font asset to lookup
                    TMPro.TMP_FontAsset.k_SearchedFontAssetLookup.add(this.GetInstanceID());

                    // Check font asset fallbacks
                    if (this.fallbackFontAssetTable != null && this.fallbackFontAssetTable.Count > 0) {
                        for (var i = 0; i < this.fallbackFontAssetTable.Count && this.fallbackFontAssetTable.getItem(i) != null; i++) {
                            var fallback = this.fallbackFontAssetTable.getItem(i);
                            var fallbackID = fallback.GetInstanceID();

                            // Search fallback if not already contained in lookup
                            if (TMPro.TMP_FontAsset.k_SearchedFontAssetLookup.add(fallbackID)) {
                                if (fallback.HasCharacter_Internal(character, true, tryAddCharacter)) {
                                    return true;
                                }
                            }
                        }
                    }

                    // Check general fallback font assets.
                    if (TMPro.TMP_Settings.fallbackFontAssets != null && TMPro.TMP_Settings.fallbackFontAssets.Count > 0) {
                        for (var i1 = 0; i1 < TMPro.TMP_Settings.fallbackFontAssets.Count && TMPro.TMP_Settings.fallbackFontAssets.getItem(i1) != null; i1++) {
                            var fallback1 = TMPro.TMP_Settings.fallbackFontAssets.getItem(i1);
                            var fallbackID1 = fallback1.GetInstanceID();

                            // Search fallback if not already contained in lookup
                            if (TMPro.TMP_FontAsset.k_SearchedFontAssetLookup.add(fallbackID1)) {
                                if (fallback1.HasCharacter_Internal(character, true, tryAddCharacter)) {
                                    return true;
                                }
                            }
                        }
                    }

                    // Check TMP Settings Default Font Asset
                    if (TMPro.TMP_Settings.defaultFontAsset != null) {
                        var fallback2 = TMPro.TMP_Settings.defaultFontAsset;
                        var fallbackID2 = fallback2.GetInstanceID();

                        // Search fallback if it has not already been searched
                        if (TMPro.TMP_FontAsset.k_SearchedFontAssetLookup.add(fallbackID2)) {
                            if (fallback2.HasCharacter_Internal(character, true, tryAddCharacter)) {
                                return true;
                            }
                        }
                    }
                }

                return false;
            },
            /*TMPro.TMP_FontAsset.HasCharacter end.*/

            /*TMPro.TMP_FontAsset.HasCharacter_Internal start.*/
            /**
             * Function to check if a character is contained in a font asset with the option to also check through fallback font assets.
             This private implementation does not search the fallback font asset in the TMP Settings file.
             *
             * @instance
             * @private
             * @this TMPro.TMP_FontAsset
             * @memberof TMPro.TMP_FontAsset
             * @param   {number}     character          
             * @param   {boolean}    searchFallbacks    
             * @param   {boolean}    tryAddCharacter
             * @return  {boolean}
             */
            HasCharacter_Internal: function (character, searchFallbacks, tryAddCharacter) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#HasCharacter_Internal", this ); }

                if (searchFallbacks === void 0) { searchFallbacks = false; }
                if (tryAddCharacter === void 0) { tryAddCharacter = false; }
                // Read font asset definition if it hasn't already been done.
                if (this.m_CharacterLookupDictionary == null) {
                    this.ReadFontAssetDefinition();

                    if (this.m_CharacterLookupDictionary == null) {
                        return false;
                    }
                }

                // Check font asset
                if (this.m_CharacterLookupDictionary.containsKey(character)) {
                    return true;
                }

                // Check if fallback is dynamic and if so try to add the requested character to it.
                if (tryAddCharacter && this.atlasPopulationMode === TMPro.AtlasPopulationMode.Dynamic) {
                    var returnedCharacter = { };

                    if (this.TryAddCharacterInternal(character, returnedCharacter)) {
                        return true;
                    }
                }

                if (searchFallbacks) {
                    // Check Font Asset Fallback fonts.
                    if (this.fallbackFontAssetTable == null || this.fallbackFontAssetTable.Count === 0) {
                        return false;
                    }

                    for (var i = 0; i < this.fallbackFontAssetTable.Count && this.fallbackFontAssetTable.getItem(i) != null; i++) {
                        var fallback = this.fallbackFontAssetTable.getItem(i);
                        var fallbackID = fallback.GetInstanceID();

                        // Search fallback if it has not already been searched
                        if (TMPro.TMP_FontAsset.k_SearchedFontAssetLookup.add(fallbackID)) {
                            if (fallback.HasCharacter_Internal(character, true, tryAddCharacter)) {
                                return true;
                            }
                        }
                    }
                }

                return false;
            },
            /*TMPro.TMP_FontAsset.HasCharacter_Internal end.*/

            /*TMPro.TMP_FontAsset.HasCharacters$1 start.*/
            /**
             * Function to check if certain characters exists in the font asset. Function returns a list of missing characters.
             *
             * @instance
             * @public
             * @this TMPro.TMP_FontAsset
             * @memberof TMPro.TMP_FontAsset
             * @param   {string}                             text                 String containing the characters to check.
             * @param   {System.Collections.Generic.List}    missingCharacters    List of missing characters.
             * @return  {boolean}
             */
            HasCharacters$1: function (text, missingCharacters) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#HasCharacters$1", this ); }

                if (this.m_CharacterLookupDictionary == null) {
                    missingCharacters.v = null;
                    return false;
                }

                missingCharacters.v = new (System.Collections.Generic.List$1(System.Char)).ctor();

                for (var i = 0; i < text.length; i++) {
                    if (!this.m_CharacterLookupDictionary.containsKey(text.charCodeAt(i))) {
                        missingCharacters.v.add(text.charCodeAt(i));
                    }
                }

                if (missingCharacters.v.Count === 0) {
                    return true;
                }

                return false;
            },
            /*TMPro.TMP_FontAsset.HasCharacters$1 end.*/

            /*TMPro.TMP_FontAsset.HasCharacters$2 start.*/
            /**
             * Function to check if the characters in the given string are contained in the font asset with the option to also check its potential local fallbacks.
             *
             * @instance
             * @public
             * @this TMPro.TMP_FontAsset
             * @memberof TMPro.TMP_FontAsset
             * @param   {string}           text                 String containing the characters to check.
             * @param   {System.UInt32}    missingCharacters    Array containing the unicode values of the missing characters.
             * @param   {boolean}          searchFallbacks      Determines if fallback font assets assigned to this font asset should be searched.
             * @param   {boolean}          tryAddCharacter
             * @return  {boolean}
             */
            HasCharacters$2: function (text, missingCharacters, searchFallbacks, tryAddCharacter) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#HasCharacters$2", this ); }

                if (searchFallbacks === void 0) { searchFallbacks = false; }
                if (tryAddCharacter === void 0) { tryAddCharacter = false; }
                missingCharacters.v = null;

                // Read font asset definition if it hasn't already been done.
                if (this.m_CharacterLookupDictionary == null) {
                    this.ReadFontAssetDefinition();

                    if (this.m_CharacterLookupDictionary == null) {
                        return false;
                    }
                }

                // Clear internal list of
                this.s_MissingCharacterList.clear();

                for (var i = 0; i < text.length; i++) {
                    var isMissingCharacter = true;
                    var character = text.charCodeAt(i);

                    if (this.m_CharacterLookupDictionary.containsKey(character)) {
                        continue;
                    }

                    // Check if fallback is dynamic and if so try to add the requested character to it.
                    if (tryAddCharacter && this.atlasPopulationMode === TMPro.AtlasPopulationMode.Dynamic) {
                        var returnedCharacter = { };

                        if (this.TryAddCharacterInternal(character, returnedCharacter)) {
                            continue;
                        }
                    }

                    if (searchFallbacks) {
                        // Initialize or clear font asset lookup
                        if (TMPro.TMP_FontAsset.k_SearchedFontAssetLookup == null) {
                            TMPro.TMP_FontAsset.k_SearchedFontAssetLookup = new (System.Collections.Generic.HashSet$1(System.Int32)).ctor();
                        } else {
                            TMPro.TMP_FontAsset.k_SearchedFontAssetLookup.clear();
                        }

                        // Add current font asset to lookup
                        TMPro.TMP_FontAsset.k_SearchedFontAssetLookup.add(this.GetInstanceID());

                        // Check font asset fallbacks
                        if (this.fallbackFontAssetTable != null && this.fallbackFontAssetTable.Count > 0) {
                            for (var j = 0; j < this.fallbackFontAssetTable.Count && this.fallbackFontAssetTable.getItem(j) != null; j++) {
                                var fallback = this.fallbackFontAssetTable.getItem(j);
                                var fallbackID = fallback.GetInstanceID();

                                // Search fallback if it has not already been searched
                                if (TMPro.TMP_FontAsset.k_SearchedFontAssetLookup.add(fallbackID)) {
                                    if (fallback.HasCharacter_Internal(character, true, tryAddCharacter) === false) {
                                        continue;
                                    }

                                    isMissingCharacter = false;
                                    break;
                                }
                            }
                        }

                        // Check general fallback font assets.
                        if (isMissingCharacter && TMPro.TMP_Settings.fallbackFontAssets != null && TMPro.TMP_Settings.fallbackFontAssets.Count > 0) {
                            for (var j1 = 0; j1 < TMPro.TMP_Settings.fallbackFontAssets.Count && TMPro.TMP_Settings.fallbackFontAssets.getItem(j1) != null; j1++) {
                                var fallback1 = TMPro.TMP_Settings.fallbackFontAssets.getItem(j1);
                                var fallbackID1 = fallback1.GetInstanceID();

                                // Search fallback if it has not already been searched
                                if (TMPro.TMP_FontAsset.k_SearchedFontAssetLookup.add(fallbackID1)) {
                                    if (fallback1.HasCharacter_Internal(character, true, tryAddCharacter) === false) {
                                        continue;
                                    }

                                    isMissingCharacter = false;
                                    break;
                                }
                            }
                        }

                        // Check TMP Settings Default Font Asset
                        if (isMissingCharacter && TMPro.TMP_Settings.defaultFontAsset != null) {
                            var fallback2 = TMPro.TMP_Settings.defaultFontAsset;
                            var fallbackID2 = fallback2.GetInstanceID();

                            // Search fallback if it has not already been searched
                            if (TMPro.TMP_FontAsset.k_SearchedFontAssetLookup.add(fallbackID2)) {
                                if (fallback2.HasCharacter_Internal(character, true, tryAddCharacter)) {
                                    isMissingCharacter = false;
                                }
                            }
                        }
                    }

                    if (isMissingCharacter) {
                        this.s_MissingCharacterList.add(character);
                    }
                }

                if (this.s_MissingCharacterList.Count > 0) {
                    missingCharacters.v = this.s_MissingCharacterList.ToArray();
                    return false;
                }

                return true;
            },
            /*TMPro.TMP_FontAsset.HasCharacters$2 end.*/

            /*TMPro.TMP_FontAsset.HasCharacters start.*/
            /**
             * Function to check if certain characters exists in the font asset. Function returns false if any characters are missing.
             *
             * @instance
             * @public
             * @this TMPro.TMP_FontAsset
             * @memberof TMPro.TMP_FontAsset
             * @param   {string}     text    String containing the characters to check
             * @return  {boolean}
             */
            HasCharacters: function (text) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#HasCharacters", this ); }

                if (this.m_CharacterLookupDictionary == null) {
                    return false;
                }

                for (var i = 0; i < text.length; i++) {
                    if (!this.m_CharacterLookupDictionary.containsKey(text.charCodeAt(i))) {
                        return false;
                    }
                }

                return true;
            },
            /*TMPro.TMP_FontAsset.HasCharacters end.*/

            /*TMPro.TMP_FontAsset.GetGlyphIndex start.*/
            /**
             * Internal function used to get the glyph index for the given Unicode.
             *
             * @instance
             * @this TMPro.TMP_FontAsset
             * @memberof TMPro.TMP_FontAsset
             * @param   {number}    unicode
             * @return  {number}
             */
            GetGlyphIndex: function (unicode) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#GetGlyphIndex", this ); }

                // Check if glyph already exists in font asset.
                if (this.m_CharacterLookupDictionary.containsKey(unicode)) {
                    return this.m_CharacterLookupDictionary.getItem(unicode).glyphIndex;
                }

                // Load font face.
                if (UnityEngine.TextCore.LowLevel.FontEngine.LoadFontFace$5(this.sourceFontFile, this.m_FaceInfo.pointSize) !== UnityEngine.TextCore.LowLevel.FontEngineError.Success) {
                    return 0;
                }

                return UnityEngine.TextCore.LowLevel.FontEngine.GetGlyphIndex(unicode);
            },
            /*TMPro.TMP_FontAsset.GetGlyphIndex end.*/

            /*TMPro.TMP_FontAsset.TryAddCharacters$2 start.*/
            /**
             * Try adding the characters from the provided string to the font asset.
             *
             * @instance
             * @public
             * @this TMPro.TMP_FontAsset
             * @memberof TMPro.TMP_FontAsset
             * @param   {Array.<number>}    unicodes               Array that contains the characters to add to the font asset.
             * @param   {boolean}           includeFontFeatures
             * @return  {boolean}                                  Returns true if all the characters were successfully added to the font asset. Return false otherwise.
             */
            TryAddCharacters$2: function (unicodes, includeFontFeatures) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#TryAddCharacters$2", this ); }

                if (includeFontFeatures === void 0) { includeFontFeatures = false; }
                var missingUnicodes = { };

                return this.TryAddCharacters$3(unicodes, missingUnicodes, includeFontFeatures);
            },
            /*TMPro.TMP_FontAsset.TryAddCharacters$2 end.*/

            /*TMPro.TMP_FontAsset.TryAddCharacters$3 start.*/
            /**
             * Try adding the characters from the provided string to the font asset.
             *
             * @instance
             * @public
             * @this TMPro.TMP_FontAsset
             * @memberof TMPro.TMP_FontAsset
             * @param   {Array.<number>}    unicodes               Array that contains the characters to add to the font asset.
             * @param   {System.UInt32}     missingUnicodes        Array containing the characters that could not be added to the font asset.
             * @param   {boolean}           includeFontFeatures
             * @return  {boolean}                                  Returns true if all the characters were successfully added to the font asset. Return false otherwise.
             */
            TryAddCharacters$3: function (unicodes, missingUnicodes, includeFontFeatures) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#TryAddCharacters$3", this ); }

                var $t;
                if (includeFontFeatures === void 0) { includeFontFeatures = false; }
                // Make sure font asset is set to dynamic and that we have a valid list of characters.
                if (unicodes == null || unicodes.length === 0 || this.m_AtlasPopulationMode === TMPro.AtlasPopulationMode.Static) {
                    if (this.m_AtlasPopulationMode === TMPro.AtlasPopulationMode.Static) {
                        UnityEngine.Debug.LogWarning$1("Unable to add characters to font asset [" + (this.name || "") + "] because its AtlasPopulationMode is set to Static.", this);
                    } else {
                        UnityEngine.Debug.LogWarning$1("Unable to add characters to font asset [" + (this.name || "") + "] because the provided Unicode list is Null or Empty.", this);
                    }

                    missingUnicodes.v = null;
                    return false;
                }

                // Load font face.
                if (UnityEngine.TextCore.LowLevel.FontEngine.LoadFontFace$5(this.m_SourceFontFile, this.m_FaceInfo.pointSize) !== UnityEngine.TextCore.LowLevel.FontEngineError.Success) {
                    missingUnicodes.v = ($t = System.UInt32, System.Linq.Enumerable.from(unicodes, $t).ToArray($t));
                    return false;
                }

                // Make sure font asset has been initialized
                if (this.m_CharacterLookupDictionary == null || this.m_GlyphLookupDictionary == null) {
                    this.ReadFontAssetDefinition();
                }

                // Clear lists used to track which character and glyphs were added or missing.
                this.m_GlyphsToAdd.clear();
                this.m_GlyphsToAddLookup.clear();
                this.m_CharactersToAdd.clear();
                this.m_CharactersToAddLookup.clear();
                this.s_MissingCharacterList.clear();

                var isMissingCharacters = false;
                var unicodeCount = unicodes.length;

                for (var i = 0; i < unicodeCount; i++) {
                    var unicode = unicodes[i];

                    // Check if character is already contained in the character table.
                    if (this.m_CharacterLookupDictionary.containsKey(unicode)) {
                        continue;
                    }

                    // Get the index of the glyph for this Unicode value.
                    var glyphIndex = UnityEngine.TextCore.LowLevel.FontEngine.GetGlyphIndex(unicode);

                    // Skip missing glyphs
                    if (glyphIndex === 0) {
                        // Special handling for characters with potential alternative glyph representations
                        switch (unicode) {
                            case 160:  // Non Breaking Space <NBSP>
                                // Use Space
                                glyphIndex = UnityEngine.TextCore.LowLevel.FontEngine.GetGlyphIndex(32);
                                break;
                            case 173: 
                            case 8209:  // Soft Hyphen <SHY> // Non Breaking Hyphen
                                // Use Hyphen Minus
                                glyphIndex = UnityEngine.TextCore.LowLevel.FontEngine.GetGlyphIndex(45);
                                break;
                        }

                        // Skip to next character if no potential alternative glyph representation is present in font file.
                        if (glyphIndex === 0) {
                            // Add character to list of missing characters.
                            this.s_MissingCharacterList.add(unicode);

                            isMissingCharacters = true;
                            continue;
                        }
                    }

                    var character = new TMPro.TMP_Character.$ctor1(unicode, glyphIndex);

                    // Check if glyph is already contained in the font asset as the same glyph might be referenced by multiple characters.
                    if (this.m_GlyphLookupDictionary.containsKey(glyphIndex)) {
                        // Add a reference to the source text asset and glyph
                        character.glyph = this.m_GlyphLookupDictionary.getItem(glyphIndex);
                        character.textAsset = this;

                        this.m_CharacterTable.add(character);
                        this.m_CharacterLookupDictionary.add(unicode, character);
                        continue;
                    }

                    // Make sure glyph index has not already been added to list of glyphs to add.
                    if (this.m_GlyphsToAddLookup.add(glyphIndex)) {
                        this.m_GlyphsToAdd.add(glyphIndex);
                    }

                    // Make sure unicode / character has not already been added.
                    if (this.m_CharactersToAddLookup.add(unicode)) {
                        this.m_CharactersToAdd.add(character);
                    }
                }

                if (this.m_GlyphsToAdd.Count === 0) {
                    //Debug.LogWarning("No characters will be added to font asset [" + this.name + "] either because they are already present in the font asset or missing from the font file.");
                    missingUnicodes.v = unicodes;
                    return false;
                }

                // Resize the Atlas Texture to the appropriate size
                if (this.m_AtlasTextures[this.m_AtlasTextureIndex].width === 0 || this.m_AtlasTextures[this.m_AtlasTextureIndex].height === 0) {
                    this.m_AtlasTextures[this.m_AtlasTextureIndex].Resize(this.m_AtlasWidth, this.m_AtlasHeight);
                    UnityEngine.TextCore.LowLevel.FontEngine.ResetAtlasTexture(this.m_AtlasTextures[this.m_AtlasTextureIndex]);
                }

                var glyphs = { };
                var allGlyphsAddedToTexture = UnityEngine.TextCore.LowLevel.FontEngine.TryAddGlyphsToTexture(this.m_GlyphsToAdd, this.m_AtlasPadding, UnityEngine.TextCore.LowLevel.GlyphPackingMode.BestShortSideFit, this.m_FreeGlyphRects, this.m_UsedGlyphRects, this.m_AtlasRenderMode, this.m_AtlasTextures[this.m_AtlasTextureIndex], glyphs);

                // Add new glyphs to relevant font asset data structure
                for (var i1 = 0; i1 < glyphs.v.length && glyphs.v[i1] != null; i1++) {
                    var glyph = glyphs.v[i1];
                    var glyphIndex1 = glyph.index;

                    glyph.atlasIndex = this.m_AtlasTextureIndex;

                    // Add new glyph to glyph table.
                    this.m_GlyphTable.add(glyph);
                    this.m_GlyphLookupDictionary.add(glyphIndex1, glyph);

                    this.m_GlyphIndexListNewlyAdded.add(glyphIndex1);
                    this.m_GlyphIndexList.add(glyphIndex1);
                }

                // Clear glyph index list to allow
                this.m_GlyphsToAdd.clear();

                // Add new characters to relevant data structures as well as track glyphs that could not be added to the current atlas texture.
                for (var i2 = 0; i2 < this.m_CharactersToAdd.Count; i2++) {
                    var character1 = this.m_CharactersToAdd.getItem(i2);
                    var glyph1 = { };

                    if (this.m_GlyphLookupDictionary.tryGetValue(character1.glyphIndex, glyph1) === false) {
                        this.m_GlyphsToAdd.add(character1.glyphIndex);
                        continue;
                    }

                    // Add a reference to the source text asset and glyph
                    character1.glyph = glyph1.v;
                    character1.textAsset = this;

                    this.m_CharacterTable.add(character1);
                    this.m_CharacterLookupDictionary.add(character1.unicode, character1);

                    // Remove character from list to add
                    this.m_CharactersToAdd.removeAt(i2);
                    i2 -= 1;
                }

                // Try adding missing glyphs to
                if (this.m_IsMultiAtlasTexturesEnabled && allGlyphsAddedToTexture === false) {
                    while (allGlyphsAddedToTexture === false) {
                        allGlyphsAddedToTexture = this.TryAddGlyphsToNewAtlasTexture();
                    }
                }

                // Get Font Features for the given characters
                if (includeFontFeatures) {
                    this.UpdateGlyphAdjustmentRecords();
                }


                // Populate list of missing characters
                for (var i3 = 0; i3 < this.m_CharactersToAdd.Count; i3++) {
                    var character2 = this.m_CharactersToAdd.getItem(i3);
                    this.s_MissingCharacterList.add(character2.unicode);
                }

                missingUnicodes.v = null;

                if (this.s_MissingCharacterList.Count > 0) {
                    missingUnicodes.v = this.s_MissingCharacterList.ToArray();
                }

                return allGlyphsAddedToTexture && !isMissingCharacters;
            },
            /*TMPro.TMP_FontAsset.TryAddCharacters$3 end.*/

            /*TMPro.TMP_FontAsset.TryAddCharacters start.*/
            /**
             * Try adding the characters from the provided string to the font asset.
             *
             * @instance
             * @public
             * @this TMPro.TMP_FontAsset
             * @memberof TMPro.TMP_FontAsset
             * @param   {string}     characters             String containing the characters to add to the font asset.
             * @param   {boolean}    includeFontFeatures
             * @return  {boolean}                           Returns true if all the characters were successfully added to the font asset. Return false otherwise.
             */
            TryAddCharacters: function (characters, includeFontFeatures) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#TryAddCharacters", this ); }

                if (includeFontFeatures === void 0) { includeFontFeatures = false; }
                var missingCharacters = { };

                return this.TryAddCharacters$1(characters, missingCharacters, includeFontFeatures);
            },
            /*TMPro.TMP_FontAsset.TryAddCharacters end.*/

            /*TMPro.TMP_FontAsset.TryAddCharacters$1 start.*/
            /**
             * Try adding the characters from the provided string to the font asset.
             *
             * @instance
             * @public
             * @this TMPro.TMP_FontAsset
             * @memberof TMPro.TMP_FontAsset
             * @param   {string}           characters             String containing the characters to add to the font asset.
             * @param   {System.String}    missingCharacters      String containing the characters that could not be added to the font asset.
             * @param   {boolean}          includeFontFeatures
             * @return  {boolean}                                 Returns true if all the characters were successfully added to the font asset. Return false otherwise.
             */
            TryAddCharacters$1: function (characters, missingCharacters, includeFontFeatures) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#TryAddCharacters$1", this ); }

                if (includeFontFeatures === void 0) { includeFontFeatures = false; }
                // Make sure font asset is set to dynamic and that we have a valid list of characters.
                if (System.String.isNullOrEmpty(characters) || this.m_AtlasPopulationMode === TMPro.AtlasPopulationMode.Static) {
                    if (this.m_AtlasPopulationMode === TMPro.AtlasPopulationMode.Static) {
                        UnityEngine.Debug.LogWarning$1("Unable to add characters to font asset [" + (this.name || "") + "] because its AtlasPopulationMode is set to Static.", this);
                    } else {
                        UnityEngine.Debug.LogWarning$1("Unable to add characters to font asset [" + (this.name || "") + "] because the provided character list is Null or Empty.", this);
                    }

                    missingCharacters.v = characters;

                    return false;
                }

                // Load font face.
                if (UnityEngine.TextCore.LowLevel.FontEngine.LoadFontFace$5(this.m_SourceFontFile, this.m_FaceInfo.pointSize) !== UnityEngine.TextCore.LowLevel.FontEngineError.Success) {
                    missingCharacters.v = characters;

                    return false;
                }

                // Make sure font asset has been initialized
                if (this.m_CharacterLookupDictionary == null || this.m_GlyphLookupDictionary == null) {
                    this.ReadFontAssetDefinition();
                }

                // Clear data structures used to track which glyph needs to be added to atlas texture.
                this.m_GlyphsToAdd.clear();
                this.m_GlyphsToAddLookup.clear();
                this.m_CharactersToAdd.clear();
                this.m_CharactersToAddLookup.clear();
                this.s_MissingCharacterList.clear();

                var isMissingCharacters = false;
                var characterCount = characters.length;

                // Iterate over each of the requested characters.
                for (var i = 0; i < characterCount; i++) {
                    var unicode = characters.charCodeAt(i);

                    // Check if character is already contained in the character table.
                    if (this.m_CharacterLookupDictionary.containsKey(unicode)) {
                        continue;
                    }

                    // Get the index of the glyph for this unicode value.
                    var glyphIndex = UnityEngine.TextCore.LowLevel.FontEngine.GetGlyphIndex(unicode);

                    // Skip missing glyphs
                    if (glyphIndex === 0) {
                        // Special handling for characters with potential alternative glyph representations
                        switch (unicode) {
                            case 160:  // Non Breaking Space <NBSP>
                                // Use Space
                                glyphIndex = UnityEngine.TextCore.LowLevel.FontEngine.GetGlyphIndex(32);
                                break;
                            case 173: 
                            case 8209:  // Soft Hyphen <SHY> // Non Breaking Hyphen
                                // Use Hyphen Minus
                                glyphIndex = UnityEngine.TextCore.LowLevel.FontEngine.GetGlyphIndex(45);
                                break;
                        }

                        // Skip to next character if no potential alternative glyph representation is present in font file.
                        if (glyphIndex === 0) {
                            // Add character to list of missing characters.
                            this.s_MissingCharacterList.add(unicode);

                            isMissingCharacters = true;
                            continue;
                        }
                    }

                    var character = new TMPro.TMP_Character.$ctor1(unicode, glyphIndex);

                    // Check if glyph is already contained in the font asset as the same glyph might be referenced by multiple characters.
                    if (this.m_GlyphLookupDictionary.containsKey(glyphIndex)) {
                        // Add a reference to the source text asset and glyph
                        character.glyph = this.m_GlyphLookupDictionary.getItem(glyphIndex);
                        character.textAsset = this;

                        this.m_CharacterTable.add(character);
                        this.m_CharacterLookupDictionary.add(unicode, character);
                        continue;
                    }

                    // Make sure glyph index has not already been added to list of glyphs to add.
                    if (this.m_GlyphsToAddLookup.add(glyphIndex)) {
                        this.m_GlyphsToAdd.add(glyphIndex);
                    }

                    // Make sure unicode / character has not already been added.
                    if (this.m_CharactersToAddLookup.add(unicode)) {
                        this.m_CharactersToAdd.add(character);
                    }
                }

                if (this.m_GlyphsToAdd.Count === 0) {
                    missingCharacters.v = characters;
                    return false;
                }

                // Resize the Atlas Texture to the appropriate size
                if (this.m_AtlasTextures[this.m_AtlasTextureIndex].width === 0 || this.m_AtlasTextures[this.m_AtlasTextureIndex].height === 0) {
                    //Debug.Log("Setting initial size of atlas texture used by font asset [" + this.name + "].");
                    this.m_AtlasTextures[this.m_AtlasTextureIndex].Resize(this.m_AtlasWidth, this.m_AtlasHeight);
                    UnityEngine.TextCore.LowLevel.FontEngine.ResetAtlasTexture(this.m_AtlasTextures[this.m_AtlasTextureIndex]);
                }

                var glyphs = { };

                var allGlyphsAddedToTexture = UnityEngine.TextCore.LowLevel.FontEngine.TryAddGlyphsToTexture(this.m_GlyphsToAdd, this.m_AtlasPadding, UnityEngine.TextCore.LowLevel.GlyphPackingMode.BestShortSideFit, this.m_FreeGlyphRects, this.m_UsedGlyphRects, this.m_AtlasRenderMode, this.m_AtlasTextures[this.m_AtlasTextureIndex], glyphs);

                for (var i1 = 0; i1 < glyphs.v.length && glyphs.v[i1] != null; i1++) {
                    var glyph = glyphs.v[i1];
                    var glyphIndex1 = glyph.index;

                    glyph.atlasIndex = this.m_AtlasTextureIndex;

                    // Add new glyph to glyph table.
                    this.m_GlyphTable.add(glyph);
                    this.m_GlyphLookupDictionary.add(glyphIndex1, glyph);

                    this.m_GlyphIndexListNewlyAdded.add(glyphIndex1);
                    this.m_GlyphIndexList.add(glyphIndex1);
                }

                // Clear glyph index list to track glyphs that were not added to the atlas texture
                this.m_GlyphsToAdd.clear();

                // Add new characters to relevant data structures.
                for (var i2 = 0; i2 < this.m_CharactersToAdd.Count; i2++) {
                    var character1 = this.m_CharactersToAdd.getItem(i2);
                    var glyph1 = { };

                    if (this.m_GlyphLookupDictionary.tryGetValue(character1.glyphIndex, glyph1) === false) {
                        this.m_GlyphsToAdd.add(character1.glyphIndex);
                        continue;
                    }

                    // Add a reference to the source text asset and glyph
                    character1.glyph = glyph1.v;
                    character1.textAsset = this;

                    this.m_CharacterTable.add(character1);
                    this.m_CharacterLookupDictionary.add(character1.unicode, character1);

                    // Remove character from list to add
                    this.m_CharactersToAdd.removeAt(i2);
                    i2 -= 1;
                }

                // Try adding glyphs that didn't fit in the current atlas texture to new atlas texture
                if (this.m_IsMultiAtlasTexturesEnabled && allGlyphsAddedToTexture === false) {
                    while (allGlyphsAddedToTexture === false) {
                        allGlyphsAddedToTexture = this.TryAddGlyphsToNewAtlasTexture();
                    }
                }

                // Get Font Features for the given characters
                if (includeFontFeatures) {
                    this.UpdateGlyphAdjustmentRecords();
                }


                missingCharacters.v = "";

                // Populate list of missing characters
                for (var i3 = 0; i3 < this.m_CharactersToAdd.Count; i3++) {
                    var character2 = this.m_CharactersToAdd.getItem(i3);
                    this.s_MissingCharacterList.add(character2.unicode);
                }

                if (this.s_MissingCharacterList.Count > 0) {
                    missingCharacters.v = TMPro.TMPro_ExtensionMethods.UintToString(this.s_MissingCharacterList);
                }

                return allGlyphsAddedToTexture && !isMissingCharacters;
            },
            /*TMPro.TMP_FontAsset.TryAddCharacters$1 end.*/

            /*TMPro.TMP_FontAsset.TryAddCharacterInternal start.*/
            /**
             * Try adding character using Unicode value to font asset.
             Function assumes internal user has already checked to make sure the character is not already contained in the font asset.
             *
             * @instance
             * @this TMPro.TMP_FontAsset
             * @memberof TMPro.TMP_FontAsset
             * @param   {number}                 unicode      The Unicode value of the character.
             * @param   {TMPro.TMP_Character}    character    The character data if successfully added to the font asset. Null otherwise.
             * @return  {boolean}                             Returns true if the character has been added. False otherwise.
             */
            TryAddCharacterInternal: function (unicode, character) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#TryAddCharacterInternal", this ); }

                character.v = null;

                // Check if the Unicode character is already known to be missing from the source font file.
                if (this.m_MissingUnicodesFromFontFile.contains(unicode)) {
                    return false;
                }

                // Load font face.
                if (UnityEngine.TextCore.LowLevel.FontEngine.LoadFontFace$5(this.sourceFontFile, this.m_FaceInfo.pointSize) !== UnityEngine.TextCore.LowLevel.FontEngineError.Success) {
                    return false;
                }

                var glyphIndex = UnityEngine.TextCore.LowLevel.FontEngine.GetGlyphIndex(unicode);
                if (glyphIndex === 0) {
                    // Special handling for characters with potential alternative glyph representations
                    switch (unicode) {
                        case 160:  // Non Breaking Space <NBSP>
                            // Use Space
                            glyphIndex = UnityEngine.TextCore.LowLevel.FontEngine.GetGlyphIndex(32);
                            break;
                        case 173: 
                        case 8209:  // Soft Hyphen <SHY> // Non Breaking Hyphen
                            // Use Hyphen Minus
                            glyphIndex = UnityEngine.TextCore.LowLevel.FontEngine.GetGlyphIndex(45);
                            break;
                    }

                    // Return if no potential alternative glyph representation is present in font file.
                    if (glyphIndex === 0) {
                        this.m_MissingUnicodesFromFontFile.add(unicode);
                        return false;
                    }
                }

                // Check if glyph is already contained in the font asset as the same glyph might be referenced by multiple characters.
                if (this.m_GlyphLookupDictionary.containsKey(glyphIndex)) {
                    character.v = new TMPro.TMP_Character.$ctor2(unicode, this, this.m_GlyphLookupDictionary.getItem(glyphIndex));
                    this.m_CharacterTable.add(character.v);
                    this.m_CharacterLookupDictionary.add(unicode, character.v);


                    return true;
                }

                var glyph = { v : null };

                // TODO: Potential new feature to explore where selected font assets share the same atlas texture(s).
                // Handling if using Dynamic Textures
                //if (m_IsUsingDynamicTextures)
                //{
                //    if (TMP_DynamicAtlasTextureGroup.AddGlyphToManagedDynamicTexture(this, glyphIndex, m_AtlasPadding, m_AtlasRenderMode, out glyph))
                //    {
                //        // Add new glyph to glyph table.
                //        m_GlyphTable.Add(glyph);
                //        m_GlyphLookupDictionary.Add(glyphIndex, glyph);

                //        // Add new character
                //        character = new TMP_Character(unicode, glyph);
                //        m_CharacterTable.Add(character);
                //        m_CharacterLookupDictionary.Add(unicode, character);

                //        m_GlyphIndexList.Add(glyphIndex);

                //        if (TMP_Settings.getFontFeaturesAtRuntime)
                //        {
                //            if (k_FontAssetsToUpdateLookup.Add(instanceID))
                //                k_FontAssetsToUpdate.Add(this);
                //        }

                //        return true;
                //    }
                //}

                // Make sure atlas texture is readable.

                // Resize the Atlas Texture to the appropriate size
                if (this.m_AtlasTextures[this.m_AtlasTextureIndex].width === 0 || this.m_AtlasTextures[this.m_AtlasTextureIndex].height === 0) {
                    this.m_AtlasTextures[this.m_AtlasTextureIndex].Resize(this.m_AtlasWidth, this.m_AtlasHeight);
                    UnityEngine.TextCore.LowLevel.FontEngine.ResetAtlasTexture(this.m_AtlasTextures[this.m_AtlasTextureIndex]);
                }

                // Try adding glyph to local atlas texture
                if (UnityEngine.TextCore.LowLevel.FontEngine.TryAddGlyphToTexture(glyphIndex, this.m_AtlasPadding, UnityEngine.TextCore.LowLevel.GlyphPackingMode.BestShortSideFit, this.m_FreeGlyphRects, this.m_UsedGlyphRects, this.m_AtlasRenderMode, this.m_AtlasTextures[this.m_AtlasTextureIndex], glyph)) {
                    // Update glyph atlas index
                    glyph.v.atlasIndex = this.m_AtlasTextureIndex;

                    // Add new glyph to glyph table.
                    this.m_GlyphTable.add(glyph.v);
                    this.m_GlyphLookupDictionary.add(glyphIndex, glyph.v);

                    // Add new character
                    character.v = new TMPro.TMP_Character.$ctor2(unicode, this, glyph.v);
                    this.m_CharacterTable.add(character.v);
                    this.m_CharacterLookupDictionary.add(unicode, character.v);

                    this.m_GlyphIndexList.add(glyphIndex);
                    this.m_GlyphIndexListNewlyAdded.add(glyphIndex);

                    if (TMPro.TMP_Settings.getFontFeaturesAtRuntime) {
                        TMPro.TMP_FontAsset.RegisterFontAssetForFontFeatureUpdate(this);
                    }


                    return true;
                }

                // Add glyph which did not fit in current atlas texture to new atlas texture.
                if (this.m_IsMultiAtlasTexturesEnabled) {
                    // Create new atlas texture
                    this.SetupNewAtlasTexture();

                    // Try adding glyph to newly created atlas texture
                    if (UnityEngine.TextCore.LowLevel.FontEngine.TryAddGlyphToTexture(glyphIndex, this.m_AtlasPadding, UnityEngine.TextCore.LowLevel.GlyphPackingMode.BestShortSideFit, this.m_FreeGlyphRects, this.m_UsedGlyphRects, this.m_AtlasRenderMode, this.m_AtlasTextures[this.m_AtlasTextureIndex], glyph)) {
                        // Update glyph atlas index
                        glyph.v.atlasIndex = this.m_AtlasTextureIndex;

                        // Add new glyph to glyph table.
                        this.m_GlyphTable.add(glyph.v);
                        this.m_GlyphLookupDictionary.add(glyphIndex, glyph.v);

                        // Add new character
                        character.v = new TMPro.TMP_Character.$ctor2(unicode, this, glyph.v);
                        this.m_CharacterTable.add(character.v);
                        this.m_CharacterLookupDictionary.add(unicode, character.v);

                        this.m_GlyphIndexList.add(glyphIndex);
                        this.m_GlyphIndexListNewlyAdded.add(glyphIndex);

                        if (TMPro.TMP_Settings.getFontFeaturesAtRuntime) {
                            TMPro.TMP_FontAsset.RegisterFontAssetForFontFeatureUpdate(this);
                        }


                        return true;
                    }
                }

                return false;
            },
            /*TMPro.TMP_FontAsset.TryAddCharacterInternal end.*/

            /*TMPro.TMP_FontAsset.TryGetCharacter_and_QueueRenderToTexture start.*/
            TryGetCharacter_and_QueueRenderToTexture: function (unicode, character) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#TryGetCharacter_and_QueueRenderToTexture", this ); }

                character.v = null;

                // Check if the Unicode character is already known to be missing from the source font file.
                if (this.m_MissingUnicodesFromFontFile.contains(unicode)) {
                    return false;
                }

                // Load font face.
                if (UnityEngine.TextCore.LowLevel.FontEngine.LoadFontFace$5(this.sourceFontFile, this.m_FaceInfo.pointSize) !== UnityEngine.TextCore.LowLevel.FontEngineError.Success) {
                    return false;
                }

                var glyphIndex = UnityEngine.TextCore.LowLevel.FontEngine.GetGlyphIndex(unicode);
                if (glyphIndex === 0) {
                    // Special handling for characters with potential alternative glyph representations
                    switch (unicode) {
                        case 160:  // Non Breaking Space <NBSP>
                            // Use Space
                            glyphIndex = UnityEngine.TextCore.LowLevel.FontEngine.GetGlyphIndex(32);
                            break;
                        case 173: 
                        case 8209:  // Soft Hyphen <SHY> // Non Breaking Hyphen
                            // Use Hyphen Minus
                            glyphIndex = UnityEngine.TextCore.LowLevel.FontEngine.GetGlyphIndex(45);
                            break;
                    }

                    // Return if no potential alternative glyph representation is present in font file.
                    if (glyphIndex === 0) {
                        this.m_MissingUnicodesFromFontFile.add(unicode);

                        return false;
                    }
                }

                // Check if glyph is already contained in the font asset as the same glyph might be referenced by multiple characters.
                if (this.m_GlyphLookupDictionary.containsKey(glyphIndex)) {
                    character.v = new TMPro.TMP_Character.$ctor2(unicode, this, this.m_GlyphLookupDictionary.getItem(glyphIndex));
                    this.m_CharacterTable.add(character.v);
                    this.m_CharacterLookupDictionary.add(unicode, character.v);


                    return true;
                }

                var glyphLoadFlags = (UnityEngine.TextCore.LowLevel.GlyphRasterModes.RASTER_MODE_NO_HINTING & this.m_AtlasRenderMode) === UnityEngine.TextCore.LowLevel.GlyphRasterModes.RASTER_MODE_NO_HINTING ? 10 : UnityEngine.TextCore.LowLevel.GlyphLoadFlags.LOAD_NO_BITMAP;

                var glyph = { v : null };

                if (UnityEngine.TextCore.LowLevel.FontEngine.TryGetGlyphWithIndexValue(glyphIndex, glyphLoadFlags, glyph)) {
                    // Add new glyph to glyph table.
                    this.m_GlyphTable.add(glyph.v);
                    this.m_GlyphLookupDictionary.add(glyphIndex, glyph.v);

                    // Add new character
                    character.v = new TMPro.TMP_Character.$ctor2(unicode, this, glyph.v);
                    this.m_CharacterTable.add(character.v);
                    this.m_CharacterLookupDictionary.add(unicode, character.v);

                    this.m_GlyphIndexList.add(glyphIndex);
                    this.m_GlyphIndexListNewlyAdded.add(glyphIndex);

                    if (TMPro.TMP_Settings.getFontFeaturesAtRuntime) {
                        TMPro.TMP_FontAsset.RegisterFontAssetForFontFeatureUpdate(this);
                    }

                    // Add glyph to list of glyphs to be rendered
                    this.m_GlyphsToRender.add(glyph.v);

                    // Register font asset to render and add glyphs to atlas textures
                    TMPro.TMP_FontAsset.RegisterFontAssetForAtlasTextureUpdate(this);


                    return true;
                }

                return false;
            },
            /*TMPro.TMP_FontAsset.TryGetCharacter_and_QueueRenderToTexture end.*/

            /*TMPro.TMP_FontAsset.TryAddGlyphsToAtlasTextures start.*/
            /**
             * This function requires an update to the TextCore:FontEngine
             *
             * @instance
             * @this TMPro.TMP_FontAsset
             * @memberof TMPro.TMP_FontAsset
             * @return  {void}
             */
            TryAddGlyphsToAtlasTextures: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#TryAddGlyphsToAtlasTextures", this ); }

                /* 
                // Return if we don't have any glyphs to add.
                if (m_GlyphsToRender.Count == 0)
                   return;

                // Resize the Atlas Texture to the appropriate size
                if (m_AtlasTextures[m_AtlasTextureIndex].width == 0 || m_AtlasTextures[m_AtlasTextureIndex].height == 0)
                {
                   //Debug.Log("Setting initial size of atlas texture used by font asset [" + this.name + "].");
                   m_AtlasTextures[m_AtlasTextureIndex].Resize(m_AtlasWidth, m_AtlasHeight);
                   FontEngine.ResetAtlasTexture(m_AtlasTextures[m_AtlasTextureIndex]);
                }

                bool allGlyphsAddedToTexture = FontEngine.TryAddGlyphsToTexture(m_GlyphsToRender, m_GlyphsRendered, m_AtlasPadding, GlyphPackingMode.BestShortSideFit, m_FreeGlyphRects, m_UsedGlyphRects, m_AtlasRenderMode, m_AtlasTextures[m_AtlasTextureIndex]);

                // Try adding glyphs that didn't fit in the current atlas texture to new atlas texture
                if (m_IsMultiAtlasTexturesEnabled && allGlyphsAddedToTexture == false)
                {
                   while (allGlyphsAddedToTexture == false)
                   {
                       // Create and prepare new atlas texture
                       SetupNewAtlasTexture();

                       // Try adding remaining glyphs in the newly created atlas texture
                       allGlyphsAddedToTexture = FontEngine.TryAddGlyphsToTexture(m_GlyphsToRender, m_GlyphsRendered, m_AtlasPadding, GlyphPackingMode.BestShortSideFit, m_FreeGlyphRects, m_UsedGlyphRects, m_AtlasRenderMode, m_AtlasTextures[m_AtlasTextureIndex]);
                   }
                }

                if (allGlyphsAddedToTexture == false)
                {
                   // TODO: Handle case when we have left over glyph to render that didn't fit in the atlas texture.
                   Debug.LogError("Unable to add some glyphs to atlas texture.");
                }

                #if UNITY_EDITOR
                // Makes the changes to the font asset persistent.
                if (UnityEditor.EditorUtility.IsPersistent(this))
                {
                   //SortGlyphAndCharacterTables();
                   TMP_EditorResourceManager.RegisterResourceForUpdate(this);
                }
                #endif
                */
            },
            /*TMPro.TMP_FontAsset.TryAddGlyphsToAtlasTextures end.*/

            /*TMPro.TMP_FontAsset.TryAddGlyphsToNewAtlasTexture start.*/
            /**
             * @instance
             * @private
             * @this TMPro.TMP_FontAsset
             * @memberof TMPro.TMP_FontAsset
             * @return  {boolean}
             */
            TryAddGlyphsToNewAtlasTexture: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#TryAddGlyphsToNewAtlasTexture", this ); }

                // Create and prepare new atlas texture
                this.SetupNewAtlasTexture();

                var glyphs = { };

                // Try adding remaining glyphs in the newly created atlas texture
                var allGlyphsAddedToTexture = UnityEngine.TextCore.LowLevel.FontEngine.TryAddGlyphsToTexture(this.m_GlyphsToAdd, this.m_AtlasPadding, UnityEngine.TextCore.LowLevel.GlyphPackingMode.BestShortSideFit, this.m_FreeGlyphRects, this.m_UsedGlyphRects, this.m_AtlasRenderMode, this.m_AtlasTextures[this.m_AtlasTextureIndex], glyphs);

                // Add new glyphs to relevant data structures.
                for (var i = 0; i < glyphs.v.length && glyphs.v[i] != null; i++) {
                    var glyph = glyphs.v[i];
                    var glyphIndex = glyph.index;

                    glyph.atlasIndex = this.m_AtlasTextureIndex;

                    // Add new glyph to glyph table.
                    this.m_GlyphTable.add(glyph);
                    this.m_GlyphLookupDictionary.add(glyphIndex, glyph);

                    this.m_GlyphIndexListNewlyAdded.add(glyphIndex);
                    this.m_GlyphIndexList.add(glyphIndex);
                }

                // Clear glyph index list to allow us to track glyphs
                this.m_GlyphsToAdd.clear();

                // Add new characters to relevant data structures as well as track glyphs that could not be added to the current atlas texture.
                for (var i1 = 0; i1 < this.m_CharactersToAdd.Count; i1++) {
                    var character = this.m_CharactersToAdd.getItem(i1);
                    var glyph1 = { };

                    if (this.m_GlyphLookupDictionary.tryGetValue(character.glyphIndex, glyph1) === false) {
                        this.m_GlyphsToAdd.add(character.glyphIndex);
                        continue;
                    }

                    // Add a reference to the source text asset and glyph
                    character.glyph = glyph1.v;
                    character.textAsset = this;

                    this.m_CharacterTable.add(character);
                    this.m_CharacterLookupDictionary.add(character.unicode, character);

                    // Remove character
                    this.m_CharactersToAdd.removeAt(i1);
                    i1 -= 1;
                }

                return allGlyphsAddedToTexture;
            },
            /*TMPro.TMP_FontAsset.TryAddGlyphsToNewAtlasTexture end.*/

            /*TMPro.TMP_FontAsset.SetupNewAtlasTexture start.*/
            /**
             * @instance
             * @private
             * @this TMPro.TMP_FontAsset
             * @memberof TMPro.TMP_FontAsset
             * @return  {void}
             */
            SetupNewAtlasTexture: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#SetupNewAtlasTexture", this ); }

                this.m_AtlasTextureIndex += 1;

                // Check size of atlas texture array
                if (this.m_AtlasTextures.length === this.m_AtlasTextureIndex) {
                    System.Array.resize(Bridge.ref(this, "m_AtlasTextures"), this.m_AtlasTextures.length * 2, null, UnityEngine.Texture2D);
                }

                // Initialize new atlas texture
                this.m_AtlasTextures[this.m_AtlasTextureIndex] = new UnityEngine.Texture2D.$ctor2(this.m_AtlasWidth, this.m_AtlasHeight, UnityEngine.TextureFormat.Alpha8, false);
                UnityEngine.TextCore.LowLevel.FontEngine.ResetAtlasTexture(this.m_AtlasTextures[this.m_AtlasTextureIndex]);

                // Clear packing GlyphRects
                var packingModifier = (this.m_AtlasRenderMode & UnityEngine.TextCore.LowLevel.GlyphRasterModes.RASTER_MODE_BITMAP) === UnityEngine.TextCore.LowLevel.GlyphRasterModes.RASTER_MODE_BITMAP ? 0 : 1;
                this.m_FreeGlyphRects.clear();
                this.m_FreeGlyphRects.add(new UnityEngine.TextCore.GlyphRect.$ctor1(0, 0, this.m_AtlasWidth - packingModifier, this.m_AtlasHeight - packingModifier));
                this.m_UsedGlyphRects.clear();

            },
            /*TMPro.TMP_FontAsset.SetupNewAtlasTexture end.*/

            /*TMPro.TMP_FontAsset.UpdateAtlasTexture start.*/
            /**
             * Not used currently
             *
             * @instance
             * @this TMPro.TMP_FontAsset
             * @memberof TMPro.TMP_FontAsset
             * @return  {void}
             */
            UpdateAtlasTexture: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#UpdateAtlasTexture", this ); }

                // Return if we don't have any glyphs to add to atlas texture.
                if (this.m_GlyphsToRender.Count === 0) {
                    return;
                }

                //Debug.Log("Updating [" + this.name + "]'s atlas texture.");

                // Pack glyphs in the given atlas texture size.
                // TODO: Packing and glyph render modes should be defined in the font asset.
                //FontEngine.PackGlyphsInAtlas(m_GlyphsToPack, m_GlyphsPacked, m_AtlasPadding, GlyphPackingMode.ContactPointRule, GlyphRenderMode.SDFAA, m_AtlasWidth, m_AtlasHeight, m_FreeGlyphRects, m_UsedGlyphRects);
                //FontEngine.RenderGlyphsToTexture(m_GlyphsPacked, m_AtlasPadding, GlyphRenderMode.SDFAA, m_AtlasTextures[m_AtlasTextureIndex]);

                // Resize the Atlas Texture to the appropriate size
                if (this.m_AtlasTextures[this.m_AtlasTextureIndex].width === 0 || this.m_AtlasTextures[this.m_AtlasTextureIndex].height === 0) {
                    //Debug.Log("Setting initial size of atlas texture used by font asset [" + this.name + "].");
                    this.m_AtlasTextures[this.m_AtlasTextureIndex].Resize(this.m_AtlasWidth, this.m_AtlasHeight);
                    UnityEngine.TextCore.LowLevel.FontEngine.ResetAtlasTexture(this.m_AtlasTextures[this.m_AtlasTextureIndex]);
                }

                //FontEngine.RenderGlyphsToTexture(m_GlyphsToRender, m_AtlasPadding, m_AtlasRenderMode, m_AtlasTextures[m_AtlasTextureIndex]);

                // Apply changes to atlas texture
                this.m_AtlasTextures[this.m_AtlasTextureIndex].Apply$1(false, false);

                // Add glyphs that were successfully packed to the glyph table.
                //for (int i = 0; i < m_GlyphsToRender.Count /* m_GlyphsPacked.Count */; i++)
                //{
                //    Glyph glyph = m_GlyphsToRender[i]; // m_GlyphsPacked[i];

                //    // Update atlas texture index
                //    glyph.atlasIndex = m_AtlasTextureIndex;

                //    m_GlyphTable.Add(glyph);
                //    m_GlyphLookupDictionary.Add(glyph.index, glyph);
                //}

                // Clear list of glyphs
                //m_GlyphsPacked.Clear();
                //m_GlyphsToRender.Clear();

                // Add any remaining glyphs into new atlas texture if multi texture support if enabled.
                //if (m_GlyphsToPack.Count > 0)
                //{
                /* 
                // Create new atlas texture
                Texture2D tex = new Texture2D(m_AtlasWidth, m_AtlasHeight, TextureFormat.Alpha8, false, true);
                tex.SetPixels32(new Color32[m_AtlasWidth * m_AtlasHeight]);
                tex.Apply();

                m_AtlasTextureIndex++;

                if (m_AtlasTextures.Length == m_AtlasTextureIndex)
                   Array.Resize(ref m_AtlasTextures, Mathf.NextPowerOfTwo(m_AtlasTextureIndex + 1));

                m_AtlasTextures[m_AtlasTextureIndex] = tex;
                */
                //}

            },
            /*TMPro.TMP_FontAsset.UpdateAtlasTexture end.*/

            /*TMPro.TMP_FontAsset.UpdateGlyphAdjustmentRecords start.*/
            /**
             * @instance
             * @this TMPro.TMP_FontAsset
             * @memberof TMPro.TMP_FontAsset
             * @return  {void}
             */
            UpdateGlyphAdjustmentRecords: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#UpdateGlyphAdjustmentRecords", this ); }

                var recordCount = { };
                // Get glyph pair adjustment records from font file.
                //GlyphPairAdjustmentRecord[] pairAdjustmentRecords = FontEngine.GetGlyphPairAdjustmentRecords(m_GlyphIndexListNewlyAdded, m_GlyphIndexList);
                var pairAdjustmentRecords = UnityEngine.TextCore.LowLevel.FontEngine.GetGlyphPairAdjustmentRecords(this.m_GlyphIndexList, recordCount);

                // Clear newly added glyph list
                this.m_GlyphIndexListNewlyAdded.clear();

                if (pairAdjustmentRecords == null || pairAdjustmentRecords.length === 0) {
                    return;
                }

                if (this.m_FontFeatureTable == null) {
                    this.m_FontFeatureTable = new TMPro.TMP_FontFeatureTable();
                }

                for (var i = 0; i < pairAdjustmentRecords.length && pairAdjustmentRecords[i].firstAdjustmentRecord.glyphIndex !== 0; i++) {
                    var pairKey = (pairAdjustmentRecords[i].secondAdjustmentRecord.glyphIndex << 16) | pairAdjustmentRecords[i].firstAdjustmentRecord.glyphIndex;

                    // Check if table already contains a pair adjustment record for this key.
                    if (this.m_FontFeatureTable.m_GlyphPairAdjustmentRecordLookupDictionary.containsKey(pairKey)) {
                        continue;
                    }

                    var record = new TMPro.TMP_GlyphPairAdjustmentRecord.$ctor1(pairAdjustmentRecords[i].$clone());

                    this.m_FontFeatureTable.m_GlyphPairAdjustmentRecords.add(record);
                    this.m_FontFeatureTable.m_GlyphPairAdjustmentRecordLookupDictionary.add(pairKey, record);
                }
            },
            /*TMPro.TMP_FontAsset.UpdateGlyphAdjustmentRecords end.*/

            /*TMPro.TMP_FontAsset.UpdateGlyphAdjustmentRecords$3 start.*/
            /**
             * Function used for debugging and performance testing.
             *
             * @instance
             * @this TMPro.TMP_FontAsset
             * @memberof TMPro.TMP_FontAsset
             * @param   {Array.<number>}    glyphIndexes
             * @return  {void}
             */
            UpdateGlyphAdjustmentRecords$3: function (glyphIndexes) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#UpdateGlyphAdjustmentRecords$3", this ); }

                // Get glyph pair adjustment records from font file.
                var pairAdjustmentRecords = UnityEngine.TextCore.LowLevel.FontEngine.GetGlyphPairAdjustmentTable(glyphIndexes);

                // Clear newly added glyph list
                //m_GlyphIndexListNewlyAdded.Clear();

                if (pairAdjustmentRecords == null || pairAdjustmentRecords.length === 0) {
                    return;
                }

                if (this.m_FontFeatureTable == null) {
                    this.m_FontFeatureTable = new TMPro.TMP_FontFeatureTable();
                }

                for (var i = 0; i < pairAdjustmentRecords.length && pairAdjustmentRecords[i].firstAdjustmentRecord.glyphIndex !== 0; i++) {
                    var pairKey = (pairAdjustmentRecords[i].secondAdjustmentRecord.glyphIndex << 16) | pairAdjustmentRecords[i].firstAdjustmentRecord.glyphIndex;

                    // Check if table already contains a pair adjustment record for this key.
                    if (this.m_FontFeatureTable.m_GlyphPairAdjustmentRecordLookupDictionary.containsKey(pairKey)) {
                        continue;
                    }

                    var record = new TMPro.TMP_GlyphPairAdjustmentRecord.$ctor1(pairAdjustmentRecords[i].$clone());

                    this.m_FontFeatureTable.m_GlyphPairAdjustmentRecords.add(record);
                    this.m_FontFeatureTable.m_GlyphPairAdjustmentRecordLookupDictionary.add(pairKey, record);
                }
            },
            /*TMPro.TMP_FontAsset.UpdateGlyphAdjustmentRecords$3 end.*/

            /*TMPro.TMP_FontAsset.UpdateGlyphAdjustmentRecords$1 start.*/
            /**
             * Function requires an update to the TextCore:FontEngine
             *
             * @instance
             * @this TMPro.TMP_FontAsset
             * @memberof TMPro.TMP_FontAsset
             * @param   {System.Collections.Generic.List$1}    glyphIndexes
             * @return  {void}
             */
            UpdateGlyphAdjustmentRecords$1: function (glyphIndexes) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#UpdateGlyphAdjustmentRecords$1", this ); }

                /* 
                k_UpdateGlyphAdjustmentRecordsMarker.Begin();

                // Get glyph pair adjustment records from font file.
                int recordCount;
                GlyphPairAdjustmentRecord[] pairAdjustmentRecords = FontEngine.GetGlyphPairAdjustmentRecords(glyphIndexes, out recordCount);

                // Clear newly added glyph list
                m_GlyphIndexListNewlyAdded.Clear();

                if (pairAdjustmentRecords == null || pairAdjustmentRecords.Length == 0)
                {
                   k_UpdateGlyphAdjustmentRecordsMarker.End();
                   return;
                }

                if (m_FontFeatureTable == null)
                   m_FontFeatureTable = new TMP_FontFeatureTable();

                for (int i = 0; i < pairAdjustmentRecords.Length && pairAdjustmentRecords[i].firstAdjustmentRecord.glyphIndex != 0; i++)
                {
                   uint pairKey = pairAdjustmentRecords[i].secondAdjustmentRecord.glyphIndex << 16 | pairAdjustmentRecords[i].firstAdjustmentRecord.glyphIndex;

                   // Check if table already contains a pair adjustment record for this key.
                   if (m_FontFeatureTable.m_GlyphPairAdjustmentRecordLookupDictionary.ContainsKey(pairKey))
                       continue;

                   TMP_GlyphPairAdjustmentRecord record = new TMP_GlyphPairAdjustmentRecord(pairAdjustmentRecords[i]);

                   m_FontFeatureTable.m_GlyphPairAdjustmentRecords.Add(record);
                   m_FontFeatureTable.m_GlyphPairAdjustmentRecordLookupDictionary.Add(pairKey, record);
                }

                k_UpdateGlyphAdjustmentRecordsMarker.End();

                #if UNITY_EDITOR
                m_FontFeatureTable.SortGlyphPairAdjustmentRecords();
                #endif
                */
            },
            /*TMPro.TMP_FontAsset.UpdateGlyphAdjustmentRecords$1 end.*/

            /*TMPro.TMP_FontAsset.UpdateGlyphAdjustmentRecords$2 start.*/
            /**
             * Function requires an update to the TextCore:FontEngine
             *
             * @instance
             * @this TMPro.TMP_FontAsset
             * @memberof TMPro.TMP_FontAsset
             * @param   {System.Collections.Generic.List$1}    newGlyphIndexes    
             * @param   {System.Collections.Generic.List$1}    allGlyphIndexes
             * @return  {void}
             */
            UpdateGlyphAdjustmentRecords$2: function (newGlyphIndexes, allGlyphIndexes) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#UpdateGlyphAdjustmentRecords$2", this ); }

                /* 
                // Get glyph pair adjustment records from font file.
                GlyphPairAdjustmentRecord[] pairAdjustmentRecords = FontEngine.GetGlyphPairAdjustmentRecords(newGlyphIndexes, allGlyphIndexes);

                // Clear newly added glyph list
                m_GlyphIndexListNewlyAdded.Clear();

                if (pairAdjustmentRecords == null || pairAdjustmentRecords.Length == 0)
                {
                   return;
                }

                if (m_FontFeatureTable == null)
                   m_FontFeatureTable = new TMP_FontFeatureTable();

                for (int i = 0; i < pairAdjustmentRecords.Length && pairAdjustmentRecords[i].firstAdjustmentRecord.glyphIndex != 0; i++)
                {
                   uint pairKey = pairAdjustmentRecords[i].secondAdjustmentRecord.glyphIndex << 16 | pairAdjustmentRecords[i].firstAdjustmentRecord.glyphIndex;

                   // Check if table already contains a pair adjustment record for this key.
                   if (m_FontFeatureTable.m_GlyphPairAdjustmentRecordLookupDictionary.ContainsKey(pairKey))
                       continue;

                   TMP_GlyphPairAdjustmentRecord record = new TMP_GlyphPairAdjustmentRecord(pairAdjustmentRecords[i]);

                   m_FontFeatureTable.m_GlyphPairAdjustmentRecords.Add(record);
                   m_FontFeatureTable.m_GlyphPairAdjustmentRecordLookupDictionary.Add(pairKey, record);
                }

                #if UNITY_EDITOR
                m_FontFeatureTable.SortGlyphPairAdjustmentRecords();
                #endif
                */
            },
            /*TMPro.TMP_FontAsset.UpdateGlyphAdjustmentRecords$2 end.*/

            /*TMPro.TMP_FontAsset.CopyListDataToArray start.*/
            /**
             * Internal method to copy generic list data to generic array of the same type.
             *
             * @instance
             * @private
             * @this TMPro.TMP_FontAsset
             * @memberof TMPro.TMP_FontAsset
             * @param   {Function}                             T           Element type
             * @param   {System.Collections.Generic.List$1}    srcList     Source
             * @param   {T}                                    dstArray    Destination
             * @return  {void}
             */
            CopyListDataToArray: function (T, srcList, dstArray) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#CopyListDataToArray", this ); }

                var size = srcList.Count;

                // Make sure destination array is appropriately sized.
                if (dstArray.v == null) {
                    dstArray.v = System.Array.init(size, function (){
                        return Bridge.getDefaultValue(T);
                    }, T);
                } else {
                    System.Array.resize(dstArray, size, function () {
                        return Bridge.getDefaultValue(T);
                    }, T);
                }

                for (var i = 0; i < size; i++) {
                    dstArray.v[i] = srcList.getItem(i);
                }
            },
            /*TMPro.TMP_FontAsset.CopyListDataToArray end.*/

            /*TMPro.TMP_FontAsset.ClearFontAssetData start.*/
            /**
             * Clears font asset data including the glyph and character tables and textures.
             Function might be changed to Internal and only used in tests.
             *
             * @instance
             * @public
             * @this TMPro.TMP_FontAsset
             * @memberof TMPro.TMP_FontAsset
             * @param   {boolean}    setAtlasSizeToZero    Will set the atlas texture size to zero width and height if true.
             * @return  {void}
             */
            ClearFontAssetData: function (setAtlasSizeToZero) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#ClearFontAssetData", this ); }

                if (setAtlasSizeToZero === void 0) { setAtlasSizeToZero = false; }

                // Clear glyph, character and font feature tables
                this.ClearFontAssetTables();

                // Clear atlas textures
                this.ClearAtlasTextures(setAtlasSizeToZero);

                this.ReadFontAssetDefinition();

                //TMP_ResourceManager.RebuildFontAssetCache(instanceID);

            },
            /*TMPro.TMP_FontAsset.ClearFontAssetData end.*/

            /*TMPro.TMP_FontAsset.ClearFontAssetDataInternal start.*/
            ClearFontAssetDataInternal: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#ClearFontAssetDataInternal", this ); }

                // Clear glyph, character and font feature tables
                this.ClearFontAssetTables();

                // Clear atlas textures
                this.ClearAtlasTextures(true);

            },
            /*TMPro.TMP_FontAsset.ClearFontAssetDataInternal end.*/

            /*TMPro.TMP_FontAsset.UpdateFontAssetData start.*/
            /**
             * @instance
             * @this TMPro.TMP_FontAsset
             * @memberof TMPro.TMP_FontAsset
             * @return  {void}
             */
            UpdateFontAssetData: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#UpdateFontAssetData", this ); }

                // Get list of all characters currently contained in the font asset.
                var unicodeCharacters = System.Array.init(this.m_CharacterTable.Count, 0, System.UInt32);

                for (var i = 0; i < this.m_CharacterTable.Count; i++) {
                    unicodeCharacters[i] = this.m_CharacterTable.getItem(i).unicode;
                }

                // Clear glyph, character and font feature tables
                this.ClearFontAssetTables();

                // Clear atlas textures
                this.ClearAtlasTextures(true);

                this.ReadFontAssetDefinition();

                //TMP_ResourceManager.RebuildFontAssetCache(instanceID);

                // Add existing glyphs and characters back in the font asset (if any)
                if (unicodeCharacters.length > 0) {
                    this.TryAddCharacters$2(unicodeCharacters, true);
                }
            },
            /*TMPro.TMP_FontAsset.UpdateFontAssetData end.*/

            /*TMPro.TMP_FontAsset.ClearFontAssetTables start.*/
            /**
             * @instance
             * @this TMPro.TMP_FontAsset
             * @memberof TMPro.TMP_FontAsset
             * @return  {void}
             */
            ClearFontAssetTables: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#ClearFontAssetTables", this ); }

                // Clear glyph and character tables
                if (this.m_GlyphTable != null) {
                    this.m_GlyphTable.clear();
                }

                if (this.m_CharacterTable != null) {
                    this.m_CharacterTable.clear();
                }

                // Clear glyph rectangles
                if (this.m_UsedGlyphRects != null) {
                    this.m_UsedGlyphRects.clear();
                }

                if (this.m_FreeGlyphRects != null) {
                    var packingModifier = (this.m_AtlasRenderMode & UnityEngine.TextCore.LowLevel.GlyphRasterModes.RASTER_MODE_BITMAP) === UnityEngine.TextCore.LowLevel.GlyphRasterModes.RASTER_MODE_BITMAP ? 0 : 1;
                    this.m_FreeGlyphRects.clear();
                    this.m_FreeGlyphRects.add(new UnityEngine.TextCore.GlyphRect.$ctor1(0, 0, this.m_AtlasWidth - packingModifier, this.m_AtlasHeight - packingModifier));
                }

                if (this.m_GlyphsToRender != null) {
                    this.m_GlyphsToRender.clear();
                }

                if (this.m_GlyphsRendered != null) {
                    this.m_GlyphsRendered.clear();
                }

                // Clear Glyph Adjustment Table
                if (this.m_FontFeatureTable != null && this.m_FontFeatureTable.m_GlyphPairAdjustmentRecords != null) {
                    this.m_FontFeatureTable.glyphPairAdjustmentRecords.clear();
                }
            },
            /*TMPro.TMP_FontAsset.ClearFontAssetTables end.*/

            /*TMPro.TMP_FontAsset.ClearAtlasTextures start.*/
            /**
             * Internal function to clear all atlas textures.
             *
             * @instance
             * @this TMPro.TMP_FontAsset
             * @memberof TMPro.TMP_FontAsset
             * @param   {boolean}    setAtlasSizeToZero    Set main atlas texture size to zero if true.
             * @return  {void}
             */
            ClearAtlasTextures: function (setAtlasSizeToZero) {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#ClearAtlasTextures", this ); }

                if (setAtlasSizeToZero === void 0) { setAtlasSizeToZero = false; }
                this.m_AtlasTextureIndex = 0;

                // Return if we don't have any atlas textures
                if (this.m_AtlasTextures == null) {
                    return;
                }

                var texture = null;

                // Clear all additional atlas textures
                for (var i = 1; i < this.m_AtlasTextures.length; i++) {
                    texture = this.m_AtlasTextures[i];

                    if (texture == null) {
                        continue;
                    }

                    UnityEngine.Object.DestroyImmediate$1(texture, true);

                }

                // Resize atlas texture array down to one texture
                System.Array.resize(Bridge.ref(this, "m_AtlasTextures"), 1, null, UnityEngine.Texture2D);

                texture = (this.m_AtlasTexture = this.m_AtlasTextures[0]);

                // Clear main atlas texture

                if (setAtlasSizeToZero) {
                    texture.Resize$1(0, 0, UnityEngine.TextureFormat.Alpha8, false);
                } else if (texture.width !== this.m_AtlasWidth || texture.height !== this.m_AtlasHeight) {
                    texture.Resize$1(this.m_AtlasWidth, this.m_AtlasHeight, UnityEngine.TextureFormat.Alpha8, false);
                }

                // Clear texture atlas
                UnityEngine.TextCore.LowLevel.FontEngine.ResetAtlasTexture(texture);
                texture.Apply();
            },
            /*TMPro.TMP_FontAsset.ClearAtlasTextures end.*/

            /*TMPro.TMP_FontAsset.UpgradeFontAsset start.*/
            /**
             * Internal method used to upgrade font asset to support Dynamic SDF.
             *
             * @instance
             * @this TMPro.TMP_FontAsset
             * @memberof TMPro.TMP_FontAsset
             * @return  {void}
             */
            UpgradeFontAsset: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#UpgradeFontAsset", this ); }

                this.m_Version = "1.1.0";

                UnityEngine.Debug.Log$1("Upgrading font asset [" + (this.name || "") + "] to version " + (this.m_Version || "") + ".", this);

                this.m_FaceInfo.familyName = this.m_fontInfo.Name;
                this.m_FaceInfo.styleName = "";

                this.m_FaceInfo.pointSize = this.m_fontInfo.PointSize;
                this.m_FaceInfo.scale = this.m_fontInfo.Scale;

                this.m_FaceInfo.lineHeight = this.m_fontInfo.LineHeight;
                this.m_FaceInfo.ascentLine = this.m_fontInfo.Ascender;
                this.m_FaceInfo.capLine = this.m_fontInfo.CapHeight;
                this.m_FaceInfo.meanLine = this.m_fontInfo.CenterLine;
                this.m_FaceInfo.baseline = this.m_fontInfo.Baseline;
                this.m_FaceInfo.descentLine = this.m_fontInfo.Descender;

                this.m_FaceInfo.superscriptOffset = this.m_fontInfo.SuperscriptOffset;
                this.m_FaceInfo.superscriptSize = this.m_fontInfo.SubSize;
                this.m_FaceInfo.subscriptOffset = this.m_fontInfo.SubscriptOffset;
                this.m_FaceInfo.subscriptSize = this.m_fontInfo.SubSize;

                this.m_FaceInfo.underlineOffset = this.m_fontInfo.Underline;
                this.m_FaceInfo.underlineThickness = this.m_fontInfo.UnderlineThickness;
                this.m_FaceInfo.strikethroughOffset = this.m_fontInfo.strikethrough;
                this.m_FaceInfo.strikethroughThickness = this.m_fontInfo.strikethroughThickness;

                this.m_FaceInfo.tabWidth = this.m_fontInfo.TabWidth;

                if (this.m_AtlasTextures == null || this.m_AtlasTextures.length === 0) {
                    this.m_AtlasTextures = System.Array.init(1, null, UnityEngine.Texture2D);
                }

                this.m_AtlasTextures[0] = this.atlas;

                //atlas = null;

                this.m_AtlasWidth = this.m_fontInfo.AtlasWidth;
                this.m_AtlasHeight = this.m_fontInfo.AtlasHeight;
                this.m_AtlasPadding = this.m_fontInfo.Padding;

                switch (this.m_CreationSettings.renderMode) {
                    case 0: 
                        this.m_AtlasRenderMode = UnityEngine.TextCore.LowLevel.GlyphRenderMode.SMOOTH_HINTED;
                        break;
                    case 1: 
                        this.m_AtlasRenderMode = UnityEngine.TextCore.LowLevel.GlyphRenderMode.SMOOTH;
                        break;
                    case 2: 
                        this.m_AtlasRenderMode = UnityEngine.TextCore.LowLevel.GlyphRenderMode.RASTER_HINTED;
                        break;
                    case 3: 
                        this.m_AtlasRenderMode = UnityEngine.TextCore.LowLevel.GlyphRenderMode.RASTER;
                        break;
                    case 6: 
                        this.m_AtlasRenderMode = UnityEngine.TextCore.LowLevel.GlyphRenderMode.SDF16;
                        break;
                    case 7: 
                        this.m_AtlasRenderMode = UnityEngine.TextCore.LowLevel.GlyphRenderMode.SDF32;
                        break;
                }

                //m_fontInfo = null;

                // Convert font weight table
                if (this.fontWeights != null && this.fontWeights.length > 0) {
                    this.m_FontWeightTable[4] = this.fontWeights[4].$clone();
                    this.m_FontWeightTable[7] = this.fontWeights[7].$clone();

                    // Clear old fontWeight
                    //fontWeights = null;
                }

                // Convert font fallbacks
                if (this.fallbackFontAssets != null && this.fallbackFontAssets.Count > 0) {
                    if (this.m_FallbackFontAssetTable == null) {
                        this.m_FallbackFontAssetTable = new (System.Collections.Generic.List$1(TMPro.TMP_FontAsset)).$ctor2(this.fallbackFontAssets.Count);
                    }

                    for (var i = 0; i < this.fallbackFontAssets.Count; i++) {
                        this.m_FallbackFontAssetTable.add(this.fallbackFontAssets.getItem(i));
                    }

                    // Clear old fallbackFontAssets list
                    //fallbackFontAssets = null;
                }

                // Check if font asset creation settings contains a reference to the source font file GUID
                if (this.m_CreationSettings.sourceFontFileGUID != null || !Bridge.referenceEquals(this.m_CreationSettings.sourceFontFileGUID, "")) {
                    this.m_SourceFontFileGUID = this.m_CreationSettings.sourceFontFileGUID;
                } else {
                    UnityEngine.Debug.LogWarning$1("Font asset [" + (this.name || "") + "] doesn't have a reference to its source font file. Please assign the appropriate source font file for this asset in the Font Atlas & Material section of font asset inspector.", this);
                }

                // Convert legacy glyph and character tables to new format
                this.m_GlyphTable.clear();
                this.m_CharacterTable.clear();

                //#if UNITY_EDITOR
                // TODO: This is causing a crash in Unity and related to AssetDatabase.LoadAssetAtPath and Resources.Load()
                // Load font to allow us to get the glyph index.
                //string path = UnityEditor.AssetDatabase.GUIDToAssetPath(m_SourceFontFileGUID);

                //if (path != string.Empty)
                //{
                //m_SourceFontFile_EditorRef = UnityEditor.AssetDatabase.LoadAssetAtPath<Font>(path);
                //FontEngine.LoadFontFace(m_SourceFontFile_EditorRef);
                //}
                //#endif

                var isSpaceCharacterPresent = false;
                for (var i1 = 0; i1 < this.m_glyphInfoList.Count; i1++) {
                    var oldGlyph = this.m_glyphInfoList.getItem(i1);

                    var glyph = new UnityEngine.TextCore.Glyph.ctor();

                    var glyphIndex = i1 + 1;

                    //#if UNITY_EDITOR
                    //if (m_SourceFontFile_EditorRef != null)
                    //    glyphIndex = FontEngine.GetGlyphIndex((uint)oldGlyph.id);
                    //#endif

                    glyph.index = glyphIndex;
                    glyph.glyphRect = new UnityEngine.TextCore.GlyphRect.$ctor1(oldGlyph.x, this.m_AtlasHeight - (oldGlyph.y + oldGlyph.height + 0.5), oldGlyph.width + 0.5, oldGlyph.height + 0.5);
                    glyph.metrics = new UnityEngine.TextCore.GlyphMetrics.$ctor1(oldGlyph.width, oldGlyph.height, oldGlyph.xOffset, oldGlyph.yOffset, oldGlyph.xAdvance);
                    glyph.scale = oldGlyph.scale;
                    glyph.atlasIndex = 0;

                    this.m_GlyphTable.add(glyph);

                    var character = new TMPro.TMP_Character.$ctor2(oldGlyph.id, this, glyph);

                    if (oldGlyph.id === 32) {
                        isSpaceCharacterPresent = true;
                    }

                    this.m_CharacterTable.add(character);
                }

                // Special handling for the synthesized space character
                if (!isSpaceCharacterPresent) {
                    UnityEngine.Debug.Log$1("Synthesizing Space for [" + (this.name || "") + "]");
                    var glyph1 = new UnityEngine.TextCore.Glyph.$ctor2(0, new UnityEngine.TextCore.GlyphMetrics.$ctor1(0, 0, 0, 0, this.m_FaceInfo.ascentLine / 5), UnityEngine.TextCore.GlyphRect.zero.$clone(), 1.0, 0);
                    this.m_GlyphTable.add(glyph1);
                    this.m_CharacterTable.add(new TMPro.TMP_Character.$ctor2(32, this, glyph1));
                }

                // Clear legacy glyph info list.
                //m_glyphInfoList.Clear();

                this.ReadFontAssetDefinition();

                // Convert atlas textures data to new format
                // TODO
            },
            /*TMPro.TMP_FontAsset.UpgradeFontAsset end.*/

            /*TMPro.TMP_FontAsset.UpgradeGlyphAdjustmentTableToFontFeatureTable start.*/
            /**
             * @instance
             * @private
             * @this TMPro.TMP_FontAsset
             * @memberof TMPro.TMP_FontAsset
             * @return  {void}
             */
            UpgradeGlyphAdjustmentTableToFontFeatureTable: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_FontAsset#UpgradeGlyphAdjustmentTableToFontFeatureTable", this ); }

                UnityEngine.Debug.Log$1("Upgrading font asset [" + (this.name || "") + "] Glyph Adjustment Table.", this);

                if (this.m_FontFeatureTable == null) {
                    this.m_FontFeatureTable = new TMPro.TMP_FontFeatureTable();
                }

                var pairCount = this.m_KerningTable.kerningPairs.Count;

                this.m_FontFeatureTable.m_GlyphPairAdjustmentRecords = new (System.Collections.Generic.List$1(TMPro.TMP_GlyphPairAdjustmentRecord)).$ctor2(pairCount);

                for (var i = 0; i < pairCount; i++) {
                    var pair = this.m_KerningTable.kerningPairs.getItem(i);

                    var firstGlyphIndex = 0;
                    var firstCharacter = { };

                    if (this.m_CharacterLookupDictionary.tryGetValue(pair.firstGlyph, firstCharacter)) {
                        firstGlyphIndex = firstCharacter.v.glyphIndex;
                    }

                    var secondGlyphIndex = 0;
                    var secondCharacter = { };

                    if (this.m_CharacterLookupDictionary.tryGetValue(pair.secondGlyph, secondCharacter)) {
                        secondGlyphIndex = secondCharacter.v.glyphIndex;
                    }

                    var firstAdjustmentRecord = new TMPro.TMP_GlyphAdjustmentRecord.$ctor1(firstGlyphIndex, new TMPro.TMP_GlyphValueRecord.$ctor1(pair.firstGlyphAdjustments.xPlacement, pair.firstGlyphAdjustments.yPlacement, pair.firstGlyphAdjustments.xAdvance, pair.firstGlyphAdjustments.yAdvance));
                    var secondAdjustmentRecord = new TMPro.TMP_GlyphAdjustmentRecord.$ctor1(secondGlyphIndex, new TMPro.TMP_GlyphValueRecord.$ctor1(pair.secondGlyphAdjustments.xPlacement, pair.secondGlyphAdjustments.yPlacement, pair.secondGlyphAdjustments.xAdvance, pair.secondGlyphAdjustments.yAdvance));
                    var record = new TMPro.TMP_GlyphPairAdjustmentRecord.ctor(firstAdjustmentRecord.$clone(), secondAdjustmentRecord.$clone());

                    this.m_FontFeatureTable.m_GlyphPairAdjustmentRecords.add(record);
                }

                // TODO: Should clear legacy kerning table.
                this.m_KerningTable.kerningPairs = null;
                this.m_KerningTable = null;

            },
            /*TMPro.TMP_FontAsset.UpgradeGlyphAdjustmentTableToFontFeatureTable end.*/


        },
        overloads: {
            "HasCharacter(int)": "HasCharacter$1",
            "HasCharacters(string, List<char>)": "HasCharacters$1",
            "HasCharacters(string, uint[], bool, bool)": "HasCharacters$2",
            "TryAddCharacters(uint[], bool)": "TryAddCharacters$2",
            "TryAddCharacters(uint[], uint[], bool)": "TryAddCharacters$3",
            "TryAddCharacters(string, string, bool)": "TryAddCharacters$1",
            "UpdateGlyphAdjustmentRecords(uint[])": "UpdateGlyphAdjustmentRecords$3",
            "UpdateGlyphAdjustmentRecords(List<uint>)": "UpdateGlyphAdjustmentRecords$1",
            "UpdateGlyphAdjustmentRecords(List<uint>, List<uint>)": "UpdateGlyphAdjustmentRecords$2"
        }
    });
    /*TMPro.TMP_FontAsset end.*/

    /*TMPro.TMP_Glyph start.*/
    Bridge.define("TMPro.TMP_Glyph", {
        inherits: [TMPro.TMP_TextElement_Legacy],
        statics: {
            methods: {
                /*TMPro.TMP_Glyph.Clone:static start.*/
                /**
                 * Function to create a deep copy of a GlyphInfo.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_Glyph
                 * @memberof TMPro.TMP_Glyph
                 * @param   {TMPro.TMP_Glyph}    source
                 * @return  {TMPro.TMP_Glyph}
                 */
                Clone: function (source) {
if ( TRACE ) { TRACE( "TMPro.TMP_Glyph#Clone", this ); }

                    var copy = new TMPro.TMP_Glyph();

                    copy.id = source.id;
                    copy.x = source.x;
                    copy.y = source.y;
                    copy.width = source.width;
                    copy.height = source.height;
                    copy.xOffset = source.xOffset;
                    copy.yOffset = source.yOffset;
                    copy.xAdvance = source.xAdvance;
                    copy.scale = source.scale;

                    return copy;
                },
                /*TMPro.TMP_Glyph.Clone:static end.*/


            }
        }
    });
    /*TMPro.TMP_Glyph end.*/

    /*TMPro.TMP_Sprite start.*/
    Bridge.define("TMPro.TMP_Sprite", {
        inherits: [TMPro.TMP_TextElement_Legacy],
        fields: {
            name: null,
            hashCode: 0,
            unicode: 0,
            pivot: null,
            sprite: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_Sprite#init", this ); }

                this.pivot = new UnityEngine.Vector2();
            }
        }
    });
    /*TMPro.TMP_Sprite end.*/

    /*TMPro.TMP_SpriteAsset start.*/
    Bridge.define("TMPro.TMP_SpriteAsset", {
        inherits: [TMPro.TMP_Asset],
        statics: {
            fields: {
                /**
                 * Used to keep track of which Sprite Assets have been searched.
                 *
                 * @static
                 * @private
                 * @memberof TMPro.TMP_SpriteAsset
                 * @type System.Collections.Generic.HashSet$1
                 */
                k_searchedSpriteAssets: null
            },
            methods: {
                /*TMPro.TMP_SpriteAsset.SearchForSpriteByUnicode:static start.*/
                /**
                 * Search through the given sprite asset and its fallbacks for the specified sprite matching the given unicode character.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_SpriteAsset
                 * @memberof TMPro.TMP_SpriteAsset
                 * @param   {TMPro.TMP_SpriteAsset}    spriteAsset         The font asset to search for the given character.
                 * @param   {number}                   unicode             The character to find.
                 * @param   {boolean}                  includeFallbacks    
                 * @param   {System.Int32}             spriteIndex
                 * @return  {TMPro.TMP_SpriteAsset}
                 */
                SearchForSpriteByUnicode: function (spriteAsset, unicode, includeFallbacks, spriteIndex) {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteAsset#SearchForSpriteByUnicode", this ); }

                    // Check to make sure sprite asset is not null
                    if (spriteAsset == null) {
                        spriteIndex.v = -1;
                        return null;
                    }

                    // Get sprite index for the given unicode
                    spriteIndex.v = spriteAsset.GetSpriteIndexFromUnicode(unicode);
                    if (spriteIndex.v !== -1) {
                        return spriteAsset;
                    }

                    // Initialize list to track instance of Sprite Assets that have already been searched.
                    if (TMPro.TMP_SpriteAsset.k_searchedSpriteAssets == null) {
                        TMPro.TMP_SpriteAsset.k_searchedSpriteAssets = new (System.Collections.Generic.HashSet$1(System.Int32)).ctor();
                    } else {
                        TMPro.TMP_SpriteAsset.k_searchedSpriteAssets.clear();
                    }

                    // Get instance ID of sprite asset and add to list.
                    var id = spriteAsset.GetInstanceID();
                    TMPro.TMP_SpriteAsset.k_searchedSpriteAssets.add(id);

                    // Search potential fallback sprite assets if includeFallbacks is true.
                    if (includeFallbacks && spriteAsset.fallbackSpriteAssets != null && spriteAsset.fallbackSpriteAssets.Count > 0) {
                        return TMPro.TMP_SpriteAsset.SearchForSpriteByUnicodeInternal(spriteAsset.fallbackSpriteAssets, unicode, true, spriteIndex);
                    }

                    // Search default sprite asset potentially assigned in the TMP Settings.
                    if (includeFallbacks && TMPro.TMP_Settings.defaultSpriteAsset != null) {
                        return TMPro.TMP_SpriteAsset.SearchForSpriteByUnicodeInternal$1(TMPro.TMP_Settings.defaultSpriteAsset, unicode, true, spriteIndex);
                    }

                    spriteIndex.v = -1;
                    return null;
                },
                /*TMPro.TMP_SpriteAsset.SearchForSpriteByUnicode:static end.*/

                /*TMPro.TMP_SpriteAsset.SearchForSpriteByUnicodeInternal:static start.*/
                /**
                 * Search through the given list of sprite assets and fallbacks for a sprite whose unicode value matches the target unicode.
                 *
                 * @static
                 * @private
                 * @this TMPro.TMP_SpriteAsset
                 * @memberof TMPro.TMP_SpriteAsset
                 * @param   {System.Collections.Generic.List$1}    spriteAssets        
                 * @param   {number}                               unicode             
                 * @param   {boolean}                              includeFallbacks    
                 * @param   {System.Int32}                         spriteIndex
                 * @return  {TMPro.TMP_SpriteAsset}
                 */
                SearchForSpriteByUnicodeInternal: function (spriteAssets, unicode, includeFallbacks, spriteIndex) {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteAsset#SearchForSpriteByUnicodeInternal", this ); }

                    for (var i = 0; i < spriteAssets.Count; i++) {
                        var temp = spriteAssets.getItem(i);
                        if (temp == null) {
                            continue;
                        }

                        var id = temp.GetInstanceID();

                        // Skip sprite asset if it has already been searched.
                        if (TMPro.TMP_SpriteAsset.k_searchedSpriteAssets.add(id) === false) {
                            continue;
                        }

                        temp = TMPro.TMP_SpriteAsset.SearchForSpriteByUnicodeInternal$1(temp, unicode, includeFallbacks, spriteIndex);

                        if (temp != null) {
                            return temp;
                        }
                    }

                    spriteIndex.v = -1;
                    return null;
                },
                /*TMPro.TMP_SpriteAsset.SearchForSpriteByUnicodeInternal:static end.*/

                /*TMPro.TMP_SpriteAsset.SearchForSpriteByUnicodeInternal$1:static start.*/
                /**
                 * Search the given sprite asset and fallbacks for a sprite whose unicode value matches the target unicode.
                 *
                 * @static
                 * @private
                 * @this TMPro.TMP_SpriteAsset
                 * @memberof TMPro.TMP_SpriteAsset
                 * @param   {TMPro.TMP_SpriteAsset}    spriteAsset         
                 * @param   {number}                   unicode             
                 * @param   {boolean}                  includeFallbacks    
                 * @param   {System.Int32}             spriteIndex
                 * @return  {TMPro.TMP_SpriteAsset}
                 */
                SearchForSpriteByUnicodeInternal$1: function (spriteAsset, unicode, includeFallbacks, spriteIndex) {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteAsset#SearchForSpriteByUnicodeInternal$1", this ); }

                    // Get sprite index for the given unicode
                    spriteIndex.v = spriteAsset.GetSpriteIndexFromUnicode(unicode);

                    if (spriteIndex.v !== -1) {
                        return spriteAsset;
                    }

                    if (includeFallbacks && spriteAsset.fallbackSpriteAssets != null && spriteAsset.fallbackSpriteAssets.Count > 0) {
                        return TMPro.TMP_SpriteAsset.SearchForSpriteByUnicodeInternal(spriteAsset.fallbackSpriteAssets, unicode, true, spriteIndex);
                    }

                    spriteIndex.v = -1;
                    return null;
                },
                /*TMPro.TMP_SpriteAsset.SearchForSpriteByUnicodeInternal$1:static end.*/

                /*TMPro.TMP_SpriteAsset.SearchForSpriteByHashCode:static start.*/
                /**
                 * Search the given sprite asset and fallbacks for a sprite whose hash code value of its name matches the target hash code.
                 *
                 * @static
                 * @public
                 * @this TMPro.TMP_SpriteAsset
                 * @memberof TMPro.TMP_SpriteAsset
                 * @param   {TMPro.TMP_SpriteAsset}    spriteAsset         The Sprite Asset to search for the given sprite whose name matches the hashcode value
                 * @param   {number}                   hashCode            The hash code value matching the name of the sprite
                 * @param   {boolean}                  includeFallbacks    Include fallback sprite assets in the search
                 * @param   {System.Int32}             spriteIndex         The index of the sprite matching the provided hash code
                 * @return  {TMPro.TMP_SpriteAsset}                        The Sprite Asset that contains the sprite
                 */
                SearchForSpriteByHashCode: function (spriteAsset, hashCode, includeFallbacks, spriteIndex) {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteAsset#SearchForSpriteByHashCode", this ); }

                    // Make sure sprite asset is not null
                    if (spriteAsset == null) {
                        spriteIndex.v = -1;
                        return null;
                    }

                    spriteIndex.v = spriteAsset.GetSpriteIndexFromHashcode(hashCode);
                    if (spriteIndex.v !== -1) {
                        return spriteAsset;
                    }

                    // Initialize or clear list to Sprite Assets that have already been searched.
                    if (TMPro.TMP_SpriteAsset.k_searchedSpriteAssets == null) {
                        TMPro.TMP_SpriteAsset.k_searchedSpriteAssets = new (System.Collections.Generic.HashSet$1(System.Int32)).ctor();
                    } else {
                        TMPro.TMP_SpriteAsset.k_searchedSpriteAssets.clear();
                    }

                    var id = spriteAsset.instanceID;

                    // Add to list of font assets already searched.
                    TMPro.TMP_SpriteAsset.k_searchedSpriteAssets.add(id);

                    var tempSpriteAsset;

                    // Search potential fallbacks assigned to local sprite asset.
                    if (includeFallbacks && spriteAsset.fallbackSpriteAssets != null && spriteAsset.fallbackSpriteAssets.Count > 0) {
                        tempSpriteAsset = TMPro.TMP_SpriteAsset.SearchForSpriteByHashCodeInternal(spriteAsset.fallbackSpriteAssets, hashCode, true, spriteIndex);

                        if (spriteIndex.v !== -1) {
                            return tempSpriteAsset;
                        }
                    }

                    // Search default sprite asset potentially assigned in the TMP Settings.
                    if (includeFallbacks && TMPro.TMP_Settings.defaultSpriteAsset != null) {
                        tempSpriteAsset = TMPro.TMP_SpriteAsset.SearchForSpriteByHashCodeInternal$1(TMPro.TMP_Settings.defaultSpriteAsset, hashCode, true, spriteIndex);

                        if (spriteIndex.v !== -1) {
                            return tempSpriteAsset;
                        }
                    }

                    // Clear search list since we are now looking for the missing sprite character.
                    TMPro.TMP_SpriteAsset.k_searchedSpriteAssets.clear();

                    var missingSpriteCharacterUnicode = TMPro.TMP_Settings.missingCharacterSpriteUnicode;

                    // Get sprite index for the given unicode
                    spriteIndex.v = spriteAsset.GetSpriteIndexFromUnicode(missingSpriteCharacterUnicode);
                    if (spriteIndex.v !== -1) {
                        return spriteAsset;
                    }

                    // Add current sprite asset to list of assets already searched.
                    TMPro.TMP_SpriteAsset.k_searchedSpriteAssets.add(id);

                    // Search for the missing sprite character in the local sprite asset and potential fallbacks.
                    if (includeFallbacks && spriteAsset.fallbackSpriteAssets != null && spriteAsset.fallbackSpriteAssets.Count > 0) {
                        tempSpriteAsset = TMPro.TMP_SpriteAsset.SearchForSpriteByUnicodeInternal(spriteAsset.fallbackSpriteAssets, missingSpriteCharacterUnicode, true, spriteIndex);

                        if (spriteIndex.v !== -1) {
                            return tempSpriteAsset;
                        }
                    }

                    // Search for the missing sprite character in the default sprite asset and potential fallbacks.
                    if (includeFallbacks && TMPro.TMP_Settings.defaultSpriteAsset != null) {
                        tempSpriteAsset = TMPro.TMP_SpriteAsset.SearchForSpriteByUnicodeInternal$1(TMPro.TMP_Settings.defaultSpriteAsset, missingSpriteCharacterUnicode, true, spriteIndex);
                        if (spriteIndex.v !== -1) {
                            return tempSpriteAsset;
                        }
                    }

                    spriteIndex.v = -1;
                    return null;
                },
                /*TMPro.TMP_SpriteAsset.SearchForSpriteByHashCode:static end.*/

                /*TMPro.TMP_SpriteAsset.SearchForSpriteByHashCodeInternal:static start.*/
                /**
                 * Search through the given list of sprite assets and fallbacks for a sprite whose hash code value of its name matches the target hash code.
                 *
                 * @static
                 * @private
                 * @this TMPro.TMP_SpriteAsset
                 * @memberof TMPro.TMP_SpriteAsset
                 * @param   {System.Collections.Generic.List$1}    spriteAssets       
                 * @param   {number}                               hashCode           
                 * @param   {boolean}                              searchFallbacks    
                 * @param   {System.Int32}                         spriteIndex
                 * @return  {TMPro.TMP_SpriteAsset}
                 */
                SearchForSpriteByHashCodeInternal: function (spriteAssets, hashCode, searchFallbacks, spriteIndex) {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteAsset#SearchForSpriteByHashCodeInternal", this ); }

                    // Search through the list of sprite assets
                    for (var i = 0; i < spriteAssets.Count; i++) {
                        var temp = spriteAssets.getItem(i);
                        if (temp == null) {
                            continue;
                        }

                        var id = temp.instanceID;

                        // Skip sprite asset if it has already been searched.
                        if (TMPro.TMP_SpriteAsset.k_searchedSpriteAssets.add(id) === false) {
                            continue;
                        }

                        temp = TMPro.TMP_SpriteAsset.SearchForSpriteByHashCodeInternal$1(temp, hashCode, searchFallbacks, spriteIndex);

                        if (temp != null) {
                            return temp;
                        }
                    }

                    spriteIndex.v = -1;
                    return null;
                },
                /*TMPro.TMP_SpriteAsset.SearchForSpriteByHashCodeInternal:static end.*/

                /*TMPro.TMP_SpriteAsset.SearchForSpriteByHashCodeInternal$1:static start.*/
                /**
                 * Search through the given sprite asset and fallbacks for a sprite whose hash code value of its name matches the target hash code.
                 *
                 * @static
                 * @private
                 * @this TMPro.TMP_SpriteAsset
                 * @memberof TMPro.TMP_SpriteAsset
                 * @param   {TMPro.TMP_SpriteAsset}    spriteAsset        
                 * @param   {number}                   hashCode           
                 * @param   {boolean}                  searchFallbacks    
                 * @param   {System.Int32}             spriteIndex
                 * @return  {TMPro.TMP_SpriteAsset}
                 */
                SearchForSpriteByHashCodeInternal$1: function (spriteAsset, hashCode, searchFallbacks, spriteIndex) {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteAsset#SearchForSpriteByHashCodeInternal$1", this ); }

                    // Get the sprite for the given hash code.
                    spriteIndex.v = spriteAsset.GetSpriteIndexFromHashcode(hashCode);
                    if (spriteIndex.v !== -1) {
                        return spriteAsset;
                    }

                    if (searchFallbacks && spriteAsset.fallbackSpriteAssets != null && spriteAsset.fallbackSpriteAssets.Count > 0) {
                        return TMPro.TMP_SpriteAsset.SearchForSpriteByHashCodeInternal(spriteAsset.fallbackSpriteAssets, hashCode, true, spriteIndex);
                    }

                    spriteIndex.v = -1;
                    return null;
                },
                /*TMPro.TMP_SpriteAsset.SearchForSpriteByHashCodeInternal$1:static end.*/


            }
        },
        fields: {
            m_NameLookup: null,
            m_GlyphIndexLookup: null,
            m_Version: null,
            m_FaceInfo: null,
            spriteSheet: null,
            m_SpriteCharacterTable: null,
            m_SpriteCharacterLookup: null,
            m_SpriteGlyphTable: null,
            m_SpriteGlyphLookup: null,
            spriteInfoList: null,
            /**
             * List which contains the Fallback font assets for this font.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_SpriteAsset
             * @type System.Collections.Generic.List$1
             */
            fallbackSpriteAssets: null,
            m_IsSpriteAssetLookupTablesDirty: false
        },
        props: {
            /**
             * The version of the sprite asset class.
             Version 1.1.0 updates the asset data structure to be compatible with new font asset structure.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_SpriteAsset
             * @function version
             * @type string
             */
            version: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteAsset#version#get", this ); }

                    return this.m_Version;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteAsset#version#set", this ); }

                    this.m_Version = value;
                }
            },
            /**
             * Information about the sprite asset's face.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_SpriteAsset
             * @function faceInfo
             * @type UnityEngine.TextCore.FaceInfo
             */
            faceInfo: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteAsset#faceInfo#get", this ); }

                    return this.m_FaceInfo.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteAsset#faceInfo#set", this ); }

                    this.m_FaceInfo = value.$clone();
                }
            },
            /**
             * @instance
             * @public
             * @memberof TMPro.TMP_SpriteAsset
             * @function spriteCharacterTable
             * @type System.Collections.Generic.List$1
             */
            spriteCharacterTable: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteAsset#spriteCharacterTable#get", this ); }

                    if (this.m_GlyphIndexLookup == null) {
                        this.UpdateLookupTables();
                    }

                    return this.m_SpriteCharacterTable;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteAsset#spriteCharacterTable#set", this ); }

                    this.m_SpriteCharacterTable = value;
                }
            },
            /**
             * Dictionary used to lookup sprite characters by their unicode value.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_SpriteAsset
             * @function spriteCharacterLookupTable
             * @type System.Collections.Generic.Dictionary$2
             */
            spriteCharacterLookupTable: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteAsset#spriteCharacterLookupTable#get", this ); }

                    if (this.m_SpriteCharacterLookup == null) {
                        this.UpdateLookupTables();
                    }

                    return this.m_SpriteCharacterLookup;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteAsset#spriteCharacterLookupTable#set", this ); }

                    this.m_SpriteCharacterLookup = value;
                }
            },
            spriteGlyphTable: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteAsset#spriteGlyphTable#get", this ); }

                    return this.m_SpriteGlyphTable;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteAsset#spriteGlyphTable#set", this ); }

                    this.m_SpriteGlyphTable = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteAsset#init", this ); }

                this.m_FaceInfo = new UnityEngine.TextCore.FaceInfo();
                this.m_SpriteCharacterTable = new (System.Collections.Generic.List$1(TMPro.TMP_SpriteCharacter)).ctor();
                this.m_SpriteGlyphTable = new (System.Collections.Generic.List$1(TMPro.TMP_SpriteGlyph)).ctor();
                this.m_IsSpriteAssetLookupTablesDirty = false;
            }
        },
        methods: {
            /*TMPro.TMP_SpriteAsset.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteAsset#Awake", this ); }

                // Check version number of sprite asset to see if it needs to be upgraded.
                if (this.material != null && System.String.isNullOrEmpty(this.m_Version)) {
                    this.UpgradeSpriteAsset();
                }
            },
            /*TMPro.TMP_SpriteAsset.Awake end.*/

            /*TMPro.TMP_SpriteAsset.GetDefaultSpriteMaterial start.*/
            /**
             * Create a material for the sprite asset.
             *
             * @instance
             * @private
             * @this TMPro.TMP_SpriteAsset
             * @memberof TMPro.TMP_SpriteAsset
             * @return  {UnityEngine.Material}
             */
            GetDefaultSpriteMaterial: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteAsset#GetDefaultSpriteMaterial", this ); }

                //isEditingAsset = true;
                TMPro.ShaderUtilities.GetShaderPropertyIDs();

                // Add a new material
                var shader = UnityEngine.Shader.Find("TextMeshPro/Sprite");
                var tempMaterial = new UnityEngine.Material.$ctor2(shader);
                tempMaterial.SetTexture(TMPro.ShaderUtilities.ID_MainTex, this.spriteSheet);
                tempMaterial.hideFlags = UnityEngine.HideFlags.HideInHierarchy;

                //isEditingAsset = false;

                return tempMaterial;
            },
            /*TMPro.TMP_SpriteAsset.GetDefaultSpriteMaterial end.*/

            /*TMPro.TMP_SpriteAsset.UpdateLookupTables start.*/
            /**
             * Function to update the sprite name and unicode lookup tables.
             This function should be called when a sprite's name or unicode value changes or when a new sprite is added.
             *
             * @instance
             * @public
             * @this TMPro.TMP_SpriteAsset
             * @memberof TMPro.TMP_SpriteAsset
             * @return  {void}
             */
            UpdateLookupTables: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteAsset#UpdateLookupTables", this ); }

                //Debug.Log("Updating [" + this.name + "] Lookup tables.");

                // Check version number of sprite asset to see if it needs to be upgraded.
                if (this.material != null && System.String.isNullOrEmpty(this.m_Version)) {
                    this.UpgradeSpriteAsset();
                }

                // Initialize / Clear glyph index lookup dictionary.
                if (this.m_GlyphIndexLookup == null) {
                    this.m_GlyphIndexLookup = new (System.Collections.Generic.Dictionary$2(System.UInt32,System.Int32)).ctor();
                } else {
                    this.m_GlyphIndexLookup.clear();
                }

                //
                if (this.m_SpriteGlyphLookup == null) {
                    this.m_SpriteGlyphLookup = new (System.Collections.Generic.Dictionary$2(System.UInt32,TMPro.TMP_SpriteGlyph)).ctor();
                } else {
                    this.m_SpriteGlyphLookup.clear();
                }

                // Initialize SpriteGlyphLookup
                for (var i = 0; i < this.m_SpriteGlyphTable.Count; i++) {
                    var spriteGlyph = this.m_SpriteGlyphTable.getItem(i);
                    var glyphIndex = spriteGlyph.index;

                    if (this.m_GlyphIndexLookup.containsKey(glyphIndex) === false) {
                        this.m_GlyphIndexLookup.add(glyphIndex, i);
                    }

                    if (this.m_SpriteGlyphLookup.containsKey(glyphIndex) === false) {
                        this.m_SpriteGlyphLookup.add(glyphIndex, spriteGlyph);
                    }
                }

                // Initialize name lookup
                if (this.m_NameLookup == null) {
                    this.m_NameLookup = new (System.Collections.Generic.Dictionary$2(System.Int32,System.Int32)).ctor();
                } else {
                    this.m_NameLookup.clear();
                }


                // Initialize character lookup
                if (this.m_SpriteCharacterLookup == null) {
                    this.m_SpriteCharacterLookup = new (System.Collections.Generic.Dictionary$2(System.UInt32,TMPro.TMP_SpriteCharacter)).ctor();
                } else {
                    this.m_SpriteCharacterLookup.clear();
                }


                // Populate Sprite Character lookup tables
                for (var i1 = 0; i1 < this.m_SpriteCharacterTable.Count; i1++) {
                    var spriteCharacter = this.m_SpriteCharacterTable.getItem(i1);

                    // Make sure sprite character is valid
                    if (spriteCharacter == null) {
                        continue;
                    }

                    var glyphIndex1 = spriteCharacter.glyphIndex;

                    // Lookup the glyph for this character
                    if (this.m_SpriteGlyphLookup.containsKey(glyphIndex1) === false) {
                        continue;
                    }

                    // Assign glyph and text asset to this character
                    spriteCharacter.glyph = this.m_SpriteGlyphLookup.getItem(glyphIndex1);
                    spriteCharacter.textAsset = this;

                    var nameHashCode = this.m_SpriteCharacterTable.getItem(i1).hashCode;

                    if (this.m_NameLookup.containsKey(nameHashCode) === false) {
                        this.m_NameLookup.add(nameHashCode, i1);
                    }

                    var unicode = this.m_SpriteCharacterTable.getItem(i1).unicode;

                    if (unicode !== 65534 && this.m_SpriteCharacterLookup.containsKey(unicode) === false) {
                        this.m_SpriteCharacterLookup.add(unicode, spriteCharacter);
                    }
                }

                this.m_IsSpriteAssetLookupTablesDirty = false;
            },
            /*TMPro.TMP_SpriteAsset.UpdateLookupTables end.*/

            /*TMPro.TMP_SpriteAsset.GetSpriteIndexFromHashcode start.*/
            /**
             * Function which returns the sprite index using the hashcode of the name
             *
             * @instance
             * @public
             * @this TMPro.TMP_SpriteAsset
             * @memberof TMPro.TMP_SpriteAsset
             * @param   {number}    hashCode
             * @return  {number}
             */
            GetSpriteIndexFromHashcode: function (hashCode) {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteAsset#GetSpriteIndexFromHashcode", this ); }

                if (this.m_NameLookup == null) {
                    this.UpdateLookupTables();
                }

                var index = { };

                if (this.m_NameLookup.tryGetValue(hashCode, index)) {
                    return index.v;
                }

                return -1;
            },
            /*TMPro.TMP_SpriteAsset.GetSpriteIndexFromHashcode end.*/

            /*TMPro.TMP_SpriteAsset.GetSpriteIndexFromUnicode start.*/
            /**
             * Returns the index of the sprite for the given unicode value.
             *
             * @instance
             * @public
             * @this TMPro.TMP_SpriteAsset
             * @memberof TMPro.TMP_SpriteAsset
             * @param   {number}    unicode
             * @return  {number}
             */
            GetSpriteIndexFromUnicode: function (unicode) {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteAsset#GetSpriteIndexFromUnicode", this ); }

                if (this.m_SpriteCharacterLookup == null) {
                    this.UpdateLookupTables();
                }

                var spriteCharacter = { };

                if (this.m_SpriteCharacterLookup.tryGetValue(unicode, spriteCharacter)) {
                    return spriteCharacter.v.glyphIndex;
                }

                return -1;
            },
            /*TMPro.TMP_SpriteAsset.GetSpriteIndexFromUnicode end.*/

            /*TMPro.TMP_SpriteAsset.GetSpriteIndexFromName start.*/
            /**
             * Returns the index of the sprite for the given name.
             *
             * @instance
             * @public
             * @this TMPro.TMP_SpriteAsset
             * @memberof TMPro.TMP_SpriteAsset
             * @param   {string}    name
             * @return  {number}
             */
            GetSpriteIndexFromName: function (name) {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteAsset#GetSpriteIndexFromName", this ); }

                if (this.m_NameLookup == null) {
                    this.UpdateLookupTables();
                }

                var hashCode = TMPro.TMP_TextUtilities.GetSimpleHashCode(name);

                return this.GetSpriteIndexFromHashcode(hashCode);
            },
            /*TMPro.TMP_SpriteAsset.GetSpriteIndexFromName end.*/

            /*TMPro.TMP_SpriteAsset.SortGlyphTable start.*/
            /**
             * Sort the sprite glyph table by glyph index.
             *
             * @instance
             * @public
             * @this TMPro.TMP_SpriteAsset
             * @memberof TMPro.TMP_SpriteAsset
             * @return  {void}
             */
            SortGlyphTable: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteAsset#SortGlyphTable", this ); }

                if (this.m_SpriteGlyphTable == null || this.m_SpriteGlyphTable.Count === 0) {
                    return;
                }

                this.m_SpriteGlyphTable = System.Linq.Enumerable.from(this.m_SpriteGlyphTable, TMPro.TMP_SpriteGlyph).orderBy(function (item) {
                        return item.index;
                    }).toList(TMPro.TMP_SpriteGlyph);
            },
            /*TMPro.TMP_SpriteAsset.SortGlyphTable end.*/

            /*TMPro.TMP_SpriteAsset.SortCharacterTable start.*/
            /**
             * Sort the sprite character table by Unicode values.
             *
             * @instance
             * @this TMPro.TMP_SpriteAsset
             * @memberof TMPro.TMP_SpriteAsset
             * @return  {void}
             */
            SortCharacterTable: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteAsset#SortCharacterTable", this ); }

                if (this.m_SpriteCharacterTable != null && this.m_SpriteCharacterTable.Count > 0) {
                    this.m_SpriteCharacterTable = System.Linq.Enumerable.from(this.m_SpriteCharacterTable, TMPro.TMP_SpriteCharacter).orderBy(function (c) {
                            return c.unicode;
                        }).toList(TMPro.TMP_SpriteCharacter);
                }
            },
            /*TMPro.TMP_SpriteAsset.SortCharacterTable end.*/

            /*TMPro.TMP_SpriteAsset.SortGlyphAndCharacterTables start.*/
            /**
             * Sort both sprite glyph and character tables.
             *
             * @instance
             * @this TMPro.TMP_SpriteAsset
             * @memberof TMPro.TMP_SpriteAsset
             * @return  {void}
             */
            SortGlyphAndCharacterTables: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteAsset#SortGlyphAndCharacterTables", this ); }

                this.SortGlyphTable();
                this.SortCharacterTable();
            },
            /*TMPro.TMP_SpriteAsset.SortGlyphAndCharacterTables end.*/

            /*TMPro.TMP_SpriteAsset.UpgradeSpriteAsset start.*/
            /**
             * Internal method used to upgrade sprite asset.
             *
             * @instance
             * @private
             * @this TMPro.TMP_SpriteAsset
             * @memberof TMPro.TMP_SpriteAsset
             * @return  {void}
             */
            UpgradeSpriteAsset: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteAsset#UpgradeSpriteAsset", this ); }

                this.m_Version = "1.1.0";

                UnityEngine.Debug.Log$1("Upgrading sprite asset [" + (this.name || "") + "] to version " + (this.m_Version || "") + ".", this);

                // Convert legacy glyph and character tables to new format
                this.m_SpriteCharacterTable.clear();
                this.m_SpriteGlyphTable.clear();

                for (var i = 0; i < this.spriteInfoList.Count; i++) {
                    var oldSprite = this.spriteInfoList.getItem(i);

                    var spriteGlyph = new TMPro.TMP_SpriteGlyph.ctor();
                    spriteGlyph.index = i;
                    spriteGlyph.sprite = oldSprite.sprite;
                    spriteGlyph.metrics = new UnityEngine.TextCore.GlyphMetrics.$ctor1(oldSprite.width, oldSprite.height, oldSprite.xOffset, oldSprite.yOffset, oldSprite.xAdvance);
                    spriteGlyph.glyphRect = new UnityEngine.TextCore.GlyphRect.$ctor1(oldSprite.x, oldSprite.y, oldSprite.width, oldSprite.height);

                    spriteGlyph.scale = 1.0;
                    spriteGlyph.atlasIndex = 0;

                    this.m_SpriteGlyphTable.add(spriteGlyph);

                    var spriteCharacter = new TMPro.TMP_SpriteCharacter.ctor();
                    spriteCharacter.glyph = spriteGlyph;
                    spriteCharacter.unicode = oldSprite.unicode === 0 ? 65534 : oldSprite.unicode;
                    spriteCharacter.name = oldSprite.name;
                    spriteCharacter.scale = oldSprite.scale;

                    this.m_SpriteCharacterTable.add(spriteCharacter);
                }

                // Clear legacy glyph info list.
                //spriteInfoList.Clear();

                this.UpdateLookupTables();

            },
            /*TMPro.TMP_SpriteAsset.UpgradeSpriteAsset end.*/


        }
    });
    /*TMPro.TMP_SpriteAsset end.*/

    /*TMPro.TMP_SpriteCharacter start.*/
    /**
     * A basic element of text representing a pictograph, image, sprite or emoji.
     *
     * @public
     * @class TMPro.TMP_SpriteCharacter
     * @augments TMPro.TMP_TextElement
     */
    Bridge.define("TMPro.TMP_SpriteCharacter", {
        inherits: [TMPro.TMP_TextElement],
        fields: {
            m_Name: null,
            m_HashCode: 0
        },
        props: {
            /**
             * The name of the sprite element.
             *
             * @instance
             * @public
             * @memberof TMPro.TMP_SpriteCharacter
             * @function name
             * @type string
             */
            name: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteCharacter#name#get", this ); }

                    return this.m_Name;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteCharacter#name#set", this ); }

                    if (Bridge.referenceEquals(value, this.m_Name)) {
                        return;
                    }

                    this.m_Name = value;
                    this.m_HashCode = TMPro.TMP_TextParsingUtilities.GetHashCodeCaseSensitive(this.m_Name);
                }
            },
            /**
             * The hashcode value which is computed from the name of the sprite element.
             This value is read-only and updated when the name of the text sprite is changed.
             *
             * @instance
             * @public
             * @readonly
             * @memberof TMPro.TMP_SpriteCharacter
             * @function hashCode
             * @type number
             */
            hashCode: {
                get: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteCharacter#hashCode#get", this ); }

                    return this.m_HashCode;
                }
            }
        },
        ctors: {
            /**
             * Default constructor.
             *
             * @instance
             * @public
             * @this TMPro.TMP_SpriteCharacter
             * @memberof TMPro.TMP_SpriteCharacter
             * @return  {void}
             */
            ctor: function () {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteCharacter#ctor", this ); }

                this.$initialize();
                TMPro.TMP_TextElement.ctor.call(this);
                this.m_ElementType = TMPro.TextElementType.Sprite;
            },
            /**
             * Constructor for new sprite character.
             *
             * @instance
             * @public
             * @this TMPro.TMP_SpriteCharacter
             * @memberof TMPro.TMP_SpriteCharacter
             * @param   {number}                   unicode    Unicode value of the sprite character.
             * @param   {TMPro.TMP_SpriteGlyph}    glyph      Glyph used by the sprite character.
             * @return  {void}
             */
            $ctor3: function (unicode, glyph) {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteCharacter#$ctor3", this ); }

                this.$initialize();
                TMPro.TMP_TextElement.ctor.call(this);
                this.m_ElementType = TMPro.TextElementType.Sprite;

                this.unicode = unicode;
                this.glyphIndex = glyph.index;
                this.glyph = glyph;
                this.scale = 1.0;
            },
            /**
             * Constructor for new sprite character.
             *
             * @instance
             * @public
             * @this TMPro.TMP_SpriteCharacter
             * @memberof TMPro.TMP_SpriteCharacter
             * @param   {number}                   unicode        Unicode value of the sprite character.
             * @param   {TMPro.TMP_SpriteAsset}    spriteAsset    Sprite Asset used by this sprite character.
             * @param   {TMPro.TMP_SpriteGlyph}    glyph          Glyph used by the sprite character.
             * @return  {void}
             */
            $ctor2: function (unicode, spriteAsset, glyph) {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteCharacter#$ctor2", this ); }

                this.$initialize();
                TMPro.TMP_TextElement.ctor.call(this);
                this.m_ElementType = TMPro.TextElementType.Sprite;

                this.unicode = unicode;
                this.textAsset = spriteAsset;
                this.glyph = glyph;
                this.glyphIndex = glyph.index;
                this.scale = 1.0;
            },
            /**
             * @instance
             * @this TMPro.TMP_SpriteCharacter
             * @memberof TMPro.TMP_SpriteCharacter
             * @param   {number}    unicode       
             * @param   {number}    glyphIndex
             * @return  {void}
             */
            $ctor1: function (unicode, glyphIndex) {
if ( TRACE ) { TRACE( "TMPro.TMP_SpriteCharacter#$ctor1", this ); }

                this.$initialize();
                TMPro.TMP_TextElement.ctor.call(this);
                this.m_ElementType = TMPro.TextElementType.Sprite;

                this.unicode = unicode;
                this.textAsset = null;
                this.glyph = null;
                this.glyphIndex = glyphIndex;
                this.scale = 1.0;
            }
        }
    });
    /*TMPro.TMP_SpriteCharacter end.*/

    /*TMPro.TweenRunner$1 start.*/
    Bridge.define("TMPro.TweenRunner$1", function (T) { return {
        statics: {
            methods: {
                /*TMPro.TweenRunner$1.Start:static start.*/
                Start: function (tweenInfo) {
if ( TRACE ) { TRACE( "TMPro.TweenRunner$1#Start", this ); }

                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        elapsedTime,
                        percentage,
                        $async_e;

                    var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        if (!tweenInfo.TMPro$ITweenValue$ValidTarget()) {
                                                $step = 1;
                                                continue;
                                            } 
                                            $step = 2;
                                            continue;
                                    }
                                    case 1: {
                                        return false;
                                    }
                                    case 2: {
                                        elapsedTime = 0.0;
                                        $step = 3;
                                        continue;
                                    }
                                    case 3: {
                                        if ( elapsedTime < tweenInfo.TMPro$ITweenValue$duration ) {
                                                $step = 4;
                                                continue;
                                            } 
                                            $step = 6;
                                            continue;
                                    }
                                    case 4: {
                                        elapsedTime += tweenInfo.TMPro$ITweenValue$ignoreTimeScale ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime;
                                            percentage = Math.max(0, Math.min(1, elapsedTime / tweenInfo.TMPro$ITweenValue$duration));
                                            tweenInfo.TMPro$ITweenValue$TweenValue(percentage);
                                            $enumerator.current = null;
                                            $step = 5;
                                            return true;
                                    }
                                    case 5: {
                                        
                                            $step = 3;
                                            continue;
                                    }
                                    case 6: {
                                        tweenInfo.TMPro$ITweenValue$TweenValue(1.0);

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                },
                /*TMPro.TweenRunner$1.Start:static end.*/


            }
        },
        fields: {
            m_CoroutineContainer: null,
            m_Tween: null
        },
        methods: {
            /*TMPro.TweenRunner$1.Init start.*/
            Init: function (coroutineContainer) {
if ( TRACE ) { TRACE( "TMPro.TweenRunner$1#Init", this ); }

                this.m_CoroutineContainer = coroutineContainer;
            },
            /*TMPro.TweenRunner$1.Init end.*/

            /*TMPro.TweenRunner$1.StartTween start.*/
            StartTween: function (info) {
if ( TRACE ) { TRACE( "TMPro.TweenRunner$1#StartTween", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.m_CoroutineContainer, null)) {
                    UnityEngine.Debug.LogWarning$1("Coroutine container not configured... did you forget to call Init?");
                    return;
                }

                this.StopTween();

                if (!this.m_CoroutineContainer.gameObject.activeInHierarchy) {
                    info.TMPro$ITweenValue$TweenValue(1.0);
                    return;
                }

                this.m_Tween = TMPro.TweenRunner$1(T).Start(info);
                this.m_CoroutineContainer.StartCoroutine$1(this.m_Tween);
            },
            /*TMPro.TweenRunner$1.StartTween end.*/

            /*TMPro.TweenRunner$1.StopTween start.*/
            StopTween: function () {
if ( TRACE ) { TRACE( "TMPro.TweenRunner$1#StopTween", this ); }

                if (this.m_Tween != null) {
                    this.m_CoroutineContainer.StopCoroutine(this.m_Tween);
                    this.m_Tween = null;
                }
            },
            /*TMPro.TweenRunner$1.StopTween end.*/


        }
    }; });
    /*TMPro.TweenRunner$1 end.*/

    if ( MODULE_reflection ) {
    var $m = Bridge.setMetadata,
        $n = ["System","TMPro","UnityEngine","UnityEngine.UI","System.Collections.Generic","UnityEngine.TextCore.LowLevel","UnityEngine.TextCore"];

    /*TMPro.FaceInfo_Legacy start.*/
    $m("TMPro.FaceInfo_Legacy", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*TMPro.FaceInfo_Legacy end.*/

    /*TMPro.FontAssetCreationSettings start.*/
    $m("TMPro.FontAssetCreationSettings", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*TMPro.FontAssetCreationSettings end.*/

    /*TMPro.GlyphValueRecord_Legacy start.*/
    $m("TMPro.GlyphValueRecord_Legacy", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*TMPro.GlyphValueRecord_Legacy end.*/

    /*TMPro.KerningPair start.*/
    $m("TMPro.KerningPair", function () { return {"at":[new System.SerializableAttribute()],"m":[{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("AscII_Left"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_FirstGlyph","t":4,"rt":$n[0].UInt32,"sn":"m_FirstGlyph","box":function ($v) { return Bridge.box($v, System.UInt32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_FirstGlyphAdjustments","t":4,"rt":$n[1].GlyphValueRecord_Legacy,"sn":"m_FirstGlyphAdjustments"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_IgnoreSpacingAdjustments","t":4,"rt":$n[0].Boolean,"sn":"m_IgnoreSpacingAdjustments","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("AscII_Right"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_SecondGlyph","t":4,"rt":$n[0].UInt32,"sn":"m_SecondGlyph","box":function ($v) { return Bridge.box($v, System.UInt32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_SecondGlyphAdjustments","t":4,"rt":$n[1].GlyphValueRecord_Legacy,"sn":"m_SecondGlyphAdjustments"},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("XadvanceOffset")],"a":2,"n":"xOffset","t":4,"rt":$n[0].Single,"sn":"xOffset","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*TMPro.KerningPair end.*/

    /*TMPro.KerningTable start.*/
    $m("TMPro.KerningTable", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*TMPro.KerningTable end.*/

    /*TMPro.Mesh_Extents start.*/
    $m("TMPro.Mesh_Extents", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*TMPro.Mesh_Extents end.*/

    /*TMPro.SpriteAssetUtilities.TexturePacker_JsonArray+Frame start.*/
    $m("TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Frame", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*TMPro.SpriteAssetUtilities.TexturePacker_JsonArray+Frame end.*/

    /*TMPro.SpriteAssetUtilities.TexturePacker_JsonArray+Meta start.*/
    $m("TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.Meta", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*TMPro.SpriteAssetUtilities.TexturePacker_JsonArray+Meta end.*/

    /*TMPro.SpriteAssetUtilities.TexturePacker_JsonArray+SpriteDataObject start.*/
    $m("TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteDataObject", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*TMPro.SpriteAssetUtilities.TexturePacker_JsonArray+SpriteDataObject end.*/

    /*TMPro.SpriteAssetUtilities.TexturePacker_JsonArray+SpriteFrame start.*/
    $m("TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteFrame", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*TMPro.SpriteAssetUtilities.TexturePacker_JsonArray+SpriteFrame end.*/

    /*TMPro.SpriteAssetUtilities.TexturePacker_JsonArray+SpriteSize start.*/
    $m("TMPro.SpriteAssetUtilities.TexturePacker_JsonArray.SpriteSize", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*TMPro.SpriteAssetUtilities.TexturePacker_JsonArray+SpriteSize end.*/

    /*TMPro.TextContainer start.*/
    $m("TMPro.TextContainer", function () { return {"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.RectTransform)],"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_anchorPosition","t":4,"rt":$n[1].TextContainerAnchors,"sn":"m_anchorPosition","box":function ($v) { return Bridge.box($v, TMPro.TextContainerAnchors, System.Enum.toStringFn(TMPro.TextContainerAnchors));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_margins","t":4,"rt":$n[2].Vector4,"sn":"m_margins"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_pivot","t":4,"rt":$n[2].Vector2,"sn":"m_pivot"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_rect","t":4,"rt":$n[2].Rect,"sn":"m_rect"}]}; }, $n);
    /*TMPro.TextContainer end.*/

    /*TMPro.TMP_Text start.*/
    $m("TMPro.TMP_Text", function () { return {"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"checkPaddingRequired","t":4,"rt":$n[0].Boolean,"sn":"checkPaddingRequired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_HorizontalAlignment","t":4,"rt":$n[1].HorizontalAlignmentOptions,"sn":"m_HorizontalAlignment","box":function ($v) { return Bridge.box($v, TMPro.HorizontalAlignmentOptions, System.Enum.toStringFn(TMPro.HorizontalAlignmentOptions));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_IsTextObjectScaleStatic","t":4,"rt":$n[0].Boolean,"sn":"m_IsTextObjectScaleStatic","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_StyleSheet","t":4,"rt":$n[1].TMP_StyleSheet,"sn":"m_StyleSheet"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_TextPreprocessor","t":4,"rt":$n[1].ITextPreprocessor,"sn":"m_TextPreprocessor"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_TextStyleHashCode","t":4,"rt":$n[0].Int32,"sn":"m_TextStyleHashCode","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_VertexBufferAutoSizeReduction","t":4,"rt":$n[0].Boolean,"sn":"m_VertexBufferAutoSizeReduction","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_VerticalAlignment","t":4,"rt":$n[1].VerticalAlignmentOptions,"sn":"m_VerticalAlignment","box":function ($v) { return Bridge.box($v, TMPro.VerticalAlignmentOptions, System.Enum.toStringFn(TMPro.VerticalAlignmentOptions));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_charWidthMaxAdj","t":4,"rt":$n[0].Single,"sn":"m_charWidthMaxAdj","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_characterSpacing","t":4,"rt":$n[0].Single,"sn":"m_characterSpacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_colorMode","t":4,"rt":$n[1].ColorMode,"sn":"m_colorMode","box":function ($v) { return Bridge.box($v, TMPro.ColorMode, System.Enum.toStringFn(TMPro.ColorMode));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_enableAutoSizing","t":4,"rt":$n[0].Boolean,"sn":"m_enableAutoSizing","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_enableExtraPadding","t":4,"rt":$n[0].Boolean,"sn":"m_enableExtraPadding","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_enableKerning","t":4,"rt":$n[0].Boolean,"sn":"m_enableKerning","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_enableVertexGradient","t":4,"rt":$n[0].Boolean,"sn":"m_enableVertexGradient","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_enableWordWrapping","t":4,"rt":$n[0].Boolean,"sn":"m_enableWordWrapping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_faceColor","t":4,"rt":$n[2].Color32,"sn":"m_faceColor"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_fontAsset","t":4,"rt":$n[1].TMP_FontAsset,"sn":"m_fontAsset"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_fontColor","t":4,"rt":$n[2].Color,"sn":"m_fontColor"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_fontColor32","t":4,"rt":$n[2].Color32,"sn":"m_fontColor32"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_fontColorGradient","t":4,"rt":$n[1].VertexGradient,"sn":"m_fontColorGradient"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_fontColorGradientPreset","t":4,"rt":$n[1].TMP_ColorGradient,"sn":"m_fontColorGradientPreset"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_fontMaterial","t":4,"rt":$n[2].Material,"sn":"m_fontMaterial"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_fontMaterials","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"m_fontMaterials"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_fontSharedMaterials","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"m_fontSharedMaterials"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_fontSize","t":4,"rt":$n[0].Single,"sn":"m_fontSize","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_fontSizeBase","t":4,"rt":$n[0].Single,"sn":"m_fontSizeBase","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_fontSizeMax","t":4,"rt":$n[0].Single,"sn":"m_fontSizeMax","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_fontSizeMin","t":4,"rt":$n[0].Single,"sn":"m_fontSizeMin","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_fontStyle","t":4,"rt":$n[1].FontStyles,"sn":"m_fontStyle","box":function ($v) { return Bridge.box($v, TMPro.FontStyles, System.Enum.toStringFn(TMPro.FontStyles));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_fontWeight","t":4,"rt":$n[1].FontWeight,"sn":"m_fontWeight","box":function ($v) { return Bridge.box($v, TMPro.FontWeight, System.Enum.toStringFn(TMPro.FontWeight));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_geometrySortingOrder","t":4,"rt":$n[1].VertexSortingOrder,"sn":"m_geometrySortingOrder","box":function ($v) { return Bridge.box($v, TMPro.VertexSortingOrder, System.Enum.toStringFn(TMPro.VertexSortingOrder));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_horizontalMapping","t":4,"rt":$n[1].TextureMappingOptions,"sn":"m_horizontalMapping","box":function ($v) { return Bridge.box($v, TMPro.TextureMappingOptions, System.Enum.toStringFn(TMPro.TextureMappingOptions));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_isCullingEnabled","t":4,"rt":$n[0].Boolean,"sn":"m_isCullingEnabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_isOrthographic","t":4,"rt":$n[0].Boolean,"sn":"m_isOrthographic","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_isRichText","t":4,"rt":$n[0].Boolean,"sn":"m_isRichText","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_isRightToLeft","t":4,"rt":$n[0].Boolean,"sn":"m_isRightToLeft","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_isUsingLegacyAnimationComponent","t":4,"rt":$n[0].Boolean,"sn":"m_isUsingLegacyAnimationComponent","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_isVolumetricText","t":4,"rt":$n[0].Boolean,"sn":"m_isVolumetricText","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_lineSpacing","t":4,"rt":$n[0].Single,"sn":"m_lineSpacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_lineSpacingMax","t":4,"rt":$n[0].Single,"sn":"m_lineSpacingMax","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_linkedTextComponent","t":4,"rt":$n[1].TMP_Text,"sn":"m_linkedTextComponent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_margin","t":4,"rt":$n[2].Vector4,"sn":"m_margin"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_overflowMode","t":4,"rt":$n[1].TextOverflowModes,"sn":"m_overflowMode","box":function ($v) { return Bridge.box($v, TMPro.TextOverflowModes, System.Enum.toStringFn(TMPro.TextOverflowModes));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_overrideHtmlColors","t":4,"rt":$n[0].Boolean,"sn":"m_overrideHtmlColors","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_pageToDisplay","t":4,"rt":$n[0].Int32,"sn":"m_pageToDisplay","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_paragraphSpacing","t":4,"rt":$n[0].Single,"sn":"m_paragraphSpacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_parseCtrlCharacters","t":4,"rt":$n[0].Boolean,"sn":"m_parseCtrlCharacters","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_sharedMaterial","t":4,"rt":$n[2].Material,"sn":"m_sharedMaterial"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_spriteAsset","t":4,"rt":$n[1].TMP_SpriteAsset,"sn":"m_spriteAsset"},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.TextAreaAttribute.$ctor1(5, 10)],"a":3,"n":"m_text","t":4,"rt":$n[0].String,"sn":"m_text"},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_lineJustification")],"a":3,"n":"m_textAlignment","t":4,"rt":$n[1].TextAlignmentOptions,"sn":"m_textAlignment","box":function ($v) { return Bridge.box($v, TMPro.TextAlignmentOptions, System.Enum.toStringFn(TMPro.TextAlignmentOptions));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_tintAllSprites","t":4,"rt":$n[0].Boolean,"sn":"m_tintAllSprites","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_useMaxVisibleDescender","t":4,"rt":$n[0].Boolean,"sn":"m_useMaxVisibleDescender","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_uvLineOffset","t":4,"rt":$n[0].Single,"sn":"m_uvLineOffset","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_verticalMapping","t":4,"rt":$n[1].TextureMappingOptions,"sn":"m_verticalMapping","box":function ($v) { return Bridge.box($v, TMPro.TextureMappingOptions, System.Enum.toStringFn(TMPro.TextureMappingOptions));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_wordSpacing","t":4,"rt":$n[0].Single,"sn":"m_wordSpacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_wordWrappingRatios","t":4,"rt":$n[0].Single,"sn":"m_wordWrappingRatios","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"parentLinkedComponent","t":4,"rt":$n[1].TMP_Text,"sn":"parentLinkedComponent"}]}; }, $n);
    /*TMPro.TMP_Text end.*/

    /*TMPro.TMP_Asset start.*/
    $m("TMPro.TMP_Asset", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*TMPro.TMP_Asset end.*/

    /*TMPro.TMP_TextElement start.*/
    $m("TMPro.TMP_TextElement", function () { return {"at":[new System.SerializableAttribute()],"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_ElementType","t":4,"rt":$n[1].TextElementType,"sn":"m_ElementType","box":function ($v) { return Bridge.box($v, TMPro.TextElementType, System.Enum.toStringFn(TMPro.TextElementType));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"m_GlyphIndex","t":4,"rt":$n[0].UInt32,"sn":"m_GlyphIndex","box":function ($v) { return Bridge.box($v, System.UInt32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"m_Scale","t":4,"rt":$n[0].Single,"sn":"m_Scale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"m_Unicode","t":4,"rt":$n[0].UInt32,"sn":"m_Unicode","box":function ($v) { return Bridge.box($v, System.UInt32);}}]}; }, $n);
    /*TMPro.TMP_TextElement end.*/

    /*TMPro.TMP_ColorGradient start.*/
    $m("TMPro.TMP_ColorGradient", function () { return {"at":[new System.SerializableAttribute(),new UnityEngine.ExcludeFromPresetAttribute()]}; }, $n);
    /*TMPro.TMP_ColorGradient end.*/

    /*TMPro.TMP_Dropdown start.*/
    $m("TMPro.TMP_Dropdown", function () { return {"at":[new UnityEngine.AddComponentMenu.$ctor1("UI/Dropdown - TextMeshPro", 35),new UnityEngine.RequireComponent.ctor(UnityEngine.RectTransform)],"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_AlphaFadeSpeed","t":4,"rt":$n[0].Single,"sn":"m_AlphaFadeSpeed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_CaptionImage","t":4,"rt":$n[3].Image,"sn":"m_CaptionImage"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_CaptionText","t":4,"rt":$n[1].TMP_Text,"sn":"m_CaptionText"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_ItemImage","t":4,"rt":$n[3].Image,"sn":"m_ItemImage"},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_ItemText","t":4,"rt":$n[1].TMP_Text,"sn":"m_ItemText"},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_OnValueChanged","t":4,"rt":$n[1].TMP_Dropdown.DropdownEvent,"sn":"m_OnValueChanged"},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Options","t":4,"rt":$n[1].TMP_Dropdown.OptionDataList,"sn":"m_Options"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Placeholder","t":4,"rt":$n[3].Graphic,"sn":"m_Placeholder"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Template","t":4,"rt":$n[2].RectTransform,"sn":"m_Template"},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Value","t":4,"rt":$n[0].Int32,"sn":"m_Value","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*TMPro.TMP_Dropdown end.*/

    /*TMPro.TMP_Dropdown+DropdownEvent start.*/
    $m("TMPro.TMP_Dropdown.DropdownEvent", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*TMPro.TMP_Dropdown+DropdownEvent end.*/

    /*TMPro.TMP_Dropdown+DropdownItem start.*/
    $m("TMPro.TMP_Dropdown.DropdownItem", function () { return {"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Image","t":4,"rt":$n[3].Image,"sn":"m_Image"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_RectTransform","t":4,"rt":$n[2].RectTransform,"sn":"m_RectTransform"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Text","t":4,"rt":$n[1].TMP_Text,"sn":"m_Text"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Toggle","t":4,"rt":$n[3].Toggle,"sn":"m_Toggle"}]}; }, $n);
    /*TMPro.TMP_Dropdown+DropdownItem end.*/

    /*TMPro.TMP_Dropdown+OptionData start.*/
    $m("TMPro.TMP_Dropdown.OptionData", function () { return {"at":[new System.SerializableAttribute()],"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Image","t":4,"rt":$n[2].Sprite,"sn":"m_Image"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Text","t":4,"rt":$n[0].String,"sn":"m_Text"}]}; }, $n);
    /*TMPro.TMP_Dropdown+OptionData end.*/

    /*TMPro.TMP_Dropdown+OptionDataList start.*/
    $m("TMPro.TMP_Dropdown.OptionDataList", function () { return {"at":[new System.SerializableAttribute()],"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Options","t":4,"rt":$n[4].List$1(TMPro.TMP_Dropdown.OptionData),"sn":"m_Options"}]}; }, $n);
    /*TMPro.TMP_Dropdown+OptionDataList end.*/

    /*TMPro.TMP_FontFeatureTable start.*/
    $m("TMPro.TMP_FontFeatureTable", function () { return {"at":[new System.SerializableAttribute()],"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"m_GlyphPairAdjustmentRecords","t":4,"rt":$n[4].List$1(TMPro.TMP_GlyphPairAdjustmentRecord),"sn":"m_GlyphPairAdjustmentRecords"}]}; }, $n);
    /*TMPro.TMP_FontFeatureTable end.*/

    /*TMPro.TMP_FontWeightPair start.*/
    $m("TMPro.TMP_FontWeightPair", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*TMPro.TMP_FontWeightPair end.*/

    /*TMPro.TMP_TextElement_Legacy start.*/
    $m("TMPro.TMP_TextElement_Legacy", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*TMPro.TMP_TextElement_Legacy end.*/

    /*TMPro.TMP_GlyphAdjustmentRecord start.*/
    $m("TMPro.TMP_GlyphAdjustmentRecord", function () { return {"at":[new System.SerializableAttribute()],"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"m_GlyphIndex","t":4,"rt":$n[0].UInt32,"sn":"m_GlyphIndex","box":function ($v) { return Bridge.box($v, System.UInt32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"m_GlyphValueRecord","t":4,"rt":$n[1].TMP_GlyphValueRecord,"sn":"m_GlyphValueRecord"}]}; }, $n);
    /*TMPro.TMP_GlyphAdjustmentRecord end.*/

    /*TMPro.TMP_GlyphPairAdjustmentRecord start.*/
    $m("TMPro.TMP_GlyphPairAdjustmentRecord", function () { return {"at":[new System.SerializableAttribute()],"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"m_FeatureLookupFlags","t":4,"rt":$n[1].FontFeatureLookupFlags,"sn":"m_FeatureLookupFlags","box":function ($v) { return Bridge.box($v, TMPro.FontFeatureLookupFlags, System.Enum.toStringFn(TMPro.FontFeatureLookupFlags));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"m_FirstAdjustmentRecord","t":4,"rt":$n[1].TMP_GlyphAdjustmentRecord,"sn":"m_FirstAdjustmentRecord"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"m_SecondAdjustmentRecord","t":4,"rt":$n[1].TMP_GlyphAdjustmentRecord,"sn":"m_SecondAdjustmentRecord"}]}; }, $n);
    /*TMPro.TMP_GlyphPairAdjustmentRecord end.*/

    /*TMPro.TMP_GlyphValueRecord start.*/
    $m("TMPro.TMP_GlyphValueRecord", function () { return {"at":[new System.SerializableAttribute()],"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"m_XAdvance","t":4,"rt":$n[0].Single,"sn":"m_XAdvance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"m_XPlacement","t":4,"rt":$n[0].Single,"sn":"m_XPlacement","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"m_YAdvance","t":4,"rt":$n[0].Single,"sn":"m_YAdvance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"m_YPlacement","t":4,"rt":$n[0].Single,"sn":"m_YPlacement","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*TMPro.TMP_GlyphValueRecord end.*/

    /*TMPro.TMP_InputField start.*/
    $m("TMPro.TMP_InputField", function () { return {"at":[new UnityEngine.AddComponentMenu.$ctor1("UI/TextMeshPro - Input Field", 11)],"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_AsteriskChar","t":4,"rt":$n[0].Char,"sn":"m_AsteriskChar","box":function ($v) { return Bridge.box($v, System.Char, String.fromCharCode, System.Char.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.RangeAttribute(0.0, 4.0)],"a":1,"n":"m_CaretBlinkRate","t":4,"rt":$n[0].Single,"sn":"m_CaretBlinkRate","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_CaretColor","t":4,"rt":$n[2].Color,"sn":"m_CaretColor"},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.RangeAttribute(1.0, 5.0)],"a":1,"n":"m_CaretWidth","t":4,"rt":$n[0].Int32,"sn":"m_CaretWidth","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_CharacterLimit","t":4,"rt":$n[0].Int32,"sn":"m_CharacterLimit","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_CharacterValidation","t":4,"rt":$n[1].TMP_InputField.CharacterValidation,"sn":"m_CharacterValidation","box":function ($v) { return Bridge.box($v, TMPro.TMP_InputField.CharacterValidation, System.Enum.toStringFn(TMPro.TMP_InputField.CharacterValidation));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_ContentType","t":4,"rt":$n[1].TMP_InputField.ContentType,"sn":"m_ContentType","box":function ($v) { return Bridge.box($v, TMPro.TMP_InputField.ContentType, System.Enum.toStringFn(TMPro.TMP_InputField.ContentType));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_CustomCaretColor","t":4,"rt":$n[0].Boolean,"sn":"m_CustomCaretColor","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_GlobalFontAsset","t":4,"rt":$n[1].TMP_FontAsset,"sn":"m_GlobalFontAsset"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_GlobalPointSize","t":4,"rt":$n[0].Single,"sn":"m_GlobalPointSize","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_HideMobileInput","t":4,"rt":$n[0].Boolean,"sn":"m_HideMobileInput","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_HideSoftKeyboard","t":4,"rt":$n[0].Boolean,"sn":"m_HideSoftKeyboard","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_InputType","t":4,"rt":$n[1].TMP_InputField.InputType,"sn":"m_InputType","box":function ($v) { return Bridge.box($v, TMPro.TMP_InputField.InputType, System.Enum.toStringFn(TMPro.TMP_InputField.InputType));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_InputValidator","t":4,"rt":$n[1].TMP_InputValidator,"sn":"m_InputValidator"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_KeyboardType","t":4,"rt":$n[2].TouchScreenKeyboardType,"sn":"m_KeyboardType","box":function ($v) { return Bridge.box($v, UnityEngine.TouchScreenKeyboardType, System.Enum.toStringFn(UnityEngine.TouchScreenKeyboardType));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_LayoutGroup","t":4,"rt":$n[3].LayoutGroup,"sn":"m_LayoutGroup"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_LineLimit","t":4,"rt":$n[0].Int32,"sn":"m_LineLimit","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_LineType","t":4,"rt":$n[1].TMP_InputField.LineType,"sn":"m_LineType","box":function ($v) { return Bridge.box($v, TMPro.TMP_InputField.LineType, System.Enum.toStringFn(TMPro.TMP_InputField.LineType));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_OnDeselect","t":4,"rt":$n[1].TMP_InputField.SelectionEvent,"sn":"m_OnDeselect"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_OnEndEdit","t":4,"rt":$n[1].TMP_InputField.SubmitEvent,"sn":"m_OnEndEdit"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_OnEndTextSelection","t":4,"rt":$n[1].TMP_InputField.TextSelectionEvent,"sn":"m_OnEndTextSelection"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_OnFocusSelectAll","t":4,"rt":$n[0].Boolean,"sn":"m_OnFocusSelectAll","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_OnSelect","t":4,"rt":$n[1].TMP_InputField.SelectionEvent,"sn":"m_OnSelect"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_OnSubmit","t":4,"rt":$n[1].TMP_InputField.SubmitEvent,"sn":"m_OnSubmit"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_OnTextSelection","t":4,"rt":$n[1].TMP_InputField.TextSelectionEvent,"sn":"m_OnTextSelection"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_OnTouchScreenKeyboardStatusChanged","t":4,"rt":$n[1].TMP_InputField.TouchScreenKeyboardEvent,"sn":"m_OnTouchScreenKeyboardStatusChanged"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_OnValidateInput","t":4,"rt":Function,"sn":"m_OnValidateInput"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_OnValueChanged","t":4,"rt":$n[1].TMP_InputField.OnChangeEvent,"sn":"m_OnValueChanged"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_Placeholder","t":4,"rt":$n[3].Graphic,"sn":"m_Placeholder"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_ReadOnly","t":4,"rt":$n[0].Boolean,"sn":"m_ReadOnly","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_RegexValue","t":4,"rt":$n[0].String,"sn":"m_RegexValue"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_ResetOnDeActivation","t":4,"rt":$n[0].Boolean,"sn":"m_ResetOnDeActivation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_RestoreOriginalTextOnEscape","t":4,"rt":$n[0].Boolean,"sn":"m_RestoreOriginalTextOnEscape","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_RichText","t":4,"rt":$n[0].Boolean,"sn":"m_RichText","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_ScrollSensitivity","t":4,"rt":$n[0].Single,"sn":"m_ScrollSensitivity","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_SelectionColor","t":4,"rt":$n[2].Color,"sn":"m_SelectionColor"},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.TextAreaAttribute.$ctor1(5, 10)],"a":3,"n":"m_Text","t":4,"rt":$n[0].String,"sn":"m_Text"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_TextComponent","t":4,"rt":$n[1].TMP_Text,"sn":"m_TextComponent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_TextViewport","t":4,"rt":$n[2].RectTransform,"sn":"m_TextViewport"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_VerticalScrollbar","t":4,"rt":$n[3].Scrollbar,"sn":"m_VerticalScrollbar"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_VerticalScrollbarEventHandler","t":4,"rt":$n[1].TMP_ScrollbarEventHandler,"sn":"m_VerticalScrollbarEventHandler"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_isRichTextEditingAllowed","t":4,"rt":$n[0].Boolean,"sn":"m_isRichTextEditingAllowed","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*TMPro.TMP_InputField end.*/

    /*TMPro.TMP_InputField+OnChangeEvent start.*/
    $m("TMPro.TMP_InputField.OnChangeEvent", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*TMPro.TMP_InputField+OnChangeEvent end.*/

    /*TMPro.TMP_InputField+SelectionEvent start.*/
    $m("TMPro.TMP_InputField.SelectionEvent", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*TMPro.TMP_InputField+SelectionEvent end.*/

    /*TMPro.TMP_InputField+SubmitEvent start.*/
    $m("TMPro.TMP_InputField.SubmitEvent", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*TMPro.TMP_InputField+SubmitEvent end.*/

    /*TMPro.TMP_InputField+TextSelectionEvent start.*/
    $m("TMPro.TMP_InputField.TextSelectionEvent", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*TMPro.TMP_InputField+TextSelectionEvent end.*/

    /*TMPro.TMP_InputField+TouchScreenKeyboardEvent start.*/
    $m("TMPro.TMP_InputField.TouchScreenKeyboardEvent", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*TMPro.TMP_InputField+TouchScreenKeyboardEvent end.*/

    /*TMPro.TMP_InputValidator start.*/
    $m("TMPro.TMP_InputValidator", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*TMPro.TMP_InputValidator end.*/

    /*TMPro.TMP_SelectionCaret start.*/
    $m("TMPro.TMP_SelectionCaret", function () { return {"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.CanvasRenderer)]}; }, $n);
    /*TMPro.TMP_SelectionCaret end.*/

    /*TMPro.TMP_Settings start.*/
    $m("TMPro.TMP_Settings", function () { return {"at":[new System.SerializableAttribute(),new UnityEngine.ExcludeFromPresetAttribute()],"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_EnableRaycastTarget","t":4,"rt":$n[0].Boolean,"sn":"m_EnableRaycastTarget","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_GetFontFeaturesAtRuntime","t":4,"rt":$n[0].Boolean,"sn":"m_GetFontFeaturesAtRuntime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_IsTextObjectScaleStatic","t":4,"rt":$n[0].Boolean,"sn":"m_IsTextObjectScaleStatic","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_MissingCharacterSpriteUnicode","t":4,"rt":$n[0].UInt32,"sn":"m_MissingCharacterSpriteUnicode","box":function ($v) { return Bridge.box($v, System.UInt32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_StyleSheetsResourcePath","t":4,"rt":$n[0].String,"sn":"m_StyleSheetsResourcePath"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_UseModernHangulLineBreakingRules","t":4,"rt":$n[0].Boolean,"sn":"m_UseModernHangulLineBreakingRules","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_autoSizeTextContainer","t":4,"rt":$n[0].Boolean,"sn":"m_autoSizeTextContainer","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_defaultAutoSizeMaxRatio","t":4,"rt":$n[0].Single,"sn":"m_defaultAutoSizeMaxRatio","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_defaultAutoSizeMinRatio","t":4,"rt":$n[0].Single,"sn":"m_defaultAutoSizeMinRatio","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_defaultColorGradientPresetsPath","t":4,"rt":$n[0].String,"sn":"m_defaultColorGradientPresetsPath"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_defaultFontAsset","t":4,"rt":$n[1].TMP_FontAsset,"sn":"m_defaultFontAsset"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_defaultFontAssetPath","t":4,"rt":$n[0].String,"sn":"m_defaultFontAssetPath"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_defaultFontSize","t":4,"rt":$n[0].Single,"sn":"m_defaultFontSize","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_defaultSpriteAsset","t":4,"rt":$n[1].TMP_SpriteAsset,"sn":"m_defaultSpriteAsset"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_defaultSpriteAssetPath","t":4,"rt":$n[0].String,"sn":"m_defaultSpriteAssetPath"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_defaultStyleSheet","t":4,"rt":$n[1].TMP_StyleSheet,"sn":"m_defaultStyleSheet"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_defaultTextMeshProTextContainerSize","t":4,"rt":$n[2].Vector2,"sn":"m_defaultTextMeshProTextContainerSize"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_defaultTextMeshProUITextContainerSize","t":4,"rt":$n[2].Vector2,"sn":"m_defaultTextMeshProUITextContainerSize"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_enableEmojiSupport","t":4,"rt":$n[0].Boolean,"sn":"m_enableEmojiSupport","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_enableExtraPadding","t":4,"rt":$n[0].Boolean,"sn":"m_enableExtraPadding","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_enableKerning","t":4,"rt":$n[0].Boolean,"sn":"m_enableKerning","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_enableParseEscapeCharacters","t":4,"rt":$n[0].Boolean,"sn":"m_enableParseEscapeCharacters","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_enableTintAllSprites","t":4,"rt":$n[0].Boolean,"sn":"m_enableTintAllSprites","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_enableWordWrapping","t":4,"rt":$n[0].Boolean,"sn":"m_enableWordWrapping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_fallbackFontAssets","t":4,"rt":$n[4].List$1(TMPro.TMP_FontAsset),"sn":"m_fallbackFontAssets"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_followingCharacters","t":4,"rt":$n[2].TextAsset,"sn":"m_followingCharacters"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_leadingCharacters","t":4,"rt":$n[2].TextAsset,"sn":"m_leadingCharacters"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_linebreakingRules","t":4,"rt":$n[1].TMP_Settings.LineBreakingTable,"sn":"m_linebreakingRules"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_matchMaterialPreset","t":4,"rt":$n[0].Boolean,"sn":"m_matchMaterialPreset","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_missingGlyphCharacter","t":4,"rt":$n[0].Int32,"sn":"m_missingGlyphCharacter","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_warningsDisabled","t":4,"rt":$n[0].Boolean,"sn":"m_warningsDisabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*TMPro.TMP_Settings end.*/

    /*TMPro.TMP_SpriteAnimator start.*/
    $m("TMPro.TMP_SpriteAnimator", function () { return {"at":[new UnityEngine.DisallowMultipleComponent()]}; }, $n);
    /*TMPro.TMP_SpriteAnimator end.*/

    /*TMPro.TMP_SpriteGlyph start.*/
    $m("TMPro.TMP_SpriteGlyph", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*TMPro.TMP_SpriteGlyph end.*/

    /*TMPro.TMP_Style start.*/
    $m("TMPro.TMP_Style", function () { return {"at":[new System.SerializableAttribute()],"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_ClosingDefinition","t":4,"rt":$n[0].String,"sn":"m_ClosingDefinition"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_ClosingTagArray","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"m_ClosingTagArray"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"m_ClosingTagUnicodeArray","t":4,"rt":$n[0].Array.type(System.UInt32),"sn":"m_ClosingTagUnicodeArray"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_HashCode","t":4,"rt":$n[0].Int32,"sn":"m_HashCode","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Name","t":4,"rt":$n[0].String,"sn":"m_Name"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_OpeningDefinition","t":4,"rt":$n[0].String,"sn":"m_OpeningDefinition"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_OpeningTagArray","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"m_OpeningTagArray"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"m_OpeningTagUnicodeArray","t":4,"rt":$n[0].Array.type(System.UInt32),"sn":"m_OpeningTagUnicodeArray"}]}; }, $n);
    /*TMPro.TMP_Style end.*/

    /*TMPro.TMP_StyleSheet start.*/
    $m("TMPro.TMP_StyleSheet", function () { return {"at":[new System.SerializableAttribute(),new UnityEngine.ExcludeFromPresetAttribute()],"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_StyleList","t":4,"rt":$n[4].List$1(TMPro.TMP_Style),"sn":"m_StyleList"}]}; }, $n);
    /*TMPro.TMP_StyleSheet end.*/

    /*TMPro.TMP_SubMesh start.*/
    $m("TMPro.TMP_SubMesh", function () { return {"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.MeshRenderer),new UnityEngine.ExecuteAlwaysAttribute()],"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_TextComponent","t":4,"rt":$n[1].TextMeshPro,"sn":"m_TextComponent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_fontAsset","t":4,"rt":$n[1].TMP_FontAsset,"sn":"m_fontAsset"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_isDefaultMaterial","t":4,"rt":$n[0].Boolean,"sn":"m_isDefaultMaterial","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_material","t":4,"rt":$n[2].Material,"sn":"m_material"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_padding","t":4,"rt":$n[0].Single,"sn":"m_padding","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_renderer","t":4,"rt":$n[2].Renderer,"sn":"m_renderer"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_sharedMaterial","t":4,"rt":$n[2].Material,"sn":"m_sharedMaterial"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_spriteAsset","t":4,"rt":$n[1].TMP_SpriteAsset,"sn":"m_spriteAsset"}]}; }, $n);
    /*TMPro.TMP_SubMesh end.*/

    /*TMPro.TMP_SubMeshUI start.*/
    $m("TMPro.TMP_SubMeshUI", function () { return {"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(UnityEngine.CanvasRenderer)],"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_TextComponent","t":4,"rt":$n[1].TextMeshProUGUI,"sn":"m_TextComponent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_fontAsset","t":4,"rt":$n[1].TMP_FontAsset,"sn":"m_fontAsset"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_isDefaultMaterial","t":4,"rt":$n[0].Boolean,"sn":"m_isDefaultMaterial","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_material","t":4,"rt":$n[2].Material,"sn":"m_material"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_materialReferenceIndex","t":4,"rt":$n[0].Int32,"sn":"m_materialReferenceIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_padding","t":4,"rt":$n[0].Single,"sn":"m_padding","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_sharedMaterial","t":4,"rt":$n[2].Material,"sn":"m_sharedMaterial"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_spriteAsset","t":4,"rt":$n[1].TMP_SpriteAsset,"sn":"m_spriteAsset"}]}; }, $n);
    /*TMPro.TMP_SubMeshUI end.*/

    /*TMPro.TMP_TextInfo start.*/
    $m("TMPro.TMP_TextInfo", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*TMPro.TMP_TextInfo end.*/

    /*TMPro.VertexGradient start.*/
    $m("TMPro.VertexGradient", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*TMPro.VertexGradient end.*/

    /*TMPro.TextMeshPro start.*/
    $m("TMPro.TextMeshPro", function () { return {"at":[new UnityEngine.DisallowMultipleComponent(),new UnityEngine.RequireComponent.ctor(UnityEngine.MeshRenderer),new UnityEngine.AddComponentMenu.ctor("Mesh/TextMeshPro - Text"),new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("https://docs.unity3d.com/Packages/com.unity.textmeshpro@3.0")],"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"_SortingLayer","t":4,"rt":$n[0].Int32,"sn":"_SortingLayer","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"_SortingLayerID","t":4,"rt":$n[0].Int32,"sn":"_SortingLayerID","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"_SortingOrder","t":4,"rt":$n[0].Int32,"sn":"_SortingOrder","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_hasFontAssetChanged","t":4,"rt":$n[0].Boolean,"sn":"m_hasFontAssetChanged","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_maskType","t":4,"rt":$n[1].MaskingTypes,"sn":"m_maskType","box":function ($v) { return Bridge.box($v, TMPro.MaskingTypes, System.Enum.toStringFn(TMPro.MaskingTypes));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_renderer","t":4,"rt":$n[2].Renderer,"sn":"m_renderer"}]}; }, $n);
    /*TMPro.TextMeshPro end.*/

    /*TMPro.TextMeshProUGUI start.*/
    $m("TMPro.TextMeshProUGUI", function () { return {"at":[new UnityEngine.DisallowMultipleComponent(),new UnityEngine.RequireComponent.ctor(UnityEngine.RectTransform),new UnityEngine.RequireComponent.ctor(UnityEngine.CanvasRenderer),new UnityEngine.AddComponentMenu.$ctor1("UI/TextMeshPro - Text (UI)", 11),new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("https://docs.unity3d.com/Packages/com.unity.textmeshpro@3.0")],"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_baseMaterial","t":4,"rt":$n[2].Material,"sn":"m_baseMaterial"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_hasFontAssetChanged","t":4,"rt":$n[0].Boolean,"sn":"m_hasFontAssetChanged","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_maskOffset","t":4,"rt":$n[2].Vector4,"sn":"m_maskOffset"}]}; }, $n);
    /*TMPro.TextMeshProUGUI end.*/

    /*TMPro.TMP_Character start.*/
    $m("TMPro.TMP_Character", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*TMPro.TMP_Character end.*/

    /*TMPro.TMP_FontAsset start.*/
    $m("TMPro.TMP_FontAsset", function () { return {"at":[new System.SerializableAttribute(),new UnityEngine.ExcludeFromPresetAttribute()],"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":2,"n":"atlas","t":4,"rt":$n[2].Texture2D,"sn":"atlas"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"fallbackFontAssets","t":4,"rt":$n[4].List$1(TMPro.TMP_FontAsset),"sn":"fallbackFontAssets"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"fontWeights","t":4,"rt":System.Array.type(TMPro.TMP_FontWeightPair),"sn":"fontWeights"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"m_AtlasHeight","t":4,"rt":$n[0].Int32,"sn":"m_AtlasHeight","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"m_AtlasPadding","t":4,"rt":$n[0].Int32,"sn":"m_AtlasPadding","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_AtlasPopulationMode","t":4,"rt":$n[1].AtlasPopulationMode,"sn":"m_AtlasPopulationMode","box":function ($v) { return Bridge.box($v, TMPro.AtlasPopulationMode, System.Enum.toStringFn(TMPro.AtlasPopulationMode));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"m_AtlasRenderMode","t":4,"rt":$n[5].GlyphRenderMode,"sn":"m_AtlasRenderMode","box":function ($v) { return Bridge.box($v, UnityEngine.TextCore.LowLevel.GlyphRenderMode, System.Enum.toStringFn(UnityEngine.TextCore.LowLevel.GlyphRenderMode));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"m_AtlasTextureIndex","t":4,"rt":$n[0].Int32,"sn":"m_AtlasTextureIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"m_AtlasTextures","t":4,"rt":System.Array.type(UnityEngine.Texture2D),"sn":"m_AtlasTextures"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"m_AtlasWidth","t":4,"rt":$n[0].Int32,"sn":"m_AtlasWidth","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"m_CharacterTable","t":4,"rt":$n[4].List$1(TMPro.TMP_Character),"sn":"m_CharacterTable"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_ClearDynamicDataOnBuild","t":4,"rt":$n[0].Boolean,"sn":"m_ClearDynamicDataOnBuild","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"m_CreationSettings","t":4,"rt":$n[1].FontAssetCreationSettings,"sn":"m_CreationSettings"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"m_FaceInfo","t":4,"rt":$n[6].FaceInfo,"sn":"m_FaceInfo"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"m_FallbackFontAssetTable","t":4,"rt":$n[4].List$1(TMPro.TMP_FontAsset),"sn":"m_FallbackFontAssetTable"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"m_FontFeatureTable","t":4,"rt":$n[1].TMP_FontFeatureTable,"sn":"m_FontFeatureTable"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_FontWeightTable","t":4,"rt":System.Array.type(TMPro.TMP_FontWeightPair),"sn":"m_FontWeightTable"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_FreeGlyphRects","t":4,"rt":$n[4].List$1(UnityEngine.TextCore.GlyphRect),"sn":"m_FreeGlyphRects"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"m_GlyphTable","t":4,"rt":$n[4].List$1(UnityEngine.TextCore.Glyph),"sn":"m_GlyphTable"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_IsMultiAtlasTexturesEnabled","t":4,"rt":$n[0].Boolean,"sn":"m_IsMultiAtlasTexturesEnabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_kerningInfo")],"a":4,"n":"m_KerningTable","t":4,"rt":$n[1].KerningTable,"sn":"m_KerningTable"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_SourceFontFile","t":4,"rt":$n[2].Font,"sn":"m_SourceFontFile"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"m_SourceFontFileGUID","t":4,"rt":$n[0].String,"sn":"m_SourceFontFileGUID"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_UsedGlyphRects","t":4,"rt":$n[4].List$1(UnityEngine.TextCore.GlyphRect),"sn":"m_UsedGlyphRects"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Version","t":4,"rt":$n[0].String,"sn":"m_Version"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_fontInfo","t":4,"rt":$n[1].FaceInfo_Legacy,"sn":"m_fontInfo"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"m_glyphInfoList","t":4,"rt":$n[4].List$1(TMPro.TMP_Glyph),"sn":"m_glyphInfoList"}]}; }, $n);
    /*TMPro.TMP_FontAsset end.*/

    /*TMPro.TMP_Glyph start.*/
    $m("TMPro.TMP_Glyph", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*TMPro.TMP_Glyph end.*/

    /*TMPro.TMP_Sprite start.*/
    $m("TMPro.TMP_Sprite", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*TMPro.TMP_Sprite end.*/

    /*TMPro.TMP_SpriteAsset start.*/
    $m("TMPro.TMP_SpriteAsset", function () { return {"at":[new UnityEngine.ExcludeFromPresetAttribute()],"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":2,"n":"fallbackSpriteAssets","t":4,"rt":$n[4].List$1(TMPro.TMP_SpriteAsset),"sn":"fallbackSpriteAssets"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":4,"n":"m_FaceInfo","t":4,"rt":$n[6].FaceInfo,"sn":"m_FaceInfo"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_SpriteCharacterTable","t":4,"rt":$n[4].List$1(TMPro.TMP_SpriteCharacter),"sn":"m_SpriteCharacterTable"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_SpriteGlyphTable","t":4,"rt":$n[4].List$1(TMPro.TMP_SpriteGlyph),"sn":"m_SpriteGlyphTable"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Version","t":4,"rt":$n[0].String,"sn":"m_Version"}]}; }, $n);
    /*TMPro.TMP_SpriteAsset end.*/

    /*TMPro.TMP_SpriteCharacter start.*/
    $m("TMPro.TMP_SpriteCharacter", function () { return {"at":[new System.SerializableAttribute()],"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_HashCode","t":4,"rt":$n[0].Int32,"sn":"m_HashCode","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Name","t":4,"rt":$n[0].String,"sn":"m_Name"}]}; }, $n);
    /*TMPro.TMP_SpriteCharacter end.*/

    }});
