if ( TRACE ) { TRACE( JSON.parse( '["UnityEngine.EventSystems.AbstractEventData#used#get","UnityEngine.EventSystems.AbstractEventData#Reset","UnityEngine.EventSystems.AbstractEventData#Use","UnityEngine.EventSystems.UIBehaviour#ctor","UnityEngine.EventSystems.UIBehaviour#$ctor1","UnityEngine.EventSystems.UIBehaviour#IsActive","UnityEngine.EventSystems.UIBehaviour#Awake","UnityEngine.EventSystems.UIBehaviour#OnEnable","UnityEngine.EventSystems.UIBehaviour#OnDisable","UnityEngine.EventSystems.UIBehaviour#OnRectTransformDimensionsChange","UnityEngine.EventSystems.UIBehaviour#OnTransformParentChanged","UnityEngine.EventSystems.UIBehaviour#OnDestroy","UnityEngine.EventSystems.UIBehaviour#Start","UnityEngine.EventSystems.UIBehaviour#OnDidApplyAnimationProperties","UnityEngine.EventSystems.UIBehaviour#ConfigureForEntity","UnityEngine.EventSystems.UIBehaviour#OnCanvasHierarchyChanged","UnityEngine.EventSystems.UIBehaviour#OnCanvasGroupChanged","UnityEngine.EventSystems.UIBehaviour#IsDestroyed","UnityEngine.EventSystems.EventTrigger.Entry#init","UnityEngine.EventSystems.EventTrigger.Entry#ctor","UnityEngine.EventSystems.ExecuteEvents#pointerEnterHandler#get","UnityEngine.EventSystems.ExecuteEvents#pointerExitHandler#get","UnityEngine.EventSystems.ExecuteEvents#pointerDownHandler#get","UnityEngine.EventSystems.ExecuteEvents#pointerUpHandler#get","UnityEngine.EventSystems.ExecuteEvents#pointerClickHandler#get","UnityEngine.EventSystems.ExecuteEvents#initializePotentialDrag#get","UnityEngine.EventSystems.ExecuteEvents#beginDragHandler#get","UnityEngine.EventSystems.ExecuteEvents#dragHandler#get","UnityEngine.EventSystems.ExecuteEvents#endDragHandler#get","UnityEngine.EventSystems.ExecuteEvents#dropHandler#get","UnityEngine.EventSystems.ExecuteEvents#scrollHandler#get","UnityEngine.EventSystems.ExecuteEvents#updateSelectedHandler#get","UnityEngine.EventSystems.ExecuteEvents#selectHandler#get","UnityEngine.EventSystems.ExecuteEvents#deselectHandler#get","UnityEngine.EventSystems.ExecuteEvents#moveHandler#get","UnityEngine.EventSystems.ExecuteEvents#submitHandler#get","UnityEngine.EventSystems.ExecuteEvents#cancelHandler#get","UnityEngine.EventSystems.ExecuteEvents#init","UnityEngine.EventSystems.ExecuteEvents#ValidateEventData","UnityEngine.EventSystems.ExecuteEvents#Execute$11","UnityEngine.EventSystems.ExecuteEvents#Execute$12","UnityEngine.EventSystems.ExecuteEvents#Execute$10","UnityEngine.EventSystems.ExecuteEvents#Execute$13","UnityEngine.EventSystems.ExecuteEvents#Execute$9","UnityEngine.EventSystems.ExecuteEvents#Execute$7","UnityEngine.EventSystems.ExecuteEvents#Execute$1","UnityEngine.EventSystems.ExecuteEvents#Execute$4","UnityEngine.EventSystems.ExecuteEvents#Execute$6","UnityEngine.EventSystems.ExecuteEvents#Execute$5","UnityEngine.EventSystems.ExecuteEvents#Execute$14","UnityEngine.EventSystems.ExecuteEvents#Execute$17","UnityEngine.EventSystems.ExecuteEvents#Execute$15","UnityEngine.EventSystems.ExecuteEvents#Execute$3","UnityEngine.EventSystems.ExecuteEvents#Execute$8","UnityEngine.EventSystems.ExecuteEvents#Execute$16","UnityEngine.EventSystems.ExecuteEvents#Execute$2","UnityEngine.EventSystems.ExecuteEvents#Execute","UnityEngine.EventSystems.ExecuteEvents#GetEventChain","UnityEngine.EventSystems.ExecuteEvents#ExecuteHierarchy","UnityEngine.EventSystems.ExecuteEvents#ShouldSendToComponent","UnityEngine.EventSystems.ExecuteEvents#GetEventList","UnityEngine.EventSystems.ExecuteEvents#CanHandleEvent","UnityEngine.EventSystems.ExecuteEvents#GetEventHandler","UnityEngine.EventSystems.PointerInputModule.ButtonState#eventData#get","UnityEngine.EventSystems.PointerInputModule.ButtonState#eventData#set","UnityEngine.EventSystems.PointerInputModule.ButtonState#button#get","UnityEngine.EventSystems.PointerInputModule.ButtonState#button#set","UnityEngine.EventSystems.PointerInputModule.ButtonState#init","UnityEngine.EventSystems.PointerInputModule.MouseButtonEventData#PressedThisFrame","UnityEngine.EventSystems.PointerInputModule.MouseButtonEventData#ReleasedThisFrame","UnityEngine.EventSystems.PointerInputModule.MouseState#init","UnityEngine.EventSystems.PointerInputModule.MouseState#AnyPressesThisFrame","UnityEngine.EventSystems.PointerInputModule.MouseState#AnyReleasesThisFrame","UnityEngine.EventSystems.PointerInputModule.MouseState#GetButtonState","UnityEngine.EventSystems.PointerInputModule.MouseState#SetButtonState","UnityEngine.EventSystems.RaycasterManager#init","UnityEngine.EventSystems.RaycasterManager#AddRaycaster","UnityEngine.EventSystems.RaycasterManager#GetRaycasters","UnityEngine.EventSystems.RaycasterManager#RemoveRaycasters","UnityEngine.EventSystems.RaycastResult#getDefaultValue","UnityEngine.EventSystems.RaycastResult#isValid#get","UnityEngine.EventSystems.RaycastResult#init","UnityEngine.EventSystems.RaycastResult#ctor","UnityEngine.EventSystems.RaycastResult#Clear","UnityEngine.EventSystems.RaycastResult#SetFrom","UnityEngine.EventSystems.RaycastResult#getHashCode","UnityEngine.EventSystems.RaycastResult#equals","UnityEngine.EventSystems.RaycastResult#$clone","UnityEngine.UI.AnimationTriggers#init","UnityEngine.UI.AnimationTriggers#normalTrigger#get","UnityEngine.UI.AnimationTriggers#normalTrigger#set","UnityEngine.UI.AnimationTriggers#highlightedTrigger#get","UnityEngine.UI.AnimationTriggers#highlightedTrigger#set","UnityEngine.UI.AnimationTriggers#pressedTrigger#get","UnityEngine.UI.AnimationTriggers#pressedTrigger#set","UnityEngine.UI.AnimationTriggers#selectedTrigger#get","UnityEngine.UI.AnimationTriggers#selectedTrigger#set","UnityEngine.UI.AnimationTriggers#disabledTrigger#get","UnityEngine.UI.AnimationTriggers#disabledTrigger#set","UnityEngine.UI.AnimationTriggers#init","UnityEngine.UI.CanvasUpdateRegistry#instance#get","UnityEngine.UI.CanvasUpdateRegistry#RegisterCanvasElementForLayoutRebuild","UnityEngine.UI.CanvasUpdateRegistry#RegisterCanvasElementForGraphicRebuild","UnityEngine.UI.CanvasUpdateRegistry#UnRegisterCanvasElementForRebuild","UnityEngine.UI.CanvasUpdateRegistry#IsRebuildingLayout","UnityEngine.UI.CanvasUpdateRegistry#IsRebuildingGraphics","UnityEngine.UI.CanvasUpdateRegistry#GetKey","UnityEngine.UI.CanvasUpdateRegistry#init","UnityEngine.UI.CanvasUpdateRegistry#ctor","UnityEngine.UI.CanvasUpdateRegistry#PerformUpdate","UnityEngine.UI.CanvasUpdateRegistry#PerformLayoutRebuildPhases","UnityEngine.UI.CanvasUpdateRegistry#PerformGraphicsRebuildPhases","UnityEngine.UI.ClipperRegistry#instance#get","UnityEngine.UI.ClipperRegistry#Register","UnityEngine.UI.ClipperRegistry#Unregister","UnityEngine.UI.ClipperRegistry#init","UnityEngine.UI.ClipperRegistry#ctor","UnityEngine.UI.ClipperRegistry#Cull","UnityEngine.UI.Clipping#FindCullAndClipWorldRect","UnityEngine.UI.Collections.IndexedSet$1#Count#get","UnityEngine.UI.Collections.IndexedSet$1#IsReadOnly#get","UnityEngine.UI.Collections.IndexedSet$1#init","UnityEngine.UI.Collections.IndexedSet$1#getItem","UnityEngine.UI.Collections.IndexedSet$1#setItem","UnityEngine.UI.Collections.IndexedSet$1#add","UnityEngine.UI.Collections.IndexedSet$1#AddUnique","UnityEngine.UI.Collections.IndexedSet$1#remove","UnityEngine.UI.Collections.IndexedSet$1#GetEnumerator","UnityEngine.UI.Collections.IndexedSet$1#System$Collections$IEnumerable$GetEnumerator","UnityEngine.UI.Collections.IndexedSet$1#clear","UnityEngine.UI.Collections.IndexedSet$1#contains","UnityEngine.UI.Collections.IndexedSet$1#copyTo","UnityEngine.UI.Collections.IndexedSet$1#indexOf","UnityEngine.UI.Collections.IndexedSet$1#insert","UnityEngine.UI.Collections.IndexedSet$1#removeAt","UnityEngine.UI.Collections.IndexedSet$1#RemoveAll","UnityEngine.UI.Collections.IndexedSet$1#Sort","UnityEngine.UI.ColorBlock#inherits","UnityEngine.UI.ColorBlock#defaultColorBlock#get","UnityEngine.UI.ColorBlock#op_Equality","UnityEngine.UI.ColorBlock#op_Inequality","UnityEngine.UI.ColorBlock#getDefaultValue","UnityEngine.UI.ColorBlock#normalColor#get","UnityEngine.UI.ColorBlock#normalColor#set","UnityEngine.UI.ColorBlock#highlightedColor#get","UnityEngine.UI.ColorBlock#highlightedColor#set","UnityEngine.UI.ColorBlock#pressedColor#get","UnityEngine.UI.ColorBlock#pressedColor#set","UnityEngine.UI.ColorBlock#selectedColor#get","UnityEngine.UI.ColorBlock#selectedColor#set","UnityEngine.UI.ColorBlock#disabledColor#get","UnityEngine.UI.ColorBlock#disabledColor#set","UnityEngine.UI.ColorBlock#colorMultiplier#get","UnityEngine.UI.ColorBlock#colorMultiplier#set","UnityEngine.UI.ColorBlock#fadeDuration#get","UnityEngine.UI.ColorBlock#fadeDuration#set","UnityEngine.UI.ColorBlock#init","UnityEngine.UI.ColorBlock#ctor","UnityEngine.UI.ColorBlock#equalsT","UnityEngine.UI.ColorBlock#equals","UnityEngine.UI.ColorBlock#getHashCode","UnityEngine.UI.ColorBlock#$clone","UnityEngine.UI.DefaultControls#init","UnityEngine.UI.DefaultControls#CreateUIElementRoot","UnityEngine.UI.DefaultControls#CreateUIObject","UnityEngine.UI.DefaultControls#SetDefaultTextValues","UnityEngine.UI.DefaultControls#SetDefaultColorTransitionValues","UnityEngine.UI.DefaultControls#SetParentAndAlign","UnityEngine.UI.DefaultControls#SetLayerRecursively","UnityEngine.UI.DefaultControls#CreatePanel","UnityEngine.UI.DefaultControls#CreateButton","UnityEngine.UI.DefaultControls#CreateText","UnityEngine.UI.DefaultControls#CreateImage","UnityEngine.UI.DefaultControls#CreateRawImage","UnityEngine.UI.DefaultControls#CreateSlider","UnityEngine.UI.DefaultControls#CreateScrollbar","UnityEngine.UI.DefaultControls#CreateToggle","UnityEngine.UI.DefaultControls#CreateInputField","UnityEngine.UI.DefaultControls#CreateDropdown","UnityEngine.UI.DefaultControls#CreateScrollView","UnityEngine.UI.DefaultControls.Resources#getDefaultValue","UnityEngine.UI.DefaultControls.Resources#ctor","UnityEngine.UI.DefaultControls.Resources#getHashCode","UnityEngine.UI.DefaultControls.Resources#equals","UnityEngine.UI.DefaultControls.Resources#$clone","UnityEngine.UI.Dropdown.OptionData#text#get","UnityEngine.UI.Dropdown.OptionData#text#set","UnityEngine.UI.Dropdown.OptionData#image#get","UnityEngine.UI.Dropdown.OptionData#image#set","UnityEngine.UI.Dropdown.OptionData#ctor","UnityEngine.UI.Dropdown.OptionData#$ctor1","UnityEngine.UI.Dropdown.OptionData#$ctor3","UnityEngine.UI.Dropdown.OptionData#$ctor2","UnityEngine.UI.Dropdown.OptionDataList#options#get","UnityEngine.UI.Dropdown.OptionDataList#options#set","UnityEngine.UI.Dropdown.OptionDataList#ctor","UnityEngine.UI.FontData#defaultFontData#get","UnityEngine.UI.FontData#font#get","UnityEngine.UI.FontData#font#set","UnityEngine.UI.FontData#fontSize#get","UnityEngine.UI.FontData#fontSize#set","UnityEngine.UI.FontData#fontStyle#get","UnityEngine.UI.FontData#fontStyle#set","UnityEngine.UI.FontData#bestFit#get","UnityEngine.UI.FontData#bestFit#set","UnityEngine.UI.FontData#minSize#get","UnityEngine.UI.FontData#minSize#set","UnityEngine.UI.FontData#maxSize#get","UnityEngine.UI.FontData#maxSize#set","UnityEngine.UI.FontData#alignment#get","UnityEngine.UI.FontData#alignment#set","UnityEngine.UI.FontData#alignByGeometry#get","UnityEngine.UI.FontData#alignByGeometry#set","UnityEngine.UI.FontData#richText#get","UnityEngine.UI.FontData#richText#set","UnityEngine.UI.FontData#horizontalOverflow#get","UnityEngine.UI.FontData#horizontalOverflow#set","UnityEngine.UI.FontData#verticalOverflow#get","UnityEngine.UI.FontData#verticalOverflow#set","UnityEngine.UI.FontData#lineSpacing#get","UnityEngine.UI.FontData#lineSpacing#set","UnityEngine.UI.GraphicRegistry#init","UnityEngine.UI.GraphicRegistry#RegisterGraphicForCanvas","UnityEngine.UI.GraphicRegistry#UnregisterGraphicForCanvas","UnityEngine.UI.GraphicRegistry#GetGraphicsForCanvas","UnityEngine.UI.GraphicRegistry#GetGraphicsForCanvasInternal","UnityEngine.UI.GraphicRegistry#UnregisterGraphicsEverywhere","UnityEngine.UI.GraphicRegistry#init","UnityEngine.UI.GraphicRegistry#ctor","UnityEngine.UI.LayoutUtility#GetMinSize","UnityEngine.UI.LayoutUtility#GetPreferredSize","UnityEngine.UI.LayoutUtility#GetFlexibleSize","UnityEngine.UI.LayoutUtility#GetMinWidth","UnityEngine.UI.LayoutUtility#GetPreferredWidth","UnityEngine.UI.LayoutUtility#GetFlexibleWidth","UnityEngine.UI.LayoutUtility#GetMinHeight","UnityEngine.UI.LayoutUtility#GetPreferredHeight","UnityEngine.UI.LayoutUtility#GetFlexibleHeight","UnityEngine.UI.LayoutUtility#GetLayoutProperty","UnityEngine.UI.LayoutUtility#GetLayoutProperty$1","UnityEngine.UI.ListPool$1#init","UnityEngine.UI.ListPool$1#Clear","UnityEngine.UI.ListPool$1#Get","UnityEngine.UI.ListPool$1#Release","UnityEngine.UI.MaskUtilities#Notify2DMaskStateChanged","UnityEngine.UI.MaskUtilities#NotifyStencilStateChanged","UnityEngine.UI.MaskUtilities#FindRootSortOverrideCanvas","UnityEngine.UI.MaskUtilities#GetStencilDepth","UnityEngine.UI.MaskUtilities#IsDescendantOrSelf","UnityEngine.UI.MaskUtilities#GetRectMaskForClippable","UnityEngine.UI.MaskUtilities#GetRectMasksForClip","UnityEngine.UI.Misc#Destroy","UnityEngine.UI.Misc#DestroyImmediate","UnityEngine.UI.Navigation#inherits","UnityEngine.UI.Navigation#defaultNavigation#get","UnityEngine.UI.Navigation#getDefaultValue","UnityEngine.UI.Navigation#mode#get","UnityEngine.UI.Navigation#mode#set","UnityEngine.UI.Navigation#selectOnUp#get","UnityEngine.UI.Navigation#selectOnUp#set","UnityEngine.UI.Navigation#selectOnDown#get","UnityEngine.UI.Navigation#selectOnDown#set","UnityEngine.UI.Navigation#selectOnLeft#get","UnityEngine.UI.Navigation#selectOnLeft#set","UnityEngine.UI.Navigation#selectOnRight#get","UnityEngine.UI.Navigation#selectOnRight#set","UnityEngine.UI.Navigation#ctor","UnityEngine.UI.Navigation#equalsT","UnityEngine.UI.Navigation#getHashCode","UnityEngine.UI.Navigation#$clone","UnityEngine.UI.ObjectPool$1#countActive#get","UnityEngine.UI.ObjectPool$1#countInactive#get","UnityEngine.UI.ObjectPool$1#init","UnityEngine.UI.ObjectPool$1#ctor","UnityEngine.UI.ObjectPool$1#Get","UnityEngine.UI.ObjectPool$1#Release","UnityEngine.UI.RectangularVertexClipper#init","UnityEngine.UI.RectangularVertexClipper#GetCanvasRect","UnityEngine.UI.ReflectionMethodsCache#Singleton#get","UnityEngine.UI.ReflectionMethodsCache#ctor","UnityEngine.UI.SetPropertyUtility#SetColor","UnityEngine.UI.SetPropertyUtility#SetStruct","UnityEngine.UI.SetPropertyUtility#SetClass","UnityEngine.UI.SpriteState#inherits","UnityEngine.UI.SpriteState#getDefaultValue","UnityEngine.UI.SpriteState#highlightedSprite#get","UnityEngine.UI.SpriteState#highlightedSprite#set","UnityEngine.UI.SpriteState#pressedSprite#get","UnityEngine.UI.SpriteState#pressedSprite#set","UnityEngine.UI.SpriteState#selectedSprite#get","UnityEngine.UI.SpriteState#selectedSprite#set","UnityEngine.UI.SpriteState#disabledSprite#get","UnityEngine.UI.SpriteState#disabledSprite#set","UnityEngine.UI.SpriteState#ctor","UnityEngine.UI.SpriteState#equalsT","UnityEngine.UI.SpriteState#getHashCode","UnityEngine.UI.SpriteState#$clone","UnityEngine.UI.StencilMaterial#init","UnityEngine.UI.StencilMaterial#Add","UnityEngine.UI.StencilMaterial#Add$1","UnityEngine.UI.StencilMaterial#Add$2","UnityEngine.UI.StencilMaterial#Remove","UnityEngine.UI.StencilMaterial#ClearAll","UnityEngine.UI.StencilMaterial.MatEntry#init","UnityEngine.UI.VertexHelper#currentVertCount#get","UnityEngine.UI.VertexHelper#init","UnityEngine.UI.VertexHelper#ctor","UnityEngine.UI.VertexHelper#$ctor1","UnityEngine.UI.VertexHelper#AddTriangle","UnityEngine.UI.VertexHelper#AddVert","UnityEngine.UI.VertexHelper#AddVert$1","UnityEngine.UI.VertexHelper#AddVert$2","UnityEngine.UI.VertexHelper#GetUIVertexStream","UnityEngine.UI.VertexHelper#Clear","UnityEngine.UI.VertexHelper#AddUIVertexQuad","UnityEngine.UI.VertexHelper#Dispose","UnityEngine.UI.VertexHelper#PopulateUIVertex","UnityEngine.UI.VertexHelper#SetUIVertex","UnityEngine.UI.VertexHelper#AddUIVertexTriangleStream","UnityEngine.UI.VertexHelper#FillMesh","UnityEngine.UI.VertexHelper#FromMesh","UnityEngine.EventSystems.BaseEventData#ctor","UnityEngine.EventSystems.BaseInput#compositionString#get","UnityEngine.EventSystems.BaseInput#imeCompositionMode#get","UnityEngine.EventSystems.BaseInput#imeCompositionMode#set","UnityEngine.EventSystems.BaseInput#compositionCursorPos#get","UnityEngine.EventSystems.BaseInput#compositionCursorPos#set","UnityEngine.EventSystems.BaseInput#mousePresent#get","UnityEngine.EventSystems.BaseInput#mousePosition#get","UnityEngine.EventSystems.BaseInput#mouseScrollDelta#get","UnityEngine.EventSystems.BaseInput#touchSupported#get","UnityEngine.EventSystems.BaseInput#touchCount#get","UnityEngine.EventSystems.BaseInput#GetMouseButtonDown","UnityEngine.EventSystems.BaseInput#GetMouseButtonUp","UnityEngine.EventSystems.BaseInput#GetMouseButton","UnityEngine.EventSystems.BaseInput#GetTouch","UnityEngine.EventSystems.BaseInput#GetAxisRaw","UnityEngine.EventSystems.BaseInput#GetButtonDown","UnityEngine.EventSystems.BaseInputModule#FindFirstRaycast","UnityEngine.EventSystems.BaseInputModule#DetermineMoveDirection","UnityEngine.EventSystems.BaseInputModule#DetermineMoveDirection$1","UnityEngine.EventSystems.BaseInputModule#FindCommonRoot","UnityEngine.EventSystems.BaseInputModule#input#get","UnityEngine.EventSystems.BaseInputModule#inputOverride#get","UnityEngine.EventSystems.BaseInputModule#inputOverride#set","UnityEngine.EventSystems.BaseInputModule#eventSystem#get","UnityEngine.EventSystems.BaseInputModule#init","UnityEngine.EventSystems.BaseInputModule#OnEnable","UnityEngine.EventSystems.BaseInputModule#OnDisable","UnityEngine.EventSystems.BaseInputModule#HandlePointerExitAndEnter","UnityEngine.EventSystems.BaseInputModule#GetAxisEventData","UnityEngine.EventSystems.BaseInputModule#GetBaseEventData","UnityEngine.EventSystems.BaseInputModule#IsPointerOverGameObject","UnityEngine.EventSystems.BaseInputModule#ShouldActivateModule","UnityEngine.EventSystems.BaseInputModule#DeactivateModule","UnityEngine.EventSystems.BaseInputModule#ActivateModule","UnityEngine.EventSystems.BaseInputModule#UpdateModule","UnityEngine.EventSystems.BaseInputModule#IsModuleSupported","UnityEngine.EventSystems.BaseRaycaster#renderOrderPriority#get","UnityEngine.EventSystems.BaseRaycaster#sortOrderPriority#get","UnityEngine.EventSystems.BaseRaycaster#rootRaycaster#get","UnityEngine.EventSystems.BaseRaycaster#ConfigureForEntity","UnityEngine.EventSystems.BaseRaycaster#OnEnable","UnityEngine.EventSystems.BaseRaycaster#OnDisable","UnityEngine.EventSystems.BaseRaycaster#OnCanvasHierarchyChanged","UnityEngine.EventSystems.BaseRaycaster#OnTransformParentChanged","UnityEngine.EventSystems.EventSystem#current#get","UnityEngine.EventSystems.EventSystem#current#set","UnityEngine.EventSystems.EventSystem#init","UnityEngine.EventSystems.EventSystem#RaycastComparer","UnityEngine.EventSystems.EventSystem#sendNavigationEvents#get","UnityEngine.EventSystems.EventSystem#sendNavigationEvents#set","UnityEngine.EventSystems.EventSystem#pixelDragThreshold#get","UnityEngine.EventSystems.EventSystem#pixelDragThreshold#set","UnityEngine.EventSystems.EventSystem#currentInputModule#get","UnityEngine.EventSystems.EventSystem#firstSelectedGameObject#get","UnityEngine.EventSystems.EventSystem#firstSelectedGameObject#set","UnityEngine.EventSystems.EventSystem#currentSelectedGameObject#get","UnityEngine.EventSystems.EventSystem#lastSelectedGameObject#get","UnityEngine.EventSystems.EventSystem#isFocused#get","UnityEngine.EventSystems.EventSystem#alreadySelecting#get","UnityEngine.EventSystems.EventSystem#baseEventDataCache#get","UnityEngine.EventSystems.EventSystem#init","UnityEngine.EventSystems.EventSystem#ctor","UnityEngine.EventSystems.EventSystem#UpdateModules","UnityEngine.EventSystems.EventSystem#SetSelectedGameObject$1","UnityEngine.EventSystems.EventSystem#SetSelectedGameObject","UnityEngine.EventSystems.EventSystem#RaycastAll","UnityEngine.EventSystems.EventSystem#IsPointerOverGameObject","UnityEngine.EventSystems.EventSystem#IsPointerOverGameObject$1","UnityEngine.EventSystems.EventSystem#OnEnable","UnityEngine.EventSystems.EventSystem#OnDisable","UnityEngine.EventSystems.EventSystem#TickModules","UnityEngine.EventSystems.EventSystem#OnApplicationFocus","UnityEngine.EventSystems.EventSystem#Update","UnityEngine.EventSystems.EventSystem#ChangeEventModule","UnityEngine.EventSystems.EventSystem#toString","UnityEngine.UI.AspectRatioFitter#aspectMode#get","UnityEngine.UI.AspectRatioFitter#aspectMode#set","UnityEngine.UI.AspectRatioFitter#aspectRatio#get","UnityEngine.UI.AspectRatioFitter#aspectRatio#set","UnityEngine.UI.AspectRatioFitter#rectTransform#get","UnityEngine.UI.AspectRatioFitter#init","UnityEngine.UI.AspectRatioFitter#UpdateRect","UnityEngine.UI.AspectRatioFitter#GetSizeDeltaToProduceSize","UnityEngine.UI.AspectRatioFitter#GetParentSize","UnityEngine.UI.AspectRatioFitter#OnEnable","UnityEngine.UI.AspectRatioFitter#SetDirty","UnityEngine.UI.AspectRatioFitter#OnRectTransformDimensionsChange","UnityEngine.UI.BaseMeshEffect#graphic#get","UnityEngine.UI.BaseMeshEffect#OnEnable","UnityEngine.UI.BaseMeshEffect#OnDisable","UnityEngine.UI.BaseMeshEffect#OnDidApplyAnimationProperties","UnityEngine.UI.BaseMeshEffect#ModifyMesh","UnityEngine.UI.CanvasScaler#uiScaleMode#get","UnityEngine.UI.CanvasScaler#uiScaleMode#set","UnityEngine.UI.CanvasScaler#screenMatchMode#get","UnityEngine.UI.CanvasScaler#screenMatchMode#set","UnityEngine.UI.CanvasScaler#referenceResolution#get","UnityEngine.UI.CanvasScaler#referenceResolution#set","UnityEngine.UI.CanvasScaler#scaleFactor#get","UnityEngine.UI.CanvasScaler#scaleFactor#set","UnityEngine.UI.CanvasScaler#matchWidthOrHeight#get","UnityEngine.UI.CanvasScaler#matchWidthOrHeight#set","UnityEngine.UI.CanvasScaler#referencePixelsPerUnit#get","UnityEngine.UI.CanvasScaler#referencePixelsPerUnit#set","UnityEngine.UI.CanvasScaler#init","UnityEngine.UI.CanvasScaler#Awake","UnityEngine.UI.CanvasScaler#ConfigureForEntity","UnityEngine.UI.CanvasScaler#HandleScaleWithScreenSize","UnityEngine.UI.CanvasScaler#UpdateScreenMatchMode","UnityEngine.UI.CoroutineTween.ColorTween#getDefaultValue","UnityEngine.UI.CoroutineTween.ColorTween#startColor#get","UnityEngine.UI.CoroutineTween.ColorTween#startColor#set","UnityEngine.UI.CoroutineTween.ColorTween#targetColor#get","UnityEngine.UI.CoroutineTween.ColorTween#targetColor#set","UnityEngine.UI.CoroutineTween.ColorTween#tweenMode#get","UnityEngine.UI.CoroutineTween.ColorTween#tweenMode#set","UnityEngine.UI.CoroutineTween.ColorTween#duration#get","UnityEngine.UI.CoroutineTween.ColorTween#duration#set","UnityEngine.UI.CoroutineTween.ColorTween#ignoreTimeScale#get","UnityEngine.UI.CoroutineTween.ColorTween#ignoreTimeScale#set","UnityEngine.UI.CoroutineTween.ColorTween#init","UnityEngine.UI.CoroutineTween.ColorTween#ctor","UnityEngine.UI.CoroutineTween.ColorTween#TweenValue","UnityEngine.UI.CoroutineTween.ColorTween#AddOnChangedCallback","UnityEngine.UI.CoroutineTween.ColorTween#GetIgnoreTimescale","UnityEngine.UI.CoroutineTween.ColorTween#GetDuration","UnityEngine.UI.CoroutineTween.ColorTween#ValidTarget","UnityEngine.UI.CoroutineTween.ColorTween#getHashCode","UnityEngine.UI.CoroutineTween.ColorTween#equals","UnityEngine.UI.CoroutineTween.ColorTween#$clone","UnityEngine.UI.CoroutineTween.FloatTween#getDefaultValue","UnityEngine.UI.CoroutineTween.FloatTween#startValue#get","UnityEngine.UI.CoroutineTween.FloatTween#startValue#set","UnityEngine.UI.CoroutineTween.FloatTween#targetValue#get","UnityEngine.UI.CoroutineTween.FloatTween#targetValue#set","UnityEngine.UI.CoroutineTween.FloatTween#duration#get","UnityEngine.UI.CoroutineTween.FloatTween#duration#set","UnityEngine.UI.CoroutineTween.FloatTween#ignoreTimeScale#get","UnityEngine.UI.CoroutineTween.FloatTween#ignoreTimeScale#set","UnityEngine.UI.CoroutineTween.FloatTween#ctor","UnityEngine.UI.CoroutineTween.FloatTween#TweenValue","UnityEngine.UI.CoroutineTween.FloatTween#AddOnChangedCallback","UnityEngine.UI.CoroutineTween.FloatTween#GetIgnoreTimescale","UnityEngine.UI.CoroutineTween.FloatTween#GetDuration","UnityEngine.UI.CoroutineTween.FloatTween#ValidTarget","UnityEngine.UI.CoroutineTween.FloatTween#getHashCode","UnityEngine.UI.CoroutineTween.FloatTween#equals","UnityEngine.UI.CoroutineTween.FloatTween#$clone","UnityEngine.UI.CoroutineTween.TweenRunner$1#Start","UnityEngine.UI.CoroutineTween.TweenRunner$1#Init","UnityEngine.UI.CoroutineTween.TweenRunner$1#StartTween","UnityEngine.UI.CoroutineTween.TweenRunner$1#StopTween","UnityEngine.UI.Graphic#defaultGraphicMaterial#get","UnityEngine.UI.Graphic#init","UnityEngine.UI.Graphic#CreateColorFromAlpha","UnityEngine.UI.Graphic#canvas#get","UnityEngine.UI.Graphic#materialForRendering#get","UnityEngine.UI.Graphic#defaultMaterial#get","UnityEngine.UI.Graphic#canvasRenderer#get","UnityEngine.UI.Graphic#rectTransform#get","UnityEngine.UI.Graphic#rectTransform#set","UnityEngine.UI.Graphic#mainTexture#get","UnityEngine.UI.Graphic#depth#get","UnityEngine.UI.Graphic#material#get","UnityEngine.UI.Graphic#material#set","UnityEngine.UI.Graphic#raycastTarget#get","UnityEngine.UI.Graphic#raycastTarget#set","UnityEngine.UI.Graphic#color#get","UnityEngine.UI.Graphic#color#set","UnityEngine.UI.Graphic#init","UnityEngine.UI.Graphic#ctor","UnityEngine.UI.Graphic#$ctor1","UnityEngine.UI.Graphic#AssignDefaultFont","UnityEngine.UI.Graphic#Awake","UnityEngine.UI.Graphic#SetNativeSize","UnityEngine.UI.Graphic#OnPopulateMesh","UnityEngine.UI.Graphic#SetMaterialDirty","UnityEngine.UI.Graphic#SetAllDirty","UnityEngine.UI.Graphic#Rebuild","UnityEngine.UI.Graphic#GetPixelAdjustedRect","UnityEngine.UI.Graphic#OnSelect","UnityEngine.UI.Graphic#OnDeselect","UnityEngine.UI.Graphic#OnSubmit","UnityEngine.UI.Graphic#OnMove","UnityEngine.UI.Graphic#RegisterDirtyVerticesCallback","UnityEngine.UI.Graphic#UnregisterDirtyVerticesCallback","UnityEngine.UI.Graphic#RegisterDirtyMaterialCallback","UnityEngine.UI.Graphic#UnregisterDirtyMaterialCallback","UnityEngine.UI.Graphic#ConfigureForEntity","UnityEngine.UI.Graphic#CrossFadeAlpha","UnityEngine.UI.Graphic#CrossFadeColor","UnityEngine.UI.Graphic#CrossFadeColor$1","UnityEngine.UI.Graphic#SetLayoutDirty","UnityEngine.UI.Graphic#SetVerticesDirty","UnityEngine.UI.Graphic#UpdateGeometry","UnityEngine.UI.Graphic#UpdateMaterial","UnityEngine.UI.Graphic#OnCanvasGroupChanged","UnityEngine.UI.Graphic#Raycast","UnityEngine.UI.Graphic#LayoutComplete","UnityEngine.UI.Graphic#GraphicUpdateComplete","UnityEngine.UI.Graphic#OnRectTransformDimensionsChange","UnityEngine.UI.Graphic#OnDidApplyAnimationProperties","UnityEngine.UI.Graphic#OnTransformParentChanged","UnityEngine.UI.Graphic#OnEnable","UnityEngine.UI.Graphic#OnDisable","UnityEngine.UI.Graphic#OnCanvasChanged","UnityEngine.UI.Graphic#PixelAdjustPoint","UnityEngine.UI.LayoutElement#minWidth#get","UnityEngine.UI.LayoutElement#minWidth#set","UnityEngine.UI.LayoutElement#minHeight#get","UnityEngine.UI.LayoutElement#minHeight#set","UnityEngine.UI.LayoutElement#preferredWidth#get","UnityEngine.UI.LayoutElement#preferredWidth#set","UnityEngine.UI.LayoutElement#preferredHeight#get","UnityEngine.UI.LayoutElement#preferredHeight#set","UnityEngine.UI.LayoutElement#flexibleWidth#get","UnityEngine.UI.LayoutElement#flexibleWidth#set","UnityEngine.UI.LayoutElement#flexibleHeight#get","UnityEngine.UI.LayoutElement#flexibleHeight#set","UnityEngine.UI.LayoutElement#layoutPriority#get","UnityEngine.UI.LayoutElement#ignoreLayout#get","UnityEngine.UI.LayoutElement#ignoreLayout#set","UnityEngine.UI.LayoutElement#init","UnityEngine.UI.LayoutElement#OnEnable","UnityEngine.UI.LayoutElement#OnDisable","UnityEngine.UI.LayoutElement#OnDidApplyAnimationProperties","UnityEngine.UI.LayoutElement#OnTransformParentChanged","UnityEngine.UI.LayoutElement#CalculateLayoutInputHorizontal","UnityEngine.UI.LayoutElement#CalculateLayoutInputVertical","UnityEngine.UI.LayoutElement#SetDirty","UnityEngine.UI.LayoutRebuilder#init","UnityEngine.UI.LayoutRebuilder#MarkLayoutForRebuild","UnityEngine.UI.LayoutRebuilder#ForceRebuildLayoutImmediate","UnityEngine.UI.LayoutRebuilder#Allocate","UnityEngine.UI.LayoutRebuilder#MarkLayoutRootForRebuild","UnityEngine.UI.LayoutRebuilder#HasValidLayoutController","UnityEngine.UI.LayoutRebuilder#GetRectTransform","UnityEngine.UI.LayoutRebuilder#LayoutComplete","UnityEngine.UI.LayoutRebuilder#GraphicUpdateComplete","UnityEngine.UI.LayoutRebuilder#IsDestroyed","UnityEngine.UI.LayoutRebuilder#Rebuild","UnityEngine.UI.LayoutRebuilder#PerformCalculateLayoutInputHorizontal","UnityEngine.UI.LayoutRebuilder#PerformCalculateLayoutInputVertical","UnityEngine.UI.LayoutRebuilder#PerformSetLayoutHorizontal","UnityEngine.UI.LayoutRebuilder#PerformSetLayoutVertical","UnityEngine.UI.Mask#graphic#get","UnityEngine.UI.Mask#rectTransform#get","UnityEngine.UI.Mask#showMaskGraphic#get","UnityEngine.UI.Mask#showMaskGraphic#set","UnityEngine.UI.Mask#init","UnityEngine.UI.Mask#$ctor1","UnityEngine.UI.Mask#ctor","UnityEngine.UI.Mask#MaskEnabled","UnityEngine.UI.Mask#Awake","UnityEngine.UI.Mask#OnEnable","UnityEngine.UI.Mask#OnDisable","UnityEngine.UI.Mask#UpdateMaskGraphicSettings","UnityEngine.UI.Mask#GetModifiedMaterial","UnityEngine.UI.Mask#IsRaycastLocationValid","UnityEngine.UI.RectMask2D#Canvas#get","UnityEngine.UI.RectMask2D#canvasRect#get","UnityEngine.UI.RectMask2D#rectTransform#get","UnityEngine.UI.RectMask2D#rootCanvasRect#get","UnityEngine.UI.RectMask2D#init","UnityEngine.UI.RectMask2D#ctor","UnityEngine.UI.RectMask2D#OnEnable","UnityEngine.UI.RectMask2D#OnDisable","UnityEngine.UI.RectMask2D#IsRaycastLocationValid","UnityEngine.UI.RectMask2D#PerformClipping","UnityEngine.UI.RectMask2D#AddClippable","UnityEngine.UI.RectMask2D#RemoveClippable","UnityEngine.UI.RectMask2D#OnTransformParentChanged","UnityEngine.UI.RectMask2D#OnCanvasHierarchyChanged","UnityEngine.UI.ToggleGroup#allowSwitchOff#get","UnityEngine.UI.ToggleGroup#allowSwitchOff#set","UnityEngine.UI.ToggleGroup#init","UnityEngine.UI.ToggleGroup#ctor","UnityEngine.UI.ToggleGroup#ValidateToggleIsInGroup","UnityEngine.UI.ToggleGroup#NotifyToggleOn","UnityEngine.UI.ToggleGroup#UnregisterToggle","UnityEngine.UI.ToggleGroup#RegisterToggle","UnityEngine.UI.ToggleGroup#AnyTogglesOn","UnityEngine.UI.ToggleGroup#ActiveToggles","UnityEngine.UI.ToggleGroup#SetAllTogglesOff","UnityEngine.EventSystems.AxisEventData#init","UnityEngine.EventSystems.AxisEventData#ctor","UnityEngine.EventSystems.EventTrigger#triggers#get","UnityEngine.EventSystems.EventTrigger#triggers#set","UnityEngine.EventSystems.EventTrigger#init","UnityEngine.EventSystems.EventTrigger#OnPointerEnter","UnityEngine.EventSystems.EventTrigger#OnPointerExit","UnityEngine.EventSystems.EventTrigger#OnDrag","UnityEngine.EventSystems.EventTrigger#OnDrop","UnityEngine.EventSystems.EventTrigger#OnPointerDown","UnityEngine.EventSystems.EventTrigger#OnPointerUp","UnityEngine.EventSystems.EventTrigger#OnPointerClick","UnityEngine.EventSystems.EventTrigger#OnSelect","UnityEngine.EventSystems.EventTrigger#OnDeselect","UnityEngine.EventSystems.EventTrigger#OnScroll","UnityEngine.EventSystems.EventTrigger#OnMove","UnityEngine.EventSystems.EventTrigger#OnUpdateSelected","UnityEngine.EventSystems.EventTrigger#OnInitializePotentialDrag","UnityEngine.EventSystems.EventTrigger#OnBeginDrag","UnityEngine.EventSystems.EventTrigger#OnEndDrag","UnityEngine.EventSystems.EventTrigger#OnSubmit","UnityEngine.EventSystems.EventTrigger#OnCancel","UnityEngine.EventSystems.EventTrigger#Execute","UnityEngine.EventSystems.PhysicsRaycaster#init","UnityEngine.EventSystems.PhysicsRaycaster#eventCamera#get","UnityEngine.EventSystems.PhysicsRaycaster#depth#get","UnityEngine.EventSystems.PhysicsRaycaster#finalEventMask#get","UnityEngine.EventSystems.PhysicsRaycaster#eventMask#get","UnityEngine.EventSystems.PhysicsRaycaster#eventMask#set","UnityEngine.EventSystems.PhysicsRaycaster#maxRayIntersections#get","UnityEngine.EventSystems.PhysicsRaycaster#maxRayIntersections#set","UnityEngine.EventSystems.PhysicsRaycaster#init","UnityEngine.EventSystems.PhysicsRaycaster#ctor","UnityEngine.EventSystems.PhysicsRaycaster#ComputeRayAndDistance","UnityEngine.EventSystems.PhysicsRaycaster#Raycast","UnityEngine.EventSystems.PointerEventData#enterEventCamera#get","UnityEngine.EventSystems.PointerEventData#pressEventCamera#get","UnityEngine.EventSystems.PointerEventData#pointerPress#get","UnityEngine.EventSystems.PointerEventData#pointerPress#set","UnityEngine.EventSystems.PointerEventData#init","UnityEngine.EventSystems.PointerEventData#ctor","UnityEngine.EventSystems.PointerEventData#IsPointerMoving","UnityEngine.EventSystems.PointerEventData#IsScrolling","UnityEngine.EventSystems.PointerEventData#toString","UnityEngine.EventSystems.PointerInputModule#init","UnityEngine.EventSystems.PointerInputModule#ShouldStartDrag","UnityEngine.EventSystems.PointerInputModule#init","UnityEngine.EventSystems.PointerInputModule#GetPointerData","UnityEngine.EventSystems.PointerInputModule#RemovePointerData","UnityEngine.EventSystems.PointerInputModule#GetTouchPointerEventData","UnityEngine.EventSystems.PointerInputModule#CopyFromTo","UnityEngine.EventSystems.PointerInputModule#StateForMouseButton","UnityEngine.EventSystems.PointerInputModule#GetMousePointerEventData","UnityEngine.EventSystems.PointerInputModule#GetMousePointerEventData$1","UnityEngine.EventSystems.PointerInputModule#GetLastPointerEventData","UnityEngine.EventSystems.PointerInputModule#ProcessMove","UnityEngine.EventSystems.PointerInputModule#ProcessDrag","UnityEngine.EventSystems.PointerInputModule#IsPointerOverGameObject","UnityEngine.EventSystems.PointerInputModule#ClearSelection","UnityEngine.EventSystems.PointerInputModule#toString","UnityEngine.EventSystems.PointerInputModule#DeselectIfSelectionChanged","UnityEngine.UI.Selectable#allSelectablesArray#get","UnityEngine.UI.Selectable#allSelectableCount#get","UnityEngine.UI.Selectable#allSelectables#get","UnityEngine.UI.Selectable#init","UnityEngine.UI.Selectable#AllSelectablesNoAlloc","UnityEngine.UI.Selectable#RemoveInvalidSelectables","UnityEngine.UI.Selectable#GetPointOnRectEdge","UnityEngine.UI.Selectable#navigation#get","UnityEngine.UI.Selectable#navigation#set","UnityEngine.UI.Selectable#transition#get","UnityEngine.UI.Selectable#transition#set","UnityEngine.UI.Selectable#colors#get","UnityEngine.UI.Selectable#colors#set","UnityEngine.UI.Selectable#spriteState#get","UnityEngine.UI.Selectable#spriteState#set","UnityEngine.UI.Selectable#animationTriggers#get","UnityEngine.UI.Selectable#animationTriggers#set","UnityEngine.UI.Selectable#targetGraphic#get","UnityEngine.UI.Selectable#targetGraphic#set","UnityEngine.UI.Selectable#interactable#get","UnityEngine.UI.Selectable#interactable#set","UnityEngine.UI.Selectable#image#get","UnityEngine.UI.Selectable#image#set","UnityEngine.UI.Selectable#animator#get","UnityEngine.UI.Selectable#currentSelectionState#get","UnityEngine.UI.Selectable#init","UnityEngine.UI.Selectable#ctor","UnityEngine.UI.Selectable#$ctor1","UnityEngine.UI.Selectable#Awake","UnityEngine.UI.Selectable#OnCanvasGroupChanged","UnityEngine.UI.Selectable#IsInteractable","UnityEngine.UI.Selectable#OnDidApplyAnimationProperties","UnityEngine.UI.Selectable#OnEnable","UnityEngine.UI.Selectable#OnTransformParentChanged","UnityEngine.UI.Selectable#OnSetProperty","UnityEngine.UI.Selectable#OnDisable","UnityEngine.UI.Selectable#InstantClearState","UnityEngine.UI.Selectable#DoStateTransition","UnityEngine.UI.Selectable#FindSelectable","UnityEngine.UI.Selectable#Navigate","UnityEngine.UI.Selectable#FindSelectableOnLeft","UnityEngine.UI.Selectable#FindSelectableOnRight","UnityEngine.UI.Selectable#FindSelectableOnUp","UnityEngine.UI.Selectable#FindSelectableOnDown","UnityEngine.UI.Selectable#OnMove","UnityEngine.UI.Selectable#StartColorTween","UnityEngine.UI.Selectable#DoSpriteSwap","UnityEngine.UI.Selectable#TriggerAnimation","UnityEngine.UI.Selectable#IsHighlighted","UnityEngine.UI.Selectable#IsPressed","UnityEngine.UI.Selectable#EvaluateAndTransitionToSelectionState","UnityEngine.UI.Selectable#OnPointerDown","UnityEngine.UI.Selectable#OnPointerUp","UnityEngine.UI.Selectable#OnPointerEnter","UnityEngine.UI.Selectable#OnPointerExit","UnityEngine.UI.Selectable#OnSelect","UnityEngine.UI.Selectable#OnDeselect","UnityEngine.UI.Selectable#Select","UnityEngine.UI.ContentSizeFitter#horizontalFit#get","UnityEngine.UI.ContentSizeFitter#horizontalFit#set","UnityEngine.UI.ContentSizeFitter#verticalFit#get","UnityEngine.UI.ContentSizeFitter#verticalFit#set","UnityEngine.UI.ContentSizeFitter#rectTransform#get","UnityEngine.UI.ContentSizeFitter#init","UnityEngine.UI.ContentSizeFitter#ctor","UnityEngine.UI.ContentSizeFitter#OnEnable","UnityEngine.UI.ContentSizeFitter#OnDisable","UnityEngine.UI.ContentSizeFitter#OnRectTransformDimensionsChange","UnityEngine.UI.ContentSizeFitter#HandleSelfFittingAlongAxis","UnityEngine.UI.ContentSizeFitter#SetLayoutHorizontal","UnityEngine.UI.ContentSizeFitter#SetLayoutVertical","UnityEngine.UI.ContentSizeFitter#SetDirty","UnityEngine.UI.Dropdown.DropdownItem#text#get","UnityEngine.UI.Dropdown.DropdownItem#text#set","UnityEngine.UI.Dropdown.DropdownItem#image#get","UnityEngine.UI.Dropdown.DropdownItem#image#set","UnityEngine.UI.Dropdown.DropdownItem#rectTransform#get","UnityEngine.UI.Dropdown.DropdownItem#rectTransform#set","UnityEngine.UI.Dropdown.DropdownItem#toggle#get","UnityEngine.UI.Dropdown.DropdownItem#toggle#set","UnityEngine.UI.Dropdown.DropdownItem#OnPointerEnter","UnityEngine.UI.Dropdown.DropdownItem#OnCancel","UnityEngine.UI.GraphicRaycaster#init","UnityEngine.UI.GraphicRaycaster#Raycast","UnityEngine.UI.GraphicRaycaster#canvas#get","UnityEngine.UI.GraphicRaycaster#ignoreReversedGraphics#get","UnityEngine.UI.GraphicRaycaster#ignoreReversedGraphics#set","UnityEngine.UI.GraphicRaycaster#blockingObjects#get","UnityEngine.UI.GraphicRaycaster#blockingObjects#set","UnityEngine.UI.GraphicRaycaster#eventCamera#get","UnityEngine.UI.GraphicRaycaster#init","UnityEngine.UI.GraphicRaycaster#ctor","UnityEngine.UI.GraphicRaycaster#Raycast","UnityEngine.UI.GraphicRaycaster#GetMainCamera","UnityEngine.UI.LayoutGroup#childAlignment#get","UnityEngine.UI.LayoutGroup#childAlignment#set","UnityEngine.UI.LayoutGroup#padding#get","UnityEngine.UI.LayoutGroup#padding#set","UnityEngine.UI.LayoutGroup#minWidth#get","UnityEngine.UI.LayoutGroup#preferredWidth#get","UnityEngine.UI.LayoutGroup#flexibleWidth#get","UnityEngine.UI.LayoutGroup#minHeight#get","UnityEngine.UI.LayoutGroup#preferredHeight#get","UnityEngine.UI.LayoutGroup#flexibleHeight#get","UnityEngine.UI.LayoutGroup#layoutPriority#get","UnityEngine.UI.LayoutGroup#rectChildren#get","UnityEngine.UI.LayoutGroup#rectTransform#get","UnityEngine.UI.LayoutGroup#isRootLayoutGroup#get","UnityEngine.UI.LayoutGroup#init","UnityEngine.UI.LayoutGroup#OnEnable","UnityEngine.UI.LayoutGroup#OnDisable","UnityEngine.UI.LayoutGroup#CalculateLayoutInputHorizontal","UnityEngine.UI.LayoutGroup#SetChildAlongAxis","UnityEngine.UI.LayoutGroup#SetChildAlongAxis$1","UnityEngine.UI.LayoutGroup#SetLayoutInputForAxis","UnityEngine.UI.LayoutGroup#GetStartOffset","UnityEngine.UI.LayoutGroup#GetAlignmentOnAxis","UnityEngine.UI.LayoutGroup#GetTotalMinSize","UnityEngine.UI.LayoutGroup#GetTotalPreferredSize","UnityEngine.UI.LayoutGroup#GetTotalFlexibleSize","UnityEngine.UI.LayoutGroup#SetProperty","UnityEngine.UI.LayoutGroup#OnTransformChildrenChanged","UnityEngine.UI.LayoutGroup#OnRectTransformDimensionsChange","UnityEngine.UI.LayoutGroup#OnDidApplyAnimationProperties","UnityEngine.UI.LayoutGroup#SetDirty","UnityEngine.UI.LayoutGroup#DelayedSetDirty","UnityEngine.UI.MaskableGraphic#onCullStateChanged#get","UnityEngine.UI.MaskableGraphic#onCullStateChanged#set","UnityEngine.UI.MaskableGraphic#maskable#get","UnityEngine.UI.MaskableGraphic#maskable#set","UnityEngine.UI.MaskableGraphic#rootCanvasRect#get","UnityEngine.UI.MaskableGraphic#init","UnityEngine.UI.MaskableGraphic#$ctor1","UnityEngine.UI.MaskableGraphic#ctor","UnityEngine.UI.MaskableGraphic#GetModifiedMaterial","UnityEngine.UI.MaskableGraphic#Cull","UnityEngine.UI.MaskableGraphic#UpdateCull","UnityEngine.UI.MaskableGraphic#SetClipRect","UnityEngine.UI.MaskableGraphic#OnEnable","UnityEngine.UI.MaskableGraphic#OnDisable","UnityEngine.UI.MaskableGraphic#OnTransformParentChanged","UnityEngine.UI.MaskableGraphic#ParentMaskStateChanged","UnityEngine.UI.MaskableGraphic#OnCanvasHierarchyChanged","UnityEngine.UI.MaskableGraphic#UpdateClipParent","UnityEngine.UI.MaskableGraphic#RecalculateClipping","UnityEngine.UI.MaskableGraphic#RecalculateMasking","UnityEngine.UI.Shadow#init","UnityEngine.UI.Shadow#effectColor#get","UnityEngine.UI.Shadow#effectColor#set","UnityEngine.UI.Shadow#effectDistance#get","UnityEngine.UI.Shadow#effectDistance#set","UnityEngine.UI.Shadow#useGraphicAlpha#get","UnityEngine.UI.Shadow#useGraphicAlpha#set","UnityEngine.UI.Shadow#init","UnityEngine.UI.Shadow#ctor","UnityEngine.UI.Shadow#ApplyShadowZeroAlloc","UnityEngine.UI.Shadow#ApplyShadow","UnityEngine.UI.Shadow#ModifyMesh$1","UnityEngine.UI.ScrollRect#RubberDelta","UnityEngine.UI.ScrollRect#UpdateOneScrollbarVisibility","UnityEngine.UI.ScrollRect#AdjustBounds","UnityEngine.UI.ScrollRect#InternalGetBounds","UnityEngine.UI.ScrollRect#InternalCalculateOffset","UnityEngine.UI.ScrollRect#content#get","UnityEngine.UI.ScrollRect#content#set","UnityEngine.UI.ScrollRect#horizontal#get","UnityEngine.UI.ScrollRect#horizontal#set","UnityEngine.UI.ScrollRect#vertical#get","UnityEngine.UI.ScrollRect#vertical#set","UnityEngine.UI.ScrollRect#movementType#get","UnityEngine.UI.ScrollRect#movementType#set","UnityEngine.UI.ScrollRect#elasticity#get","UnityEngine.UI.ScrollRect#elasticity#set","UnityEngine.UI.ScrollRect#inertia#get","UnityEngine.UI.ScrollRect#inertia#set","UnityEngine.UI.ScrollRect#decelerationRate#get","UnityEngine.UI.ScrollRect#decelerationRate#set","UnityEngine.UI.ScrollRect#scrollSensitivity#get","UnityEngine.UI.ScrollRect#scrollSensitivity#set","UnityEngine.UI.ScrollRect#viewport#get","UnityEngine.UI.ScrollRect#viewport#set","UnityEngine.UI.ScrollRect#horizontalScrollbar#get","UnityEngine.UI.ScrollRect#horizontalScrollbar#set","UnityEngine.UI.ScrollRect#verticalScrollbar#get","UnityEngine.UI.ScrollRect#verticalScrollbar#set","UnityEngine.UI.ScrollRect#horizontalScrollbarVisibility#get","UnityEngine.UI.ScrollRect#horizontalScrollbarVisibility#set","UnityEngine.UI.ScrollRect#verticalScrollbarVisibility#get","UnityEngine.UI.ScrollRect#verticalScrollbarVisibility#set","UnityEngine.UI.ScrollRect#horizontalScrollbarSpacing#get","UnityEngine.UI.ScrollRect#horizontalScrollbarSpacing#set","UnityEngine.UI.ScrollRect#verticalScrollbarSpacing#get","UnityEngine.UI.ScrollRect#verticalScrollbarSpacing#set","UnityEngine.UI.ScrollRect#onValueChanged#get","UnityEngine.UI.ScrollRect#onValueChanged#set","UnityEngine.UI.ScrollRect#viewRect#get","UnityEngine.UI.ScrollRect#velocity#get","UnityEngine.UI.ScrollRect#velocity#set","UnityEngine.UI.ScrollRect#rectTransform#get","UnityEngine.UI.ScrollRect#normalizedPosition#get","UnityEngine.UI.ScrollRect#normalizedPosition#set","UnityEngine.UI.ScrollRect#horizontalNormalizedPosition#get","UnityEngine.UI.ScrollRect#horizontalNormalizedPosition#set","UnityEngine.UI.ScrollRect#verticalNormalizedPosition#get","UnityEngine.UI.ScrollRect#verticalNormalizedPosition#set","UnityEngine.UI.ScrollRect#hScrollingNeeded#get","UnityEngine.UI.ScrollRect#vScrollingNeeded#get","UnityEngine.UI.ScrollRect#minWidth#get","UnityEngine.UI.ScrollRect#preferredWidth#get","UnityEngine.UI.ScrollRect#flexibleWidth#get","UnityEngine.UI.ScrollRect#minHeight#get","UnityEngine.UI.ScrollRect#preferredHeight#get","UnityEngine.UI.ScrollRect#flexibleHeight#get","UnityEngine.UI.ScrollRect#layoutPriority#get","UnityEngine.UI.ScrollRect#init","UnityEngine.UI.ScrollRect#ctor","UnityEngine.UI.ScrollRect#Rebuild","UnityEngine.UI.ScrollRect#LayoutComplete","UnityEngine.UI.ScrollRect#GraphicUpdateComplete","UnityEngine.UI.ScrollRect#UpdateCachedData","UnityEngine.UI.ScrollRect#OnEnable","UnityEngine.UI.ScrollRect#OnDisable","UnityEngine.UI.ScrollRect#IsActive","UnityEngine.UI.ScrollRect#EnsureLayoutHasRebuilt","UnityEngine.UI.ScrollRect#StopMovement","UnityEngine.UI.ScrollRect#OnScroll","UnityEngine.UI.ScrollRect#OnInitializePotentialDrag","UnityEngine.UI.ScrollRect#OnBeginDrag","UnityEngine.UI.ScrollRect#OnEndDrag","UnityEngine.UI.ScrollRect#OnDrag","UnityEngine.UI.ScrollRect#SetContentAnchoredPosition","UnityEngine.UI.ScrollRect#LateUpdate","UnityEngine.UI.ScrollRect#UpdatePrevData","UnityEngine.UI.ScrollRect#UpdateScrollbars","UnityEngine.UI.ScrollRect#SetHorizontalNormalizedPosition","UnityEngine.UI.ScrollRect#SetVerticalNormalizedPosition","UnityEngine.UI.ScrollRect#SetNormalizedPosition","UnityEngine.UI.ScrollRect#OnRectTransformDimensionsChange","UnityEngine.UI.ScrollRect#CalculateLayoutInputHorizontal","UnityEngine.UI.ScrollRect#CalculateLayoutInputVertical","UnityEngine.UI.ScrollRect#SetLayoutHorizontal","UnityEngine.UI.ScrollRect#SetLayoutVertical","UnityEngine.UI.ScrollRect#UpdateScrollbarVisibility","UnityEngine.UI.ScrollRect#UpdateScrollbarLayout","UnityEngine.UI.ScrollRect#UpdateBounds","UnityEngine.UI.ScrollRect#GetBounds","UnityEngine.UI.ScrollRect#CalculateOffset","UnityEngine.UI.ScrollRect#SetDirty","UnityEngine.UI.ScrollRect#SetDirtyCaching","UnityEngine.EventSystems.Physics2DRaycaster#ctor","UnityEngine.EventSystems.Physics2DRaycaster#Raycast","UnityEngine.EventSystems.StandaloneInputModule#inputMode#get","UnityEngine.EventSystems.StandaloneInputModule#allowActivationOnMobileDevice#get","UnityEngine.EventSystems.StandaloneInputModule#allowActivationOnMobileDevice#set","UnityEngine.EventSystems.StandaloneInputModule#forceModuleActive#get","UnityEngine.EventSystems.StandaloneInputModule#forceModuleActive#set","UnityEngine.EventSystems.StandaloneInputModule#inputActionsPerSecond#get","UnityEngine.EventSystems.StandaloneInputModule#inputActionsPerSecond#set","UnityEngine.EventSystems.StandaloneInputModule#repeatDelay#get","UnityEngine.EventSystems.StandaloneInputModule#repeatDelay#set","UnityEngine.EventSystems.StandaloneInputModule#horizontalAxis#get","UnityEngine.EventSystems.StandaloneInputModule#horizontalAxis#set","UnityEngine.EventSystems.StandaloneInputModule#verticalAxis#get","UnityEngine.EventSystems.StandaloneInputModule#verticalAxis#set","UnityEngine.EventSystems.StandaloneInputModule#submitButton#get","UnityEngine.EventSystems.StandaloneInputModule#submitButton#set","UnityEngine.EventSystems.StandaloneInputModule#cancelButton#get","UnityEngine.EventSystems.StandaloneInputModule#cancelButton#set","UnityEngine.EventSystems.StandaloneInputModule#init","UnityEngine.EventSystems.StandaloneInputModule#ctor","UnityEngine.EventSystems.StandaloneInputModule#ShouldIgnoreEventsOnNoFocus","UnityEngine.EventSystems.StandaloneInputModule#UpdateModule","UnityEngine.EventSystems.StandaloneInputModule#ReleaseMouse","UnityEngine.EventSystems.StandaloneInputModule#IsModuleSupported","UnityEngine.EventSystems.StandaloneInputModule#ShouldActivateModule","UnityEngine.EventSystems.StandaloneInputModule#ActivateModule","UnityEngine.EventSystems.StandaloneInputModule#DeactivateModule","UnityEngine.EventSystems.StandaloneInputModule#Process","UnityEngine.EventSystems.StandaloneInputModule#ProcessTouchEvents","UnityEngine.EventSystems.StandaloneInputModule#ProcessTouchPress","UnityEngine.EventSystems.StandaloneInputModule#SendSubmitEventToSelectedObject","UnityEngine.EventSystems.StandaloneInputModule#GetRawMoveVector","UnityEngine.EventSystems.StandaloneInputModule#SendMoveEventToSelectedObject","UnityEngine.EventSystems.StandaloneInputModule#ProcessMouseEvent","UnityEngine.EventSystems.StandaloneInputModule#ProcessMouseEvent$1","UnityEngine.EventSystems.StandaloneInputModule#ForceAutoSelect","UnityEngine.EventSystems.StandaloneInputModule#SendUpdateEventToSelectedObject","UnityEngine.EventSystems.StandaloneInputModule#ProcessMousePress","UnityEngine.EventSystems.StandaloneInputModule#GetCurrentFocusedGameObject","UnityEngine.UI.Button#onClick#get","UnityEngine.UI.Button#onClick#set","UnityEngine.UI.Button#init","UnityEngine.UI.Button#$ctor1","UnityEngine.UI.Button#ctor","UnityEngine.UI.Button#OnPointerClick","UnityEngine.UI.Button#OnSubmit","UnityEngine.UI.Button#Press","UnityEngine.UI.Button#OnFinishSubmit","UnityEngine.UI.Button#ConfigureForEntity","UnityEngine.UI.Dropdown#init","UnityEngine.UI.Dropdown#GetOrAddComponent","UnityEngine.UI.Dropdown#template#get","UnityEngine.UI.Dropdown#template#set","UnityEngine.UI.Dropdown#captionText#get","UnityEngine.UI.Dropdown#captionText#set","UnityEngine.UI.Dropdown#captionImage#get","UnityEngine.UI.Dropdown#captionImage#set","UnityEngine.UI.Dropdown#itemText#get","UnityEngine.UI.Dropdown#itemText#set","UnityEngine.UI.Dropdown#itemImage#get","UnityEngine.UI.Dropdown#itemImage#set","UnityEngine.UI.Dropdown#options#get","UnityEngine.UI.Dropdown#options#set","UnityEngine.UI.Dropdown#onValueChanged#get","UnityEngine.UI.Dropdown#onValueChanged#set","UnityEngine.UI.Dropdown#alphaFadeSpeed#get","UnityEngine.UI.Dropdown#alphaFadeSpeed#set","UnityEngine.UI.Dropdown#value#get","UnityEngine.UI.Dropdown#value#set","UnityEngine.UI.Dropdown#init","UnityEngine.UI.Dropdown#$ctor1","UnityEngine.UI.Dropdown#ctor","UnityEngine.UI.Dropdown#SetValueWithoutNotify","UnityEngine.UI.Dropdown#Set","UnityEngine.UI.Dropdown#Awake","UnityEngine.UI.Dropdown#Start","UnityEngine.UI.Dropdown#OnDisable","UnityEngine.UI.Dropdown#RefreshShownValue","UnityEngine.UI.Dropdown#AddOptions$2","UnityEngine.UI.Dropdown#AddOptions","UnityEngine.UI.Dropdown#AddOptions$1","UnityEngine.UI.Dropdown#ClearOptions","UnityEngine.UI.Dropdown#SetupTemplate","UnityEngine.UI.Dropdown#OnPointerClick","UnityEngine.UI.Dropdown#OnSubmit","UnityEngine.UI.Dropdown#OnCancel","UnityEngine.UI.Dropdown#Show","UnityEngine.UI.Dropdown#CreateBlocker","UnityEngine.UI.Dropdown#DestroyBlocker","UnityEngine.UI.Dropdown#CreateDropdownList","UnityEngine.UI.Dropdown#DestroyDropdownList","UnityEngine.UI.Dropdown#CreateItem","UnityEngine.UI.Dropdown#DestroyItem","UnityEngine.UI.Dropdown#AddItem","UnityEngine.UI.Dropdown#AlphaFadeList","UnityEngine.UI.Dropdown#AlphaFadeList$1","UnityEngine.UI.Dropdown#SetAlpha","UnityEngine.UI.Dropdown#Hide","UnityEngine.UI.Dropdown#DelayedDestroyDropdownList","UnityEngine.UI.Dropdown#ImmediateDestroyDropdownList","UnityEngine.UI.Dropdown#OnSelectItem","UnityEngine.UI.GridLayoutGroup#startCorner#get","UnityEngine.UI.GridLayoutGroup#startCorner#set","UnityEngine.UI.GridLayoutGroup#startAxis#get","UnityEngine.UI.GridLayoutGroup#startAxis#set","UnityEngine.UI.GridLayoutGroup#cellSize#get","UnityEngine.UI.GridLayoutGroup#cellSize#set","UnityEngine.UI.GridLayoutGroup#spacing#get","UnityEngine.UI.GridLayoutGroup#spacing#set","UnityEngine.UI.GridLayoutGroup#constraint#get","UnityEngine.UI.GridLayoutGroup#constraint#set","UnityEngine.UI.GridLayoutGroup#constraintCount#get","UnityEngine.UI.GridLayoutGroup#constraintCount#set","UnityEngine.UI.GridLayoutGroup#init","UnityEngine.UI.GridLayoutGroup#CalculateLayoutInputHorizontal","UnityEngine.UI.GridLayoutGroup#CalculateLayoutInputVertical","UnityEngine.UI.GridLayoutGroup#SetLayoutHorizontal","UnityEngine.UI.GridLayoutGroup#SetLayoutVertical","UnityEngine.UI.GridLayoutGroup#SetCellsAlongAxis","UnityEngine.UI.HorizontalOrVerticalLayoutGroup#spacing#get","UnityEngine.UI.HorizontalOrVerticalLayoutGroup#spacing#set","UnityEngine.UI.HorizontalOrVerticalLayoutGroup#childForceExpandWidth#get","UnityEngine.UI.HorizontalOrVerticalLayoutGroup#childForceExpandWidth#set","UnityEngine.UI.HorizontalOrVerticalLayoutGroup#childForceExpandHeight#get","UnityEngine.UI.HorizontalOrVerticalLayoutGroup#childForceExpandHeight#set","UnityEngine.UI.HorizontalOrVerticalLayoutGroup#childControlWidth#get","UnityEngine.UI.HorizontalOrVerticalLayoutGroup#childControlWidth#set","UnityEngine.UI.HorizontalOrVerticalLayoutGroup#childControlHeight#get","UnityEngine.UI.HorizontalOrVerticalLayoutGroup#childControlHeight#set","UnityEngine.UI.HorizontalOrVerticalLayoutGroup#init","UnityEngine.UI.HorizontalOrVerticalLayoutGroup#CalcAlongAxis","UnityEngine.UI.HorizontalOrVerticalLayoutGroup#SetChildrenAlongAxis","UnityEngine.UI.HorizontalOrVerticalLayoutGroup#GetChildSizes","UnityEngine.UI.Image#sprite#get","UnityEngine.UI.Image#sprite#set","UnityEngine.UI.Image#overrideSprite#get","UnityEngine.UI.Image#overrideSprite#set","UnityEngine.UI.Image#activeSprite#get","UnityEngine.UI.Image#type#get","UnityEngine.UI.Image#type#set","UnityEngine.UI.Image#fillMethod#get","UnityEngine.UI.Image#fillMethod#set","UnityEngine.UI.Image#fillCenter#get","UnityEngine.UI.Image#fillCenter#set","UnityEngine.UI.Image#fillOrigin#get","UnityEngine.UI.Image#fillOrigin#set","UnityEngine.UI.Image#fillClockwise#get","UnityEngine.UI.Image#fillClockwise#set","UnityEngine.UI.Image#fillAmount#get","UnityEngine.UI.Image#fillAmount#set","UnityEngine.UI.Image#preserveAspect#get","UnityEngine.UI.Image#preserveAspect#set","UnityEngine.UI.Image#material#get","UnityEngine.UI.Image#material#set","UnityEngine.UI.Image#enabled#get","UnityEngine.UI.Image#enabled#set","UnityEngine.UI.Image#pixelsPerUnitMultiplier#get","UnityEngine.UI.Image#pixelsPerUnitMultiplier#set","UnityEngine.UI.Image#pixelsPerUnit#get","UnityEngine.UI.Image#multipliedPixelsPerUnit#get","UnityEngine.UI.Image#mainTexture#get","UnityEngine.UI.Image#hasBorder#get","UnityEngine.UI.Image#minWidth#get","UnityEngine.UI.Image#preferredWidth#get","UnityEngine.UI.Image#flexibleWidth#get","UnityEngine.UI.Image#minHeight#get","UnityEngine.UI.Image#preferredHeight#get","UnityEngine.UI.Image#flexibleHeight#get","UnityEngine.UI.Image#layoutPriority#get","UnityEngine.UI.Image#alphaHitTestMinimumThreshold#get","UnityEngine.UI.Image#alphaHitTestMinimumThreshold#set","UnityEngine.UI.Image#init","UnityEngine.UI.Image#$ctor1","UnityEngine.UI.Image#ctor","UnityEngine.UI.Image#DisableSpriteOptimizations","UnityEngine.UI.Image#Awake","UnityEngine.UI.Image#OnEnable","UnityEngine.UI.Image#OnDisable","UnityEngine.UI.Image#ConfigureForEntity","UnityEngine.UI.Image#OnDidApplyAnimationProperties","UnityEngine.UI.Image#CalculateLayoutInputHorizontal","UnityEngine.UI.Image#CalculateLayoutInputVertical","UnityEngine.UI.Image#SetNativeSize","UnityEngine.UI.Image#IsRaycastLocationValid","UnityEngine.UI.Image#MapCoordinate","UnityEngine.UI.Image#GetAdjustedBorders","UnityEngine.UI.InputField#clipboard#get","UnityEngine.UI.InputField#clipboard#set","UnityEngine.UI.InputField#init","UnityEngine.UI.InputField#GetLineStartPosition","UnityEngine.UI.InputField#GetLineEndPosition","UnityEngine.UI.InputField#input#get","UnityEngine.UI.InputField#compositionString#get","UnityEngine.UI.InputField#mesh#get","UnityEngine.UI.InputField#cachedInputTextGenerator#get","UnityEngine.UI.InputField#shouldHideMobileInput#get","UnityEngine.UI.InputField#shouldHideMobileInput#set","UnityEngine.UI.InputField#shouldActivateOnSelect#get","UnityEngine.UI.InputField#text#get","UnityEngine.UI.InputField#text#set","UnityEngine.UI.InputField#isFocused#get","UnityEngine.UI.InputField#caretBlinkRate#get","UnityEngine.UI.InputField#caretBlinkRate#set","UnityEngine.UI.InputField#caretWidth#get","UnityEngine.UI.InputField#caretWidth#set","UnityEngine.UI.InputField#textComponent#get","UnityEngine.UI.InputField#textComponent#set","UnityEngine.UI.InputField#placeholder#get","UnityEngine.UI.InputField#placeholder#set","UnityEngine.UI.InputField#caretColor#get","UnityEngine.UI.InputField#caretColor#set","UnityEngine.UI.InputField#customCaretColor#get","UnityEngine.UI.InputField#customCaretColor#set","UnityEngine.UI.InputField#selectionColor#get","UnityEngine.UI.InputField#selectionColor#set","UnityEngine.UI.InputField#onEndEdit#get","UnityEngine.UI.InputField#onEndEdit#set","UnityEngine.UI.InputField#onValueChange#get","UnityEngine.UI.InputField#onValueChange#set","UnityEngine.UI.InputField#onValueChanged#get","UnityEngine.UI.InputField#onValueChanged#set","UnityEngine.UI.InputField#onValidateInput#get","UnityEngine.UI.InputField#onValidateInput#set","UnityEngine.UI.InputField#characterLimit#get","UnityEngine.UI.InputField#characterLimit#set","UnityEngine.UI.InputField#contentType#get","UnityEngine.UI.InputField#contentType#set","UnityEngine.UI.InputField#lineType#get","UnityEngine.UI.InputField#lineType#set","UnityEngine.UI.InputField#inputType#get","UnityEngine.UI.InputField#inputType#set","UnityEngine.UI.InputField#touchScreenKeyboard#get","UnityEngine.UI.InputField#keyboardType#get","UnityEngine.UI.InputField#keyboardType#set","UnityEngine.UI.InputField#characterValidation#get","UnityEngine.UI.InputField#characterValidation#set","UnityEngine.UI.InputField#readOnly#get","UnityEngine.UI.InputField#readOnly#set","UnityEngine.UI.InputField#multiLine#get","UnityEngine.UI.InputField#asteriskChar#get","UnityEngine.UI.InputField#asteriskChar#set","UnityEngine.UI.InputField#wasCanceled#get","UnityEngine.UI.InputField#caretPositionInternal#get","UnityEngine.UI.InputField#caretPositionInternal#set","UnityEngine.UI.InputField#caretSelectPositionInternal#get","UnityEngine.UI.InputField#caretSelectPositionInternal#set","UnityEngine.UI.InputField#hasSelection$1#get","UnityEngine.UI.InputField#caretPosition#get","UnityEngine.UI.InputField#caretPosition#set","UnityEngine.UI.InputField#selectionAnchorPosition#get","UnityEngine.UI.InputField#selectionAnchorPosition#set","UnityEngine.UI.InputField#selectionFocusPosition#get","UnityEngine.UI.InputField#selectionFocusPosition#set","UnityEngine.UI.InputField#minWidth#get","UnityEngine.UI.InputField#preferredWidth#get","UnityEngine.UI.InputField#flexibleWidth#get","UnityEngine.UI.InputField#minHeight#get","UnityEngine.UI.InputField#preferredHeight#get","UnityEngine.UI.InputField#flexibleHeight#get","UnityEngine.UI.InputField#layoutPriority#get","UnityEngine.UI.InputField#init","UnityEngine.UI.InputField#ctor","UnityEngine.UI.InputField#ClampPos","UnityEngine.UI.InputField#OnEnable","UnityEngine.UI.InputField#OnDisable","UnityEngine.UI.InputField#CaretBlink","UnityEngine.UI.InputField#SetCaretVisible","UnityEngine.UI.InputField#SetCaretActive","UnityEngine.UI.InputField#UpdateCaretMaterial","UnityEngine.UI.InputField#OnFocus","UnityEngine.UI.InputField#SelectAll","UnityEngine.UI.InputField#MoveTextEnd","UnityEngine.UI.InputField#MoveTextStart","UnityEngine.UI.InputField#InPlaceEditing","UnityEngine.UI.InputField#UpdateCaretFromKeyboard","UnityEngine.UI.InputField#LateUpdate","UnityEngine.UI.InputField#GetUnclampedCharacterLineFromPosition","UnityEngine.UI.InputField#GetCharacterIndexFromPosition","UnityEngine.UI.InputField#MayDrag","UnityEngine.UI.InputField#OnBeginDrag","UnityEngine.UI.InputField#OnDrag","UnityEngine.UI.InputField#MouseDragOutsideRect","UnityEngine.UI.InputField#OnEndDrag","UnityEngine.UI.InputField#OnPointerDown","UnityEngine.UI.InputField#KeyPressed","UnityEngine.UI.InputField#IsValidChar","UnityEngine.UI.InputField#ProcessEvent","UnityEngine.UI.InputField#OnUpdateSelected","UnityEngine.UI.InputField#GetSelectedString","UnityEngine.UI.InputField#FindtNextWordBegin","UnityEngine.UI.InputField#MoveRight","UnityEngine.UI.InputField#FindtPrevWordBegin","UnityEngine.UI.InputField#MoveLeft","UnityEngine.UI.InputField#DetermineCharacterLine","UnityEngine.UI.InputField#LineUpCharacterPosition","UnityEngine.UI.InputField#LineDownCharacterPosition","UnityEngine.UI.InputField#MoveDown","UnityEngine.UI.InputField#MoveDown$1","UnityEngine.UI.InputField#MoveUp","UnityEngine.UI.InputField#MoveUp$1","UnityEngine.UI.InputField#Delete","UnityEngine.UI.InputField#ForwardSpace","UnityEngine.UI.InputField#Backspace","UnityEngine.UI.InputField#Insert","UnityEngine.UI.InputField#SendOnValueChangedAndUpdateLabel","UnityEngine.UI.InputField#SendOnValueChanged","UnityEngine.UI.InputField#SendOnSubmit","UnityEngine.UI.InputField#Append$1","UnityEngine.UI.InputField#Append","UnityEngine.UI.InputField#UpdateLabel","UnityEngine.UI.InputField#IsSelectionVisible","UnityEngine.UI.InputField#SetDrawRangeToContainCaretPosition","UnityEngine.UI.InputField#ForceLabelUpdate","UnityEngine.UI.InputField#MarkGeometryAsDirty","UnityEngine.UI.InputField#Rebuild","UnityEngine.UI.InputField#LayoutComplete","UnityEngine.UI.InputField#GraphicUpdateComplete","UnityEngine.UI.InputField#UpdateGeometry","UnityEngine.UI.InputField#AssignPositioningIfNeeded","UnityEngine.UI.InputField#OnFillVBO","UnityEngine.UI.InputField#GenerateCaret","UnityEngine.UI.InputField#CreateCursorVerts","UnityEngine.UI.InputField#GenerateHightlight","UnityEngine.UI.InputField#Validate","UnityEngine.UI.InputField#ActivateInputField","UnityEngine.UI.InputField#ActivateInputFieldInternal","UnityEngine.UI.InputField#OnSelect","UnityEngine.UI.InputField#OnPointerClick","UnityEngine.UI.InputField#DeactivateInputField","UnityEngine.UI.InputField#OnDeselect","UnityEngine.UI.InputField#OnSubmit","UnityEngine.UI.InputField#EnforceContentType","UnityEngine.UI.InputField#EnforceTextHOverflow","UnityEngine.UI.InputField#SetToCustomIfContentTypeIsNot","UnityEngine.UI.InputField#SetToCustom","UnityEngine.UI.InputField#DoStateTransition","UnityEngine.UI.InputField#CalculateLayoutInputHorizontal","UnityEngine.UI.InputField#CalculateLayoutInputVertical","UnityEngine.UI.InputField#Awake","UnityEngine.UI.InputField#OnCanvasHierarchyChanged","UnityEngine.UI.InputField#OnEnableWebInput","UnityEngine.UI.InputField#OnRectTransformDimensionsChange","UnityEngine.UI.InputField#AllCanvasedEnabled","UnityEngine.UI.InputField#Update","UnityEngine.UI.InputField#OnDisableWebInput","UnityEngine.UI.InputField#ResizeWebInput","UnityEngine.UI.Outline#ctor","UnityEngine.UI.Outline#ModifyMesh$1","UnityEngine.UI.RawImage#texture#get","UnityEngine.UI.RawImage#texture#set","UnityEngine.UI.RawImage#mainTexture#get","UnityEngine.UI.RawImage#uvRect#get","UnityEngine.UI.RawImage#uvRect#set","UnityEngine.UI.RawImage#enabled#get","UnityEngine.UI.RawImage#enabled#set","UnityEngine.UI.RawImage#init","UnityEngine.UI.RawImage#$ctor1","UnityEngine.UI.RawImage#ctor","UnityEngine.UI.RawImage#Awake","UnityEngine.UI.RawImage#OnDidApplyAnimationProperties","UnityEngine.UI.RawImage#ConfigureForEntity","UnityEngine.UI.Scrollbar#handleRect#get","UnityEngine.UI.Scrollbar#handleRect#set","UnityEngine.UI.Scrollbar#direction#get","UnityEngine.UI.Scrollbar#direction#set","UnityEngine.UI.Scrollbar#value#get","UnityEngine.UI.Scrollbar#value#set","UnityEngine.UI.Scrollbar#size#get","UnityEngine.UI.Scrollbar#size#set","UnityEngine.UI.Scrollbar#numberOfSteps#get","UnityEngine.UI.Scrollbar#numberOfSteps#set","UnityEngine.UI.Scrollbar#stepSize#get","UnityEngine.UI.Scrollbar#axis#get","UnityEngine.UI.Scrollbar#reverseValue#get","UnityEngine.UI.Scrollbar#init","UnityEngine.UI.Scrollbar#ctor","UnityEngine.UI.Scrollbar#Update","UnityEngine.UI.Scrollbar#OnEnable","UnityEngine.UI.Scrollbar#OnDisable","UnityEngine.UI.Scrollbar#OnRectTransformDimensionsChange","UnityEngine.UI.Scrollbar#OnBeginDrag","UnityEngine.UI.Scrollbar#Rebuild","UnityEngine.UI.Scrollbar#LayoutComplete","UnityEngine.UI.Scrollbar#GraphicUpdateComplete","UnityEngine.UI.Scrollbar#OnDrag","UnityEngine.UI.Scrollbar#OnInitializePotentialDrag","UnityEngine.UI.Scrollbar#SetValueWithoutNotify","UnityEngine.UI.Scrollbar#UpdateCachedReferences","UnityEngine.UI.Scrollbar#Set","UnityEngine.UI.Scrollbar#UpdateVisuals","UnityEngine.UI.Scrollbar#UpdateDrag","UnityEngine.UI.Scrollbar#DoUpdateDrag","UnityEngine.UI.Scrollbar#MayDrag","UnityEngine.UI.Scrollbar#OnPointerDown","UnityEngine.UI.Scrollbar#ClickRepeat","UnityEngine.UI.Scrollbar#OnPointerUp","UnityEngine.UI.Scrollbar#OnMove","UnityEngine.UI.Scrollbar#FindSelectableOnLeft","UnityEngine.UI.Scrollbar#FindSelectableOnRight","UnityEngine.UI.Scrollbar#FindSelectableOnUp","UnityEngine.UI.Scrollbar#FindSelectableOnDown","UnityEngine.UI.Scrollbar#SetDirection","UnityEngine.UI.Slider#fillRect#get","UnityEngine.UI.Slider#fillRect#set","UnityEngine.UI.Slider#handleRect#get","UnityEngine.UI.Slider#handleRect#set","UnityEngine.UI.Slider#direction#get","UnityEngine.UI.Slider#direction#set","UnityEngine.UI.Slider#minValue#get","UnityEngine.UI.Slider#minValue#set","UnityEngine.UI.Slider#maxValue#get","UnityEngine.UI.Slider#maxValue#set","UnityEngine.UI.Slider#wholeNumbers#get","UnityEngine.UI.Slider#wholeNumbers#set","UnityEngine.UI.Slider#value#get","UnityEngine.UI.Slider#value#set","UnityEngine.UI.Slider#normalizedValue#get","UnityEngine.UI.Slider#normalizedValue#set","UnityEngine.UI.Slider#onValueChanged#get","UnityEngine.UI.Slider#onValueChanged#set","UnityEngine.UI.Slider#stepSize#get","UnityEngine.UI.Slider#axis#get","UnityEngine.UI.Slider#reverseValue#get","UnityEngine.UI.Slider#init","UnityEngine.UI.Slider#ctor","UnityEngine.UI.Slider#$ctor1","UnityEngine.UI.Slider#SetValueWithoutNotify","UnityEngine.UI.Slider#Rebuild","UnityEngine.UI.Slider#LayoutComplete","UnityEngine.UI.Slider#GraphicUpdateComplete","UnityEngine.UI.Slider#OnEnable","UnityEngine.UI.Slider#OnDisable","UnityEngine.UI.Slider#Update","UnityEngine.UI.Slider#OnDidApplyAnimationProperties","UnityEngine.UI.Slider#UpdateCachedReferences","UnityEngine.UI.Slider#ClampValue","UnityEngine.UI.Slider#Set","UnityEngine.UI.Slider#OnRectTransformDimensionsChange","UnityEngine.UI.Slider#UpdateVisuals","UnityEngine.UI.Slider#UpdateDrag","UnityEngine.UI.Slider#MayDrag","UnityEngine.UI.Slider#OnPointerDown","UnityEngine.UI.Slider#OnDrag","UnityEngine.UI.Slider#OnMove","UnityEngine.UI.Slider#FindSelectableOnLeft","UnityEngine.UI.Slider#FindSelectableOnRight","UnityEngine.UI.Slider#FindSelectableOnUp","UnityEngine.UI.Slider#FindSelectableOnDown","UnityEngine.UI.Slider#OnInitializePotentialDrag","UnityEngine.UI.Slider#SetDirection","UnityEngine.UI.Slider#ConfigureForEntity","UnityEngine.UI.Text#material#get","UnityEngine.UI.Text#material#set","UnityEngine.UI.Text#fontData#get","UnityEngine.UI.Text#fontData#set","UnityEngine.UI.Text#mainTexture#get","UnityEngine.UI.Text#alignment#get","UnityEngine.UI.Text#alignment#set","UnityEngine.UI.Text#text#get","UnityEngine.UI.Text#text#set","UnityEngine.UI.Text#font#get","UnityEngine.UI.Text#font#set","UnityEngine.UI.Text#fontSize#get","UnityEngine.UI.Text#fontSize#set","UnityEngine.UI.Text#fontStyle#get","UnityEngine.UI.Text#fontStyle#set","UnityEngine.UI.Text#resizeTextMaxSize#get","UnityEngine.UI.Text#resizeTextMaxSize#set","UnityEngine.UI.Text#resizeTextMinSize#get","UnityEngine.UI.Text#resizeTextMinSize#set","UnityEngine.UI.Text#textGenerator#get","UnityEngine.UI.Text#cachedTextGenerator#get","UnityEngine.UI.Text#resizeTextForBestFit#get","UnityEngine.UI.Text#resizeTextForBestFit#set","UnityEngine.UI.Text#flexibleHeight#get","UnityEngine.UI.Text#flexibleWidth#get","UnityEngine.UI.Text#layoutPriority#get","UnityEngine.UI.Text#minHeight#get","UnityEngine.UI.Text#minWidth#get","UnityEngine.UI.Text#preferredWidth#get","UnityEngine.UI.Text#preferredHeight#get","UnityEngine.UI.Text#horizontalOverflow#get","UnityEngine.UI.Text#horizontalOverflow#set","UnityEngine.UI.Text#verticalOverflow#get","UnityEngine.UI.Text#verticalOverflow#set","UnityEngine.UI.Text#supportRichText#get","UnityEngine.UI.Text#supportRichText#set","UnityEngine.UI.Text#pixelsPerUnit#get","UnityEngine.UI.Text#init","UnityEngine.UI.Text#$ctor1","UnityEngine.UI.Text#ctor","UnityEngine.UI.Text#ConfigureForEntity","UnityEngine.UI.Text#Awake","UnityEngine.UI.Text#OnEnable","UnityEngine.UI.Text#OnDisable","UnityEngine.UI.Text#ApplyFontDataChanges","UnityEngine.UI.Text#CalculateLayoutInputHorizontal","UnityEngine.UI.Text#CalculateLayoutInputVertical","UnityEngine.UI.Text#OnDidApplyAnimationProperties","UnityEngine.UI.Text#OnRectTransformDimensionsChange","UnityEngine.UI.Text#GetGenerationSettings","UnityEngine.UI.Toggle#group#get","UnityEngine.UI.Toggle#group#set","UnityEngine.UI.Toggle#isOn#get","UnityEngine.UI.Toggle#isOn#set","UnityEngine.UI.Toggle#init","UnityEngine.UI.Toggle#ctor","UnityEngine.UI.Toggle#Start","UnityEngine.UI.Toggle#OnEnable","UnityEngine.UI.Toggle#OnDisable","UnityEngine.UI.Toggle#OnDidApplyAnimationProperties","UnityEngine.UI.Toggle#Rebuild","UnityEngine.UI.Toggle#LayoutComplete","UnityEngine.UI.Toggle#GraphicUpdateComplete","UnityEngine.UI.Toggle#OnPointerClick","UnityEngine.UI.Toggle#OnSubmit","UnityEngine.UI.Toggle#SetToggleGroup","UnityEngine.UI.Toggle#SetIsOnWithoutNotify","UnityEngine.UI.Toggle#Set","UnityEngine.UI.Toggle#PlayEffect","UnityEngine.UI.Toggle#InternalToggle","UnityEngine.UI.HorizontalLayoutGroup#ctor","UnityEngine.UI.HorizontalLayoutGroup#CalculateLayoutInputHorizontal","UnityEngine.UI.HorizontalLayoutGroup#CalculateLayoutInputVertical","UnityEngine.UI.HorizontalLayoutGroup#SetLayoutHorizontal","UnityEngine.UI.HorizontalLayoutGroup#SetLayoutVertical","UnityEngine.UI.VerticalLayoutGroup#ctor","UnityEngine.UI.VerticalLayoutGroup#CalculateLayoutInputHorizontal","UnityEngine.UI.VerticalLayoutGroup#CalculateLayoutInputVertical","UnityEngine.UI.VerticalLayoutGroup#SetLayoutHorizontal","UnityEngine.UI.VerticalLayoutGroup#SetLayoutVertical"]' ) ); }
/**
 * @compiler Bridge.NET 17.9.33-luna
 */
Bridge.assembly("UnityEngine.UI", function ($asm, globals) {
    "use strict";

    /*UnityEngine.EventSystems.AbstractEventData start.*/
    Bridge.define("UnityEngine.EventSystems.AbstractEventData", {
        fields: {
            m_Used: false
        },
        props: {
            used: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.AbstractEventData#used#get", this ); }

                    return this.m_Used;
                }
            }
        },
        methods: {
            /*UnityEngine.EventSystems.AbstractEventData.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.AbstractEventData#Reset", this ); }

                this.m_Used = false;
            },
            /*UnityEngine.EventSystems.AbstractEventData.Reset end.*/

            /*UnityEngine.EventSystems.AbstractEventData.Use start.*/
            Use: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.AbstractEventData#Use", this ); }

                this.m_Used = true;
            },
            /*UnityEngine.EventSystems.AbstractEventData.Use end.*/


        }
    });
    /*UnityEngine.EventSystems.AbstractEventData end.*/

    /*UnityEngine.EventSystems.UIBehaviour start.*/
    Bridge.define("UnityEngine.EventSystems.UIBehaviour", {
        inherits: [UnityEngine.MonoBehaviour],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.UIBehaviour#ctor", this ); }

                this.$initialize();
                UnityEngine.MonoBehaviour.ctor.call(this);
            },
            /**
             * Initializes a new instance of the {@link } class.
             *
             * @instance
             * @public
             * @this UnityEngine.EventSystems.UIBehaviour
             * @memberof UnityEngine.EventSystems.UIBehaviour
             * @param   {pc.MonoBehaviourComponent}    handle    Handle.
             * @return  {void}
             */
            $ctor1: function (handle) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.UIBehaviour#$ctor1", this ); }

                this.$initialize();
                UnityEngine.MonoBehaviour.ctor.call(this, handle);
            }
        },
        methods: {
            /*UnityEngine.EventSystems.UIBehaviour.IsActive start.*/
            /**
             * Ises the active.
             *
             * @instance
             * @public
             * @this UnityEngine.EventSystems.UIBehaviour
             * @memberof UnityEngine.EventSystems.UIBehaviour
             * @return  {boolean}        <pre><code>true</code></pre>, if active was ised, <pre><code>false</code></pre> otherwise.
             */
            IsActive: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.UIBehaviour#IsActive", this ); }

                return this.handle.enabled;
            },
            /*UnityEngine.EventSystems.UIBehaviour.IsActive end.*/

            /*UnityEngine.EventSystems.UIBehaviour.Awake start.*/
            /**
             * Awake this instance.
             *
             * @instance
             * @protected
             * @this UnityEngine.EventSystems.UIBehaviour
             * @memberof UnityEngine.EventSystems.UIBehaviour
             * @return  {void}
             */
            Awake: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.UIBehaviour#Awake", this ); }
 },
            /*UnityEngine.EventSystems.UIBehaviour.Awake end.*/

            /*UnityEngine.EventSystems.UIBehaviour.OnEnable start.*/
            /**
             * Ons the enable.
             *
             * @instance
             * @protected
             * @this UnityEngine.EventSystems.UIBehaviour
             * @memberof UnityEngine.EventSystems.UIBehaviour
             * @return  {void}
             */
            OnEnable: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.UIBehaviour#OnEnable", this ); }
 },
            /*UnityEngine.EventSystems.UIBehaviour.OnEnable end.*/

            /*UnityEngine.EventSystems.UIBehaviour.OnDisable start.*/
            /**
             * Ons the disable.
             *
             * @instance
             * @protected
             * @this UnityEngine.EventSystems.UIBehaviour
             * @memberof UnityEngine.EventSystems.UIBehaviour
             * @return  {void}
             */
            OnDisable: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.UIBehaviour#OnDisable", this ); }
 },
            /*UnityEngine.EventSystems.UIBehaviour.OnDisable end.*/

            /*UnityEngine.EventSystems.UIBehaviour.OnRectTransformDimensionsChange start.*/
            /**
             * Ons the rect transform dimensions change.
             *
             * @instance
             * @protected
             * @this UnityEngine.EventSystems.UIBehaviour
             * @memberof UnityEngine.EventSystems.UIBehaviour
             * @return  {void}
             */
            OnRectTransformDimensionsChange: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.UIBehaviour#OnRectTransformDimensionsChange", this ); }
 },
            /*UnityEngine.EventSystems.UIBehaviour.OnRectTransformDimensionsChange end.*/

            /*UnityEngine.EventSystems.UIBehaviour.OnTransformParentChanged start.*/
            /**
             * Ons the transform parent changed.
             *
             * @instance
             * @protected
             * @this UnityEngine.EventSystems.UIBehaviour
             * @memberof UnityEngine.EventSystems.UIBehaviour
             * @return  {void}
             */
            OnTransformParentChanged: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.UIBehaviour#OnTransformParentChanged", this ); }
 },
            /*UnityEngine.EventSystems.UIBehaviour.OnTransformParentChanged end.*/

            /*UnityEngine.EventSystems.UIBehaviour.OnDestroy start.*/
            /**
             * Ons the destroy.
             *
             * @instance
             * @protected
             * @this UnityEngine.EventSystems.UIBehaviour
             * @memberof UnityEngine.EventSystems.UIBehaviour
             * @return  {void}
             */
            OnDestroy: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.UIBehaviour#OnDestroy", this ); }
 },
            /*UnityEngine.EventSystems.UIBehaviour.OnDestroy end.*/

            /*UnityEngine.EventSystems.UIBehaviour.Start start.*/
            /**
             * Start this instance.
             *
             * @instance
             * @protected
             * @this UnityEngine.EventSystems.UIBehaviour
             * @memberof UnityEngine.EventSystems.UIBehaviour
             * @return  {void}
             */
            Start: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.UIBehaviour#Start", this ); }
 },
            /*UnityEngine.EventSystems.UIBehaviour.Start end.*/

            /*UnityEngine.EventSystems.UIBehaviour.OnDidApplyAnimationProperties start.*/
            /**
             * <p>See UI.LayoutGroup.OnDidApplyAnimationProperties.</p>
             *
             * @instance
             * @protected
             * @this UnityEngine.EventSystems.UIBehaviour
             * @memberof UnityEngine.EventSystems.UIBehaviour
             * @return  {void}
             */
            OnDidApplyAnimationProperties: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.UIBehaviour#OnDidApplyAnimationProperties", this ); }
 },
            /*UnityEngine.EventSystems.UIBehaviour.OnDidApplyAnimationProperties end.*/

            /*UnityEngine.EventSystems.UIBehaviour.ConfigureForEntity start.*/
            /**
             * Configures for entity.
             *
             * @instance
             * @public
             * @override
             * @this UnityEngine.EventSystems.UIBehaviour
             * @memberof UnityEngine.EventSystems.UIBehaviour
             * @param   {pc.Entity}    entity    Entity.
             * @return  {void}
             */
            ConfigureForEntity: function (entity) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.UIBehaviour#ConfigureForEntity", this ); }

                UnityEngine.MonoBehaviour.prototype.ConfigureForEntity.call(this, entity);

                if (entity.element == null) {
                    entity.addComponent("element");
                }

                // check for ILayoutElement interface presence
                if (!!this.UnityEngine$UI$ILayoutElement$CalculateLayoutInputHorizontal) {
                    entity._layoutElements.push(this);
                }

                // check for ICanvasElement interface presence
                if (!!this.UnityEngine$UI$ICanvasElement$LayoutComplete) {
                    entity._canvasElements.push(this);
                }

                // check that the implementation of the OnRectTransformDimensionsChange is different from base one (empty)
                if (this.OnRectTransformDimensionsChange !== UnityEngine.EventSystems.UIBehaviour.prototype.OnRectTransformDimensionsChange) {
                    entity._dimensionListeners.push(this);
                }

                // check for ILayoutController interface presence
                var isLayoutController = !!this.UnityEngine$UI$ILayoutController$SetLayoutHorizontal;

                if (!isLayoutController) {
                    return;
                }

                // this check has to stay as in: ILayoutSelfController does not introduce new methods :(
                if (Bridge.is(this, UnityEngine.UI.ILayoutSelfController)) {
                    entity._layoutSelfControllers.push(this);
                } else {
                    entity._layoutControllers.push(this);
                }
            },
            /*UnityEngine.EventSystems.UIBehaviour.ConfigureForEntity end.*/

            /*UnityEngine.EventSystems.UIBehaviour.OnCanvasHierarchyChanged start.*/
            /**
             * Called when the state of the parent Canvas is changed.
             *
             * @instance
             * @protected
             * @this UnityEngine.EventSystems.UIBehaviour
             * @memberof UnityEngine.EventSystems.UIBehaviour
             * @return  {void}
             */
            OnCanvasHierarchyChanged: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.UIBehaviour#OnCanvasHierarchyChanged", this ); }
 },
            /*UnityEngine.EventSystems.UIBehaviour.OnCanvasHierarchyChanged end.*/

            /*UnityEngine.EventSystems.UIBehaviour.OnCanvasGroupChanged start.*/
            OnCanvasGroupChanged: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.UIBehaviour#OnCanvasGroupChanged", this ); }
 },
            /*UnityEngine.EventSystems.UIBehaviour.OnCanvasGroupChanged end.*/

            /*UnityEngine.EventSystems.UIBehaviour.IsDestroyed start.*/
            /**
             * <p>Returns true if the native representation of the behaviour has been destroyed.</p>
             *
             * @instance
             * @public
             * @this UnityEngine.EventSystems.UIBehaviour
             * @memberof UnityEngine.EventSystems.UIBehaviour
             * @return  {boolean}        <p>True if Destroyed.</p>
             */
            IsDestroyed: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.UIBehaviour#IsDestroyed", this ); }

                return Bridge.referenceEquals(Bridge.cast(this, UnityEngine.Object), null);
            },
            /*UnityEngine.EventSystems.UIBehaviour.IsDestroyed end.*/


        }
    });
    /*UnityEngine.EventSystems.UIBehaviour end.*/

    /*UnityEngine.EventSystems.IEventSystemHandler start.*/
    Bridge.define("UnityEngine.EventSystems.IEventSystemHandler", {
        $kind: 3
    });
    /*UnityEngine.EventSystems.IEventSystemHandler end.*/

    /*UnityEngine.EventSystems.EventTrigger+Entry start.*/
    /** @namespace UnityEngine.EventSystems */

    /**
     * Entry.
     *
     * @public
     * @class UnityEngine.EventSystems.EventTrigger.Entry
     */
    Bridge.define("UnityEngine.EventSystems.EventTrigger.Entry", {
        $kind: 1002,
        fields: {
            eventID: 0,
            callback: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventTrigger.Entry#init", this ); }

                this.callback = new UnityEngine.EventSystems.EventTrigger.TriggerEvent();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventTrigger.Entry#ctor", this ); }

                this.$initialize();
            }
        }
    });
    /*UnityEngine.EventSystems.EventTrigger+Entry end.*/

    /*UnityEngine.EventSystems.EventTriggerType start.*/
    Bridge.define("UnityEngine.EventSystems.EventTriggerType", {
        $kind: 6,
        statics: {
            fields: {
                PointerEnter: 0,
                PointerExit: 1,
                PointerDown: 2,
                PointerUp: 3,
                PointerClick: 4,
                Drag: 5,
                Drop: 6,
                Scroll: 7,
                UpdateSelected: 8,
                Select: 9,
                Deselect: 10,
                Move: 11,
                InitializePotentialDrag: 12,
                BeginDrag: 13,
                EndDrag: 14,
                Submit: 15,
                Cancel: 16
            }
        }
    });
    /*UnityEngine.EventSystems.EventTriggerType end.*/

    /*UnityEngine.EventSystems.ExecuteEvents start.*/
    Bridge.define("UnityEngine.EventSystems.ExecuteEvents", {
        statics: {
            fields: {
                _pointerEnterHandler: null,
                _pointerExitHandler: null,
                _pointerDownHandler: null,
                _pointerUpHandler: null,
                _pointerClickHandler: null,
                _initializePotentialDragHandler: null,
                _beginDragHandler: null,
                _dragHandler: null,
                _endDragHandler: null,
                _dropHandler: null,
                _scrollHandler: null,
                _updateSelectedHandler: null,
                _selectHandler: null,
                _deselectHandler: null,
                _moveHandler: null,
                _submitHandler: null,
                _cancelHandler: null,
                _handlerListPool: null,
                /**
                 * Execute the specified event on the first game object underneath the current touch.
                 *
                 * @static
                 * @private
                 * @readonly
                 * @memberof UnityEngine.EventSystems.ExecuteEvents
                 * @type System.Collections.Generic.List$1
                 */
                _internalTransformList: null
            },
            props: {
                pointerEnterHandler: {
                    get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#pointerEnterHandler#get", this ); }

                        return UnityEngine.EventSystems.ExecuteEvents._pointerEnterHandler;
                    }
                },
                pointerExitHandler: {
                    get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#pointerExitHandler#get", this ); }

                        return UnityEngine.EventSystems.ExecuteEvents._pointerExitHandler;
                    }
                },
                pointerDownHandler: {
                    get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#pointerDownHandler#get", this ); }

                        return UnityEngine.EventSystems.ExecuteEvents._pointerDownHandler;
                    }
                },
                pointerUpHandler: {
                    get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#pointerUpHandler#get", this ); }

                        return UnityEngine.EventSystems.ExecuteEvents._pointerUpHandler;
                    }
                },
                pointerClickHandler: {
                    get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#pointerClickHandler#get", this ); }

                        return UnityEngine.EventSystems.ExecuteEvents._pointerClickHandler;
                    }
                },
                initializePotentialDrag: {
                    get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#initializePotentialDrag#get", this ); }

                        return UnityEngine.EventSystems.ExecuteEvents._initializePotentialDragHandler;
                    }
                },
                beginDragHandler: {
                    get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#beginDragHandler#get", this ); }

                        return UnityEngine.EventSystems.ExecuteEvents._beginDragHandler;
                    }
                },
                dragHandler: {
                    get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#dragHandler#get", this ); }

                        return UnityEngine.EventSystems.ExecuteEvents._dragHandler;
                    }
                },
                endDragHandler: {
                    get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#endDragHandler#get", this ); }

                        return UnityEngine.EventSystems.ExecuteEvents._endDragHandler;
                    }
                },
                dropHandler: {
                    get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#dropHandler#get", this ); }

                        return UnityEngine.EventSystems.ExecuteEvents._dropHandler;
                    }
                },
                scrollHandler: {
                    get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#scrollHandler#get", this ); }

                        return UnityEngine.EventSystems.ExecuteEvents._scrollHandler;
                    }
                },
                updateSelectedHandler: {
                    get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#updateSelectedHandler#get", this ); }

                        return UnityEngine.EventSystems.ExecuteEvents._updateSelectedHandler;
                    }
                },
                selectHandler: {
                    get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#selectHandler#get", this ); }

                        return UnityEngine.EventSystems.ExecuteEvents._selectHandler;
                    }
                },
                deselectHandler: {
                    get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#deselectHandler#get", this ); }

                        return UnityEngine.EventSystems.ExecuteEvents._deselectHandler;
                    }
                },
                moveHandler: {
                    get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#moveHandler#get", this ); }

                        return UnityEngine.EventSystems.ExecuteEvents._moveHandler;
                    }
                },
                submitHandler: {
                    get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#submitHandler#get", this ); }

                        return UnityEngine.EventSystems.ExecuteEvents._submitHandler;
                    }
                },
                cancelHandler: {
                    get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#cancelHandler#get", this ); }

                        return UnityEngine.EventSystems.ExecuteEvents._cancelHandler;
                    }
                }
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#init", this ); }

                    this._pointerEnterHandler = UnityEngine.EventSystems.ExecuteEvents.Execute$11;
                    this._pointerExitHandler = UnityEngine.EventSystems.ExecuteEvents.Execute$12;
                    this._pointerDownHandler = UnityEngine.EventSystems.ExecuteEvents.Execute$10;
                    this._pointerUpHandler = UnityEngine.EventSystems.ExecuteEvents.Execute$13;
                    this._pointerClickHandler = UnityEngine.EventSystems.ExecuteEvents.Execute$9;
                    this._initializePotentialDragHandler = UnityEngine.EventSystems.ExecuteEvents.Execute$7;
                    this._beginDragHandler = UnityEngine.EventSystems.ExecuteEvents.Execute$1;
                    this._dragHandler = UnityEngine.EventSystems.ExecuteEvents.Execute$4;
                    this._endDragHandler = UnityEngine.EventSystems.ExecuteEvents.Execute$6;
                    this._dropHandler = UnityEngine.EventSystems.ExecuteEvents.Execute$5;
                    this._scrollHandler = UnityEngine.EventSystems.ExecuteEvents.Execute$14;
                    this._updateSelectedHandler = UnityEngine.EventSystems.ExecuteEvents.Execute$17;
                    this._selectHandler = UnityEngine.EventSystems.ExecuteEvents.Execute$15;
                    this._deselectHandler = UnityEngine.EventSystems.ExecuteEvents.Execute$3;
                    this._moveHandler = UnityEngine.EventSystems.ExecuteEvents.Execute$8;
                    this._submitHandler = UnityEngine.EventSystems.ExecuteEvents.Execute$16;
                    this._cancelHandler = UnityEngine.EventSystems.ExecuteEvents.Execute$2;
                    this._handlerListPool = new (UnityEngine.UI.ObjectPool$1(System.Collections.Generic.List$1(UnityEngine.EventSystems.IEventSystemHandler)))(null, function (l) {
                        l.clear();
                    });
                    this._internalTransformList = new (System.Collections.Generic.List$1(UnityEngine.Transform)).$ctor2(30);
                }
            },
            methods: {
                /*UnityEngine.EventSystems.ExecuteEvents.ValidateEventData:static start.*/
                ValidateEventData: function (T, data) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#ValidateEventData", this ); }

                    if (Bridge.as(data, T) == null) {
                        throw new System.ArgumentException.$ctor1(System.String.format("Invalid type: {0} passed to event expecting {1}", Bridge.getType(data), T));
                    }

                    return Bridge.as(data, T);
                },
                /*UnityEngine.EventSystems.ExecuteEvents.ValidateEventData:static end.*/

                /*UnityEngine.EventSystems.ExecuteEvents.Execute$11:static start.*/
                Execute$11: function (handler, eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#Execute$11", this ); }

                    handler.UnityEngine$EventSystems$IPointerEnterHandler$OnPointerEnter(UnityEngine.EventSystems.ExecuteEvents.ValidateEventData(UnityEngine.EventSystems.PointerEventData, eventData));
                },
                /*UnityEngine.EventSystems.ExecuteEvents.Execute$11:static end.*/

                /*UnityEngine.EventSystems.ExecuteEvents.Execute$12:static start.*/
                Execute$12: function (handler, eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#Execute$12", this ); }

                    handler.UnityEngine$EventSystems$IPointerExitHandler$OnPointerExit(UnityEngine.EventSystems.ExecuteEvents.ValidateEventData(UnityEngine.EventSystems.PointerEventData, eventData));
                },
                /*UnityEngine.EventSystems.ExecuteEvents.Execute$12:static end.*/

                /*UnityEngine.EventSystems.ExecuteEvents.Execute$10:static start.*/
                Execute$10: function (handler, eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#Execute$10", this ); }

                    handler.UnityEngine$EventSystems$IPointerDownHandler$OnPointerDown(UnityEngine.EventSystems.ExecuteEvents.ValidateEventData(UnityEngine.EventSystems.PointerEventData, eventData));
                },
                /*UnityEngine.EventSystems.ExecuteEvents.Execute$10:static end.*/

                /*UnityEngine.EventSystems.ExecuteEvents.Execute$13:static start.*/
                Execute$13: function (handler, eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#Execute$13", this ); }

                    handler.UnityEngine$EventSystems$IPointerUpHandler$OnPointerUp(UnityEngine.EventSystems.ExecuteEvents.ValidateEventData(UnityEngine.EventSystems.PointerEventData, eventData));
                },
                /*UnityEngine.EventSystems.ExecuteEvents.Execute$13:static end.*/

                /*UnityEngine.EventSystems.ExecuteEvents.Execute$9:static start.*/
                Execute$9: function (handler, eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#Execute$9", this ); }

                    handler.UnityEngine$EventSystems$IPointerClickHandler$OnPointerClick(UnityEngine.EventSystems.ExecuteEvents.ValidateEventData(UnityEngine.EventSystems.PointerEventData, eventData));
                },
                /*UnityEngine.EventSystems.ExecuteEvents.Execute$9:static end.*/

                /*UnityEngine.EventSystems.ExecuteEvents.Execute$7:static start.*/
                Execute$7: function (handler, eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#Execute$7", this ); }

                    handler.UnityEngine$EventSystems$IInitializePotentialDragHandler$OnInitializePotentialDrag(UnityEngine.EventSystems.ExecuteEvents.ValidateEventData(UnityEngine.EventSystems.PointerEventData, eventData));
                },
                /*UnityEngine.EventSystems.ExecuteEvents.Execute$7:static end.*/

                /*UnityEngine.EventSystems.ExecuteEvents.Execute$1:static start.*/
                Execute$1: function (handler, eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#Execute$1", this ); }

                    handler.UnityEngine$EventSystems$IBeginDragHandler$OnBeginDrag(UnityEngine.EventSystems.ExecuteEvents.ValidateEventData(UnityEngine.EventSystems.PointerEventData, eventData));
                },
                /*UnityEngine.EventSystems.ExecuteEvents.Execute$1:static end.*/

                /*UnityEngine.EventSystems.ExecuteEvents.Execute$4:static start.*/
                Execute$4: function (handler, eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#Execute$4", this ); }

                    handler.UnityEngine$EventSystems$IDragHandler$OnDrag(UnityEngine.EventSystems.ExecuteEvents.ValidateEventData(UnityEngine.EventSystems.PointerEventData, eventData));
                },
                /*UnityEngine.EventSystems.ExecuteEvents.Execute$4:static end.*/

                /*UnityEngine.EventSystems.ExecuteEvents.Execute$6:static start.*/
                Execute$6: function (handler, eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#Execute$6", this ); }

                    handler.UnityEngine$EventSystems$IEndDragHandler$OnEndDrag(UnityEngine.EventSystems.ExecuteEvents.ValidateEventData(UnityEngine.EventSystems.PointerEventData, eventData));
                },
                /*UnityEngine.EventSystems.ExecuteEvents.Execute$6:static end.*/

                /*UnityEngine.EventSystems.ExecuteEvents.Execute$5:static start.*/
                Execute$5: function (handler, eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#Execute$5", this ); }

                    handler.UnityEngine$EventSystems$IDropHandler$OnDrop(UnityEngine.EventSystems.ExecuteEvents.ValidateEventData(UnityEngine.EventSystems.PointerEventData, eventData));
                },
                /*UnityEngine.EventSystems.ExecuteEvents.Execute$5:static end.*/

                /*UnityEngine.EventSystems.ExecuteEvents.Execute$14:static start.*/
                Execute$14: function (handler, eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#Execute$14", this ); }

                    handler.UnityEngine$EventSystems$IScrollHandler$OnScroll(UnityEngine.EventSystems.ExecuteEvents.ValidateEventData(UnityEngine.EventSystems.PointerEventData, eventData));
                },
                /*UnityEngine.EventSystems.ExecuteEvents.Execute$14:static end.*/

                /*UnityEngine.EventSystems.ExecuteEvents.Execute$17:static start.*/
                Execute$17: function (handler, eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#Execute$17", this ); }

                    handler.UnityEngine$EventSystems$IUpdateSelectedHandler$OnUpdateSelected(eventData);
                },
                /*UnityEngine.EventSystems.ExecuteEvents.Execute$17:static end.*/

                /*UnityEngine.EventSystems.ExecuteEvents.Execute$15:static start.*/
                Execute$15: function (handler, eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#Execute$15", this ); }

                    handler.UnityEngine$EventSystems$ISelectHandler$OnSelect(eventData);
                },
                /*UnityEngine.EventSystems.ExecuteEvents.Execute$15:static end.*/

                /*UnityEngine.EventSystems.ExecuteEvents.Execute$3:static start.*/
                Execute$3: function (handler, eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#Execute$3", this ); }

                    handler.UnityEngine$EventSystems$IDeselectHandler$OnDeselect(eventData);
                },
                /*UnityEngine.EventSystems.ExecuteEvents.Execute$3:static end.*/

                /*UnityEngine.EventSystems.ExecuteEvents.Execute$8:static start.*/
                Execute$8: function (handler, eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#Execute$8", this ); }

                    handler.UnityEngine$EventSystems$IMoveHandler$OnMove(UnityEngine.EventSystems.ExecuteEvents.ValidateEventData(UnityEngine.EventSystems.AxisEventData, eventData));
                },
                /*UnityEngine.EventSystems.ExecuteEvents.Execute$8:static end.*/

                /*UnityEngine.EventSystems.ExecuteEvents.Execute$16:static start.*/
                Execute$16: function (handler, eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#Execute$16", this ); }

                    handler.UnityEngine$EventSystems$ISubmitHandler$OnSubmit(eventData);
                },
                /*UnityEngine.EventSystems.ExecuteEvents.Execute$16:static end.*/

                /*UnityEngine.EventSystems.ExecuteEvents.Execute$2:static start.*/
                Execute$2: function (handler, eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#Execute$2", this ); }

                    handler.UnityEngine$EventSystems$ICancelHandler$OnCancel(eventData);
                },
                /*UnityEngine.EventSystems.ExecuteEvents.Execute$2:static end.*/

                /*UnityEngine.EventSystems.ExecuteEvents.Execute:static start.*/
                Execute: function (T, target, eventData, functor) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#Execute", this ); }

                    var internalHandlers = UnityEngine.EventSystems.ExecuteEvents._handlerListPool.Get();
                    UnityEngine.EventSystems.ExecuteEvents.GetEventList(T, target, internalHandlers);
                    //  if (s_InternalHandlers.Count > 0)
                    //      Debug.Log("Executinng " + typeof (T) + " on " + target);

                    for (var i = 0; i < internalHandlers.Count; i++) {
                        var arg;
                        try {
                            arg = Bridge.cast(internalHandlers.getItem(i), T);
                        } catch (e) {
                            e = System.Exception.create(e);
                            var temp = internalHandlers.getItem(i);
                            UnityEngine.Debug.LogException(new System.Exception(System.String.format("Type {0} expected {1} received.", Bridge.Reflection.getTypeName(T), Bridge.Reflection.getTypeName(Bridge.getType(temp))), e));
                            continue;
                        }

                        try {
                            functor(Bridge.rValue(arg), eventData);
                        } catch (e1) {
                            e1 = System.Exception.create(e1);
                            UnityEngine.Debug.LogException(e1);
                        }
                    }

                    var handlerCount = internalHandlers.Count;
                    UnityEngine.EventSystems.ExecuteEvents._handlerListPool.Release(internalHandlers);
                    return handlerCount > 0;
                },
                /*UnityEngine.EventSystems.ExecuteEvents.Execute:static end.*/

                /*UnityEngine.EventSystems.ExecuteEvents.GetEventChain:static start.*/
                GetEventChain: function (root, eventChain) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#GetEventChain", this ); }

                    System.Array.clear(eventChain, UnityEngine.Transform);
                    if (UnityEngine.GameObject.op_Equality(root, null)) {
                        return;
                    }

                    var t = root.transform;
                    while (UnityEngine.Component.op_Inequality(t, null)) {
                        System.Array.add(eventChain, t, UnityEngine.Transform);
                        t = t.parent;
                    }
                },
                /*UnityEngine.EventSystems.ExecuteEvents.GetEventChain:static end.*/

                /*UnityEngine.EventSystems.ExecuteEvents.ExecuteHierarchy:static start.*/
                ExecuteHierarchy: function (T, root, eventData, callbackFunction) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#ExecuteHierarchy", this ); }

                    UnityEngine.EventSystems.ExecuteEvents.GetEventChain(root, UnityEngine.EventSystems.ExecuteEvents._internalTransformList);

                    for (var i = 0; i < UnityEngine.EventSystems.ExecuteEvents._internalTransformList.Count; i++) {
                        var transform = UnityEngine.EventSystems.ExecuteEvents._internalTransformList.getItem(i);
                        if (UnityEngine.EventSystems.ExecuteEvents.Execute(T, transform.gameObject, eventData, callbackFunction)) {
                            return transform.gameObject;
                        }
                    }

                    return null;
                },
                /*UnityEngine.EventSystems.ExecuteEvents.ExecuteHierarchy:static end.*/

                /*UnityEngine.EventSystems.ExecuteEvents.ShouldSendToComponent:static start.*/
                ShouldSendToComponent: function (T, component) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#ShouldSendToComponent", this ); }

                    var valid = Bridge.is(component, T);
                    if (!valid) {
                        return false;
                    }

                    var behaviour = Bridge.as(component, UnityEngine.Behaviour);
                    if (UnityEngine.Component.op_Inequality(behaviour, null)) {
                        return behaviour.isActiveAndEnabled;
                    }

                    return true;
                },
                /*UnityEngine.EventSystems.ExecuteEvents.ShouldSendToComponent:static end.*/

                /*UnityEngine.EventSystems.ExecuteEvents.GetEventList:static start.*/
                /**
                 * Get the specified object's event event.
                 *
                 * @static
                 * @private
                 * @this UnityEngine.EventSystems.ExecuteEvents
                 * @memberof UnityEngine.EventSystems.ExecuteEvents
                 * @param   {Function}                              T          
                 * @param   {UnityEngine.GameObject}                go         
                 * @param   {System.Collections.Generic.IList$1}    results
                 * @return  {void}
                 */
                GetEventList: function (T, go, results) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#GetEventList", this ); }

                    
                if ( results == null ) {
                    throw new System.ArgumentException.$ctor3('Results array is null', 'results');
                    }

                    var entity = go ? go.handle : null;
                        if ( entity === null || entity._destroyed || !entity.enabled ) {
                        return;
                    }

                    var shouldSendToComponent = UnityEngine.EventSystems.ExecuteEvents.ShouldSendToComponent;
                    var iEventSystemHandler = UnityEngine.EventSystems.IEventSystemHandler;
                    var components = entity._unityComponents.monoBehaviour;
                        for ( var i = 0; i < components.length; i++ ) {
                        var component = components[ i ].code;
                        if ( !shouldSendToComponent( T, component ) ) {
                            continue;
                        }

                        System.Array.add( results, Bridge.as( component, iEventSystemHandler ), iEventSystemHandler );
                    }
            ;
                },
                /*UnityEngine.EventSystems.ExecuteEvents.GetEventList:static end.*/

                /*UnityEngine.EventSystems.ExecuteEvents.CanHandleEvent:static start.*/
                /**
                 * Whether the specified game object will be able to handle the specified event.
                 *
                 * @static
                 * @public
                 * @this UnityEngine.EventSystems.ExecuteEvents
                 * @memberof UnityEngine.EventSystems.ExecuteEvents
                 * @param   {Function}                  T     
                 * @param   {UnityEngine.GameObject}    go
                 * @return  {boolean}
                 */
                CanHandleEvent: function (T, go) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#CanHandleEvent", this ); }

                    var internalHandlers = UnityEngine.EventSystems.ExecuteEvents._handlerListPool.Get();
                    UnityEngine.EventSystems.ExecuteEvents.GetEventList(T, go, internalHandlers);
                    var handlerCount = internalHandlers.Count;
                    UnityEngine.EventSystems.ExecuteEvents._handlerListPool.Release(internalHandlers);
                    return handlerCount !== 0;
                },
                /*UnityEngine.EventSystems.ExecuteEvents.CanHandleEvent:static end.*/

                /*UnityEngine.EventSystems.ExecuteEvents.GetEventHandler:static start.*/
                /**
                 * Bubble the specified event on the game object, figuring out which object will actually receive the event.
                 *
                 * @static
                 * @public
                 * @this UnityEngine.EventSystems.ExecuteEvents
                 * @memberof UnityEngine.EventSystems.ExecuteEvents
                 * @param   {Function}                  T       
                 * @param   {UnityEngine.GameObject}    root
                 * @return  {UnityEngine.GameObject}
                 */
                GetEventHandler: function (T, root) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.ExecuteEvents#GetEventHandler", this ); }

                    if (UnityEngine.GameObject.op_Equality(root, null)) {
                        return null;
                    }

                    var t = root.transform;
                    while (UnityEngine.Component.op_Inequality(t, null)) {
                        if (UnityEngine.EventSystems.ExecuteEvents.CanHandleEvent(T, t.gameObject)) {
                            return t.gameObject;
                        }

                        t = t.parent;
                    }

                    return null;
                },
                /*UnityEngine.EventSystems.ExecuteEvents.GetEventHandler:static end.*/


            }
        }
    });
    /*UnityEngine.EventSystems.ExecuteEvents end.*/

    /*UnityEngine.EventSystems.MoveDirection start.*/
    Bridge.define("UnityEngine.EventSystems.MoveDirection", {
        $kind: 6,
        statics: {
            fields: {
                Left: 0,
                Up: 1,
                Right: 2,
                Down: 3,
                None: 4
            }
        }
    });
    /*UnityEngine.EventSystems.MoveDirection end.*/

    /*UnityEngine.EventSystems.PointerEventData+FramePressState start.*/
    /**
     * The state of a press for the given frame.
     *
     * @public
     * @class number
     */
    Bridge.define("UnityEngine.EventSystems.PointerEventData.FramePressState", {
        $kind: 1006,
        statics: {
            fields: {
                /**
                 * Button was pressed this frame.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                Pressed: 0,
                /**
                 * Button was released this frame.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                Released: 1,
                /**
                 * Button was pressed and released this frame.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                PressedAndReleased: 2,
                /**
                 * Same as last frame.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 3
                 * @type number
                 */
                NotChanged: 3
            }
        }
    });
    /*UnityEngine.EventSystems.PointerEventData+FramePressState end.*/

    /*UnityEngine.EventSystems.PointerEventData+InputButton start.*/
    /**
     * Input press tracking.
     *
     * @public
     * @class number
     */
    Bridge.define("UnityEngine.EventSystems.PointerEventData.InputButton", {
        $kind: 1006,
        statics: {
            fields: {
                /**
                 * Left button
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                Left: 0,
                /**
                 * Right button.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                Right: 1,
                /**
                 * Middle button
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                Middle: 2
            }
        }
    });
    /*UnityEngine.EventSystems.PointerEventData+InputButton end.*/

    /*UnityEngine.EventSystems.PointerInputModule+ButtonState start.*/
    Bridge.define("UnityEngine.EventSystems.PointerInputModule.ButtonState", {
        $kind: 1002,
        fields: {
            m_Button: 0,
            m_EventData: null
        },
        props: {
            eventData: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerInputModule.ButtonState#eventData#get", this ); }

                    return this.m_EventData;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerInputModule.ButtonState#eventData#set", this ); }

                    this.m_EventData = value;
                }
            },
            button: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerInputModule.ButtonState#button#get", this ); }

                    return this.m_Button;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerInputModule.ButtonState#button#set", this ); }

                    this.m_Button = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerInputModule.ButtonState#init", this ); }

                this.m_Button = UnityEngine.EventSystems.PointerEventData.InputButton.Left;
            }
        }
    });
    /*UnityEngine.EventSystems.PointerInputModule+ButtonState end.*/

    /*UnityEngine.EventSystems.PointerInputModule+MouseButtonEventData start.*/
    /**
     * Information about a mouse button event.
     *
     * @public
     * @class UnityEngine.EventSystems.PointerInputModule.MouseButtonEventData
     */
    Bridge.define("UnityEngine.EventSystems.PointerInputModule.MouseButtonEventData", {
        $kind: 1002,
        fields: {
            /**
             * The state of the button this frame.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.PointerInputModule.MouseButtonEventData
             * @type number
             */
            buttonState: 0,
            /**
             * Pointer data associated with the mouse event.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.PointerInputModule.MouseButtonEventData
             * @type UnityEngine.EventSystems.PointerEventData
             */
            buttonData: null
        },
        methods: {
            /*UnityEngine.EventSystems.PointerInputModule+MouseButtonEventData.PressedThisFrame start.*/
            /**
             * Was the button pressed this frame?
             *
             * @instance
             * @public
             * @this UnityEngine.EventSystems.PointerInputModule.MouseButtonEventData
             * @memberof UnityEngine.EventSystems.PointerInputModule.MouseButtonEventData
             * @return  {boolean}
             */
            PressedThisFrame: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerInputModule.MouseButtonEventData#PressedThisFrame", this ); }

                return this.buttonState === UnityEngine.EventSystems.PointerEventData.FramePressState.Pressed || this.buttonState === UnityEngine.EventSystems.PointerEventData.FramePressState.PressedAndReleased;
            },
            /*UnityEngine.EventSystems.PointerInputModule+MouseButtonEventData.PressedThisFrame end.*/

            /*UnityEngine.EventSystems.PointerInputModule+MouseButtonEventData.ReleasedThisFrame start.*/
            /**
             * Was the button released this frame?
             *
             * @instance
             * @public
             * @this UnityEngine.EventSystems.PointerInputModule.MouseButtonEventData
             * @memberof UnityEngine.EventSystems.PointerInputModule.MouseButtonEventData
             * @return  {boolean}
             */
            ReleasedThisFrame: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerInputModule.MouseButtonEventData#ReleasedThisFrame", this ); }

                return this.buttonState === UnityEngine.EventSystems.PointerEventData.FramePressState.Released || this.buttonState === UnityEngine.EventSystems.PointerEventData.FramePressState.PressedAndReleased;
            },
            /*UnityEngine.EventSystems.PointerInputModule+MouseButtonEventData.ReleasedThisFrame end.*/


        }
    });
    /*UnityEngine.EventSystems.PointerInputModule+MouseButtonEventData end.*/

    /*UnityEngine.EventSystems.PointerInputModule+MouseState start.*/
    Bridge.define("UnityEngine.EventSystems.PointerInputModule.MouseState", {
        $kind: 1002,
        fields: {
            m_TrackedButtons: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerInputModule.MouseState#init", this ); }

                this.m_TrackedButtons = new (System.Collections.Generic.List$1(UnityEngine.EventSystems.PointerInputModule.ButtonState)).ctor();
            }
        },
        methods: {
            /*UnityEngine.EventSystems.PointerInputModule+MouseState.AnyPressesThisFrame start.*/
            AnyPressesThisFrame: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerInputModule.MouseState#AnyPressesThisFrame", this ); }

                for (var i = 0; i < this.m_TrackedButtons.Count; i++) {
                    if (this.m_TrackedButtons.getItem(i).eventData.PressedThisFrame()) {
                        return true;
                    }
                }

                return false;
            },
            /*UnityEngine.EventSystems.PointerInputModule+MouseState.AnyPressesThisFrame end.*/

            /*UnityEngine.EventSystems.PointerInputModule+MouseState.AnyReleasesThisFrame start.*/
            AnyReleasesThisFrame: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerInputModule.MouseState#AnyReleasesThisFrame", this ); }

                for (var i = 0; i < this.m_TrackedButtons.Count; i++) {
                    if (this.m_TrackedButtons.getItem(i).eventData.ReleasedThisFrame()) {
                        return true;
                    }
                }

                return false;
            },
            /*UnityEngine.EventSystems.PointerInputModule+MouseState.AnyReleasesThisFrame end.*/

            /*UnityEngine.EventSystems.PointerInputModule+MouseState.GetButtonState start.*/
            GetButtonState: function (button) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerInputModule.MouseState#GetButtonState", this ); }

                var $t;
                var tracked = null;
                for (var i = 0; i < this.m_TrackedButtons.Count; i++) {
                    if (this.m_TrackedButtons.getItem(i).button === button) {
                        tracked = this.m_TrackedButtons.getItem(i);
                        break;
                    }
                }

                if (tracked == null) {
                    tracked = ($t = new UnityEngine.EventSystems.PointerInputModule.ButtonState(), $t.button = button, $t.eventData = new UnityEngine.EventSystems.PointerInputModule.MouseButtonEventData(), $t);
                    this.m_TrackedButtons.add(tracked);
                }

                return tracked;
            },
            /*UnityEngine.EventSystems.PointerInputModule+MouseState.GetButtonState end.*/

            /*UnityEngine.EventSystems.PointerInputModule+MouseState.SetButtonState start.*/
            SetButtonState: function (button, stateForMouseButton, data) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerInputModule.MouseState#SetButtonState", this ); }

                var toModify = this.GetButtonState(button);
                toModify.eventData.buttonState = stateForMouseButton;
                toModify.eventData.buttonData = data;
            },
            /*UnityEngine.EventSystems.PointerInputModule+MouseState.SetButtonState end.*/


        }
    });
    /*UnityEngine.EventSystems.PointerInputModule+MouseState end.*/

    /*UnityEngine.EventSystems.RaycasterManager start.*/
    Bridge.define("UnityEngine.EventSystems.RaycasterManager", {
        statics: {
            fields: {
                s_Raycasters: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.RaycasterManager#init", this ); }

                    this.s_Raycasters = new (System.Collections.Generic.List$1(UnityEngine.EventSystems.BaseRaycaster)).ctor();
                }
            },
            methods: {
                /*UnityEngine.EventSystems.RaycasterManager.AddRaycaster:static start.*/
                AddRaycaster: function (baseRaycaster) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.RaycasterManager#AddRaycaster", this ); }

                    if (UnityEngine.EventSystems.RaycasterManager.s_Raycasters.contains(baseRaycaster)) {
                        return;
                    }

                    UnityEngine.EventSystems.RaycasterManager.s_Raycasters.add(baseRaycaster);
                },
                /*UnityEngine.EventSystems.RaycasterManager.AddRaycaster:static end.*/

                /*UnityEngine.EventSystems.RaycasterManager.GetRaycasters:static start.*/
                GetRaycasters: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.RaycasterManager#GetRaycasters", this ); }

                    return UnityEngine.EventSystems.RaycasterManager.s_Raycasters;
                },
                /*UnityEngine.EventSystems.RaycasterManager.GetRaycasters:static end.*/

                /*UnityEngine.EventSystems.RaycasterManager.RemoveRaycasters:static start.*/
                RemoveRaycasters: function (baseRaycaster) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.RaycasterManager#RemoveRaycasters", this ); }

                    if (!UnityEngine.EventSystems.RaycasterManager.s_Raycasters.contains(baseRaycaster)) {
                        return;
                    }

                    UnityEngine.EventSystems.RaycasterManager.s_Raycasters.remove(baseRaycaster);
                },
                /*UnityEngine.EventSystems.RaycasterManager.RemoveRaycasters:static end.*/


            }
        }
    });
    /*UnityEngine.EventSystems.RaycasterManager end.*/

    /*UnityEngine.EventSystems.RaycastResult start.*/
    Bridge.define("UnityEngine.EventSystems.RaycastResult", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.RaycastResult#getDefaultValue", this ); }
 return new UnityEngine.EventSystems.RaycastResult(); }
            }
        },
        fields: {
            /**
             * The screen position.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.RaycastResult
             * @type UnityEngine.Vector2
             */
            screenPosition: null,
            /**
             * The world normal.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.RaycastResult
             * @type UnityEngine.Vector3
             */
            worldNormal: null,
            /**
             * The world position.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.RaycastResult
             * @type UnityEngine.Vector3
             */
            worldPosition: null,
            /**
             * The sorting order.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.RaycastResult
             * @type number
             */
            sortingOrder: 0,
            /**
             * The distance.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.RaycastResult
             * @type number
             */
            distance: 0,
            /**
             * The index.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.RaycastResult
             * @type number
             */
            index: 0,
            /**
             * The depth.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.RaycastResult
             * @type number
             */
            depth: 0,
            /**
             * The sorting layer.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.RaycastResult
             * @type number
             */
            sortingLayer: 0,
            /**
             * <p>BaseInputModule that raised the hit.</p>
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.RaycastResult
             * @type UnityEngine.EventSystems.BaseRaycaster
             */
            module: null,
            /**
             * Gets or sets the game object.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.RaycastResult
             * @function gameObject
             * @type UnityEngine.GameObject
             */
            gameObject: null
        },
        props: {
            /**
             * Gets a value indicating whether this {@link } is valid.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.EventSystems.RaycastResult
             * @function isValid
             * @type boolean
             */
            isValid: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.RaycastResult#isValid#get", this ); }

                    return !Bridge.referenceEquals(Bridge.cast(this.module, UnityEngine.Object), null) && !Bridge.referenceEquals(Bridge.cast(this.gameObject, UnityEngine.Object), null);
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.RaycastResult#init", this ); }

                this.screenPosition = new UnityEngine.Vector2();
                this.worldNormal = new UnityEngine.Vector3();
                this.worldPosition = new UnityEngine.Vector3();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.RaycastResult#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*UnityEngine.EventSystems.RaycastResult.Clear start.*/
            /**
             * Clear this instance.
             *
             * @instance
             * @public
             * @this UnityEngine.EventSystems.RaycastResult
             * @memberof UnityEngine.EventSystems.RaycastResult
             * @return  {void}
             */
            Clear: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.RaycastResult#Clear", this ); }

                this.gameObject = null;
                this.module = null;
                this.distance = 0.0;
                this.index = 0.0;
                this.depth = 0;
                this.sortingLayer = 0;
                this.sortingOrder = 0;
                this.worldNormal = pc.Vec3.UP.clone();
                this.worldPosition = pc.Vec3.ZERO.clone();
                this.screenPosition = pc.Vec2.ZERO.clone();
            },
            /*UnityEngine.EventSystems.RaycastResult.Clear end.*/

            /*UnityEngine.EventSystems.RaycastResult.SetFrom start.*/
            SetFrom: function (other) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.RaycastResult#SetFrom", this ); }

                this.gameObject = other.gameObject;
                this.module = other.module;
                this.distance = other.distance;
                this.index = other.index;
                this.depth = other.depth;
                this.sortingLayer = other.sortingLayer;
                this.sortingOrder = other.sortingOrder;
                this.worldNormal.copy( other.worldNormal );
                this.worldPosition.copy( other.worldPosition );
                this.screenPosition.copy( other.screenPosition );
                return this;
            },
            /*UnityEngine.EventSystems.RaycastResult.SetFrom end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.RaycastResult#getHashCode", this ); }

                var h = Bridge.addHash([4871899276, this.screenPosition, this.worldNormal, this.worldPosition, this.sortingOrder, this.distance, this.index, this.depth, this.sortingLayer, this.module, this.gameObject]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.RaycastResult#equals", this ); }

                if (!Bridge.is(o, UnityEngine.EventSystems.RaycastResult)) {
                    return false;
                }
                return Bridge.equals(this.screenPosition, o.screenPosition) && Bridge.equals(this.worldNormal, o.worldNormal) && Bridge.equals(this.worldPosition, o.worldPosition) && Bridge.equals(this.sortingOrder, o.sortingOrder) && Bridge.equals(this.distance, o.distance) && Bridge.equals(this.index, o.index) && Bridge.equals(this.depth, o.depth) && Bridge.equals(this.sortingLayer, o.sortingLayer) && Bridge.equals(this.module, o.module) && Bridge.equals(this.gameObject, o.gameObject);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.RaycastResult#$clone", this ); }

                var s = to || new UnityEngine.EventSystems.RaycastResult();
                s.screenPosition = this.screenPosition.$clone();
                s.worldNormal = this.worldNormal.$clone();
                s.worldPosition = this.worldPosition.$clone();
                s.sortingOrder = this.sortingOrder;
                s.distance = this.distance;
                s.index = this.index;
                s.depth = this.depth;
                s.sortingLayer = this.sortingLayer;
                s.module = this.module;
                s.gameObject = this.gameObject;
                return s;
            }
        }
    });
    /*UnityEngine.EventSystems.RaycastResult end.*/

    /*UnityEngine.EventSystems.StandaloneInputModule+InputMode start.*/
    Bridge.define("UnityEngine.EventSystems.StandaloneInputModule.InputMode", {
        $kind: 1006,
        statics: {
            fields: {
                Mouse: 0,
                Buttons: 1
            }
        }
    });
    /*UnityEngine.EventSystems.StandaloneInputModule+InputMode end.*/

    /*UnityEngine.ICanvasRaycastFilter start.*/
    Bridge.define("UnityEngine.ICanvasRaycastFilter", {
        $kind: 3
    });
    /*UnityEngine.ICanvasRaycastFilter end.*/

    /*UnityEngine.UI.AnimationTriggers start.*/
    Bridge.define("UnityEngine.UI.AnimationTriggers", {
        statics: {
            fields: {
                DefaultNormalAnimName: null,
                DefaultHighlightedAnimName: null,
                DefaultPressedAnimName: null,
                DefaultSelectedAnimName: null,
                DefaultDisabledAnimName: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.AnimationTriggers#init", this ); }

                    this.DefaultNormalAnimName = "Normal";
                    this.DefaultHighlightedAnimName = "Highlighted";
                    this.DefaultPressedAnimName = "Pressed";
                    this.DefaultSelectedAnimName = "Selected";
                    this.DefaultDisabledAnimName = "Disabled";
                }
            }
        },
        fields: {
            m_NormalTrigger: null,
            m_HighlightedTrigger: null,
            m_PressedTrigger: null,
            m_SelectedTrigger: null,
            m_DisabledTrigger: null
        },
        props: {
            /**
             * Trigger to send to animator when entering normal state.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.AnimationTriggers
             * @function normalTrigger
             * @type string
             */
            normalTrigger: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.AnimationTriggers#normalTrigger#get", this ); }

                    return this.m_NormalTrigger;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.AnimationTriggers#normalTrigger#set", this ); }

                    this.m_NormalTrigger = value;
                }
            },
            /**
             * Trigger to send to animator when entering highlighted state.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.AnimationTriggers
             * @function highlightedTrigger
             * @type string
             */
            highlightedTrigger: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.AnimationTriggers#highlightedTrigger#get", this ); }

                    return this.m_HighlightedTrigger;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.AnimationTriggers#highlightedTrigger#set", this ); }

                    this.m_HighlightedTrigger = value;
                }
            },
            /**
             * Trigger to send to animator when entering pressed state.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.AnimationTriggers
             * @function pressedTrigger
             * @type string
             */
            pressedTrigger: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.AnimationTriggers#pressedTrigger#get", this ); }

                    return this.m_PressedTrigger;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.AnimationTriggers#pressedTrigger#set", this ); }

                    this.m_PressedTrigger = value;
                }
            },
            /**
             * Trigger to send to animator when entering selected state.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.AnimationTriggers
             * @function selectedTrigger
             * @type string
             */
            selectedTrigger: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.AnimationTriggers#selectedTrigger#get", this ); }

                    return this.m_SelectedTrigger;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.AnimationTriggers#selectedTrigger#set", this ); }

                    this.m_SelectedTrigger = value;
                }
            },
            /**
             * Trigger to send to animator when entering disabled state.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.AnimationTriggers
             * @function disabledTrigger
             * @type string
             */
            disabledTrigger: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.AnimationTriggers#disabledTrigger#get", this ); }

                    return this.m_DisabledTrigger;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.AnimationTriggers#disabledTrigger#set", this ); }

                    this.m_DisabledTrigger = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.AnimationTriggers#init", this ); }

                this.m_NormalTrigger = "Normal";
                this.m_HighlightedTrigger = "Highlighted";
                this.m_PressedTrigger = "Pressed";
                this.m_SelectedTrigger = "Selected";
                this.m_DisabledTrigger = "Disabled";
            }
        }
    });
    /*UnityEngine.UI.AnimationTriggers end.*/

    /*UnityEngine.UI.AspectRatioFitter+AspectMode start.*/
    /** @namespace UnityEngine.UI */

    /**
     * Aspect mode.
     *
     * @public
     * @class number
     */
    Bridge.define("UnityEngine.UI.AspectRatioFitter.AspectMode", {
        $kind: 1006,
        statics: {
            fields: {
                None: 0,
                WidthControlsHeight: 1,
                HeightControlsWidth: 2,
                FitInParent: 3,
                EnvelopeParent: 4
            }
        }
    });
    /*UnityEngine.UI.AspectRatioFitter+AspectMode end.*/

    /*UnityEngine.UI.IMeshModifier start.*/
    Bridge.define("UnityEngine.UI.IMeshModifier", {
        $kind: 3
    });
    /*UnityEngine.UI.IMeshModifier end.*/

    /*UnityEngine.UI.Button+ButtonClickedEvent start.*/
    /**
     * Button clicked event.
     *
     * @public
     * @class UnityEngine.UI.Button.ButtonClickedEvent
     * @augments UnityEngine.Events.UnityEvent
     */
    Bridge.define("UnityEngine.UI.Button.ButtonClickedEvent", {
        inherits: [UnityEngine.Events.UnityEvent],
        $kind: 1002
    });
    /*UnityEngine.UI.Button+ButtonClickedEvent end.*/

    /*UnityEngine.UI.CanvasScaler+ScaleMode start.*/
    /**
     * Scale mode.
     *
     * @public
     * @class number
     */
    Bridge.define("UnityEngine.UI.CanvasScaler.ScaleMode", {
        $kind: 1006,
        statics: {
            fields: {
                ConstantPixelSize: 0,
                ScaleWithScreenSize: 1,
                ConstantPhysicalSize: 2
            }
        }
    });
    /*UnityEngine.UI.CanvasScaler+ScaleMode end.*/

    /*UnityEngine.UI.CanvasScaler+ScreenMatchMode start.*/
    Bridge.define("UnityEngine.UI.CanvasScaler.ScreenMatchMode", {
        $kind: 1006,
        statics: {
            fields: {
                MatchWidthOrHeight: 0,
                Expand: 1,
                Shrink: 2
            }
        }
    });
    /*UnityEngine.UI.CanvasScaler+ScreenMatchMode end.*/

    /*UnityEngine.UI.CanvasUpdateRegistry start.*/
    Bridge.define("UnityEngine.UI.CanvasUpdateRegistry", {
        statics: {
            fields: {
                /**
                 * Singleton instance.
                 *
                 * @static
                 * @private
                 * @memberof UnityEngine.UI.CanvasUpdateRegistry
                 * @type UnityEngine.UI.CanvasUpdateRegistry
                 */
                s_Instance: null
            },
            props: {
                /**
                 * Singleton accessor.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof UnityEngine.UI.CanvasUpdateRegistry
                 * @function instance
                 * @type UnityEngine.UI.CanvasUpdateRegistry
                 */
                instance: {
                    get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CanvasUpdateRegistry#instance#get", this ); }

                        UnityEngine.UI.CanvasUpdateRegistry.s_Instance = UnityEngine.UI.CanvasUpdateRegistry.s_Instance || new UnityEngine.UI.CanvasUpdateRegistry();
                        return UnityEngine.UI.CanvasUpdateRegistry.s_Instance;
                    }
                }
            },
            methods: {
                /*UnityEngine.UI.CanvasUpdateRegistry.RegisterCanvasElementForLayoutRebuild:static start.*/
                /**
                 * Marks the element for layout rebuild.
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.CanvasUpdateRegistry
                 * @memberof UnityEngine.UI.CanvasUpdateRegistry
                 * @param   {UnityEngine.UI.ICanvasElement}    element
                 * @return  {void}
                 */
                RegisterCanvasElementForLayoutRebuild: function (element) {
if ( TRACE ) { TRACE( "UnityEngine.UI.CanvasUpdateRegistry#RegisterCanvasElementForLayoutRebuild", this ); }

                    if (element.entity && element.entity.isPrefab) {
                        return;
                    }

                    var registry = UnityEngine.UI.CanvasUpdateRegistry.instance;

                    var key = UnityEngine.UI.CanvasUpdateRegistry.GetKey(element);
                    if (!registry.layoutRebuildIndex.has( key )) {
                        registry.layoutRebuildQueue.push(element);
                        registry.layoutRebuildIndex.add( key );
                    }
                },
                /*UnityEngine.UI.CanvasUpdateRegistry.RegisterCanvasElementForLayoutRebuild:static end.*/

                /*UnityEngine.UI.CanvasUpdateRegistry.RegisterCanvasElementForGraphicRebuild:static start.*/
                /**
                 * Marks the element for graphics rebuild.
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.CanvasUpdateRegistry
                 * @memberof UnityEngine.UI.CanvasUpdateRegistry
                 * @param   {UnityEngine.UI.ICanvasElement}    element
                 * @return  {void}
                 */
                RegisterCanvasElementForGraphicRebuild: function (element) {
if ( TRACE ) { TRACE( "UnityEngine.UI.CanvasUpdateRegistry#RegisterCanvasElementForGraphicRebuild", this ); }

                    if (element.entity && element.entity.isPrefab) {
                        return;
                    }

                    var registry = UnityEngine.UI.CanvasUpdateRegistry.instance;

                    var key = UnityEngine.UI.CanvasUpdateRegistry.GetKey(element);
                    if (!registry.graphicsRebuildIndex.has( key )) {
                        registry.graphicsRebuildQueue.push(element);
                        registry.graphicsRebuildIndex.add( key );
                    }
                },
                /*UnityEngine.UI.CanvasUpdateRegistry.RegisterCanvasElementForGraphicRebuild:static end.*/

                /*UnityEngine.UI.CanvasUpdateRegistry.UnRegisterCanvasElementForRebuild:static start.*/
                /**
                 * Removes element from layout rebuild queue.
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.CanvasUpdateRegistry
                 * @memberof UnityEngine.UI.CanvasUpdateRegistry
                 * @param   {UnityEngine.UI.ICanvasElement}    element
                 * @return  {void}
                 */
                UnRegisterCanvasElementForRebuild: function (element) {
if ( TRACE ) { TRACE( "UnityEngine.UI.CanvasUpdateRegistry#UnRegisterCanvasElementForRebuild", this ); }

                    // IMPORTANT: we don't touch the array - we will validate the items later during out update pass,
                    // so let's save some cycles by only marking elements within the set
                    var key = UnityEngine.UI.CanvasUpdateRegistry.GetKey(element);
                    UnityEngine.UI.CanvasUpdateRegistry.instance.layoutRebuildIndex.delete( key );
                    UnityEngine.UI.CanvasUpdateRegistry.instance.graphicsRebuildIndex.delete( key );
                },
                /*UnityEngine.UI.CanvasUpdateRegistry.UnRegisterCanvasElementForRebuild:static end.*/

                /*UnityEngine.UI.CanvasUpdateRegistry.IsRebuildingLayout:static start.*/
                /**
                 * Returns true if layout rebuild is in progress now.
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.CanvasUpdateRegistry
                 * @memberof UnityEngine.UI.CanvasUpdateRegistry
                 * @return  {boolean}
                 */
                IsRebuildingLayout: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CanvasUpdateRegistry#IsRebuildingLayout", this ); }

                    return UnityEngine.UI.CanvasUpdateRegistry.instance.m_PerformingLayoutUpdate;
                },
                /*UnityEngine.UI.CanvasUpdateRegistry.IsRebuildingLayout:static end.*/

                /*UnityEngine.UI.CanvasUpdateRegistry.IsRebuildingGraphics:static start.*/
                /**
                 * Returns true if graphics rebuild is in progress now.
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.CanvasUpdateRegistry
                 * @memberof UnityEngine.UI.CanvasUpdateRegistry
                 * @return  {boolean}
                 */
                IsRebuildingGraphics: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CanvasUpdateRegistry#IsRebuildingGraphics", this ); }

                    return UnityEngine.UI.CanvasUpdateRegistry.instance.m_PerformingGraphicUpdate;
                },
                /*UnityEngine.UI.CanvasUpdateRegistry.IsRebuildingGraphics:static end.*/

                /*UnityEngine.UI.CanvasUpdateRegistry.GetKey:static start.*/
                GetKey: function (element) {
if ( TRACE ) { TRACE( "UnityEngine.UI.CanvasUpdateRegistry#GetKey", this ); }

                    // ICanvasElement could be LayoutRebuilder, RectTransform or for example ScrollRect
                    // But when we compare LayoutRebuilder == RectTransform, Layout rebuilder has override for getHashCode
                    // But ScrollRect doesn't have such override, and could be pushed to queue, even if transform are already there
                    return element.$$fullname === 'UnityEngine.UI.ScrollRect' ? element : element.transform;
                },
                /*UnityEngine.UI.CanvasUpdateRegistry.GetKey:static end.*/


            }
        },
        fields: {
            /**
             * Whether layout pass is in progress.
             *
             * @instance
             * @private
             * @memberof UnityEngine.UI.CanvasUpdateRegistry
             * @default false
             * @type boolean
             */
            m_PerformingLayoutUpdate: false,
            /**
             * Whether graphics pass is in progress
             *
             * @instance
             * @private
             * @memberof UnityEngine.UI.CanvasUpdateRegistry
             * @default false
             * @type boolean
             */
            m_PerformingGraphicUpdate: false,
            /**
             * Contains ICanvasElement instances which require layout rebuild.
             *
             * @instance
             * @private
             * @readonly
             * @memberof UnityEngine.UI.CanvasUpdateRegistry
             * @type Array.<UnityEngine.UI.ICanvasElement>
             */
            layoutRebuildQueue: null,
            /**
             * Keeps transforms added to the layout rebuild queue.
             *
             * @instance
             * @private
             * @readonly
             * @memberof UnityEngine.UI.CanvasUpdateRegistry
             * @type System.Object
             */
            layoutRebuildIndex: null,
            /**
             * Contains ICanvasElement instances which require graphics rebuild.
             *
             * @instance
             * @private
             * @readonly
             * @memberof UnityEngine.UI.CanvasUpdateRegistry
             * @type Array.<UnityEngine.UI.ICanvasElement>
             */
            graphicsRebuildQueue: null,
            /**
             * Keeps transforms added to the graphics rebuild queue.
             *
             * @instance
             * @private
             * @readonly
             * @memberof UnityEngine.UI.CanvasUpdateRegistry
             * @type System.Object
             */
            graphicsRebuildIndex: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CanvasUpdateRegistry#init", this ); }

                this.m_PerformingLayoutUpdate = false;
                this.m_PerformingGraphicUpdate = false;
                this.layoutRebuildQueue = System.Array.init(0, null, UnityEngine.UI.ICanvasElement);
                this.graphicsRebuildQueue = System.Array.init(0, null, UnityEngine.UI.ICanvasElement);
            },
            /**
             * Subscribes to canvas update event.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.CanvasUpdateRegistry
             * @memberof UnityEngine.UI.CanvasUpdateRegistry
             * @return  {void}
             */
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CanvasUpdateRegistry#ctor", this ); }

                this.$initialize();
                UnityEngine.Canvas.addwillRenderCanvases(Bridge.fn.cacheBind(this, this.PerformUpdate));

                this.layoutRebuildIndex = new Set();
                this.graphicsRebuildIndex = new Set();
            }
        },
        methods: {
            /*UnityEngine.UI.CanvasUpdateRegistry.PerformUpdate start.*/
            /**
             * Rebuilds the layout and graphics.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.CanvasUpdateRegistry
             * @memberof UnityEngine.UI.CanvasUpdateRegistry
             * @return  {void}
             */
            PerformUpdate: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CanvasUpdateRegistry#PerformUpdate", this ); }

                // mark the start of rebuild
                this.m_PerformingLayoutUpdate = true;

                // run rebuild pass
                this.PerformLayoutRebuildPhases();

                // mark the end of rebuild
                this.m_PerformingLayoutUpdate = false;

                // mark the start of graphics update
                this.m_PerformingGraphicUpdate = true;

                // run graphics pass
                this.PerformGraphicsRebuildPhases();

                // mark the end of graphics update
                this.m_PerformingGraphicUpdate = false;
            },
            /*UnityEngine.UI.CanvasUpdateRegistry.PerformUpdate end.*/

            /*UnityEngine.UI.CanvasUpdateRegistry.PerformLayoutRebuildPhases start.*/
            /**
             * Executes events up to PostLayout against layout queue.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.CanvasUpdateRegistry
             * @memberof UnityEngine.UI.CanvasUpdateRegistry
             * @return  {void}
             */
            PerformLayoutRebuildPhases: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CanvasUpdateRegistry#PerformLayoutRebuildPhases", this ); }

                
                // gather items
                var items = this.layoutRebuildQueue;
                const sortTransformsByGraphDepth = function ( elementA, elementB ) {
                    return elementA.transform.handle._graphDepth - elementB.transform.handle._graphDepth;
                }
                items.sort( sortTransformsByGraphDepth );
                // run layout phases
                for ( var phase = 0; phase <= UnityEngine.UI.CanvasUpdate.PostLayout; phase++ ) {
                    for ( var i = 0; i < items.length; i++ ) {
                        var item = items[ i ];
                        if ( this.layoutRebuildIndex.has( item.transform ) ) {
                            item.Rebuild( phase );
                        }
                    }
                }
                // notify about layout phase completion
                for ( var i = 0; i < items.length; i++ ) {
                    items[ i ].LayoutComplete();
                }
                // clear the queue
                this.layoutRebuildIndex.clear();
                this.layoutRebuildQueue.length = 0;
            },
            /*UnityEngine.UI.CanvasUpdateRegistry.PerformLayoutRebuildPhases end.*/

            /*UnityEngine.UI.CanvasUpdateRegistry.PerformGraphicsRebuildPhases start.*/
            /**
             * Executes events up to MaxUpdateVpalue against graphics queue.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.CanvasUpdateRegistry
             * @memberof UnityEngine.UI.CanvasUpdateRegistry
             * @return  {void}
             */
            PerformGraphicsRebuildPhases: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CanvasUpdateRegistry#PerformGraphicsRebuildPhases", this ); }

                
                // gather items
                var items = this.graphicsRebuildQueue;
                // run layout phases
                for ( var phase = UnityEngine.UI.CanvasUpdate.PreRender; phase <= UnityEngine.UI.CanvasUpdate.MaxUpdateValue; phase++ ) {
                    for ( var i = 0; i < items.length; i++ ) {
                        var item = items[ i ];
                        if ( this.graphicsRebuildIndex.has( item.transform ) ) {
                            item.Rebuild( phase );
                        }
                    }
                }
                // notify about layout phase completion
                for ( var i = 0; i < items.length; i++ ) {
                    items[ i ].GraphicUpdateComplete();
                }
                // clear the queue
                this.graphicsRebuildIndex.clear();
                this.graphicsRebuildQueue.length = 0;
            },
            /*UnityEngine.UI.CanvasUpdateRegistry.PerformGraphicsRebuildPhases end.*/


        }
    });
    /*UnityEngine.UI.CanvasUpdateRegistry end.*/

    /*UnityEngine.UI.ClipperRegistry start.*/
    /**
     * Registry class to keep track of all IClippers that exist in the scene
     *
     * @public
     * @class UnityEngine.UI.ClipperRegistry
     */
    Bridge.define("UnityEngine.UI.ClipperRegistry", {
        statics: {
            fields: {
                s_Instance: null
            },
            props: {
                /**
                 * The singleton instance of the clipper registry.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof UnityEngine.UI.ClipperRegistry
                 * @function instance
                 * @type UnityEngine.UI.ClipperRegistry
                 */
                instance: {
                    get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ClipperRegistry#instance#get", this ); }

                        if (UnityEngine.UI.ClipperRegistry.s_Instance == null) {
                            UnityEngine.UI.ClipperRegistry.s_Instance = new UnityEngine.UI.ClipperRegistry();
                        }

                        return UnityEngine.UI.ClipperRegistry.s_Instance;
                    }
                }
            },
            methods: {
                /*UnityEngine.UI.ClipperRegistry.Register:static start.*/
                /**
                 * Register a unique IClipper element
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.ClipperRegistry
                 * @memberof UnityEngine.UI.ClipperRegistry
                 * @param   {UnityEngine.UI.IClipper}    c    The clipper element to add
                 * @return  {void}
                 */
                Register: function (c) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ClipperRegistry#Register", this ); }

                    if (c == null) {
                        return;
                    }

                    UnityEngine.UI.ClipperRegistry.instance.m_Clippers.AddUnique(c);
                },
                /*UnityEngine.UI.ClipperRegistry.Register:static end.*/

                /*UnityEngine.UI.ClipperRegistry.Unregister:static start.*/
                /**
                 * UnRegister a IClipper element
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.ClipperRegistry
                 * @memberof UnityEngine.UI.ClipperRegistry
                 * @param   {UnityEngine.UI.IClipper}    c    The Element to try and remove.
                 * @return  {void}
                 */
                Unregister: function (c) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ClipperRegistry#Unregister", this ); }

                    UnityEngine.UI.ClipperRegistry.instance.m_Clippers.remove(c);
                },
                /*UnityEngine.UI.ClipperRegistry.Unregister:static end.*/


            }
        },
        fields: {
            m_Clippers: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ClipperRegistry#init", this ); }

                this.m_Clippers = new (UnityEngine.UI.Collections.IndexedSet$1(UnityEngine.UI.IClipper))();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ClipperRegistry#ctor", this ); }

                this.$initialize();
                // This is needed for AOT platforms. Without it the compile doesn't get the definition of the Dictionarys
                var emptyIClipperDic;
            }
        },
        methods: {
            /*UnityEngine.UI.ClipperRegistry.Cull start.*/
            /**
             * Perform the clipping on all registered IClipper
             *
             * @instance
             * @public
             * @this UnityEngine.UI.ClipperRegistry
             * @memberof UnityEngine.UI.ClipperRegistry
             * @return  {void}
             */
            Cull: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ClipperRegistry#Cull", this ); }

                for (var i = 0; i < this.m_Clippers.Count; ++i) {
                    this.m_Clippers.getItem(i).UnityEngine$UI$IClipper$PerformClipping();
                }
            },
            /*UnityEngine.UI.ClipperRegistry.Cull end.*/


        }
    });
    /*UnityEngine.UI.ClipperRegistry end.*/

    /*UnityEngine.UI.Clipping start.*/
    /**
     * Utility class to help when clipping using IClipper.
     *
     * @static
     * @abstract
     * @public
     * @class UnityEngine.UI.Clipping
     */
    Bridge.define("UnityEngine.UI.Clipping", {
        statics: {
            methods: {
                /*UnityEngine.UI.Clipping.FindCullAndClipWorldRect:static start.*/
                /**
                 * Find the Rect to use for clipping.
                 Given the input RectMask2ds find a rectangle that is the overlap of all the inputs.
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.Clipping
                 * @memberof UnityEngine.UI.Clipping
                 * @param   {System.Collections.Generic.List$1}    rectMaskParents    RectMasks to build the overlap rect from.
                 * @param   {System.Boolean}                       validRect          Was there a valid Rect found.
                 * @return  {UnityEngine.Rect}                                        The final compounded overlapping rect
                 */
                FindCullAndClipWorldRect: function (rectMaskParents, validRect) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Clipping#FindCullAndClipWorldRect", this ); }

                    if (rectMaskParents.Count === 0) {
                        validRect.v = false;
                        return new UnityEngine.Rect.ctor();
                    }

                    var current = rectMaskParents.getItem(0).canvasRect.$clone();
                    var xMin = current.xMin;
                    var xMax = current.xMax;
                    var yMin = current.yMin;
                    var yMax = current.yMax;
                    for (var i = 1; i < rectMaskParents.Count; ++i) {
                        current = rectMaskParents.getItem(i).canvasRect.$clone();
                        if (xMin < current.xMin) {
                            xMin = current.xMin;
                        }

                        if (yMin < current.yMin) {
                            yMin = current.yMin;
                        }

                        if (xMax > current.xMax) {
                            xMax = current.xMax;
                        }

                        if (yMax > current.yMax) {
                            yMax = current.yMax;
                        }
                    }

                    validRect.v = xMax > xMin && yMax > yMin;
                    if (validRect.v) {
                        return new UnityEngine.Rect.$ctor1(xMin, yMin, xMax - xMin, yMax - yMin);
                    } else {
                        return new UnityEngine.Rect.ctor();
                    }
                },
                /*UnityEngine.UI.Clipping.FindCullAndClipWorldRect:static end.*/


            }
        }
    });
    /*UnityEngine.UI.Clipping end.*/

    /*UnityEngine.UI.Collections.IndexedSet$1 start.*/
    Bridge.define("UnityEngine.UI.Collections.IndexedSet$1", function (T) { return {
        inherits: [System.Collections.Generic.IList$1(T)],
        fields: {
            m_List: null,
            m_Dictionary: null
        },
        props: {
            Count: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Collections.IndexedSet$1#Count#get", this ); }

                    return this.m_List.Count;
                }
            },
            IsReadOnly: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Collections.IndexedSet$1#IsReadOnly#get", this ); }

                    return false;
                }
            }
        },
        alias: [
            "add", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$add",
            "remove", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$remove",
            "GetEnumerator", ["System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(T) + "$GetEnumerator", "System$Collections$Generic$IEnumerable$1$GetEnumerator"],
            "clear", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$clear",
            "contains", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$contains",
            "copyTo", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$copyTo",
            "Count", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$Count",
            "IsReadOnly", "System$Collections$Generic$ICollection$1$" + Bridge.getTypeAlias(T) + "$IsReadOnly",
            "indexOf", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$indexOf",
            "insert", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$insert",
            "removeAt", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$removeAt",
            "getItem", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$getItem",
            "setItem", "System$Collections$Generic$IList$1$" + Bridge.getTypeAlias(T) + "$setItem"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Collections.IndexedSet$1#init", this ); }

                this.m_List = new (System.Collections.Generic.List$1(T)).ctor();
                this.m_Dictionary = new (System.Collections.Generic.Dictionary$2(T,System.Int32)).ctor();
            }
        },
        methods: {
            getItem: function (index) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Collections.IndexedSet$1#getItem", this ); }

                return Bridge.rValue(this.m_List.getItem(index));
            },
            setItem: function (index, value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Collections.IndexedSet$1#setItem", this ); }

                var item = Bridge.rValue(this.m_List.getItem(index));
                this.m_Dictionary.remove(Bridge.rValue(item));
                this.m_List.setItem(index, Bridge.rValue(value));
                this.m_Dictionary.add(Bridge.rValue(item), index);
            },
            /*UnityEngine.UI.Collections.IndexedSet$1.add start.*/
            add: function (item) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Collections.IndexedSet$1#add", this ); }

                this.m_List.add(Bridge.rValue(item));
                this.m_Dictionary.add(Bridge.rValue(item), this.m_List.Count - 1);
            },
            /*UnityEngine.UI.Collections.IndexedSet$1.add end.*/

            /*UnityEngine.UI.Collections.IndexedSet$1.AddUnique start.*/
            AddUnique: function (item) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Collections.IndexedSet$1#AddUnique", this ); }

                if (this.m_Dictionary.containsKey(Bridge.rValue(item))) {
                    return false;
                }

                this.m_List.add(Bridge.rValue(item));
                this.m_Dictionary.add(Bridge.rValue(item), this.m_List.Count - 1);

                return true;
            },
            /*UnityEngine.UI.Collections.IndexedSet$1.AddUnique end.*/

            /*UnityEngine.UI.Collections.IndexedSet$1.remove start.*/
            remove: function (item) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Collections.IndexedSet$1#remove", this ); }

                var index = { v : -1 };
                if (!this.m_Dictionary.tryGetValue(Bridge.rValue(item), index)) {
                    return false;
                }

                this.removeAt(index.v);
                return true;
            },
            /*UnityEngine.UI.Collections.IndexedSet$1.remove end.*/

            /*UnityEngine.UI.Collections.IndexedSet$1.GetEnumerator start.*/
            GetEnumerator: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Collections.IndexedSet$1#GetEnumerator", this ); }

                throw new System.NotImplementedException.ctor();
            },
            /*UnityEngine.UI.Collections.IndexedSet$1.GetEnumerator end.*/

            /*UnityEngine.UI.Collections.IndexedSet$1.System$Collections$IEnumerable$GetEnumerator start.*/
            System$Collections$IEnumerable$GetEnumerator: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Collections.IndexedSet$1#System$Collections$IEnumerable$GetEnumerator", this ); }

                return this.GetEnumerator();
            },
            /*UnityEngine.UI.Collections.IndexedSet$1.System$Collections$IEnumerable$GetEnumerator end.*/

            /*UnityEngine.UI.Collections.IndexedSet$1.clear start.*/
            clear: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Collections.IndexedSet$1#clear", this ); }

                this.m_List.clear();
                this.m_Dictionary.clear();
            },
            /*UnityEngine.UI.Collections.IndexedSet$1.clear end.*/

            /*UnityEngine.UI.Collections.IndexedSet$1.contains start.*/
            contains: function (item) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Collections.IndexedSet$1#contains", this ); }

                return this.m_Dictionary.containsKey(Bridge.rValue(item));
            },
            /*UnityEngine.UI.Collections.IndexedSet$1.contains end.*/

            /*UnityEngine.UI.Collections.IndexedSet$1.copyTo start.*/
            copyTo: function (array, arrayIndex) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Collections.IndexedSet$1#copyTo", this ); }

                this.m_List.copyTo(array, arrayIndex);
            },
            /*UnityEngine.UI.Collections.IndexedSet$1.copyTo end.*/

            /*UnityEngine.UI.Collections.IndexedSet$1.indexOf start.*/
            indexOf: function (item) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Collections.IndexedSet$1#indexOf", this ); }

                var index = { v : -1 };
                if (this.m_Dictionary.tryGetValue(Bridge.rValue(item), index)) {
                    return index.v;
                }

                return -1;
            },
            /*UnityEngine.UI.Collections.IndexedSet$1.indexOf end.*/

            /*UnityEngine.UI.Collections.IndexedSet$1.insert start.*/
            insert: function (index, item) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Collections.IndexedSet$1#insert", this ); }

                //We could support this, but the semantics would be weird. Order is not guaranteed..
                throw new System.NotSupportedException.$ctor1("Random Insertion is semantically invalid, since this structure does not guarantee ordering.");
            },
            /*UnityEngine.UI.Collections.IndexedSet$1.insert end.*/

            /*UnityEngine.UI.Collections.IndexedSet$1.removeAt start.*/
            removeAt: function (index) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Collections.IndexedSet$1#removeAt", this ); }

                var item = Bridge.rValue(this.m_List.getItem(index));
                this.m_Dictionary.remove(Bridge.rValue(item));
                if (index === this.m_List.Count - 1) {
                    this.m_List.removeAt(index);
                } else {
                    var replaceItemIndex = this.m_List.Count - 1;
                    var replaceItem = Bridge.rValue(this.m_List.getItem(replaceItemIndex));
                    this.m_List.setItem(index, Bridge.rValue(replaceItem));
                    this.m_Dictionary.setItem(Bridge.rValue(replaceItem), index);
                    this.m_List.removeAt(replaceItemIndex);
                }
            },
            /*UnityEngine.UI.Collections.IndexedSet$1.removeAt end.*/

            /*UnityEngine.UI.Collections.IndexedSet$1.RemoveAll start.*/
            RemoveAll: function (match) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Collections.IndexedSet$1#RemoveAll", this ); }

                //I guess this could be optmized by instead of removing the items from the list immediatly,
                //We move them to the end, and then remove all in one go.
                //But I don't think this is going to be the bottleneck, so leaving as is for now.
                var i = 0;
                while (i < this.m_List.Count) {
                    var item = Bridge.rValue(this.m_List.getItem(i));
                    if (match(Bridge.rValue(item))) {
                        this.remove(Bridge.rValue(item));
                    } else {
                        i++;
                    }
                }
            },
            /*UnityEngine.UI.Collections.IndexedSet$1.RemoveAll end.*/

            /*UnityEngine.UI.Collections.IndexedSet$1.Sort start.*/
            Sort: function (sortLayoutFunction) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Collections.IndexedSet$1#Sort", this ); }

                //There might be better ways to sort and keep the dictionary index up to date.
                this.m_List.Sort$2(sortLayoutFunction);
                //Rebuild the dictionary index.
                for (var i = 0; i < this.m_List.Count; ++i) {
                    var item = Bridge.rValue(this.m_List.getItem(i));
                    this.m_Dictionary.setItem(Bridge.rValue(item), i);
                }
            },
            /*UnityEngine.UI.Collections.IndexedSet$1.Sort end.*/


        },
        overloads: {
            "Add(T)": "add",
            "Remove(T)": "remove",
            "Clear()": "clear",
            "Contains(T)": "contains",
            "CopyTo(T[], int)": "copyTo",
            "IndexOf(T)": "indexOf",
            "Insert(int, T)": "insert",
            "RemoveAt(int)": "removeAt"
        }
    }; });
    /*UnityEngine.UI.Collections.IndexedSet$1 end.*/

    /*UnityEngine.UI.ColorBlock start.*/
    Bridge.define("UnityEngine.UI.ColorBlock", {
        inherits: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ColorBlock#inherits", this ); }
 return [System.IEquatable$1(UnityEngine.UI.ColorBlock)]; },
        $kind: 4,
        statics: {
            props: {
                /**
                 * Simple getter for a code generated default ColorBlock.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof UnityEngine.UI.ColorBlock
                 * @function defaultColorBlock
                 * @type UnityEngine.UI.ColorBlock
                 */
                defaultColorBlock: {
                    get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ColorBlock#defaultColorBlock#get", this ); }

                        var $t;
                        var c = ($t = new UnityEngine.UI.ColorBlock(), $t.m_NormalColor = UnityEngine.Color32.op_Implicit(new UnityEngine.Color32.$ctor1(255, 255, 255, 255)), $t.m_HighlightedColor = UnityEngine.Color32.op_Implicit(new UnityEngine.Color32.$ctor1(245, 245, 245, 255)), $t.m_PressedColor = UnityEngine.Color32.op_Implicit(new UnityEngine.Color32.$ctor1(200, 200, 200, 255)), $t.m_SelectedColor = UnityEngine.Color32.op_Implicit(new UnityEngine.Color32.$ctor1(245, 245, 245, 255)), $t.m_DisabledColor = UnityEngine.Color32.op_Implicit(new UnityEngine.Color32.$ctor1(200, 200, 200, 128)), $t.colorMultiplier = 1.0, $t.fadeDuration = 0.1, $t);
                        return c.$clone();
                    }
                }
            },
            methods: {
                op_Equality: function (point1, point2) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ColorBlock#op_Equality", this ); }

                    return point1.equalsT(point2.$clone());
                },
                op_Inequality: function (point1, point2) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ColorBlock#op_Inequality", this ); }

                    return !point1.equalsT(point2.$clone());
                },
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ColorBlock#getDefaultValue", this ); }
 return new UnityEngine.UI.ColorBlock(); }
            }
        },
        fields: {
            m_ColorMultiplier: 0,
            m_DisabledColor: null,
            m_FadeDuration: 0,
            m_HighlightedColor: null,
            m_NormalColor: null,
            m_PressedColor: null,
            m_SelectedColor: null
        },
        props: {
            /**
             * The normal color for this color block.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.ColorBlock
             * @function normalColor
             * @type UnityEngine.Color
             */
            normalColor: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ColorBlock#normalColor#get", this ); }

                    return this.m_NormalColor.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ColorBlock#normalColor#set", this ); }

                    this.m_NormalColor = value.$clone();
                }
            },
            /**
             * The highlight color for this color block.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.ColorBlock
             * @function highlightedColor
             * @type UnityEngine.Color
             */
            highlightedColor: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ColorBlock#highlightedColor#get", this ); }

                    return this.m_HighlightedColor.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ColorBlock#highlightedColor#set", this ); }

                    this.m_HighlightedColor = value.$clone();
                }
            },
            /**
             * The pressed color for this color block.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.ColorBlock
             * @function pressedColor
             * @type UnityEngine.Color
             */
            pressedColor: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ColorBlock#pressedColor#get", this ); }

                    return this.m_PressedColor.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ColorBlock#pressedColor#set", this ); }

                    this.m_PressedColor = value.$clone();
                }
            },
            /**
             * The selected color for this color block.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.ColorBlock
             * @function selectedColor
             * @type UnityEngine.Color
             */
            selectedColor: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ColorBlock#selectedColor#get", this ); }

                    return this.m_SelectedColor.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ColorBlock#selectedColor#set", this ); }

                    this.m_SelectedColor = value.$clone();
                }
            },
            /**
             * The disabled color for this color block.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.ColorBlock
             * @function disabledColor
             * @type UnityEngine.Color
             */
            disabledColor: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ColorBlock#disabledColor#get", this ); }

                    return this.m_DisabledColor.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ColorBlock#disabledColor#set", this ); }

                    this.m_DisabledColor = value.$clone();
                }
            },
            /**
             * Multiplier applied to colors (allows brightening greater then base color).
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.ColorBlock
             * @function colorMultiplier
             * @type number
             */
            colorMultiplier: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ColorBlock#colorMultiplier#get", this ); }

                    return this.m_ColorMultiplier;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ColorBlock#colorMultiplier#set", this ); }

                    this.m_ColorMultiplier = value;
                }
            },
            /**
             * How long a color transition between states should take.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.ColorBlock
             * @function fadeDuration
             * @type number
             */
            fadeDuration: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ColorBlock#fadeDuration#get", this ); }

                    return this.m_FadeDuration;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ColorBlock#fadeDuration#set", this ); }

                    this.m_FadeDuration = value;
                }
            }
        },
        alias: ["equalsT", "System$IEquatable$1$UnityEngine$UI$ColorBlock$equalsT"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ColorBlock#init", this ); }

                this.m_DisabledColor = new UnityEngine.Color();
                this.m_HighlightedColor = new UnityEngine.Color();
                this.m_NormalColor = new UnityEngine.Color();
                this.m_PressedColor = new UnityEngine.Color();
                this.m_SelectedColor = new UnityEngine.Color();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ColorBlock#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*UnityEngine.UI.ColorBlock.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ColorBlock#equalsT", this ); }

                return pc.Color.equals( this.normalColor, other.normalColor ) && pc.Color.equals( this.highlightedColor, other.highlightedColor ) && pc.Color.equals( this.pressedColor, other.pressedColor ) && pc.Color.equals( this.selectedColor, other.selectedColor ) && pc.Color.equals( this.disabledColor, other.disabledColor ) && this.colorMultiplier === other.colorMultiplier && this.fadeDuration === other.fadeDuration;
            },
            /*UnityEngine.UI.ColorBlock.equalsT end.*/

            /*UnityEngine.UI.ColorBlock.equals start.*/
            equals: function (obj) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ColorBlock#equals", this ); }

                if (!(Bridge.is(obj, UnityEngine.UI.ColorBlock))) {
                    return false;
                }

                return this.equalsT(Bridge.cast(obj, UnityEngine.UI.ColorBlock));
            },
            /*UnityEngine.UI.ColorBlock.equals end.*/

            /*UnityEngine.UI.ColorBlock.getHashCode start.*/
            getHashCode: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ColorBlock#getHashCode", this ); }

                return Bridge.getHashCode(this);
            },
            /*UnityEngine.UI.ColorBlock.getHashCode end.*/

            $clone: function (to) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ColorBlock#$clone", this ); }

                var s = to || new UnityEngine.UI.ColorBlock();
                s.m_ColorMultiplier = this.m_ColorMultiplier;
                s.m_DisabledColor = this.m_DisabledColor.$clone();
                s.m_FadeDuration = this.m_FadeDuration;
                s.m_HighlightedColor = this.m_HighlightedColor.$clone();
                s.m_NormalColor = this.m_NormalColor.$clone();
                s.m_PressedColor = this.m_PressedColor.$clone();
                s.m_SelectedColor = this.m_SelectedColor.$clone();
                return s;
            }
        },
        overloads: {
            "Equals(ColorBlock)": "equalsT",
            "Equals(object)": "equals",
            "GetHashCode()": "getHashCode"
        }
    });
    /*UnityEngine.UI.ColorBlock end.*/

    /*UnityEngine.UI.ILayoutController start.*/
    /**
     * Base interface to implement by components that control the layout of RectTransforms.
     *
     * @abstract
     * @public
     * @class UnityEngine.UI.ILayoutController
     */
    Bridge.define("UnityEngine.UI.ILayoutController", {
        $kind: 3
    });
    /*UnityEngine.UI.ILayoutController end.*/

    /*UnityEngine.UI.ContentSizeFitter+FitMode start.*/
    Bridge.define("UnityEngine.UI.ContentSizeFitter.FitMode", {
        $kind: 1006,
        statics: {
            fields: {
                Unconstrained: 0,
                MinSize: 1,
                PreferredSize: 2
            }
        }
    });
    /*UnityEngine.UI.ContentSizeFitter+FitMode end.*/

    /*UnityEngine.UI.CoroutineTween.ITweenValue start.*/
    Bridge.define("UnityEngine.UI.CoroutineTween.ITweenValue", {
        $kind: 3
    });
    /*UnityEngine.UI.CoroutineTween.ITweenValue end.*/

    /*UnityEngine.UI.CoroutineTween.ColorTween+ColorTweenCallback start.*/
    Bridge.define("UnityEngine.UI.CoroutineTween.ColorTween.ColorTweenCallback", {
        inherits: [UnityEngine.Events.UnityEvent$1(UnityEngine.Color)],
        $kind: 1002
    });
    /*UnityEngine.UI.CoroutineTween.ColorTween+ColorTweenCallback end.*/

    /*UnityEngine.UI.CoroutineTween.ColorTween+ColorTweenMode start.*/
    Bridge.define("UnityEngine.UI.CoroutineTween.ColorTween.ColorTweenMode", {
        $kind: 1006,
        statics: {
            fields: {
                All: 0,
                RGB: 1,
                Alpha: 2
            }
        }
    });
    /*UnityEngine.UI.CoroutineTween.ColorTween+ColorTweenMode end.*/

    /*UnityEngine.UI.CoroutineTween.FloatTween+FloatTweenCallback start.*/
    Bridge.define("UnityEngine.UI.CoroutineTween.FloatTween.FloatTweenCallback", {
        inherits: [UnityEngine.Events.UnityEvent$1(System.Single)],
        $kind: 1002
    });
    /*UnityEngine.UI.CoroutineTween.FloatTween+FloatTweenCallback end.*/

    /*UnityEngine.UI.DefaultControls start.*/
    Bridge.define("UnityEngine.UI.DefaultControls", {
        statics: {
            fields: {
                kWidth: 0,
                kThickHeight: 0,
                kThinHeight: 0,
                s_ThickElementSize: null,
                s_ThinElementSize: null,
                s_ImageElementSize: null,
                s_DefaultSelectableColor: null,
                s_PanelColor: null,
                s_TextColor: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.DefaultControls#init", this ); }

                    this.s_ThickElementSize = new UnityEngine.Vector2();
                    this.s_ThinElementSize = new UnityEngine.Vector2();
                    this.s_ImageElementSize = new UnityEngine.Vector2();
                    this.s_DefaultSelectableColor = new UnityEngine.Color();
                    this.s_PanelColor = new UnityEngine.Color();
                    this.s_TextColor = new UnityEngine.Color();
                    this.kWidth = 160.0;
                    this.kThickHeight = 30.0;
                    this.kThinHeight = 20.0;
                    this.s_ThickElementSize = new pc.Vec2( 160.0, 30.0 );
                    this.s_ThinElementSize = new pc.Vec2( 160.0, 20.0 );
                    this.s_ImageElementSize = new pc.Vec2( 100.0, 100.0 );
                    this.s_DefaultSelectableColor = new pc.Color( 1.0, 1.0, 1.0, 1.0 );
                    this.s_PanelColor = new pc.Color( 1.0, 1.0, 1.0, 0.392 );
                    this.s_TextColor = new pc.Color( 0.1960784, 0.1960784, 0.1960784, 1.0 );
                }
            },
            methods: {
                /*UnityEngine.UI.DefaultControls.CreateUIElementRoot:static start.*/
                CreateUIElementRoot: function (name, size) {
if ( TRACE ) { TRACE( "UnityEngine.UI.DefaultControls#CreateUIElementRoot", this ); }

                    var gameObject = new UnityEngine.GameObject.$ctor2(name);
                    gameObject.AddComponent(UnityEngine.RectTransform).sizeDelta = size.$clone();
                    return gameObject;
                },
                /*UnityEngine.UI.DefaultControls.CreateUIElementRoot:static end.*/

                /*UnityEngine.UI.DefaultControls.CreateUIObject:static start.*/
                CreateUIObject: function (name, parent) {
if ( TRACE ) { TRACE( "UnityEngine.UI.DefaultControls#CreateUIObject", this ); }

                    var child = new UnityEngine.GameObject.$ctor2(name);
                    child.AddComponent(UnityEngine.RectTransform);
                    UnityEngine.UI.DefaultControls.SetParentAndAlign(child, parent);
                    return child;
                },
                /*UnityEngine.UI.DefaultControls.CreateUIObject:static end.*/

                /*UnityEngine.UI.DefaultControls.SetDefaultTextValues:static start.*/
                SetDefaultTextValues: function (lbl) {
if ( TRACE ) { TRACE( "UnityEngine.UI.DefaultControls#SetDefaultTextValues", this ); }

                    lbl.color = UnityEngine.UI.DefaultControls.s_TextColor.$clone();
                    lbl.AssignDefaultFont();
                },
                /*UnityEngine.UI.DefaultControls.SetDefaultTextValues:static end.*/

                /*UnityEngine.UI.DefaultControls.SetDefaultColorTransitionValues:static start.*/
                SetDefaultColorTransitionValues: function (slider) {
if ( TRACE ) { TRACE( "UnityEngine.UI.DefaultControls#SetDefaultColorTransitionValues", this ); }

                    var colors = slider.colors.$clone();
                    colors.highlightedColor = new pc.Color( 0.882, 0.882, 0.882, 1 );
                    colors.pressedColor = new pc.Color( 0.698, 0.698, 0.698, 1 );
                    colors.disabledColor = new pc.Color( 0.521, 0.521, 0.521, 1 );
                },
                /*UnityEngine.UI.DefaultControls.SetDefaultColorTransitionValues:static end.*/

                /*UnityEngine.UI.DefaultControls.SetParentAndAlign:static start.*/
                SetParentAndAlign: function (child, parent) {
if ( TRACE ) { TRACE( "UnityEngine.UI.DefaultControls#SetParentAndAlign", this ); }

                    if (Bridge.referenceEquals(Bridge.cast(parent, UnityEngine.Object), null)) {
                        return;
                    }

                    child.transform.SetParent(parent.transform, false);
                    UnityEngine.UI.DefaultControls.SetLayerRecursively(child, parent.layer);
                },
                /*UnityEngine.UI.DefaultControls.SetParentAndAlign:static end.*/

                /*UnityEngine.UI.DefaultControls.SetLayerRecursively:static start.*/
                SetLayerRecursively: function (go, layer) {
if ( TRACE ) { TRACE( "UnityEngine.UI.DefaultControls#SetLayerRecursively", this ); }

                    go.layer = layer;
                    var transform = go.transform;
                    for (var index = 0; index < transform.childCount; ++index) {
                        UnityEngine.UI.DefaultControls.SetLayerRecursively(transform.GetChild(index).gameObject, layer);
                    }
                },
                /*UnityEngine.UI.DefaultControls.SetLayerRecursively:static end.*/

                /*UnityEngine.UI.DefaultControls.CreatePanel:static start.*/
                CreatePanel: function (resources) {
if ( TRACE ) { TRACE( "UnityEngine.UI.DefaultControls#CreatePanel", this ); }

                    var uiElementRoot = UnityEngine.UI.DefaultControls.CreateUIElementRoot("Panel", UnityEngine.UI.DefaultControls.s_ThickElementSize.$clone());
                    var component = uiElementRoot.GetComponent(UnityEngine.RectTransform);
                    component.anchorMin = pc.Vec2.ZERO.clone();
                    component.anchorMax = pc.Vec2.ONE.clone();
                    component.anchoredPosition = pc.Vec2.ZERO.clone();
                    component.sizeDelta = pc.Vec2.ZERO.clone();
                    var image = uiElementRoot.AddComponent(UnityEngine.UI.Image);
                    image.sprite = resources.background;
                    image.type = UnityEngine.UI.Image.Type.Sliced;
                    image.color = UnityEngine.UI.DefaultControls.s_PanelColor.$clone();
                    return uiElementRoot;
                },
                /*UnityEngine.UI.DefaultControls.CreatePanel:static end.*/

                /*UnityEngine.UI.DefaultControls.CreateButton:static start.*/
                CreateButton: function (resources) {
if ( TRACE ) { TRACE( "UnityEngine.UI.DefaultControls#CreateButton", this ); }

                    var uiElementRoot = UnityEngine.UI.DefaultControls.CreateUIElementRoot("Button", UnityEngine.UI.DefaultControls.s_ThickElementSize.$clone());
                    var child = new UnityEngine.GameObject.$ctor2("Text");
                    child.AddComponent(UnityEngine.RectTransform);
                    UnityEngine.UI.DefaultControls.SetParentAndAlign(child, uiElementRoot);
                    var image = uiElementRoot.AddComponent(UnityEngine.UI.Image);
                    image.sprite = resources.standard;
                    image.type = UnityEngine.UI.Image.Type.Sliced;
                    image.color = UnityEngine.UI.DefaultControls.s_DefaultSelectableColor.$clone();
                    UnityEngine.UI.DefaultControls.SetDefaultColorTransitionValues(Bridge.cast(uiElementRoot.AddComponent(UnityEngine.UI.Button), UnityEngine.UI.Selectable));
                    var lbl = child.AddComponent(UnityEngine.UI.Text);
                    lbl.text = "Button";
                    lbl.alignment = UnityEngine.TextAnchor.MiddleCenter;
                    UnityEngine.UI.DefaultControls.SetDefaultTextValues(lbl);
                    var component = child.GetComponent(UnityEngine.RectTransform);
                    component.anchorMin = pc.Vec2.ZERO.clone();
                    component.anchorMax = pc.Vec2.ONE.clone();
                    component.sizeDelta = pc.Vec2.ZERO.clone();
                    return uiElementRoot;
                },
                /*UnityEngine.UI.DefaultControls.CreateButton:static end.*/

                /*UnityEngine.UI.DefaultControls.CreateText:static start.*/
                CreateText: function (resources) {
if ( TRACE ) { TRACE( "UnityEngine.UI.DefaultControls#CreateText", this ); }

                    var uiElementRoot = UnityEngine.UI.DefaultControls.CreateUIElementRoot("Text", UnityEngine.UI.DefaultControls.s_ThickElementSize.$clone());
                    var lbl = uiElementRoot.AddComponent(UnityEngine.UI.Text);
                    lbl.text = "New Text";
                    UnityEngine.UI.DefaultControls.SetDefaultTextValues(lbl);
                    return uiElementRoot;
                },
                /*UnityEngine.UI.DefaultControls.CreateText:static end.*/

                /*UnityEngine.UI.DefaultControls.CreateImage:static start.*/
                CreateImage: function (resources) {
if ( TRACE ) { TRACE( "UnityEngine.UI.DefaultControls#CreateImage", this ); }

                    var uiElementRoot = UnityEngine.UI.DefaultControls.CreateUIElementRoot("Image", UnityEngine.UI.DefaultControls.s_ImageElementSize.$clone());
                    uiElementRoot.AddComponent(UnityEngine.UI.Image);
                    return uiElementRoot;
                },
                /*UnityEngine.UI.DefaultControls.CreateImage:static end.*/

                /*UnityEngine.UI.DefaultControls.CreateRawImage:static start.*/
                CreateRawImage: function (resources) {
if ( TRACE ) { TRACE( "UnityEngine.UI.DefaultControls#CreateRawImage", this ); }

                    var uiElementRoot = UnityEngine.UI.DefaultControls.CreateUIElementRoot("RawImage", UnityEngine.UI.DefaultControls.s_ImageElementSize.$clone());
                    uiElementRoot.AddComponent(UnityEngine.UI.RawImage);
                    return uiElementRoot;
                },
                /*UnityEngine.UI.DefaultControls.CreateRawImage:static end.*/

                /*UnityEngine.UI.DefaultControls.CreateSlider:static start.*/
                CreateSlider: function (resources) {
if ( TRACE ) { TRACE( "UnityEngine.UI.DefaultControls#CreateSlider", this ); }

                    var uiElementRoot = UnityEngine.UI.DefaultControls.CreateUIElementRoot("Slider", UnityEngine.UI.DefaultControls.s_ThinElementSize.$clone());
                    var uiObject1 = UnityEngine.UI.DefaultControls.CreateUIObject("Background", uiElementRoot);
                    var uiObject2 = UnityEngine.UI.DefaultControls.CreateUIObject("Fill Area", uiElementRoot);
                    var uiObject3 = UnityEngine.UI.DefaultControls.CreateUIObject("Fill", uiObject2);
                    var uiObject4 = UnityEngine.UI.DefaultControls.CreateUIObject("Handle Slide Area", uiElementRoot);
                    var uiObject5 = UnityEngine.UI.DefaultControls.CreateUIObject("Handle", uiObject4);
                    var image1 = uiObject1.AddComponent(UnityEngine.UI.Image);
                    image1.sprite = resources.background;
                    image1.type = UnityEngine.UI.Image.Type.Sliced;
                    image1.color = UnityEngine.UI.DefaultControls.s_DefaultSelectableColor.$clone();
                    var component1 = uiObject1.GetComponent(UnityEngine.RectTransform);
                    component1.anchorMin = new pc.Vec2( 0.0, 0.25 );
                    component1.anchorMax = new pc.Vec2( 1.0, 0.75 );
                    component1.sizeDelta = new pc.Vec2( 0.0, 0.0 );
                    var component2 = uiObject2.GetComponent(UnityEngine.RectTransform);
                    component2.anchorMin = new pc.Vec2( 0.0, 0.25 );
                    component2.anchorMax = new pc.Vec2( 1.0, 0.75 );
                    component2.anchoredPosition = new pc.Vec2( -5.0, 0.0 );
                    component2.sizeDelta = new pc.Vec2( -20.0, 0.0 );
                    var image2 = uiObject3.AddComponent(UnityEngine.UI.Image);
                    image2.sprite = resources.standard;
                    image2.type = UnityEngine.UI.Image.Type.Sliced;
                    image2.color = UnityEngine.UI.DefaultControls.s_DefaultSelectableColor.$clone();
                    uiObject3.GetComponent(UnityEngine.RectTransform).sizeDelta = new pc.Vec2( 10.0, 0.0 );
                    var component3 = uiObject4.GetComponent(UnityEngine.RectTransform);
                    component3.sizeDelta = new pc.Vec2( -20.0, 0.0 );
                    component3.anchorMin = new pc.Vec2( 0.0, 0.0 );
                    component3.anchorMax = new pc.Vec2( 1.0, 1.0 );
                    var image3 = uiObject5.AddComponent(UnityEngine.UI.Image);
                    image3.sprite = resources.knob;
                    image3.color = UnityEngine.UI.DefaultControls.s_DefaultSelectableColor.$clone();
                    uiObject5.GetComponent(UnityEngine.RectTransform).sizeDelta = new pc.Vec2( 20.0, 0.0 );
                    var slider = uiElementRoot.AddComponent(UnityEngine.UI.Slider);
                    slider.fillRect = uiObject3.GetComponent(UnityEngine.RectTransform);
                    slider.handleRect = uiObject5.GetComponent(UnityEngine.RectTransform);
                    slider.targetGraphic = Bridge.cast(image3, UnityEngine.UI.Graphic);
                    slider.direction = UnityEngine.UI.Slider.Direction.LeftToRight;
                    UnityEngine.UI.DefaultControls.SetDefaultColorTransitionValues(Bridge.cast(slider, UnityEngine.UI.Selectable));
                    return uiElementRoot;
                },
                /*UnityEngine.UI.DefaultControls.CreateSlider:static end.*/

                /*UnityEngine.UI.DefaultControls.CreateScrollbar:static start.*/
                CreateScrollbar: function (resources) {
if ( TRACE ) { TRACE( "UnityEngine.UI.DefaultControls#CreateScrollbar", this ); }

                    var uiElementRoot = UnityEngine.UI.DefaultControls.CreateUIElementRoot("Scrollbar", UnityEngine.UI.DefaultControls.s_ThinElementSize.$clone());
                    var uiObject1 = UnityEngine.UI.DefaultControls.CreateUIObject("Sliding Area", uiElementRoot);
                    var uiObject2 = UnityEngine.UI.DefaultControls.CreateUIObject("Handle", uiObject1);
                    var image1 = uiElementRoot.AddComponent(UnityEngine.UI.Image);
                    image1.sprite = resources.background;
                    image1.type = UnityEngine.UI.Image.Type.Sliced;
                    image1.color = UnityEngine.UI.DefaultControls.s_DefaultSelectableColor.$clone();
                    var image2 = uiObject2.AddComponent(UnityEngine.UI.Image);
                    image2.sprite = resources.standard;
                    image2.type = UnityEngine.UI.Image.Type.Sliced;
                    image2.color = UnityEngine.UI.DefaultControls.s_DefaultSelectableColor.$clone();
                    var component1 = uiObject1.GetComponent(UnityEngine.RectTransform);
                    component1.sizeDelta = new pc.Vec2( -20.0, -20.0 );
                    component1.anchorMin = pc.Vec2.ZERO.clone();
                    component1.anchorMax = pc.Vec2.ONE.clone();
                    var component2 = uiObject2.GetComponent(UnityEngine.RectTransform);
                    component2.sizeDelta = new pc.Vec2( 20.0, 20.0 );
                    var scrollbar = uiElementRoot.AddComponent(UnityEngine.UI.Scrollbar);
                    scrollbar.handleRect = component2;
                    scrollbar.targetGraphic = Bridge.cast(image2, UnityEngine.UI.Graphic);
                    UnityEngine.UI.DefaultControls.SetDefaultColorTransitionValues(Bridge.cast(scrollbar, UnityEngine.UI.Selectable));
                    return uiElementRoot;
                },
                /*UnityEngine.UI.DefaultControls.CreateScrollbar:static end.*/

                /*UnityEngine.UI.DefaultControls.CreateToggle:static start.*/
                CreateToggle: function (resources) {
if ( TRACE ) { TRACE( "UnityEngine.UI.DefaultControls#CreateToggle", this ); }

                    var uiElementRoot = UnityEngine.UI.DefaultControls.CreateUIElementRoot("Toggle", UnityEngine.UI.DefaultControls.s_ThinElementSize.$clone());
                    var uiObject1 = UnityEngine.UI.DefaultControls.CreateUIObject("Background", uiElementRoot);
                    var uiObject2 = UnityEngine.UI.DefaultControls.CreateUIObject("Checkmark", uiObject1);
                    var uiObject3 = UnityEngine.UI.DefaultControls.CreateUIObject("Label", uiElementRoot);
                    var toggle = uiElementRoot.AddComponent(UnityEngine.UI.Toggle);
                    toggle.isOn = true;
                    var image1 = uiObject1.AddComponent(UnityEngine.UI.Image);
                    image1.sprite = resources.standard;
                    image1.type = UnityEngine.UI.Image.Type.Sliced;
                    image1.color = UnityEngine.UI.DefaultControls.s_DefaultSelectableColor.$clone();
                    var image2 = uiObject2.AddComponent(UnityEngine.UI.Image);
                    image2.sprite = resources.checkmark;
                    var lbl = uiObject3.AddComponent(UnityEngine.UI.Text);
                    lbl.text = "Toggle";
                    UnityEngine.UI.DefaultControls.SetDefaultTextValues(lbl);
                    toggle.graphic = Bridge.cast(image2, UnityEngine.UI.Graphic);
                    toggle.targetGraphic = Bridge.cast(image1, UnityEngine.UI.Graphic);
                    UnityEngine.UI.DefaultControls.SetDefaultColorTransitionValues(Bridge.cast(toggle, UnityEngine.UI.Selectable));
                    var component1 = uiObject1.GetComponent(UnityEngine.RectTransform);
                    component1.anchorMin = new pc.Vec2( 0.0, 1.0 );
                    component1.anchorMax = new pc.Vec2( 0.0, 1.0 );
                    component1.anchoredPosition = new pc.Vec2( 10.0, -10.0 );
                    component1.sizeDelta = new pc.Vec2( 20.0, 20.0 );
                    var component2 = uiObject2.GetComponent(UnityEngine.RectTransform);
                    component2.anchorMin = new pc.Vec2( 0.5, 0.5 );
                    component2.anchorMax = new pc.Vec2( 0.5, 0.5 );
                    component2.anchoredPosition = pc.Vec2.ZERO.clone();
                    component2.sizeDelta = new pc.Vec2( 20.0, 20.0 );
                    var component3 = uiObject3.GetComponent(UnityEngine.RectTransform);
                    component3.anchorMin = new pc.Vec2( 0.0, 0.0 );
                    component3.anchorMax = new pc.Vec2( 1.0, 1.0 );
                    component3.offsetMin = new pc.Vec2( 23.0, 1.0 );
                    component3.offsetMax = new pc.Vec2( -5.0, -2.0 );
                    return uiElementRoot;
                },
                /*UnityEngine.UI.DefaultControls.CreateToggle:static end.*/

                /*UnityEngine.UI.DefaultControls.CreateInputField:static start.*/
                CreateInputField: function (resources) {
if ( TRACE ) { TRACE( "UnityEngine.UI.DefaultControls#CreateInputField", this ); }

                    var uiElementRoot = UnityEngine.UI.DefaultControls.CreateUIElementRoot("InputField", UnityEngine.UI.DefaultControls.s_ThickElementSize.$clone());
                    var uiObject1 = UnityEngine.UI.DefaultControls.CreateUIObject("Placeholder", uiElementRoot);
                    var uiObject2 = UnityEngine.UI.DefaultControls.CreateUIObject("Text", uiElementRoot);
                    var image = uiElementRoot.AddComponent(UnityEngine.UI.Image);
                    image.sprite = resources.inputField;
                    image.type = UnityEngine.UI.Image.Type.Sliced;
                    image.color = UnityEngine.UI.DefaultControls.s_DefaultSelectableColor.$clone();
                    var inputField = uiElementRoot.AddComponent(UnityEngine.UI.InputField);
                    UnityEngine.UI.DefaultControls.SetDefaultColorTransitionValues(Bridge.cast(inputField, UnityEngine.UI.Selectable));
                    var lbl = uiObject2.AddComponent(UnityEngine.UI.Text);
                    lbl.text = "";
                    lbl.supportRichText = false;
                    UnityEngine.UI.DefaultControls.SetDefaultTextValues(lbl);
                    var text = uiObject1.AddComponent(UnityEngine.UI.Text);
                    text.text = "Enter text...";
                    text.fontStyle = UnityEngine.FontStyle.Italic;
                    var color = lbl.color.$clone();
                    color.a *= 0.5;
                    text.color = color.$clone();
                    var component1 = uiObject2.GetComponent(UnityEngine.RectTransform);
                    component1.anchorMin = pc.Vec2.ZERO.clone();
                    component1.anchorMax = pc.Vec2.ONE.clone();
                    component1.sizeDelta = pc.Vec2.ZERO.clone();
                    component1.offsetMin = new pc.Vec2( 10.0, 6.0 );
                    component1.offsetMax = new pc.Vec2( -10.0, -7.0 );
                    var component2 = uiObject1.GetComponent(UnityEngine.RectTransform);
                    component2.anchorMin = pc.Vec2.ZERO.clone();
                    component2.anchorMax = pc.Vec2.ONE.clone();
                    component2.sizeDelta = pc.Vec2.ZERO.clone();
                    component2.offsetMin = new pc.Vec2( 10.0, 6.0 );
                    component2.offsetMax = new pc.Vec2( -10.0, -7.0 );
                    inputField.textComponent = lbl;
                    inputField.placeholder = Bridge.cast(text, UnityEngine.UI.Graphic);
                    return uiElementRoot;
                },
                /*UnityEngine.UI.DefaultControls.CreateInputField:static end.*/

                /*UnityEngine.UI.DefaultControls.CreateDropdown:static start.*/
                CreateDropdown: function (resources) {
if ( TRACE ) { TRACE( "UnityEngine.UI.DefaultControls#CreateDropdown", this ); }

                    var $t;
                    var uiElementRoot = UnityEngine.UI.DefaultControls.CreateUIElementRoot("Dropdown", UnityEngine.UI.DefaultControls.s_ThickElementSize.$clone());
                    var uiObject1 = UnityEngine.UI.DefaultControls.CreateUIObject("Label", uiElementRoot);
                    var uiObject2 = UnityEngine.UI.DefaultControls.CreateUIObject("Arrow", uiElementRoot);
                    var uiObject3 = UnityEngine.UI.DefaultControls.CreateUIObject("Template", uiElementRoot);
                    var uiObject4 = UnityEngine.UI.DefaultControls.CreateUIObject("Viewport", uiObject3);
                    var uiObject5 = UnityEngine.UI.DefaultControls.CreateUIObject("Content", uiObject4);
                    var uiObject6 = UnityEngine.UI.DefaultControls.CreateUIObject("Item", uiObject5);
                    var uiObject7 = UnityEngine.UI.DefaultControls.CreateUIObject("Item Background", uiObject6);
                    var uiObject8 = UnityEngine.UI.DefaultControls.CreateUIObject("Item Checkmark", uiObject6);
                    var uiObject9 = UnityEngine.UI.DefaultControls.CreateUIObject("Item Label", uiObject6);
                    var scrollbar = UnityEngine.UI.DefaultControls.CreateScrollbar(resources.$clone());
                    scrollbar.name = "Scrollbar";
                    UnityEngine.UI.DefaultControls.SetParentAndAlign(scrollbar, uiObject3);
                    var component1 = scrollbar.GetComponent(UnityEngine.UI.Scrollbar);
                    component1.SetDirection(UnityEngine.UI.Scrollbar.Direction.BottomToTop, true);
                    var component2 = scrollbar.GetComponent(UnityEngine.RectTransform);
                    component2.anchorMin = pc.Vec2.RIGHT.clone();
                    component2.anchorMax = pc.Vec2.ONE.clone();
                    component2.pivot = pc.Vec2.ONE.clone();
                    component2.sizeDelta = new pc.Vec2( component2.sizeDelta.x, 0.0 );
                    var lbl1 = uiObject9.AddComponent(UnityEngine.UI.Text);
                    UnityEngine.UI.DefaultControls.SetDefaultTextValues(lbl1);
                    lbl1.alignment = UnityEngine.TextAnchor.MiddleLeft;
                    var image1 = uiObject7.AddComponent(UnityEngine.UI.Image);
                    image1.color = UnityEngine.Color32.op_Implicit(new UnityEngine.Color32.$ctor1(245, 245, 245, 255));
                    var image2 = uiObject8.AddComponent(UnityEngine.UI.Image);
                    image2.sprite = resources.checkmark;
                    var toggle = uiObject6.AddComponent(UnityEngine.UI.Toggle);
                    toggle.targetGraphic = Bridge.cast(image1, UnityEngine.UI.Graphic);
                    toggle.graphic = Bridge.cast(image2, UnityEngine.UI.Graphic);
                    toggle.isOn = true;
                    var image3 = uiObject3.AddComponent(UnityEngine.UI.Image);
                    image3.sprite = resources.standard;
                    image3.type = UnityEngine.UI.Image.Type.Sliced;
                    var scrollRect = uiObject3.AddComponent(UnityEngine.UI.ScrollRect);
                    scrollRect.content = Bridge.cast(uiObject5.transform, UnityEngine.RectTransform);
                    scrollRect.viewport = Bridge.cast(uiObject4.transform, UnityEngine.RectTransform);
                    scrollRect.horizontal = false;
                    scrollRect.movementType = UnityEngine.UI.ScrollRect.MovementType.Clamped;
                    scrollRect.verticalScrollbar = component1;
                    scrollRect.verticalScrollbarVisibility = UnityEngine.UI.ScrollRect.ScrollbarVisibility.AutoHideAndExpandViewport;
                    scrollRect.verticalScrollbarSpacing = -3.0;
                    uiObject4.AddComponent(UnityEngine.UI.Mask).showMaskGraphic = false;
                    var image4 = uiObject4.AddComponent(UnityEngine.UI.Image);
                    image4.sprite = resources.mask;
                    image4.type = UnityEngine.UI.Image.Type.Sliced;
                    var lbl2 = uiObject1.AddComponent(UnityEngine.UI.Text);
                    UnityEngine.UI.DefaultControls.SetDefaultTextValues(lbl2);
                    lbl2.alignment = UnityEngine.TextAnchor.MiddleLeft;
                    uiObject2.AddComponent(UnityEngine.UI.Image).sprite = resources.dropdown;
                    var image5 = uiElementRoot.AddComponent(UnityEngine.UI.Image);
                    image5.sprite = resources.standard;
                    image5.color = UnityEngine.UI.DefaultControls.s_DefaultSelectableColor.$clone();
                    image5.type = UnityEngine.UI.Image.Type.Sliced;
                    var dropdown = uiElementRoot.AddComponent(UnityEngine.UI.Dropdown);
                    dropdown.targetGraphic = Bridge.cast(image5, UnityEngine.UI.Graphic);
                    UnityEngine.UI.DefaultControls.SetDefaultColorTransitionValues(Bridge.cast(dropdown, UnityEngine.UI.Selectable));
                    dropdown.template = uiObject3.GetComponent(UnityEngine.RectTransform);
                    dropdown.captionText = lbl2;
                    dropdown.itemText = lbl1;
                    lbl1.text = "Option A";
                    dropdown.options.add(($t = new UnityEngine.UI.Dropdown.OptionData.ctor(), $t.text = "Option A", $t));
                    dropdown.options.add(($t = new UnityEngine.UI.Dropdown.OptionData.ctor(), $t.text = "Option B", $t));
                    dropdown.options.add(($t = new UnityEngine.UI.Dropdown.OptionData.ctor(), $t.text = "Option C", $t));
                    dropdown.RefreshShownValue();
                    var component3 = uiObject1.GetComponent(UnityEngine.RectTransform);
                    component3.anchorMin = pc.Vec2.ZERO.clone();
                    component3.anchorMax = pc.Vec2.ONE.clone();
                    component3.offsetMin = new pc.Vec2( 10.0, 6.0 );
                    component3.offsetMax = new pc.Vec2( -25.0, -7.0 );
                    var component4 = uiObject2.GetComponent(UnityEngine.RectTransform);
                    component4.anchorMin = new pc.Vec2( 1.0, 0.5 );
                    component4.anchorMax = new pc.Vec2( 1.0, 0.5 );
                    component4.sizeDelta = new pc.Vec2( 20.0, 20.0 );
                    component4.anchoredPosition = new pc.Vec2( -15.0, 0.0 );
                    var component5 = uiObject3.GetComponent(UnityEngine.RectTransform);
                    component5.anchorMin = new pc.Vec2( 0.0, 0.0 );
                    component5.anchorMax = new pc.Vec2( 1.0, 0.0 );
                    component5.pivot = new pc.Vec2( 0.5, 1.0 );
                    component5.anchoredPosition = new pc.Vec2( 0.0, 2.0 );
                    component5.sizeDelta = new pc.Vec2( 0.0, 150.0 );
                    var component6 = uiObject4.GetComponent(UnityEngine.RectTransform);
                    component6.anchorMin = new pc.Vec2( 0.0, 0.0 );
                    component6.anchorMax = new pc.Vec2( 1.0, 1.0 );
                    component6.sizeDelta = new pc.Vec2( -18.0, 0.0 );
                    component6.pivot = new pc.Vec2( 0.0, 1.0 );
                    var component7 = uiObject5.GetComponent(UnityEngine.RectTransform);
                    component7.anchorMin = new pc.Vec2( 0.0, 1.0 );
                    component7.anchorMax = new pc.Vec2( 1.0, 1.0 );
                    component7.pivot = new pc.Vec2( 0.5, 1.0 );
                    component7.anchoredPosition = new pc.Vec2( 0.0, 0.0 );
                    component7.sizeDelta = new pc.Vec2( 0.0, 28.0 );
                    var component8 = uiObject6.GetComponent(UnityEngine.RectTransform);
                    component8.anchorMin = new pc.Vec2( 0.0, 0.5 );
                    component8.anchorMax = new pc.Vec2( 1.0, 0.5 );
                    component8.sizeDelta = new pc.Vec2( 0.0, 20.0 );
                    var component9 = uiObject7.GetComponent(UnityEngine.RectTransform);
                    component9.anchorMin = pc.Vec2.ZERO.clone();
                    component9.anchorMax = pc.Vec2.ONE.clone();
                    component9.sizeDelta = pc.Vec2.ZERO.clone();
                    var component10 = uiObject8.GetComponent(UnityEngine.RectTransform);
                    component10.anchorMin = new pc.Vec2( 0.0, 0.5 );
                    component10.anchorMax = new pc.Vec2( 0.0, 0.5 );
                    component10.sizeDelta = new pc.Vec2( 20.0, 20.0 );
                    component10.anchoredPosition = new pc.Vec2( 10.0, 0.0 );
                    var component11 = uiObject9.GetComponent(UnityEngine.RectTransform);
                    component11.anchorMin = pc.Vec2.ZERO.clone();
                    component11.anchorMax = pc.Vec2.ONE.clone();
                    component11.offsetMin = new pc.Vec2( 20.0, 1.0 );
                    component11.offsetMax = new pc.Vec2( -10.0, -2.0 );
                    uiObject3.SetActive(false);
                    return uiElementRoot;
                },
                /*UnityEngine.UI.DefaultControls.CreateDropdown:static end.*/

                /*UnityEngine.UI.DefaultControls.CreateScrollView:static start.*/
                CreateScrollView: function (resources) {
if ( TRACE ) { TRACE( "UnityEngine.UI.DefaultControls#CreateScrollView", this ); }

                    var uiElementRoot = UnityEngine.UI.DefaultControls.CreateUIElementRoot("Scroll View", new pc.Vec2( 200.0, 200.0 ));
                    var uiObject1 = UnityEngine.UI.DefaultControls.CreateUIObject("Viewport", uiElementRoot);
                    var uiObject2 = UnityEngine.UI.DefaultControls.CreateUIObject("Content", uiObject1);
                    var scrollbar1 = UnityEngine.UI.DefaultControls.CreateScrollbar(resources.$clone());
                    scrollbar1.name = "Scrollbar Horizontal";
                    UnityEngine.UI.DefaultControls.SetParentAndAlign(scrollbar1, uiElementRoot);
                    var component1 = scrollbar1.GetComponent(UnityEngine.RectTransform);
                    component1.anchorMin = pc.Vec2.ZERO.clone();
                    component1.anchorMax = pc.Vec2.RIGHT.clone();
                    component1.pivot = pc.Vec2.ZERO.clone();
                    component1.sizeDelta = new pc.Vec2( 0.0, component1.sizeDelta.y );
                    var scrollbar2 = UnityEngine.UI.DefaultControls.CreateScrollbar(resources.$clone());
                    scrollbar2.name = "Scrollbar Vertical";
                    UnityEngine.UI.DefaultControls.SetParentAndAlign(scrollbar2, uiElementRoot);
                    scrollbar2.GetComponent(UnityEngine.UI.Scrollbar).SetDirection(UnityEngine.UI.Scrollbar.Direction.BottomToTop, true);
                    var component2 = scrollbar2.GetComponent(UnityEngine.RectTransform);
                    component2.anchorMin = pc.Vec2.RIGHT.clone();
                    component2.anchorMax = pc.Vec2.ONE.clone();
                    component2.pivot = pc.Vec2.ONE.clone();
                    component2.sizeDelta = new pc.Vec2( component2.sizeDelta.x, 0.0 );
                    var component3 = uiObject1.GetComponent(UnityEngine.RectTransform);
                    component3.anchorMin = pc.Vec2.ZERO.clone();
                    component3.anchorMax = pc.Vec2.ONE.clone();
                    component3.sizeDelta = pc.Vec2.ZERO.clone();
                    component3.pivot = pc.Vec2.UP.clone();
                    var component4 = uiObject2.GetComponent(UnityEngine.RectTransform);
                    component4.anchorMin = pc.Vec2.UP.clone();
                    component4.anchorMax = pc.Vec2.ONE.clone();
                    component4.sizeDelta = new pc.Vec2( 0.0, 300.0 );
                    component4.pivot = pc.Vec2.UP.clone();
                    var scrollRect = uiElementRoot.AddComponent(UnityEngine.UI.ScrollRect);
                    scrollRect.content = component4;
                    scrollRect.viewport = component3;
                    scrollRect.horizontalScrollbar = scrollbar1.GetComponent(UnityEngine.UI.Scrollbar);
                    scrollRect.verticalScrollbar = scrollbar2.GetComponent(UnityEngine.UI.Scrollbar);
                    scrollRect.horizontalScrollbarVisibility = UnityEngine.UI.ScrollRect.ScrollbarVisibility.AutoHideAndExpandViewport;
                    scrollRect.verticalScrollbarVisibility = UnityEngine.UI.ScrollRect.ScrollbarVisibility.AutoHideAndExpandViewport;
                    scrollRect.horizontalScrollbarSpacing = -3.0;
                    scrollRect.verticalScrollbarSpacing = -3.0;
                    var image1 = uiElementRoot.AddComponent(UnityEngine.UI.Image);
                    image1.sprite = resources.background;
                    image1.type = UnityEngine.UI.Image.Type.Sliced;
                    image1.color = UnityEngine.UI.DefaultControls.s_PanelColor.$clone();
                    uiObject1.AddComponent(UnityEngine.UI.Mask).showMaskGraphic = false;
                    var image2 = uiObject1.AddComponent(UnityEngine.UI.Image);
                    image2.sprite = resources.mask;
                    image2.type = UnityEngine.UI.Image.Type.Sliced;
                    return uiElementRoot;
                },
                /*UnityEngine.UI.DefaultControls.CreateScrollView:static end.*/


            }
        }
    });
    /*UnityEngine.UI.DefaultControls end.*/

    /*UnityEngine.UI.DefaultControls+Resources start.*/
    Bridge.define("UnityEngine.UI.DefaultControls.Resources", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.DefaultControls.Resources#getDefaultValue", this ); }
 return new UnityEngine.UI.DefaultControls.Resources(); }
            }
        },
        fields: {
            standard: null,
            background: null,
            inputField: null,
            knob: null,
            checkmark: null,
            dropdown: null,
            mask: null
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.DefaultControls.Resources#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.DefaultControls.Resources#getHashCode", this ); }

                var h = Bridge.addHash([3570849850, this.standard, this.background, this.inputField, this.knob, this.checkmark, this.dropdown, this.mask]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "UnityEngine.UI.DefaultControls.Resources#equals", this ); }

                if (!Bridge.is(o, UnityEngine.UI.DefaultControls.Resources)) {
                    return false;
                }
                return Bridge.equals(this.standard, o.standard) && Bridge.equals(this.background, o.background) && Bridge.equals(this.inputField, o.inputField) && Bridge.equals(this.knob, o.knob) && Bridge.equals(this.checkmark, o.checkmark) && Bridge.equals(this.dropdown, o.dropdown) && Bridge.equals(this.mask, o.mask);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "UnityEngine.UI.DefaultControls.Resources#$clone", this ); }

                var s = to || new UnityEngine.UI.DefaultControls.Resources();
                s.standard = this.standard;
                s.background = this.background;
                s.inputField = this.inputField;
                s.knob = this.knob;
                s.checkmark = this.checkmark;
                s.dropdown = this.dropdown;
                s.mask = this.mask;
                return s;
            }
        }
    });
    /*UnityEngine.UI.DefaultControls+Resources end.*/

    /*UnityEngine.UI.Dropdown+DropdownEvent start.*/
    /**
     * UnityEvent callback for when a dropdown current option is changed.
     *
     * @public
     * @class UnityEngine.UI.Dropdown.DropdownEvent
     * @augments UnityEngine.Events.UnityEvent$1
     */
    Bridge.define("UnityEngine.UI.Dropdown.DropdownEvent", {
        inherits: [UnityEngine.Events.UnityEvent$1(System.Int32)],
        $kind: 1002
    });
    /*UnityEngine.UI.Dropdown+DropdownEvent end.*/

    /*UnityEngine.UI.Dropdown+OptionData start.*/
    /**
     * Class to store the text and/or image of a single option in the dropdown list.
     *
     * @public
     * @class UnityEngine.UI.Dropdown.OptionData
     */
    Bridge.define("UnityEngine.UI.Dropdown.OptionData", {
        $kind: 1002,
        fields: {
            m_Text: null,
            m_Image: null
        },
        props: {
            /**
             * The text associated with the option.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Dropdown.OptionData
             * @function text
             * @type string
             */
            text: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown.OptionData#text#get", this ); }

                    return this.m_Text;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown.OptionData#text#set", this ); }

                    this.m_Text = value;
                }
            },
            /**
             * The image associated with the option.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Dropdown.OptionData
             * @function image
             * @type UnityEngine.Sprite
             */
            image: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown.OptionData#image#get", this ); }

                    return this.m_Image;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown.OptionData#image#set", this ); }

                    this.m_Image = value;
                }
            }
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown.OptionData#ctor", this ); }

                this.$initialize();
            },
            $ctor1: function (text) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown.OptionData#$ctor1", this ); }

                this.$initialize();
                this.text = text;
            },
            $ctor3: function (image) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown.OptionData#$ctor3", this ); }

                this.$initialize();
                this.image = image;
            },
            /**
             * Create an object representing a single option for the dropdown list.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Dropdown.OptionData
             * @memberof UnityEngine.UI.Dropdown.OptionData
             * @param   {string}                text     Optional text for the option.
             * @param   {UnityEngine.Sprite}    image    Optional image for the option.
             * @return  {void}
             */
            $ctor2: function (text, image) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown.OptionData#$ctor2", this ); }

                this.$initialize();
                this.text = text;
                this.image = image;
            }
        }
    });
    /*UnityEngine.UI.Dropdown+OptionData end.*/

    /*UnityEngine.UI.Dropdown+OptionDataList start.*/
    /**
     * Class used internally to store the list of options for the dropdown list.
     *
     * @public
     * @class UnityEngine.UI.Dropdown.OptionDataList
     */
    Bridge.define("UnityEngine.UI.Dropdown.OptionDataList", {
        $kind: 1002,
        fields: {
            m_Options: null
        },
        props: {
            /**
             * The list of options for the dropdown list.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Dropdown.OptionDataList
             * @function options
             * @type System.Collections.Generic.List$1
             */
            options: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown.OptionDataList#options#get", this ); }

                    return this.m_Options;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown.OptionDataList#options#set", this ); }

                    this.m_Options = value;
                }
            }
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown.OptionDataList#ctor", this ); }

                this.$initialize();
                this.options = new (System.Collections.Generic.List$1(UnityEngine.UI.Dropdown.OptionData)).ctor();
            }
        }
    });
    /*UnityEngine.UI.Dropdown+OptionDataList end.*/

    /*UnityEngine.UI.FontData start.*/
    /**
     * Font data.
     *
     * @public
     * @class UnityEngine.UI.FontData
     */
    Bridge.define("UnityEngine.UI.FontData", {
        statics: {
            props: {
                /**
                 * Gets the default font data.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof UnityEngine.UI.FontData
                 * @function defaultFontData
                 * @type UnityEngine.UI.FontData
                 */
                defaultFontData: {
                    get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.FontData#defaultFontData#get", this ); }

                        var $t;
                        return ($t = new UnityEngine.UI.FontData(), $t.m_FontSize = 14, $t.m_LineSpacing = 1.0, $t.m_FontStyle = UnityEngine.FontStyle.Normal, $t.m_BestFit = false, $t.m_MinSize = 10, $t.m_MaxSize = 40, $t.m_Alignment = UnityEngine.TextAnchor.UpperLeft, $t.m_HorizontalOverflow = UnityEngine.HorizontalWrapMode.Wrap, $t.m_VerticalOverflow = UnityEngine.VerticalWrapMode.Truncate, $t.m_RichText = true, $t.m_AlignByGeometry = false, $t);
                    }
                }
            }
        },
        fields: {
            m_Font: null,
            m_FontSize: 0,
            m_FontStyle: 0,
            m_BestFit: false,
            m_MinSize: 0,
            m_MaxSize: 0,
            m_Alignment: 0,
            m_AlignByGeometry: false,
            m_RichText: false,
            m_HorizontalOverflow: 0,
            m_VerticalOverflow: 0,
            m_LineSpacing: 0
        },
        props: {
            /**
             * Gets or sets the font.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.FontData
             * @function font
             * @type UnityEngine.Font
             */
            font: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.FontData#font#get", this ); }

                    return this.m_Font;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.FontData#font#set", this ); }

                    this.m_Font = value;
                }
            },
            /**
             * Gets or sets the size of the font.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.FontData
             * @function fontSize
             * @type number
             */
            fontSize: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.FontData#fontSize#get", this ); }

                    return this.m_FontSize;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.FontData#fontSize#set", this ); }

                    this.m_FontSize = value;
                }
            },
            /**
             * Font Style.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.FontData
             * @function fontStyle
             * @type UnityEngine.FontStyle
             */
            fontStyle: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.FontData#fontStyle#get", this ); }

                    return this.m_FontStyle;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.FontData#fontStyle#set", this ); }

                    this.m_FontStyle = value;
                }
            },
            /**
             * Gets or sets a value indicating whether best fit is used for this {@link }.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.FontData
             * @function bestFit
             * @type boolean
             */
            bestFit: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.FontData#bestFit#get", this ); }

                    return this.m_BestFit;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.FontData#bestFit#set", this ); }

                    this.m_BestFit = value;
                }
            },
            /**
             * Gets or sets minimum text size.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.FontData
             * @function minSize
             * @type number
             */
            minSize: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.FontData#minSize#get", this ); }

                    return this.m_MinSize;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.FontData#minSize#set", this ); }

                    this.m_MinSize = value;
                }
            },
            /**
             * Gets or sets maximum text size.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.FontData
             * @function maxSize
             * @type number
             */
            maxSize: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.FontData#maxSize#get", this ); }

                    return this.m_MaxSize;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.FontData#maxSize#set", this ); }

                    this.m_MaxSize = value;
                }
            },
            /**
             * Gets or sets the alignment, how is the text aligned.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.FontData
             * @function alignment
             * @type UnityEngine.TextAnchor
             */
            alignment: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.FontData#alignment#get", this ); }

                    return this.m_Alignment;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.FontData#alignment#set", this ); }

                    this.m_Alignment = value;
                }
            },
            /**
             * Gets or sets a value indicating whether this {@link } align by geometry.
             Use the extents of glyph geometry to perform horizontal alignment rather than glyph metrics.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.FontData
             * @function alignByGeometry
             * @type boolean
             */
            alignByGeometry: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.FontData#alignByGeometry#get", this ); }

                    return this.m_AlignByGeometry;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.FontData#alignByGeometry#set", this ); }

                    this.m_AlignByGeometry = value;
                }
            },
            /**
             * Should RichText be used?
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.FontData
             * @function richText
             * @type boolean
             */
            richText: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.FontData#richText#get", this ); }

                    return this.m_RichText;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.FontData#richText#set", this ); }

                    this.m_RichText = value;
                }
            },
            /**
             * Horizontal overflow mode.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.FontData
             * @function horizontalOverflow
             * @type UnityEngine.HorizontalWrapMode
             */
            horizontalOverflow: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.FontData#horizontalOverflow#get", this ); }

                    return this.m_HorizontalOverflow;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.FontData#horizontalOverflow#set", this ); }

                    this.m_HorizontalOverflow = value;
                }
            },
            /**
             * Vertical overflow mode.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.FontData
             * @function verticalOverflow
             * @type UnityEngine.VerticalWrapMode
             */
            verticalOverflow: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.FontData#verticalOverflow#get", this ); }

                    return this.m_VerticalOverflow;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.FontData#verticalOverflow#set", this ); }

                    this.m_VerticalOverflow = value;
                }
            },
            /**
             * Gets or sets the line spacing.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.FontData
             * @function lineSpacing
             * @type number
             */
            lineSpacing: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.FontData#lineSpacing#get", this ); }

                    return this.m_LineSpacing;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.FontData#lineSpacing#set", this ); }

                    this.m_LineSpacing = value;
                }
            }
        }
    });
    /*UnityEngine.UI.FontData end.*/

    /*UnityEngine.UI.ICanvasElement start.*/
    /**
     * This is an element that can live on a Canvas.
     *
     * @abstract
     * @public
     * @class UnityEngine.UI.ICanvasElement
     */
    Bridge.define("UnityEngine.UI.ICanvasElement", {
        $kind: 3
    });
    /*UnityEngine.UI.ICanvasElement end.*/

    /*UnityEngine.UI.GraphicRaycaster+BlockingObjects start.*/
    /**
     * Type of raycasters to check against to check for canvas blocking elements.
     *
     * @public
     * @class number
     */
    Bridge.define("UnityEngine.UI.GraphicRaycaster.BlockingObjects", {
        $kind: 1006,
        statics: {
            fields: {
                /**
                 * Perform no raycasts.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                None: 0,
                /**
                 * Perform a 2D raycast check to check for blocking 2D elements
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                TwoD: 1,
                /**
                 * Perform a 3D raycast check to check for blocking 3D elements
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                ThreeD: 2,
                /**
                 * Perform a 2D and a 3D raycasts to check for blocking 2D and 3D elements.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 3
                 * @type number
                 */
                All: 3
            }
        }
    });
    /*UnityEngine.UI.GraphicRaycaster+BlockingObjects end.*/

    /*UnityEngine.UI.GraphicRegistry start.*/
    Bridge.define("UnityEngine.UI.GraphicRegistry", {
        statics: {
            fields: {
                /**
                 * Empty result to help with memory allocations.
                 *
                 * @static
                 * @private
                 * @readonly
                 * @memberof UnityEngine.UI.GraphicRegistry
                 * @type System.Collections.Generic.List$1
                 */
                s_EmptyList: null,
                /**
                 * Singleton accessor.
                 *
                 * @static
                 * @public
                 * @memberof UnityEngine.UI.GraphicRegistry
                 * @function instance
                 * @type UnityEngine.UI.GraphicRegistry
                 */
                instance: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.GraphicRegistry#init", this ); }

                    this.s_EmptyList = new (System.Collections.Generic.List$1(UnityEngine.UI.Graphic)).ctor();
                    this.instance = new UnityEngine.UI.GraphicRegistry();
                }
            },
            methods: {
                /*UnityEngine.UI.GraphicRegistry.RegisterGraphicForCanvas:static start.*/
                /**
                 * Registers graphics instance as belonging to a specific canvas instance.
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.GraphicRegistry
                 * @memberof UnityEngine.UI.GraphicRegistry
                 * @param   {UnityEngine.Canvas}        canvas     
                 * @param   {UnityEngine.UI.Graphic}    graphic
                 * @return  {void}
                 */
                RegisterGraphicForCanvas: function (canvas, graphic) {
if ( TRACE ) { TRACE( "UnityEngine.UI.GraphicRegistry#RegisterGraphicForCanvas", this ); }

                    if (UnityEngine.Component.op_Inequality(canvas, null)) {
                        var set = { v : null };
                        UnityEngine.UI.GraphicRegistry.instance.m_Graphics.tryGetValue(canvas, set);

                        if (set.v != null) {
                            set.v.add(graphic);
                        } else {
                            set.v = new Set();
                            set.v.add(graphic);

                            UnityEngine.UI.GraphicRegistry.instance.m_Graphics.add(canvas, set.v);
                        }
                    }
                },
                /*UnityEngine.UI.GraphicRegistry.RegisterGraphicForCanvas:static end.*/

                /*UnityEngine.UI.GraphicRegistry.UnregisterGraphicForCanvas:static start.*/
                /**
                 * De-registers the graphics from all collections.
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.GraphicRegistry
                 * @memberof UnityEngine.UI.GraphicRegistry
                 * @param   {UnityEngine.Canvas}        canvas     
                 * @param   {UnityEngine.UI.Graphic}    graphic
                 * @return  {void}
                 */
                UnregisterGraphicForCanvas: function (canvas, graphic) {
if ( TRACE ) { TRACE( "UnityEngine.UI.GraphicRegistry#UnregisterGraphicForCanvas", this ); }

                    var set = { v : null };

                    if (UnityEngine.Component.op_Inequality(canvas, null) && UnityEngine.UI.GraphicRegistry.instance.m_Graphics.tryGetValue(canvas, set)) {
                        set.v.delete(graphic);

                        if (set.v.size === 0) {
                            UnityEngine.UI.GraphicRegistry.instance.m_Graphics.remove(canvas);
                        }
                    }
                },
                /*UnityEngine.UI.GraphicRegistry.UnregisterGraphicForCanvas:static end.*/

                /*UnityEngine.UI.GraphicRegistry.GetGraphicsForCanvas:static start.*/
                /**
                 * Public-facing version of GetGraphicsForCanvasInternal that returns Graphics instances registered
                 for a specific canvas.
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.GraphicRegistry
                 * @memberof UnityEngine.UI.GraphicRegistry
                 * @param   {UnityEngine.Canvas}                    canvas
                 * @return  {System.Collections.Generic.IList$1}
                 */
                GetGraphicsForCanvas: function (canvas) {
if ( TRACE ) { TRACE( "UnityEngine.UI.GraphicRegistry#GetGraphicsForCanvas", this ); }

                    var $t;
                    var result = { v : null };

                    if (UnityEngine.UI.GraphicRegistry.instance.m_Graphics.tryGetValue(canvas, result)) {
                        return ($t = UnityEngine.UI.Graphic, System.Linq.Enumerable.from(Array.from( result.v ), $t).toList($t));
                    }

                    return UnityEngine.UI.GraphicRegistry.s_EmptyList;
                },
                /*UnityEngine.UI.GraphicRegistry.GetGraphicsForCanvas:static end.*/

                /*UnityEngine.UI.GraphicRegistry.GetGraphicsForCanvasInternal:static start.*/
                /**
                 * Returns an internal data structure with graphics instances.
                 *
                 * @static
                 * @this UnityEngine.UI.GraphicRegistry
                 * @memberof UnityEngine.UI.GraphicRegistry
                 * @param   {UnityEngine.Canvas}    canvas
                 * @return  {Set}
                 */
                GetGraphicsForCanvasInternal: function (canvas) {
if ( TRACE ) { TRACE( "UnityEngine.UI.GraphicRegistry#GetGraphicsForCanvasInternal", this ); }

                    var result = { v : null };

                    if (canvas.enabled && UnityEngine.UI.GraphicRegistry.instance.m_Graphics.tryGetValue(canvas, result)) {
                        return result.v;
                    }

                    return null;
                },
                /*UnityEngine.UI.GraphicRegistry.GetGraphicsForCanvasInternal:static end.*/

                /*UnityEngine.UI.GraphicRegistry.UnregisterGraphicsEverywhere:static start.*/
                /**
                 * Unregister graphics for cases when canvas already removed
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.GraphicRegistry
                 * @memberof UnityEngine.UI.GraphicRegistry
                 * @param   {UnityEngine.UI.Graphic}    graphic
                 * @return  {void}
                 */
                UnregisterGraphicsEverywhere: function (graphic) {
if ( TRACE ) { TRACE( "UnityEngine.UI.GraphicRegistry#UnregisterGraphicsEverywhere", this ); }

                    var $t;
                    if (UnityEngine.MonoBehaviour.op_Equality(graphic, null)) {
                        return;
                    }

                    $t = Bridge.getEnumerator(UnityEngine.UI.GraphicRegistry.instance.m_Graphics.Values);
                    try {
                        while ($t.moveNext()) {
                            var graphicsSet = $t.Current;
                            graphicsSet.delete(graphic);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                },
                /*UnityEngine.UI.GraphicRegistry.UnregisterGraphicsEverywhere:static end.*/


            }
        },
        fields: {
            /**
             * Internal storage of per-canvas graphics instances.
             *
             * @instance
             * @private
             * @readonly
             * @memberof UnityEngine.UI.GraphicRegistry
             * @type System.Collections.Generic.Dictionary$2
             */
            m_Graphics: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.GraphicRegistry#init", this ); }

                this.m_Graphics = new (System.Collections.Generic.Dictionary$2(UnityEngine.Canvas,Set)).ctor();
            },
            /**
             * Initializes the registry.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.GraphicRegistry
             * @memberof UnityEngine.UI.GraphicRegistry
             * @return  {void}
             */
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.GraphicRegistry#ctor", this ); }

                this.$initialize();
            }
        }
    });
    /*UnityEngine.UI.GraphicRegistry end.*/

    /*UnityEngine.UI.ILayoutElement start.*/
    /**
     * A component is treated as a layout element by the auto layout system if it implements ILayoutElement.
     *
     * @abstract
     * @public
     * @class UnityEngine.UI.ILayoutElement
     */
    Bridge.define("UnityEngine.UI.ILayoutElement", {
        $kind: 3
    });
    /*UnityEngine.UI.ILayoutElement end.*/

    /*UnityEngine.UI.GridLayoutGroup+Axis start.*/
    Bridge.define("UnityEngine.UI.GridLayoutGroup.Axis", {
        $kind: 1006,
        statics: {
            fields: {
                Horizontal: 0,
                Vertical: 1
            }
        }
    });
    /*UnityEngine.UI.GridLayoutGroup+Axis end.*/

    /*UnityEngine.UI.GridLayoutGroup+Constraint start.*/
    Bridge.define("UnityEngine.UI.GridLayoutGroup.Constraint", {
        $kind: 1006,
        statics: {
            fields: {
                Flexible: 0,
                FixedColumnCount: 1,
                FixedRowCount: 2
            }
        }
    });
    /*UnityEngine.UI.GridLayoutGroup+Constraint end.*/

    /*UnityEngine.UI.GridLayoutGroup+Corner start.*/
    Bridge.define("UnityEngine.UI.GridLayoutGroup.Corner", {
        $kind: 1006,
        statics: {
            fields: {
                UpperLeft: 0,
                UpperRight: 1,
                LowerLeft: 2,
                LowerRight: 3
            }
        }
    });
    /*UnityEngine.UI.GridLayoutGroup+Corner end.*/

    /*UnityEngine.UI.IClippable start.*/
    Bridge.define("UnityEngine.UI.IClippable", {
        $kind: 3
    });
    /*UnityEngine.UI.IClippable end.*/

    /*UnityEngine.UI.IClipper start.*/
    Bridge.define("UnityEngine.UI.IClipper", {
        $kind: 3
    });
    /*UnityEngine.UI.IClipper end.*/

    /*UnityEngine.UI.ILayoutIgnorer start.*/
    /**
     * A RectTransform will be ignored by the layout system if it has a component which implements ILayoutIgnorer.
     *
     * @abstract
     * @public
     * @class UnityEngine.UI.ILayoutIgnorer
     */
    Bridge.define("UnityEngine.UI.ILayoutIgnorer", {
        $kind: 3
    });
    /*UnityEngine.UI.ILayoutIgnorer end.*/

    /*UnityEngine.UI.IMaterialModifier start.*/
    Bridge.define("UnityEngine.UI.IMaterialModifier", {
        $kind: 3
    });
    /*UnityEngine.UI.IMaterialModifier end.*/

    /*UnityEngine.UI.IMaskable start.*/
    Bridge.define("UnityEngine.UI.IMaskable", {
        $kind: 3
    });
    /*UnityEngine.UI.IMaskable end.*/

    /*UnityEngine.UI.Image+FillMethod start.*/
    /**
     * Fill method.
     *
     * @public
     * @class number
     */
    Bridge.define("UnityEngine.UI.Image.FillMethod", {
        $kind: 1006,
        statics: {
            fields: {
                Horizontal: 0,
                Vertical: 1,
                Radial90: 2,
                Radial180: 3,
                Radial360: 4
            }
        }
    });
    /*UnityEngine.UI.Image+FillMethod end.*/

    /*UnityEngine.UI.Image+Type start.*/
    /**
     * Type.
     *
     * @public
     * @class number
     */
    Bridge.define("UnityEngine.UI.Image.Type", {
        $kind: 1006,
        statics: {
            fields: {
                Simple: 0,
                Sliced: 1,
                Tiled: 2,
                Filled: 3
            }
        }
    });
    /*UnityEngine.UI.Image+Type end.*/

    /*UnityEngine.UI.InputField+CharacterValidation start.*/
    /**
     * The type of characters that are allowed to be added to the string.
     *
     * @public
     * @class number
     */
    Bridge.define("UnityEngine.UI.InputField.CharacterValidation", {
        $kind: 1006,
        statics: {
            fields: {
                /**
                 * No validation. Any input is valid.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                None: 0,
                /**
                 * Allow whole numbers (positive or negative).
                 Characters 0-9 and - (dash / minus sign) are allowed. The dash is only allowed as the first character.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                Integer: 1,
                /**
                 * Allows decimal numbers (positive or negative).
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                Decimal: 2,
                /**
                 * Allows letters A-Z, a-z and numbers 0-9.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 3
                 * @type number
                 */
                Alphanumeric: 3,
                /**
                 * Only allow names and enforces capitalization.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 4
                 * @type number
                 */
                Name: 4,
                /**
                 * Allows the characters that are allowed in an email address.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 5
                 * @type number
                 */
                EmailAddress: 5
            }
        }
    });
    /*UnityEngine.UI.InputField+CharacterValidation end.*/

    /*UnityEngine.UI.InputField+ContentType start.*/
    /**
     * Setting the content type acts as a shortcut for setting a combination of InputType, CharacterValidation, LineType, and TouchScreenKeyboardType
     *
     * @public
     * @class number
     */
    Bridge.define("UnityEngine.UI.InputField.ContentType", {
        $kind: 1006,
        statics: {
            fields: {
                /**
                 * Allows all input.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                Standard: 0,
                /**
                 * Allows all input and performs auto-correction on platforms that support it.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                Autocorrected: 1,
                /**
                 * Allow whole numbers (positive or negative).
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                IntegerNumber: 2,
                /**
                 * Allows decimal numbers (positive or negative).
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 3
                 * @type number
                 */
                DecimalNumber: 3,
                /**
                 * Allows letters A-Z, a-z and numbers 0-9.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 4
                 * @type number
                 */
                Alphanumeric: 4,
                /**
                 * The InputField is used for typing in a name, and enforces capitalization of the first letter of each word. Note that the user can circumvent the first letter capitalization rules by deleting automatically-capitalized letters.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 5
                 * @type number
                 */
                Name: 5,
                /**
                 * The input is used for typing in an email address.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 6
                 * @type number
                 */
                EmailAddress: 6,
                /**
                 * Allows all input and hides the typed characters by showing them as asterisks characters.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 7
                 * @type number
                 */
                Password: 7,
                /**
                 * Allows integer numbers and hides the typed characters by showing them as asterisks characters.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 8
                 * @type number
                 */
                Pin: 8,
                /**
                 * Custom types that allows user-defined settings.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 9
                 * @type number
                 */
                Custom: 9
            }
        }
    });
    /*UnityEngine.UI.InputField+ContentType end.*/

    /*UnityEngine.UI.InputField+EditState start.*/
    Bridge.define("UnityEngine.UI.InputField.EditState", {
        $kind: 1006,
        statics: {
            fields: {
                Continue: 0,
                Finish: 1
            }
        }
    });
    /*UnityEngine.UI.InputField+EditState end.*/

    /*UnityEngine.UI.InputField+InputType start.*/
    /**
     * Type of data expected by the input field mobile keyboard.
     *
     * @public
     * @class number
     */
    Bridge.define("UnityEngine.UI.InputField.InputType", {
        $kind: 1006,
        statics: {
            fields: {
                /**
                 * The standard mobile keyboard
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                Standard: 0,
                /**
                 * The mobile autocorrect keyboard.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                AutoCorrect: 1,
                /**
                 * The mobile password keyboard.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                Password: 2
            }
        }
    });
    /*UnityEngine.UI.InputField+InputType end.*/

    /*UnityEngine.UI.InputField+LineType start.*/
    /**
     * The LineType is used to describe the behavior of the InputField.
     *
     * @public
     * @class number
     */
    Bridge.define("UnityEngine.UI.InputField.LineType", {
        $kind: 1006,
        statics: {
            fields: {
                /**
                 * Only allows 1 line to be entered. Has horizontal scrolling and no word wrap. Pressing enter will submit the InputField.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                SingleLine: 0,
                /**
                 * Is a multiline InputField with vertical scrolling and overflow. Pressing the return key will submit.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                MultiLineSubmit: 1,
                /**
                 * Is a multiline InputField with vertical scrolling and overflow. Pressing the return key will insert a new line character.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                MultiLineNewline: 2
            }
        }
    });
    /*UnityEngine.UI.InputField+LineType end.*/

    /*UnityEngine.UI.InputField+OnChangeEvent start.*/
    /**
     * The callback sent anytime the Inputfield is updated.
     *
     * @public
     * @class UnityEngine.UI.InputField.OnChangeEvent
     * @augments UnityEngine.Events.UnityEvent$1
     */
    Bridge.define("UnityEngine.UI.InputField.OnChangeEvent", {
        inherits: [UnityEngine.Events.UnityEvent$1(System.String)],
        $kind: 1002
    });
    /*UnityEngine.UI.InputField+OnChangeEvent end.*/

    /*UnityEngine.UI.InputField+SubmitEvent start.*/
    /**
     * Unity Event with a inputfield as a param.
     *
     * @public
     * @class UnityEngine.UI.InputField.SubmitEvent
     * @augments UnityEngine.Events.UnityEvent$1
     */
    Bridge.define("UnityEngine.UI.InputField.SubmitEvent", {
        inherits: [UnityEngine.Events.UnityEvent$1(System.String)],
        $kind: 1002
    });
    /*UnityEngine.UI.InputField+SubmitEvent end.*/
    /** @namespace System */

    /**
     * @memberof System
     * @callback System.Func
     * @param   {UnityEngine.UI.ILayoutElement}    arg
     * @return  {number}
     */


    /*UnityEngine.UI.LayoutUtility start.*/
    Bridge.define("UnityEngine.UI.LayoutUtility", {
        statics: {
            methods: {
                /*UnityEngine.UI.LayoutUtility.GetMinSize:static start.*/
                /**
                 * Gets the minimum size.
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.LayoutUtility
                 * @memberof UnityEngine.UI.LayoutUtility
                 * @param   {UnityEngine.RectTransform}    rect    Rect.
                 * @param   {number}                       axis    Axis.
                 * @return  {number}                               The minimum size.
                 */
                GetMinSize: function (rect, axis) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutUtility#GetMinSize", this ); }

                    if (rect.handle._layoutElements.length === 0) {
                        return 0;
                    }

                    var layoutElement = rect.handle._layoutElements[0];
                    if (rect.handle._layoutElements.length === 1) {
                        var result = axis === 0 ? layoutElement.UnityEngine$UI$ILayoutElement$minWidth : layoutElement.UnityEngine$UI$ILayoutElement$minHeight;
                        return UnityEngine.Mathf.Max(result, 0);
                    }

                    if (axis === 0) {
                        return UnityEngine.UI.LayoutUtility.GetMinWidth(rect);
                    }

                    return UnityEngine.UI.LayoutUtility.GetMinHeight(rect);
                },
                /*UnityEngine.UI.LayoutUtility.GetMinSize:static end.*/

                /*UnityEngine.UI.LayoutUtility.GetPreferredSize:static start.*/
                /**
                 * Gets the size of the preferred.
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.LayoutUtility
                 * @memberof UnityEngine.UI.LayoutUtility
                 * @param   {UnityEngine.RectTransform}    rect    Rect.
                 * @param   {number}                       axis    Axis.
                 * @return  {number}                               The preferred size.
                 */
                GetPreferredSize: function (rect, axis) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutUtility#GetPreferredSize", this ); }

                    var $t;
                    if (rect.handle._layoutElements.length === 0) {
                        return 0;
                    }

                    if (rect.handle._layoutElements.length === 1 && rect.handle._layoutElements[0].enabled) {
                        var layoutElement = Bridge.as(($t = rect.handle._layoutElements)[0], UnityEngine.UI.ILayoutElement);
                        var result = axis === 0 ? UnityEngine.Mathf.Max(layoutElement.UnityEngine$UI$ILayoutElement$preferredWidth, layoutElement.UnityEngine$UI$ILayoutElement$minWidth) : UnityEngine.Mathf.Max(layoutElement.UnityEngine$UI$ILayoutElement$preferredHeight, layoutElement.UnityEngine$UI$ILayoutElement$minHeight);
                        return UnityEngine.Mathf.Max(result, 0);
                    }

                    if (axis === 0) {
                        return UnityEngine.UI.LayoutUtility.GetPreferredWidth(rect);
                    }

                    return UnityEngine.UI.LayoutUtility.GetPreferredHeight(rect);
                },
                /*UnityEngine.UI.LayoutUtility.GetPreferredSize:static end.*/

                /*UnityEngine.UI.LayoutUtility.GetFlexibleSize:static start.*/
                /**
                 * Gets the size of the flexible.
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.LayoutUtility
                 * @memberof UnityEngine.UI.LayoutUtility
                 * @param   {UnityEngine.RectTransform}    rect    Rect.
                 * @param   {number}                       axis    Axis.
                 * @return  {number}                               The flexible size.
                 */
                GetFlexibleSize: function (rect, axis) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutUtility#GetFlexibleSize", this ); }

                    if (rect.handle._layoutElements.length === 0) {
                        return 0;
                    }

                    var layoutElement = rect.handle._layoutElements[0];
                    if (rect.handle._layoutElements.length === 1) {
                        var result = axis === 0 ? layoutElement.UnityEngine$UI$ILayoutElement$flexibleWidth : layoutElement.UnityEngine$UI$ILayoutElement$flexibleHeight;
                        return UnityEngine.Mathf.Max(result, 0);
                    }

                    if (axis === 0) {
                        return UnityEngine.UI.LayoutUtility.GetFlexibleWidth(rect);
                    }

                    return UnityEngine.UI.LayoutUtility.GetFlexibleHeight(rect);
                },
                /*UnityEngine.UI.LayoutUtility.GetFlexibleSize:static end.*/

                /*UnityEngine.UI.LayoutUtility.GetMinWidth:static start.*/
                /**
                 * Gets the minimum width.
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.LayoutUtility
                 * @memberof UnityEngine.UI.LayoutUtility
                 * @param   {UnityEngine.RectTransform}    rect    Rect.
                 * @return  {number}                               The minimum width.
                 */
                GetMinWidth: function (rect) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutUtility#GetMinWidth", this ); }

                    return UnityEngine.UI.LayoutUtility.GetLayoutProperty(rect, function (e) {
                        return e.UnityEngine$UI$ILayoutElement$minWidth;
                    }, 0);
                },
                /*UnityEngine.UI.LayoutUtility.GetMinWidth:static end.*/

                /*UnityEngine.UI.LayoutUtility.GetPreferredWidth:static start.*/
                /**
                 * Gets the width of the preferred.
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.LayoutUtility
                 * @memberof UnityEngine.UI.LayoutUtility
                 * @param   {UnityEngine.RectTransform}    rect    Rect.
                 * @return  {number}                               The preferred width.
                 */
                GetPreferredWidth: function (rect) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutUtility#GetPreferredWidth", this ); }

                    return UnityEngine.Mathf.Max(UnityEngine.UI.LayoutUtility.GetLayoutProperty(rect, function (e) {
                        return e.UnityEngine$UI$ILayoutElement$minWidth;
                    }, 0), UnityEngine.UI.LayoutUtility.GetLayoutProperty(rect, function (e) {
                        return e.UnityEngine$UI$ILayoutElement$preferredWidth;
                    }, 0));
                },
                /*UnityEngine.UI.LayoutUtility.GetPreferredWidth:static end.*/

                /*UnityEngine.UI.LayoutUtility.GetFlexibleWidth:static start.*/
                /**
                 * Gets the width of the flexible.
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.LayoutUtility
                 * @memberof UnityEngine.UI.LayoutUtility
                 * @param   {UnityEngine.RectTransform}    rect    Rect.
                 * @return  {number}                               The flexible width.
                 */
                GetFlexibleWidth: function (rect) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutUtility#GetFlexibleWidth", this ); }

                    return UnityEngine.UI.LayoutUtility.GetLayoutProperty(rect, function (e) {
                        return e.UnityEngine$UI$ILayoutElement$flexibleWidth;
                    }, 0);
                },
                /*UnityEngine.UI.LayoutUtility.GetFlexibleWidth:static end.*/

                /*UnityEngine.UI.LayoutUtility.GetMinHeight:static start.*/
                /**
                 * Gets the minimum height.
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.LayoutUtility
                 * @memberof UnityEngine.UI.LayoutUtility
                 * @param   {UnityEngine.RectTransform}    rect    Rect.
                 * @return  {number}                               The minimum height.
                 */
                GetMinHeight: function (rect) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutUtility#GetMinHeight", this ); }

                    return UnityEngine.UI.LayoutUtility.GetLayoutProperty(rect, function (e) {
                        return e.UnityEngine$UI$ILayoutElement$minHeight;
                    }, 0);
                },
                /*UnityEngine.UI.LayoutUtility.GetMinHeight:static end.*/

                /*UnityEngine.UI.LayoutUtility.GetPreferredHeight:static start.*/
                /**
                 * Gets the height of the preferred.
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.LayoutUtility
                 * @memberof UnityEngine.UI.LayoutUtility
                 * @param   {UnityEngine.RectTransform}    rect    Rect.
                 * @return  {number}                               The preferred height.
                 */
                GetPreferredHeight: function (rect) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutUtility#GetPreferredHeight", this ); }

                    return UnityEngine.Mathf.Max(UnityEngine.UI.LayoutUtility.GetLayoutProperty(rect, function (e) {
                        return e.UnityEngine$UI$ILayoutElement$minHeight;
                    }, 0), UnityEngine.UI.LayoutUtility.GetLayoutProperty(rect, function (e) {
                        return e.UnityEngine$UI$ILayoutElement$preferredHeight;
                    }, 0));
                },
                /*UnityEngine.UI.LayoutUtility.GetPreferredHeight:static end.*/

                /*UnityEngine.UI.LayoutUtility.GetFlexibleHeight:static start.*/
                /**
                 * Gets the height of the flexible.
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.LayoutUtility
                 * @memberof UnityEngine.UI.LayoutUtility
                 * @param   {UnityEngine.RectTransform}    rect    Rect.
                 * @return  {number}                               The flexible height.
                 */
                GetFlexibleHeight: function (rect) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutUtility#GetFlexibleHeight", this ); }

                    return UnityEngine.UI.LayoutUtility.GetLayoutProperty(rect, function (e) {
                        return e.UnityEngine$UI$ILayoutElement$flexibleHeight;
                    }, 0);
                },
                /*UnityEngine.UI.LayoutUtility.GetFlexibleHeight:static end.*/

                /*UnityEngine.UI.LayoutUtility.GetLayoutProperty:static start.*/
                /**
                 * Gets the layout property.
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.LayoutUtility
                 * @memberof UnityEngine.UI.LayoutUtility
                 * @param   {UnityEngine.RectTransform}    rect            Rect.
                 * @param   {System.Func}                  property        Property.
                 * @param   {number}                       defaultValue    Default value.
                 * @return  {number}                                       The layout property.
                 */
                GetLayoutProperty: function (rect, property, defaultValue) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutUtility#GetLayoutProperty", this ); }

                    var dummy = { };
                    return UnityEngine.UI.LayoutUtility.GetLayoutProperty$1(rect, property, defaultValue, dummy);
                },
                /*UnityEngine.UI.LayoutUtility.GetLayoutProperty:static end.*/

                /*UnityEngine.UI.LayoutUtility.GetLayoutProperty$1:static start.*/
                /**
                 * Gets the layout property.
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.LayoutUtility
                 * @memberof UnityEngine.UI.LayoutUtility
                 * @param   {UnityEngine.RectTransform}        rect            Rect.
                 * @param   {System.Func}                      property        Property.
                 * @param   {number}                           defaultValue    Default value.
                 * @param   {UnityEngine.UI.ILayoutElement}    source          Source.
                 * @return  {number}                                           The layout property.
                 */
                GetLayoutProperty$1: function (rect, property, defaultValue, source) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutUtility#GetLayoutProperty$1", this ); }

                    source.v = null;

                    if (UnityEngine.Component.op_Equality(rect, null)) {
                        return 0;
                    }

                    var min = defaultValue;
                    var maxPriority = -2147483648;
                    var components = rect.handle._layoutElements;

                    for (var i = 0; i < components.length; i++) {
                        var layoutComp = components[i];

                        if (!layoutComp.handle.enabled) {
                            continue;
                        }

                        var priority = layoutComp.UnityEngine$UI$ILayoutElement$layoutPriority;

                        // If this layout components has lower priority than a previously used, ignore it.
                        if (priority < maxPriority) {
                            continue;
                        }

                        var prop = property(layoutComp);

                        // If this layout property is set to a negative value, it means it should be ignored.
                        if (prop < 0) {
                            continue;
                        }

                        // If this layout component has higher priority than all previous ones,
                        // overwrite with this one's value.
                        if (priority > maxPriority) {
                            min = prop;
                            maxPriority = priority;
                            source.v = layoutComp;
                        } else if (prop > min) {
                            min = prop;
                            source.v = layoutComp;
                        }
                    }

                    return min;
                },
                /*UnityEngine.UI.LayoutUtility.GetLayoutProperty$1:static end.*/


            }
        }
    });
    /*UnityEngine.UI.LayoutUtility end.*/

    /*UnityEngine.UI.ListPool$1 start.*/
    Bridge.define("UnityEngine.UI.ListPool$1", function (T) { return {
        statics: {
            fields: {
                s_ListPool: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ListPool$1#init", this ); }

                    this.s_ListPool = new (UnityEngine.UI.ObjectPool$1(System.Collections.Generic.List$1(T)))(null, UnityEngine.UI.ListPool$1(T).Clear);
                }
            },
            methods: {
                /*UnityEngine.UI.ListPool$1.Clear:static start.*/
                Clear: function (l) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ListPool$1#Clear", this ); }

                    l.clear();
                },
                /*UnityEngine.UI.ListPool$1.Clear:static end.*/

                /*UnityEngine.UI.ListPool$1.Get:static start.*/
                Get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ListPool$1#Get", this ); }

                    return UnityEngine.UI.ListPool$1(T).s_ListPool.Get();
                },
                /*UnityEngine.UI.ListPool$1.Get:static end.*/

                /*UnityEngine.UI.ListPool$1.Release:static start.*/
                Release: function (toRelease) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ListPool$1#Release", this ); }

                    UnityEngine.UI.ListPool$1(T).s_ListPool.Release(toRelease);
                },
                /*UnityEngine.UI.ListPool$1.Release:static end.*/


            }
        }
    }; });
    /*UnityEngine.UI.ListPool$1 end.*/

    /*UnityEngine.UI.MaskableGraphic+CullStateChangedEvent start.*/
    Bridge.define("UnityEngine.UI.MaskableGraphic.CullStateChangedEvent", {
        inherits: [UnityEngine.Events.UnityEvent$1(System.Boolean)],
        $kind: 1002
    });
    /*UnityEngine.UI.MaskableGraphic+CullStateChangedEvent end.*/

    /*UnityEngine.UI.MaskUtilities start.*/
    /**
     * Mask related utility class. This class provides masking-specific utility functions.
     *
     * @public
     * @class UnityEngine.UI.MaskUtilities
     */
    Bridge.define("UnityEngine.UI.MaskUtilities", {
        statics: {
            methods: {
                /*UnityEngine.UI.MaskUtilities.Notify2DMaskStateChanged:static start.*/
                /**
                 * Notify all IClippables under the given component that they need to recalculate clipping.
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.MaskUtilities
                 * @memberof UnityEngine.UI.MaskUtilities
                 * @param   {UnityEngine.Component}    mask    The object thats changed for whose children should be notified.
                 * @return  {void}
                 */
                Notify2DMaskStateChanged: function (mask) {
if ( TRACE ) { TRACE( "UnityEngine.UI.MaskUtilities#Notify2DMaskStateChanged", this ); }

                    var components = UnityEngine.UI.ListPool$1(UnityEngine.Component).Get();
                    mask.GetComponentsInChildren$3(UnityEngine.Component, components);
                    for (var i = 0; i < components.Count; i++) {
                        if (UnityEngine.Component.op_Equality(components.getItem(i), null) || UnityEngine.GameObject.op_Equality(components.getItem(i).gameObject, mask.gameObject)) {
                            continue;
                        }

                        var toNotify = Bridge.as(components.getItem(i), UnityEngine.UI.IClippable);
                        if (toNotify != null) {
                            toNotify.UnityEngine$UI$IClippable$RecalculateClipping();
                        }
                    }

                    UnityEngine.UI.ListPool$1(UnityEngine.Component).Release(components);
                },
                /*UnityEngine.UI.MaskUtilities.Notify2DMaskStateChanged:static end.*/

                /*UnityEngine.UI.MaskUtilities.NotifyStencilStateChanged:static start.*/
                /**
                 * Notify all IMaskable under the given component that they need to recalculate masking.
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.MaskUtilities
                 * @memberof UnityEngine.UI.MaskUtilities
                 * @param   {UnityEngine.Component}    mask    The object thats changed for whose children should be notified.
                 * @return  {void}
                 */
                NotifyStencilStateChanged: function (mask) {
if ( TRACE ) { TRACE( "UnityEngine.UI.MaskUtilities#NotifyStencilStateChanged", this ); }

                    var components = UnityEngine.UI.ListPool$1(UnityEngine.Component).Get();
                    mask.GetComponentsInChildren$3(UnityEngine.Component, components);
                    for (var i = 0; i < components.Count; i++) {
                        if (UnityEngine.Component.op_Equality(components.getItem(i), null) || UnityEngine.GameObject.op_Equality(components.getItem(i).gameObject, mask.gameObject)) {
                            continue;
                        }

                        var toNotify = Bridge.as(components.getItem(i), UnityEngine.UI.IMaskable);
                        if (toNotify != null) {
                            toNotify.UnityEngine$UI$IMaskable$RecalculateMasking();
                        }
                    }

                    UnityEngine.UI.ListPool$1(UnityEngine.Component).Release(components);
                },
                /*UnityEngine.UI.MaskUtilities.NotifyStencilStateChanged:static end.*/

                /*UnityEngine.UI.MaskUtilities.FindRootSortOverrideCanvas:static start.*/
                /**
                 * Find a root Canvas.
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.MaskUtilities
                 * @memberof UnityEngine.UI.MaskUtilities
                 * @param   {UnityEngine.Transform}    start    Transform to start the search at going up the hierarchy.
                 * @return  {UnityEngine.Transform}             Finds either the most root canvas, or the first canvas that overrides sorting.
                 */
                FindRootSortOverrideCanvas: function (start) {
if ( TRACE ) { TRACE( "UnityEngine.UI.MaskUtilities#FindRootSortOverrideCanvas", this ); }

                    var canvasList = UnityEngine.UI.ListPool$1(UnityEngine.Canvas).Get();
                    start.GetComponentsInParent$2(UnityEngine.Canvas, false, canvasList);
                    var canvas = null;

                    for (var i = 0; i < canvasList.Count; ++i) {
                        canvas = canvasList.getItem(i);

                        // We found the canvas we want to use break
                        if (canvas.overrideSorting) {
                            break;
                        }
                    }

                    UnityEngine.UI.ListPool$1(UnityEngine.Canvas).Release(canvasList);

                    return UnityEngine.Component.op_Inequality(canvas, null) ? canvas.transform : null;
                },
                /*UnityEngine.UI.MaskUtilities.FindRootSortOverrideCanvas:static end.*/

                /*UnityEngine.UI.MaskUtilities.GetStencilDepth:static start.*/
                /**
                 * Find the stencil depth for a given element.
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.MaskUtilities
                 * @memberof UnityEngine.UI.MaskUtilities
                 * @param   {UnityEngine.Transform}    transform    The starting transform to search.
                 * @param   {UnityEngine.Transform}    stopAfter    Where the search of parents should stop
                 * @return  {number}                                What the proper stencil buffer index should be.
                 */
                GetStencilDepth: function (transform, stopAfter) {
if ( TRACE ) { TRACE( "UnityEngine.UI.MaskUtilities#GetStencilDepth", this ); }

                    var depth = 0;
                    if (UnityEngine.Component.op_Equality(transform, stopAfter)) {
                        return depth;
                    }

                    var t = transform.parent;
                    var components = UnityEngine.UI.ListPool$1(UnityEngine.UI.Mask).Get();
                    while (UnityEngine.Component.op_Inequality(t, null)) {
                        t.GetComponents$2(UnityEngine.UI.Mask, components);
                        for (var i = 0; i < components.Count; ++i) {
                            if (UnityEngine.MonoBehaviour.op_Inequality(components.getItem(i), null) && components.getItem(i).MaskEnabled() && components.getItem(i).graphic.IsActive()) {
                                ++depth;
                                break;
                            }
                        }

                        if (UnityEngine.Component.op_Equality(t, stopAfter)) {
                            break;
                        }

                        t = t.parent;
                    }

                    UnityEngine.UI.ListPool$1(UnityEngine.UI.Mask).Release(components);
                    return depth;
                },
                /*UnityEngine.UI.MaskUtilities.GetStencilDepth:static end.*/

                /*UnityEngine.UI.MaskUtilities.IsDescendantOrSelf:static start.*/
                /**
                 * Helper function to determine if the child is a descendant of father or is father.
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.MaskUtilities
                 * @memberof UnityEngine.UI.MaskUtilities
                 * @param   {UnityEngine.Transform}    father    The transform to compare against.
                 * @param   {UnityEngine.Transform}    child     The starting transform to search up the hierarchy.
                 * @return  {boolean}                            Is child equal to father or is a descendant.
                 */
                IsDescendantOrSelf: function (father, child) {
if ( TRACE ) { TRACE( "UnityEngine.UI.MaskUtilities#IsDescendantOrSelf", this ); }

                    if (UnityEngine.Component.op_Equality(father, null) || UnityEngine.Component.op_Equality(child, null)) {
                        return false;
                    }

                    if (UnityEngine.Component.op_Equality(father, child)) {
                        return true;
                    }

                    while (UnityEngine.Component.op_Inequality(child.parent, null)) {
                        if (UnityEngine.Component.op_Equality(child.parent, father)) {
                            return true;
                        }

                        child = child.parent;
                    }

                    return false;
                },
                /*UnityEngine.UI.MaskUtilities.IsDescendantOrSelf:static end.*/

                /*UnityEngine.UI.MaskUtilities.GetRectMaskForClippable:static start.*/
                /**
                 * Find the correct RectMask2D for a given IClippable.
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.MaskUtilities
                 * @memberof UnityEngine.UI.MaskUtilities
                 * @param   {UnityEngine.UI.IClippable}    clippable    Clippable to search from.
                 * @return  {UnityEngine.UI.RectMask2D}                 The Correct RectMask2D
                 */
                GetRectMaskForClippable: function (clippable) {
if ( TRACE ) { TRACE( "UnityEngine.UI.MaskUtilities#GetRectMaskForClippable", this ); }

                    var rectMaskComponents = UnityEngine.UI.ListPool$1(UnityEngine.UI.RectMask2D).Get();
                    var canvasComponents = UnityEngine.UI.ListPool$1(UnityEngine.Canvas).Get();
                    var componentToReturn = null;

                    clippable.UnityEngine$UI$IClippable$gameObject.GetComponentsInParent$1(UnityEngine.UI.RectMask2D, false, rectMaskComponents);

                    if (rectMaskComponents.Count > 0) {
                        for (var rmi = 0; rmi < rectMaskComponents.Count; rmi++) {
                            componentToReturn = rectMaskComponents.getItem(rmi);
                            if (UnityEngine.GameObject.op_Equality(componentToReturn.gameObject, clippable.UnityEngine$UI$IClippable$gameObject)) {
                                componentToReturn = null;
                                continue;
                            }

                            if (!componentToReturn.isActiveAndEnabled) {
                                componentToReturn = null;
                                continue;
                            }

                            clippable.UnityEngine$UI$IClippable$gameObject.GetComponentsInParent$1(UnityEngine.Canvas, false, canvasComponents);
                            for (var i = canvasComponents.Count - 1; i >= 0; i--) {
                                if (!UnityEngine.UI.MaskUtilities.IsDescendantOrSelf(canvasComponents.getItem(i).transform, componentToReturn.transform) && canvasComponents.getItem(i).overrideSorting) {
                                    componentToReturn = null;
                                    break;
                                }
                            }

                            break;
                        }
                    }

                    UnityEngine.UI.ListPool$1(UnityEngine.UI.RectMask2D).Release(rectMaskComponents);
                    UnityEngine.UI.ListPool$1(UnityEngine.Canvas).Release(canvasComponents);

                    return componentToReturn;
                },
                /*UnityEngine.UI.MaskUtilities.GetRectMaskForClippable:static end.*/

                /*UnityEngine.UI.MaskUtilities.GetRectMasksForClip:static start.*/
                /**
                 * Search for all RectMask2D that apply to the given RectMask2D (includes self).
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.MaskUtilities
                 * @memberof UnityEngine.UI.MaskUtilities
                 * @param   {UnityEngine.UI.RectMask2D}            clipper    Starting clipping object.
                 * @param   {System.Collections.Generic.List$1}    masks      The list of Rect masks
                 * @return  {void}
                 */
                GetRectMasksForClip: function (clipper, masks) {
if ( TRACE ) { TRACE( "UnityEngine.UI.MaskUtilities#GetRectMasksForClip", this ); }

                    masks.clear();

                    var canvasComponents = UnityEngine.UI.ListPool$1(UnityEngine.Canvas).Get();
                    var rectMaskComponents = UnityEngine.UI.ListPool$1(UnityEngine.UI.RectMask2D).Get();
                    clipper.transform.GetComponentsInParent$2(UnityEngine.UI.RectMask2D, false, rectMaskComponents);

                    if (rectMaskComponents.Count > 0) {
                        clipper.transform.GetComponentsInParent$2(UnityEngine.Canvas, false, canvasComponents);
                        for (var i = rectMaskComponents.Count - 1; i >= 0; i--) {
                            if (!rectMaskComponents.getItem(i).IsActive()) {
                                continue;
                            }

                            var shouldAdd = true;
                            for (var j = canvasComponents.Count - 1; j >= 0; j--) {
                                if (!UnityEngine.UI.MaskUtilities.IsDescendantOrSelf(canvasComponents.getItem(j).transform, rectMaskComponents.getItem(i).transform) && canvasComponents.getItem(j).overrideSorting) {
                                    shouldAdd = false;
                                    break;
                                }
                            }

                            if (shouldAdd) {
                                masks.add(rectMaskComponents.getItem(i));
                            }
                        }
                    }

                    UnityEngine.UI.ListPool$1(UnityEngine.UI.RectMask2D).Release(rectMaskComponents);
                    UnityEngine.UI.ListPool$1(UnityEngine.Canvas).Release(canvasComponents);
                },
                /*UnityEngine.UI.MaskUtilities.GetRectMasksForClip:static end.*/


            }
        }
    });
    /*UnityEngine.UI.MaskUtilities end.*/

    /*UnityEngine.UI.Misc start.*/
    Bridge.define("UnityEngine.UI.Misc", {
        statics: {
            methods: {
                /*UnityEngine.UI.Misc.Destroy:static start.*/
                Destroy: function (obj) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Misc#Destroy", this ); }

                    if (!(!Bridge.referenceEquals(obj, null))) {
                        return;
                    }

                    if (UnityEngine.Application.isPlaying) {
                        if (Bridge.is(obj, UnityEngine.GameObject)) {
                            (Bridge.as(obj, UnityEngine.GameObject)).transform.parent = null;
                        }

                        UnityEngine.Object.Destroy(obj);
                    } else {
                        UnityEngine.Object.DestroyImmediate(obj);
                    }
                },
                /*UnityEngine.UI.Misc.Destroy:static end.*/

                /*UnityEngine.UI.Misc.DestroyImmediate:static start.*/
                DestroyImmediate: function (obj) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Misc#DestroyImmediate", this ); }

                    if (!(!Bridge.referenceEquals(obj, null))) {
                        return;
                    }

                    if (UnityEngine.Application.isEditor) {
                        UnityEngine.Object.DestroyImmediate(obj);
                    } else {
                        UnityEngine.Object.Destroy(obj);
                    }
                },
                /*UnityEngine.UI.Misc.DestroyImmediate:static end.*/


            }
        }
    });
    /*UnityEngine.UI.Misc end.*/

    /*UnityEngine.UI.Navigation start.*/
    Bridge.define("UnityEngine.UI.Navigation", {
        inherits: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Navigation#inherits", this ); }
 return [System.IEquatable$1(UnityEngine.UI.Navigation)]; },
        $kind: 4,
        statics: {
            props: {
                defaultNavigation: {
                    get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Navigation#defaultNavigation#get", this ); }

                        var result = Bridge.getDefaultValue(UnityEngine.UI.Navigation);
                        result.m_Mode = UnityEngine.UI.Navigation.Mode.Automatic;
                        return result.$clone();
                    }
                }
            },
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Navigation#getDefaultValue", this ); }
 return new UnityEngine.UI.Navigation(); }
            }
        },
        fields: {
            m_Mode: 0,
            m_SelectOnUp: null,
            m_SelectOnDown: null,
            m_SelectOnLeft: null,
            m_SelectOnRight: null
        },
        props: {
            mode: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Navigation#mode#get", this ); }

                    return this.m_Mode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Navigation#mode#set", this ); }

                    this.m_Mode = value;
                }
            },
            selectOnUp: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Navigation#selectOnUp#get", this ); }

                    return this.m_SelectOnUp;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Navigation#selectOnUp#set", this ); }

                    this.m_SelectOnUp = value;
                }
            },
            selectOnDown: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Navigation#selectOnDown#get", this ); }

                    return this.m_SelectOnDown;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Navigation#selectOnDown#set", this ); }

                    this.m_SelectOnDown = value;
                }
            },
            selectOnLeft: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Navigation#selectOnLeft#get", this ); }

                    return this.m_SelectOnLeft;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Navigation#selectOnLeft#set", this ); }

                    this.m_SelectOnLeft = value;
                }
            },
            selectOnRight: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Navigation#selectOnRight#get", this ); }

                    return this.m_SelectOnRight;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Navigation#selectOnRight#set", this ); }

                    this.m_SelectOnRight = value;
                }
            }
        },
        alias: ["equalsT", "System$IEquatable$1$UnityEngine$UI$Navigation$equalsT"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Navigation#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*UnityEngine.UI.Navigation.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Navigation#equalsT", this ); }

                return this.mode === other.mode && Bridge.referenceEquals(Bridge.cast(this.selectOnUp, UnityEngine.Object), Bridge.cast(other.selectOnUp, UnityEngine.Object)) && Bridge.referenceEquals(Bridge.cast(this.selectOnDown, UnityEngine.Object), Bridge.cast(other.selectOnDown, UnityEngine.Object)) && Bridge.referenceEquals(Bridge.cast(this.selectOnLeft, UnityEngine.Object), Bridge.cast(other.selectOnLeft, UnityEngine.Object)) && Bridge.referenceEquals(Bridge.cast(this.selectOnRight, UnityEngine.Object), Bridge.cast(other.selectOnRight, UnityEngine.Object));
            },
            /*UnityEngine.UI.Navigation.equalsT end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Navigation#getHashCode", this ); }

                var h = Bridge.addHash([3538628900, this.m_Mode, this.m_SelectOnUp, this.m_SelectOnDown, this.m_SelectOnLeft, this.m_SelectOnRight]);
                return h;
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Navigation#$clone", this ); }

                var s = to || new UnityEngine.UI.Navigation();
                s.m_Mode = this.m_Mode;
                s.m_SelectOnUp = this.m_SelectOnUp;
                s.m_SelectOnDown = this.m_SelectOnDown;
                s.m_SelectOnLeft = this.m_SelectOnLeft;
                s.m_SelectOnRight = this.m_SelectOnRight;
                return s;
            }
        },
        overloads: {
            "Equals(Navigation)": "equalsT"
        }
    });
    /*UnityEngine.UI.Navigation end.*/

    /*UnityEngine.UI.Navigation+Mode start.*/
    Bridge.define("UnityEngine.UI.Navigation.Mode", {
        $kind: 1006,
        statics: {
            fields: {
                None: 0,
                Horizontal: 1,
                Vertical: 2,
                Automatic: 3,
                Explicit: 4
            }
        },
        $flags: true
    });
    /*UnityEngine.UI.Navigation+Mode end.*/

    /*UnityEngine.UI.ObjectPool$1 start.*/
    Bridge.define("UnityEngine.UI.ObjectPool$1", function (T) { return {
        fields: {
            m_Stack: null,
            m_ActionOnGet: null,
            m_ActionOnRelease: null,
            countAll: 0
        },
        props: {
            countActive: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ObjectPool$1#countActive#get", this ); }

                    return this.countAll - this.countInactive;
                }
            },
            countInactive: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ObjectPool$1#countInactive#get", this ); }

                    return this.m_Stack.Count;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ObjectPool$1#init", this ); }

                this.m_Stack = new (System.Collections.Generic.Stack$1(T)).ctor();
            },
            ctor: function (actionOnGet, actionOnRelease) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ObjectPool$1#ctor", this ); }

                this.$initialize();
                this.m_ActionOnGet = actionOnGet;
                this.m_ActionOnRelease = actionOnRelease;
            }
        },
        methods: {
            /*UnityEngine.UI.ObjectPool$1.Get start.*/
            Get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ObjectPool$1#Get", this ); }

                var element;
                if (this.m_Stack.Count === 0) {
                    element = Bridge.createInstance(T);
                    this.countAll++;
                } else {
                    element = Bridge.rValue(this.m_Stack.Pop());
                }

                if (!Bridge.staticEquals(this.m_ActionOnGet, null)) {
                    this.m_ActionOnGet(Bridge.rValue(element));
                }

                return Bridge.rValue(element);
            },
            /*UnityEngine.UI.ObjectPool$1.Get end.*/

            /*UnityEngine.UI.ObjectPool$1.Release start.*/
            Release: function (element) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ObjectPool$1#Release", this ); }

                if (this.m_Stack.Count > 0 && Bridge.referenceEquals(Bridge.rValue(this.m_Stack.Peek()), Bridge.rValue(element))) {
                    UnityEngine.Debug.LogError$2("Internal error. Trying to destroy object that is already released to pool.");
                }

                if (!Bridge.staticEquals(this.m_ActionOnRelease, null)) {
                    this.m_ActionOnRelease(Bridge.rValue(element));
                }

                this.m_Stack.Push(Bridge.rValue(element));
            },
            /*UnityEngine.UI.ObjectPool$1.Release end.*/


        }
    }; });
    /*UnityEngine.UI.ObjectPool$1 end.*/

    /*UnityEngine.UI.RectangularVertexClipper start.*/
    Bridge.define("UnityEngine.UI.RectangularVertexClipper", {
        fields: {
            m_WorldCorners: null,
            m_CanvasCorners: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.RectangularVertexClipper#init", this ); }

                this.m_WorldCorners = System.Array.init(4, function (){
                    return new UnityEngine.Vector3();
                }, UnityEngine.Vector3);
                this.m_CanvasCorners = System.Array.init(4, function (){
                    return new UnityEngine.Vector3();
                }, UnityEngine.Vector3);
            }
        },
        methods: {
            /*UnityEngine.UI.RectangularVertexClipper.GetCanvasRect start.*/
            GetCanvasRect: function (t, c) {
if ( TRACE ) { TRACE( "UnityEngine.UI.RectangularVertexClipper#GetCanvasRect", this ); }

                if (UnityEngine.Component.op_Equality(c, null)) {
                    return new UnityEngine.Rect.ctor();
                }

                t.GetWorldCorners(this.m_WorldCorners);
                var canvasTransform = c.GetComponent(UnityEngine.Transform);
                for (var i = 0; i < 4; ++i) {
                    this.m_CanvasCorners[i] = canvasTransform.InverseTransformPoint(this.m_WorldCorners[i]);
                }

                return new UnityEngine.Rect.$ctor1(this.m_CanvasCorners[0].x, this.m_CanvasCorners[0].y, this.m_CanvasCorners[2].x - this.m_CanvasCorners[0].x, this.m_CanvasCorners[2].y - this.m_CanvasCorners[0].y);
            },
            /*UnityEngine.UI.RectangularVertexClipper.GetCanvasRect end.*/


        }
    });
    /*UnityEngine.UI.RectangularVertexClipper end.*/

    /*UnityEngine.UI.ReflectionMethodsCache start.*/
    Bridge.define("UnityEngine.UI.ReflectionMethodsCache", {
        statics: {
            fields: {
                s_ReflectionMethodsCache: null
            },
            props: {
                Singleton: {
                    get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ReflectionMethodsCache#Singleton#get", this ); }

                        if (UnityEngine.UI.ReflectionMethodsCache.s_ReflectionMethodsCache == null) {
                            UnityEngine.UI.ReflectionMethodsCache.s_ReflectionMethodsCache = new UnityEngine.UI.ReflectionMethodsCache();
                        }

                        return UnityEngine.UI.ReflectionMethodsCache.s_ReflectionMethodsCache;
                    }
                }
            }
        },
        fields: {
            raycast3D: null,
            raycast3DAll: null,
            raycast2D: null,
            getRayIntersectionAll: null,
            getRayIntersectionAllNonAlloc: null,
            getRaycastNonAlloc: null
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ReflectionMethodsCache#ctor", this ); }

                this.$initialize();
                // See task EN-750
                /* var raycast3DMethodInfo = typeof( Physics ).GetMethod( "Raycast",
                   new[] { typeof( Ray ), typeof( RaycastHit ).MakeByRefType(), typeof( float ), typeof( int ) } );
                if ( raycast3DMethodInfo != null )
                   raycast3D = ( Raycast3DCallback ) Delegate.CreateDelegate( typeof( Raycast3DCallback ),
                       raycast3DMethodInfo );*/

                var raycast2DMethodInfo = Bridge.Reflection.getMembers(UnityEngine.Physics2D, 8, 284, "Raycast", System.Array.init([UnityEngine.Vector2, UnityEngine.Vector2, System.Single, System.Int32], System.Type));
                if (raycast2DMethodInfo != null) {
                    this.raycast2D = Bridge.Reflection.createDelegate(raycast2DMethodInfo);
                }

                var raycastAllMethodInfo = Bridge.Reflection.getMembers(UnityEngine.Physics, 8, 284, "RaycastAll", System.Array.init([UnityEngine.Ray, System.Single, System.Int32], System.Type));
                if (raycastAllMethodInfo != null) {
                    this.raycast3DAll = Bridge.Reflection.createDelegate(raycastAllMethodInfo);
                }

                var getRayIntersectionAllMethodInfo = Bridge.Reflection.getMembers(UnityEngine.Physics2D, 8, 284, "GetRayIntersectionAll", System.Array.init([UnityEngine.Ray, System.Single, System.Int32], System.Type));
                if (getRayIntersectionAllMethodInfo != null) {
                    this.getRayIntersectionAll = Bridge.Reflection.createDelegate(getRayIntersectionAllMethodInfo);
                }

                var getRayIntersectionAllNonAllocMethodInfo = Bridge.Reflection.getMembers(UnityEngine.Physics2D, 8, 284, "GetRayIntersectionNonAlloc", System.Array.init([UnityEngine.Ray, System.Array.type(UnityEngine.RaycastHit2D), System.Single, System.Int32], System.Type));
                if (getRayIntersectionAllNonAllocMethodInfo != null) {
                    this.getRayIntersectionAllNonAlloc = Bridge.Reflection.createDelegate(getRayIntersectionAllNonAllocMethodInfo);
                }

                var getRaycastAllNonAllocMethodInfo = Bridge.Reflection.getMembers(UnityEngine.Physics, 8, 284, "RaycastNonAlloc", System.Array.init([UnityEngine.Ray, System.Array.type(UnityEngine.RaycastHit), System.Single, System.Int32], System.Type));
                if (getRaycastAllNonAllocMethodInfo != null) {
                    this.getRaycastNonAlloc = Bridge.Reflection.createDelegate(getRaycastAllNonAllocMethodInfo);
                }
            }
        }
    });
    /*UnityEngine.UI.ReflectionMethodsCache end.*/

    /*UnityEngine.UI.Scrollbar+Axis start.*/
    Bridge.define("UnityEngine.UI.Scrollbar.Axis", {
        $kind: 1006,
        statics: {
            fields: {
                Horizontal: 0,
                Vertical: 1
            }
        }
    });
    /*UnityEngine.UI.Scrollbar+Axis end.*/

    /*UnityEngine.UI.Scrollbar+Direction start.*/
    /**
     * Setting that indicates one of four directions the scrollbar will travel.
     *
     * @public
     * @class number
     */
    Bridge.define("UnityEngine.UI.Scrollbar.Direction", {
        $kind: 1006,
        statics: {
            fields: {
                /**
                 * Starting position is the Left.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                LeftToRight: 0,
                /**
                 * Starting position is the Right
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                RightToLeft: 1,
                /**
                 * Starting position is the Bottom.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                BottomToTop: 2,
                /**
                 * Starting position is the Top.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 3
                 * @type number
                 */
                TopToBottom: 3
            }
        }
    });
    /*UnityEngine.UI.Scrollbar+Direction end.*/

    /*UnityEngine.UI.Scrollbar+ScrollEvent start.*/
    /**
     * UnityEvent callback for when a scrollbar is scrolled.
     *
     * @public
     * @class UnityEngine.UI.Scrollbar.ScrollEvent
     * @augments UnityEngine.Events.UnityEvent$1
     */
    Bridge.define("UnityEngine.UI.Scrollbar.ScrollEvent", {
        inherits: [UnityEngine.Events.UnityEvent$1(System.Single)],
        $kind: 1002
    });
    /*UnityEngine.UI.Scrollbar+ScrollEvent end.*/

    /*UnityEngine.UI.ScrollRect+MovementType start.*/
    /**
     * A setting for which behavior to use when content moves beyond the confines of its container.
     *
     * @public
     * @class number
     */
    Bridge.define("UnityEngine.UI.ScrollRect.MovementType", {
        $kind: 1006,
        statics: {
            fields: {
                /**
                 * Unrestricted movement. The content can move forever.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                Unrestricted: 0,
                /**
                 * Elastic movement. The content is allowed to temporarily move beyond the container, but is pulled back elastically.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                Elastic: 1,
                /**
                 * Clamped movement. The content can not be moved beyond its container.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                Clamped: 2
            }
        }
    });
    /*UnityEngine.UI.ScrollRect+MovementType end.*/

    /*UnityEngine.UI.ScrollRect+ScrollbarVisibility start.*/
    /**
     * Enum for which behavior to use for scrollbar visibility.
     *
     * @public
     * @class number
     */
    Bridge.define("UnityEngine.UI.ScrollRect.ScrollbarVisibility", {
        $kind: 1006,
        statics: {
            fields: {
                /**
                 * Always show the scrollbar.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                Permanent: 0,
                /**
                 * Automatically hide the scrollbar when no scrolling is needed on this axis. The viewport rect will not be changed.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                AutoHide: 1,
                /**
                 * Automatically hide the scrollbar when no scrolling is needed on this axis, and expand the viewport rect accordingly.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                AutoHideAndExpandViewport: 2
            }
        }
    });
    /*UnityEngine.UI.ScrollRect+ScrollbarVisibility end.*/

    /*UnityEngine.UI.ScrollRect+ScrollRectEvent start.*/
    /**
     * Event type used by the ScrollRect.
     *
     * @public
     * @class UnityEngine.UI.ScrollRect.ScrollRectEvent
     * @augments UnityEngine.Events.UnityEvent$1
     */
    Bridge.define("UnityEngine.UI.ScrollRect.ScrollRectEvent", {
        inherits: [UnityEngine.Events.UnityEvent$1(UnityEngine.Vector2)],
        $kind: 1002
    });
    /*UnityEngine.UI.ScrollRect+ScrollRectEvent end.*/

    /*UnityEngine.UI.Selectable+SelectionState start.*/
    /**
     * An enumeration of selected states of objects
     *
     * @protected
     * @class number
     */
    Bridge.define("UnityEngine.UI.Selectable.SelectionState", {
        $kind: 1006,
        statics: {
            fields: {
                /**
                 * The UI object can be selected.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                Normal: 0,
                /**
                 * The UI object is highlighted.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                Highlighted: 1,
                /**
                 * The UI object is pressed.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                Pressed: 2,
                /**
                 * The UI object is selected
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 3
                 * @type number
                 */
                Selected: 3,
                /**
                 * The UI object cannot be selected.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 4
                 * @type number
                 */
                Disabled: 4
            }
        }
    });
    /*UnityEngine.UI.Selectable+SelectionState end.*/

    /*UnityEngine.UI.Selectable+Transition start.*/
    /**
     * Transition mode for a Selectable.
     *
     * @public
     * @class number
     */
    Bridge.define("UnityEngine.UI.Selectable.Transition", {
        $kind: 1006,
        statics: {
            fields: {
                /**
                 * No Transition.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                None: 0,
                /**
                 * Use an color tint transition.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                ColorTint: 1,
                /**
                 * Use a sprite swap transition.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                SpriteSwap: 2,
                /**
                 * Use an animation transition.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 3
                 * @type number
                 */
                Animation: 3
            }
        }
    });
    /*UnityEngine.UI.Selectable+Transition end.*/

    /*UnityEngine.UI.SetPropertyUtility start.*/
    Bridge.define("UnityEngine.UI.SetPropertyUtility", {
        statics: {
            methods: {
                /*UnityEngine.UI.SetPropertyUtility.SetColor:static start.*/
                SetColor: function (currentValue, newValue) {
if ( TRACE ) { TRACE( "UnityEngine.UI.SetPropertyUtility#SetColor", this ); }

                    if (currentValue.v.r === newValue.r && currentValue.v.g === newValue.g && currentValue.v.b === newValue.b && currentValue.v.a === newValue.a) {
                        return false;
                    }

                    currentValue.v = newValue.$clone();
                    return true;
                },
                /*UnityEngine.UI.SetPropertyUtility.SetColor:static end.*/

                /*UnityEngine.UI.SetPropertyUtility.SetStruct:static start.*/
                SetStruct: function (T, currentValue, newValue) {
if ( TRACE ) { TRACE( "UnityEngine.UI.SetPropertyUtility#SetStruct", this ); }

                    if (System.Collections.Generic.EqualityComparer$1(T).def.equals2(Bridge.rValue(currentValue.v), Bridge.rValue(newValue))) {
                        return false;
                    }

                    currentValue.v = Bridge.rValue(newValue);
                    return true;
                },
                /*UnityEngine.UI.SetPropertyUtility.SetStruct:static end.*/

                /*UnityEngine.UI.SetPropertyUtility.SetClass:static start.*/
                SetClass: function (T, currentValue, newValue) {
if ( TRACE ) { TRACE( "UnityEngine.UI.SetPropertyUtility#SetClass", this ); }

                    if (Bridge.rValue(currentValue.v) == null && Bridge.rValue(newValue) == null || Bridge.rValue(currentValue.v) != null && Bridge.equals(Bridge.rValue(currentValue.v), Bridge.rValue(newValue))) {
                        return false;
                    }

                    currentValue.v = Bridge.rValue(newValue);
                    return true;
                },
                /*UnityEngine.UI.SetPropertyUtility.SetClass:static end.*/


            }
        }
    });
    /*UnityEngine.UI.SetPropertyUtility end.*/

    /*UnityEngine.UI.Slider+Axis start.*/
    Bridge.define("UnityEngine.UI.Slider.Axis", {
        $kind: 1006,
        statics: {
            fields: {
                Horizontal: 0,
                Vertical: 1
            }
        }
    });
    /*UnityEngine.UI.Slider+Axis end.*/

    /*UnityEngine.UI.Slider+Direction start.*/
    /**
     * Setting that indicates one of four directions.
     *
     * @public
     * @class number
     */
    Bridge.define("UnityEngine.UI.Slider.Direction", {
        $kind: 1006,
        statics: {
            fields: {
                /**
                 * From the left to the right
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                LeftToRight: 0,
                /**
                 * From the right to the left
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                RightToLeft: 1,
                /**
                 * From the bottom to the top.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                BottomToTop: 2,
                /**
                 * From the top to the bottom.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 3
                 * @type number
                 */
                TopToBottom: 3
            }
        }
    });
    /*UnityEngine.UI.Slider+Direction end.*/

    /*UnityEngine.UI.Slider+SliderEvent start.*/
    /**
     * Event type used by the UI.Slider.
     *
     * @public
     * @class UnityEngine.UI.Slider.SliderEvent
     * @augments UnityEngine.Events.UnityEvent$1
     */
    Bridge.define("UnityEngine.UI.Slider.SliderEvent", {
        inherits: [UnityEngine.Events.UnityEvent$1(System.Single)],
        $kind: 1002
    });
    /*UnityEngine.UI.Slider+SliderEvent end.*/

    /*UnityEngine.UI.SpriteState start.*/
    /**
     * Structure to store the state of a sprite transition on a Selectable.
     *
     * @public
     * @class UnityEngine.UI.SpriteState
     * @implements  System.IEquatable$1
     */
    Bridge.define("UnityEngine.UI.SpriteState", {
        inherits: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.SpriteState#inherits", this ); }
 return [System.IEquatable$1(UnityEngine.UI.SpriteState)]; },
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.SpriteState#getDefaultValue", this ); }
 return new UnityEngine.UI.SpriteState(); }
            }
        },
        fields: {
            m_HighlightedSprite: null,
            m_PressedSprite: null,
            m_SelectedSprite: null,
            m_DisabledSprite: null
        },
        props: {
            /**
             * Highlighted sprite.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.SpriteState
             * @function highlightedSprite
             * @type UnityEngine.Sprite
             */
            highlightedSprite: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.SpriteState#highlightedSprite#get", this ); }

                    return this.m_HighlightedSprite;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.SpriteState#highlightedSprite#set", this ); }

                    this.m_HighlightedSprite = value;
                }
            },
            /**
             * Pressed sprite.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.SpriteState
             * @function pressedSprite
             * @type UnityEngine.Sprite
             */
            pressedSprite: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.SpriteState#pressedSprite#get", this ); }

                    return this.m_PressedSprite;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.SpriteState#pressedSprite#set", this ); }

                    this.m_PressedSprite = value;
                }
            },
            /**
             * Selected sprite.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.SpriteState
             * @function selectedSprite
             * @type UnityEngine.Sprite
             */
            selectedSprite: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.SpriteState#selectedSprite#get", this ); }

                    return this.m_SelectedSprite;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.SpriteState#selectedSprite#set", this ); }

                    this.m_SelectedSprite = value;
                }
            },
            /**
             * Disabled sprite.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.SpriteState
             * @function disabledSprite
             * @type UnityEngine.Sprite
             */
            disabledSprite: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.SpriteState#disabledSprite#get", this ); }

                    return this.m_DisabledSprite;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.SpriteState#disabledSprite#set", this ); }

                    this.m_DisabledSprite = value;
                }
            }
        },
        alias: ["equalsT", "System$IEquatable$1$UnityEngine$UI$SpriteState$equalsT"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.SpriteState#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*UnityEngine.UI.SpriteState.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "UnityEngine.UI.SpriteState#equalsT", this ); }

                return Bridge.referenceEquals(this.highlightedSprite, other.highlightedSprite) && Bridge.referenceEquals(this.pressedSprite, other.pressedSprite) && Bridge.referenceEquals(this.selectedSprite, other.selectedSprite) && Bridge.referenceEquals(this.disabledSprite, other.disabledSprite);
            },
            /*UnityEngine.UI.SpriteState.equalsT end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.SpriteState#getHashCode", this ); }

                var h = Bridge.addHash([3727378984, this.m_HighlightedSprite, this.m_PressedSprite, this.m_SelectedSprite, this.m_DisabledSprite]);
                return h;
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "UnityEngine.UI.SpriteState#$clone", this ); }

                var s = to || new UnityEngine.UI.SpriteState();
                s.m_HighlightedSprite = this.m_HighlightedSprite;
                s.m_PressedSprite = this.m_PressedSprite;
                s.m_SelectedSprite = this.m_SelectedSprite;
                s.m_DisabledSprite = this.m_DisabledSprite;
                return s;
            }
        },
        overloads: {
            "Equals(SpriteState)": "equalsT"
        }
    });
    /*UnityEngine.UI.SpriteState end.*/

    /*UnityEngine.UI.StencilMaterial start.*/
    /**
     * Dynamic material class makes it possible to create custom materials on the fly on a per-Graphic basis,
     and still have them get cleaned up correctly.
     *
     * @static
     * @abstract
     * @public
     * @class UnityEngine.UI.StencilMaterial
     */
    Bridge.define("UnityEngine.UI.StencilMaterial", {
        statics: {
            fields: {
                m_List: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.StencilMaterial#init", this ); }

                    this.m_List = new (System.Collections.Generic.List$1(UnityEngine.UI.StencilMaterial.MatEntry)).ctor();
                }
            },
            methods: {
                /*UnityEngine.UI.StencilMaterial.Add:static start.*/
                Add: function (baseMat, stencilID) {
if ( TRACE ) { TRACE( "UnityEngine.UI.StencilMaterial#Add", this ); }

                    return null;
                },
                /*UnityEngine.UI.StencilMaterial.Add:static end.*/

                /*UnityEngine.UI.StencilMaterial.Add$1:static start.*/
                /**
                 * Add a new material using the specified base and stencil ID.
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.StencilMaterial
                 * @memberof UnityEngine.UI.StencilMaterial
                 * @param   {UnityEngine.Material}                     baseMat            
                 * @param   {number}                                   stencilID          
                 * @param   {UnityEngine.Rendering.StencilOp}          operation          
                 * @param   {UnityEngine.Rendering.CompareFunction}    compareFunction    
                 * @param   {UnityEngine.Rendering.ColorWriteMask}     colorWriteMask
                 * @return  {UnityEngine.Material}
                 */
                Add$1: function (baseMat, stencilID, operation, compareFunction, colorWriteMask) {
if ( TRACE ) { TRACE( "UnityEngine.UI.StencilMaterial#Add$1", this ); }

                    return UnityEngine.UI.StencilMaterial.Add$2(baseMat, stencilID, operation, compareFunction, colorWriteMask, 255, 255);
                },
                /*UnityEngine.UI.StencilMaterial.Add$1:static end.*/

                /*UnityEngine.UI.StencilMaterial.Add$2:static start.*/
                /**
                 * Add a new material using the specified base and stencil ID.
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.StencilMaterial
                 * @memberof UnityEngine.UI.StencilMaterial
                 * @param   {UnityEngine.Material}                     baseMat            
                 * @param   {number}                                   stencilID          
                 * @param   {UnityEngine.Rendering.StencilOp}          operation          
                 * @param   {UnityEngine.Rendering.CompareFunction}    compareFunction    
                 * @param   {UnityEngine.Rendering.ColorWriteMask}     colorWriteMask     
                 * @param   {number}                                   readMask           
                 * @param   {number}                                   writeMask
                 * @return  {UnityEngine.Material}
                 */
                Add$2: function (baseMat, stencilID, operation, compareFunction, colorWriteMask, readMask, writeMask) {
if ( TRACE ) { TRACE( "UnityEngine.UI.StencilMaterial#Add$2", this ); }

                    if (stencilID <= 0 && colorWriteMask === UnityEngine.Rendering.ColorWriteMask.All || baseMat == null) {
                        return baseMat;
                    }

                    if (!baseMat.HasProperty$1("_Stencil")) {
                        UnityEngine.Debug.LogWarning$1("Material " + (baseMat.name || "") + " doesn't have _Stencil property", baseMat);
                        return baseMat;
                    }

                    if (!baseMat.HasProperty$1("_StencilOp")) {
                        UnityEngine.Debug.LogWarning$1("Material " + (baseMat.name || "") + " doesn't have _StencilOp property", baseMat);
                        return baseMat;
                    }

                    if (!baseMat.HasProperty$1("_StencilComp")) {
                        UnityEngine.Debug.LogWarning$1("Material " + (baseMat.name || "") + " doesn't have _StencilComp property", baseMat);
                        return baseMat;
                    }

                    if (!baseMat.HasProperty$1("_StencilReadMask")) {
                        UnityEngine.Debug.LogWarning$1("Material " + (baseMat.name || "") + " doesn't have _StencilReadMask property", baseMat);
                        return baseMat;
                    }

                    if (!baseMat.HasProperty$1("_StencilWriteMask")) {
                        UnityEngine.Debug.LogWarning$1("Material " + (baseMat.name || "") + " doesn't have _StencilWriteMask property", baseMat);
                        return baseMat;
                    }

                    if (!baseMat.HasProperty$1("_ColorMask")) {
                        UnityEngine.Debug.LogWarning$1("Material " + (baseMat.name || "") + " doesn't have _ColorMask property", baseMat);
                        return baseMat;
                    }

                    for (var i = 0; i < UnityEngine.UI.StencilMaterial.m_List.Count; ++i) {
                        var ent = UnityEngine.UI.StencilMaterial.m_List.getItem(i);

                        if (Bridge.referenceEquals(ent.baseMat, baseMat) && ent.stencilId === stencilID && ent.operation === operation && ent.compareFunction === compareFunction && ent.readMask === readMask && ent.writeMask === writeMask && ent.colorMask === colorWriteMask) {
                            ++ent.count;
                            return ent.customMat;
                        }
                    }

                    var newEnt = new UnityEngine.UI.StencilMaterial.MatEntry();
                    newEnt.count = 1;
                    newEnt.baseMat = baseMat;
                    newEnt.customMat = new UnityEngine.Material.$ctor1(baseMat);
                    newEnt.customMat.hideFlags = UnityEngine.HideFlags.HideAndDontSave;
                    newEnt.stencilId = stencilID;
                    newEnt.operation = operation;
                    newEnt.compareFunction = compareFunction;
                    newEnt.readMask = readMask;
                    newEnt.writeMask = writeMask;
                    newEnt.colorMask = colorWriteMask;
                    newEnt.useAlphaClip = operation !== UnityEngine.Rendering.StencilOp.Keep && writeMask > 0;

                    newEnt.customMat.name = System.String.format("Stencil Id:{0}, Op:{1}, Comp:{2}, WriteMask:{3}, ReadMask:{4}, ColorMask:{5} AlphaClip:{6} ({7})", stencilID, operation, compareFunction, writeMask, readMask, colorWriteMask, newEnt.useAlphaClip, baseMat.name);

                    newEnt.customMat.SetInt$1("_Stencil", stencilID);
                    newEnt.customMat.SetInt$1("_StencilOp", operation);
                    newEnt.customMat.SetInt$1("_StencilComp", compareFunction);
                    newEnt.customMat.SetInt$1("_StencilReadMask", readMask);
                    newEnt.customMat.SetInt$1("_StencilWriteMask", writeMask);
                    newEnt.customMat.SetInt$1("_ColorMask", colorWriteMask);
                    newEnt.customMat.SetInt$1("_UseUIAlphaClip", newEnt.useAlphaClip ? 1 : 0);

                    if (newEnt.useAlphaClip) {
                        newEnt.customMat.EnableKeyword("UNITY_UI_ALPHACLIP");
                    } else {
                        newEnt.customMat.DisableKeyword("UNITY_UI_ALPHACLIP");
                    }

                    UnityEngine.UI.StencilMaterial.m_List.add(newEnt);
                    return newEnt.customMat;
                },
                /*UnityEngine.UI.StencilMaterial.Add$2:static end.*/

                /*UnityEngine.UI.StencilMaterial.Remove:static start.*/
                /**
                 * Remove an existing material, automatically cleaning it up if it's no longer in use.
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.StencilMaterial
                 * @memberof UnityEngine.UI.StencilMaterial
                 * @param   {UnityEngine.Material}    customMat
                 * @return  {void}
                 */
                Remove: function (customMat) {
if ( TRACE ) { TRACE( "UnityEngine.UI.StencilMaterial#Remove", this ); }

                    if (customMat == null) {
                        return;
                    }

                    for (var i = 0; i < UnityEngine.UI.StencilMaterial.m_List.Count; ++i) {
                        var ent = UnityEngine.UI.StencilMaterial.m_List.getItem(i);

                        if (!Bridge.referenceEquals(ent.customMat, customMat)) {
                            continue;
                        }

                        if (--ent.count === 0) {
                            UnityEngine.UI.Misc.DestroyImmediate(ent.customMat);
                            ent.baseMat = null;
                            UnityEngine.UI.StencilMaterial.m_List.removeAt(i);
                        }

                        return;
                    }
                },
                /*UnityEngine.UI.StencilMaterial.Remove:static end.*/

                /*UnityEngine.UI.StencilMaterial.ClearAll:static start.*/
                ClearAll: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.StencilMaterial#ClearAll", this ); }

                    for (var i = 0; i < UnityEngine.UI.StencilMaterial.m_List.Count; ++i) {
                        var ent = UnityEngine.UI.StencilMaterial.m_List.getItem(i);

                        UnityEngine.UI.Misc.DestroyImmediate(ent.customMat);
                        ent.baseMat = null;
                    }

                    UnityEngine.UI.StencilMaterial.m_List.clear();
                },
                /*UnityEngine.UI.StencilMaterial.ClearAll:static end.*/


            }
        }
    });
    /*UnityEngine.UI.StencilMaterial end.*/

    /*UnityEngine.UI.StencilMaterial+MatEntry start.*/
    Bridge.define("UnityEngine.UI.StencilMaterial.MatEntry", {
        $kind: 1002,
        fields: {
            baseMat: null,
            customMat: null,
            count: 0,
            stencilId: 0,
            operation: 0,
            compareFunction: 0,
            readMask: 0,
            writeMask: 0,
            useAlphaClip: false,
            colorMask: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.StencilMaterial.MatEntry#init", this ); }

                this.operation = UnityEngine.Rendering.StencilOp.Keep;
                this.compareFunction = UnityEngine.Rendering.CompareFunction.Always;
            }
        }
    });
    /*UnityEngine.UI.StencilMaterial+MatEntry end.*/

    /*UnityEngine.UI.Toggle+ToggleEvent start.*/
    Bridge.define("UnityEngine.UI.Toggle.ToggleEvent", {
        inherits: [UnityEngine.Events.UnityEvent$1(System.Boolean)],
        $kind: 1002
    });
    /*UnityEngine.UI.Toggle+ToggleEvent end.*/

    /*UnityEngine.UI.Toggle+ToggleTransition start.*/
    /**
     * Display settings for when a toggle is activated or deactivated.
     *
     * @public
     * @class number
     */
    Bridge.define("UnityEngine.UI.Toggle.ToggleTransition", {
        $kind: 1006,
        statics: {
            fields: {
                /**
                 * Show / hide the toggle instantly
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                None: 0,
                /**
                 * Fade the toggle in / out smoothly.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                Fade: 1
            }
        }
    });
    /*UnityEngine.UI.Toggle+ToggleTransition end.*/

    /*UnityEngine.UI.VertexHelper start.*/
    /**
     * Represents a UI vertex.
     *
     * @public
     * @class UnityEngine.UI.VertexHelper
     * @implements  System.IDisposable
     */
    Bridge.define("UnityEngine.UI.VertexHelper", {
        inherits: [System.IDisposable],
        fields: {
            /**
             * Holds the list of vertices.
             *
             * @instance
             * @protected
             * @memberof UnityEngine.UI.VertexHelper
             * @type System.Collections.Generic.List$1
             */
            vertices: null,
            /**
             * List of triangle indexes.
             *
             * @instance
             * @protected
             * @memberof UnityEngine.UI.VertexHelper
             * @type System.Collections.Generic.List$1
             */
            triangles: null
        },
        props: {
            currentVertCount: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.VertexHelper#currentVertCount#get", this ); }

                    return this.vertices.Count;
                }
            }
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.VertexHelper#init", this ); }

                this.vertices = new (System.Collections.Generic.List$1(UnityEngine.UIVertex)).ctor();
                this.triangles = new (System.Collections.Generic.List$1(System.Int32)).ctor();
            },
            /**
             * Initializes a new instance of the {@link } class.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.VertexHelper
             * @memberof UnityEngine.UI.VertexHelper
             * @return  {void}
             */
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.VertexHelper#ctor", this ); }

                this.$initialize();
            },
            /**
             * Initializes the instance of the vertex helper with mesh as a target.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.VertexHelper
             * @memberof UnityEngine.UI.VertexHelper
             * @param   {UnityEngine.Mesh}    mesh
             * @return  {void}
             */
            $ctor1: function (mesh) {
if ( TRACE ) { TRACE( "UnityEngine.UI.VertexHelper#$ctor1", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*UnityEngine.UI.VertexHelper.AddTriangle start.*/
            /**
             * Adds the triangle.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.VertexHelper
             * @memberof UnityEngine.UI.VertexHelper
             * @param   {number}    idx0    Idx0.
             * @param   {number}    idx1    Idx1.
             * @param   {number}    idx2    Idx2.
             * @return  {void}
             */
            AddTriangle: function (idx0, idx1, idx2) {
if ( TRACE ) { TRACE( "UnityEngine.UI.VertexHelper#AddTriangle", this ); }

                this.triangles.add(idx0);
                this.triangles.add(idx1);
                this.triangles.add(idx2);
            },
            /*UnityEngine.UI.VertexHelper.AddTriangle end.*/

            /*UnityEngine.UI.VertexHelper.AddVert start.*/
            /**
             * Adds the vert.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.VertexHelper
             * @memberof UnityEngine.UI.VertexHelper
             * @param   {UnityEngine.UIVertex}    v    V.
             * @return  {void}
             */
            AddVert: function (v) {
if ( TRACE ) { TRACE( "UnityEngine.UI.VertexHelper#AddVert", this ); }

                // the vertex is already cloned here - so, let's take a shortcut :)
                this.vertices.add( v );
            },
            /*UnityEngine.UI.VertexHelper.AddVert end.*/

            /*UnityEngine.UI.VertexHelper.AddVert$1 start.*/
            /**
             * Adds the vert.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.VertexHelper
             * @memberof UnityEngine.UI.VertexHelper
             * @param   {UnityEngine.Vector3}    position    Position.
             * @param   {UnityEngine.Color32}    color       Color.
             * @param   {UnityEngine.Vector2}    uv0         Uv0.
             * @return  {void}
             */
            AddVert$1: function (position, color, uv0) {
if ( TRACE ) { TRACE( "UnityEngine.UI.VertexHelper#AddVert$1", this ); }

                var $t;
                this.AddVert(($t = new UnityEngine.UIVertex(), $t.position = position.$clone(), $t.color = color.$clone(), $t.uv0 = uv0.$clone(), $t));
            },
            /*UnityEngine.UI.VertexHelper.AddVert$1 end.*/

            /*UnityEngine.UI.VertexHelper.AddVert$2 start.*/
            /**
             * Adds the vert.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.VertexHelper
             * @memberof UnityEngine.UI.VertexHelper
             * @param   {UnityEngine.Vector3}    position    Position.
             * @param   {UnityEngine.Color32}    color       Color.
             * @param   {UnityEngine.Vector2}    uv0         Uv0.
             * @param   {UnityEngine.Vector2}    uv1         Uv1.
             * @param   {UnityEngine.Vector3}    normal      Normal.
             * @param   {UnityEngine.Vector4}    tangent     Tangent.
             * @return  {void}
             */
            AddVert$2: function (position, color, uv0, uv1, normal, tangent) {
if ( TRACE ) { TRACE( "UnityEngine.UI.VertexHelper#AddVert$2", this ); }

                var $t;
                this.AddVert(($t = new UnityEngine.UIVertex(), $t.position = position.$clone(), $t.color = color.$clone(), $t.uv0 = uv0.$clone(), $t.uv1 = uv1.$clone(), $t.normal = normal.$clone(), $t.tangent = tangent.$clone(), $t));
            },
            /*UnityEngine.UI.VertexHelper.AddVert$2 end.*/

            /*UnityEngine.UI.VertexHelper.GetUIVertexStream start.*/
            /**
             * Returns the stream of vertices currently stored in vertex helper.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.VertexHelper
             * @memberof UnityEngine.UI.VertexHelper
             * @param   {System.Collections.Generic.List$1}    vertexList
             * @return  {void}
             */
            GetUIVertexStream: function (vertexList) {
if ( TRACE ) { TRACE( "UnityEngine.UI.VertexHelper#GetUIVertexStream", this ); }

                vertexList.clear();
                vertexList.AddRange(this.vertices);
            },
            /*UnityEngine.UI.VertexHelper.GetUIVertexStream end.*/

            /*UnityEngine.UI.VertexHelper.Clear start.*/
            /**
             * Clear this instance.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.VertexHelper
             * @memberof UnityEngine.UI.VertexHelper
             * @return  {void}
             */
            Clear: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.VertexHelper#Clear", this ); }

                this.vertices.clear();
                this.triangles.clear();
            },
            /*UnityEngine.UI.VertexHelper.Clear end.*/

            /*UnityEngine.UI.VertexHelper.AddUIVertexQuad start.*/
            /**
             * Adds a quad composed of 4 vertices and appends corresponding triangle indexes.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.VertexHelper
             * @memberof UnityEngine.UI.VertexHelper
             * @param   {Array.<UnityEngine.UIVertex>}    verts
             * @return  {void}
             */
            AddUIVertexQuad: function (verts) {
if ( TRACE ) { TRACE( "UnityEngine.UI.VertexHelper#AddUIVertexQuad", this ); }

                // memoize index of the first vertex we are about to add
                var firstVertex = this.vertices.Count;

                // add vertices
                for (var i = 0; i < 4; i++) {
                    this.AddVert(verts[i].$clone());
                }

                // add triangles
                this.AddTriangle(firstVertex, firstVertex + 1, firstVertex + 2);
                this.AddTriangle(firstVertex + 2, firstVertex + 3, firstVertex);
            },
            /*UnityEngine.UI.VertexHelper.AddUIVertexQuad end.*/

            /*UnityEngine.UI.VertexHelper.Dispose start.*/
            /**
             * Releases all resource used by the {@link } object.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.VertexHelper
             * @memberof UnityEngine.UI.VertexHelper
             * @return  {void}
             */
            Dispose: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.VertexHelper#Dispose", this ); }
 },
            /*UnityEngine.UI.VertexHelper.Dispose end.*/

            /*UnityEngine.UI.VertexHelper.PopulateUIVertex start.*/
            /**
             * Populates the UIV ertex.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.VertexHelper
             * @memberof UnityEngine.UI.VertexHelper
             * @param   {UnityEngine.UIVertex}    vertex    Vertex.
             * @param   {number}                  i         The index.
             * @return  {void}
             */
            PopulateUIVertex: function (vertex, i) {
if ( TRACE ) { TRACE( "UnityEngine.UI.VertexHelper#PopulateUIVertex", this ); }

                // As we use pure C# Color32 struct we should use its 'Copy' method instead of 'copy'
                
                var original = this.vertices.getItem( i );
                vertex.v.position.copy( original.position );
                vertex.v.tangent.copy( original.tangent );
                vertex.v.uv1.copy( original.uv1 );
                vertex.v.uv0.copy( original.uv0 );
                vertex.v.color.Copy( original.color );
                vertex.v.normal.copy( original.normal );
            
            },
            /*UnityEngine.UI.VertexHelper.PopulateUIVertex end.*/

            /*UnityEngine.UI.VertexHelper.SetUIVertex start.*/
            /**
             * Sets the UIV ertex.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.VertexHelper
             * @memberof UnityEngine.UI.VertexHelper
             * @param   {UnityEngine.UIVertex}    vertex    Vertex.
             * @param   {number}                  i         The index.
             * @return  {void}
             */
            SetUIVertex: function (vertex, i) {
if ( TRACE ) { TRACE( "UnityEngine.UI.VertexHelper#SetUIVertex", this ); }

                // we are cloned here already, so, let's simply put it
                this.vertices.setItem( i, vertex );
            },
            /*UnityEngine.UI.VertexHelper.SetUIVertex end.*/

            /*UnityEngine.UI.VertexHelper.AddUIVertexTriangleStream start.*/
            /**
             * Adds the vertices into the stream.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.VertexHelper
             * @memberof UnityEngine.UI.VertexHelper
             * @param   {System.Collections.Generic.List$1}    vertexList
             * @return  {void}
             */
            AddUIVertexTriangleStream: function (vertexList) {
if ( TRACE ) { TRACE( "UnityEngine.UI.VertexHelper#AddUIVertexTriangleStream", this ); }

                var lastVertex = this.vertices.Count;
                this.vertices.AddRange(vertexList);

                for (var i = 0; i < vertexList.Count; i++) {
                    this.triangles.add(lastVertex + i);
                }
            },
            /*UnityEngine.UI.VertexHelper.AddUIVertexTriangleStream end.*/

            /*UnityEngine.UI.VertexHelper.FillMesh start.*/
            /**
             * Populates the mesh with vertex data.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.VertexHelper
             * @memberof UnityEngine.UI.VertexHelper
             * @param   {UnityEngine.Mesh}    mesh
             * @return  {void}
             */
            FillMesh: function (mesh) {
if ( TRACE ) { TRACE( "UnityEngine.UI.VertexHelper#FillMesh", this ); }

                mesh.handle.setUIVertexStream(this.vertices, this.triangles);
            },
            /*UnityEngine.UI.VertexHelper.FillMesh end.*/

            /*UnityEngine.UI.VertexHelper.FromMesh start.*/
            FromMesh: function (mesh) {
if ( TRACE ) { TRACE( "UnityEngine.UI.VertexHelper#FromMesh", this ); }

                this.vertices.clear();
                this.triangles.clear();

                mesh.handle.getUIVertexStream(this.vertices, this.triangles);

                // var originalVertices = mesh.vertices;
                // var originalUvs = mesh.uv;
                // var originalColor = mesh.colors;
                // vertices = new List<UIVertex>( originalVertices.Length );
                // for ( int i = 0; i < mesh.vertexCount; i++ ) {
                //     vertices.Add( new UIVertex() {
                //         position = originalVertices[ i ],
                //         uv0 = originalUvs[ i ],
                //         color = originalColor.Length > 0 ? originalColor[ i ] : Color.white
                //     } );
                // }
                // triangles = new List<int>( mesh.triangles );
            },
            /*UnityEngine.UI.VertexHelper.FromMesh end.*/


        },
        overloads: {
            "AddVert(Vector3, Color32, Vector2)": "AddVert$1",
            "AddVert(Vector3, Color32, Vector2, Vector2, Vector3, Vector4)": "AddVert$2"
        }
    });
    /*UnityEngine.UI.VertexHelper end.*/

    /*UnityEngine.EventSystems.BaseEventData start.*/
    Bridge.define("UnityEngine.EventSystems.BaseEventData", {
        inherits: [UnityEngine.EventSystems.AbstractEventData],
        fields: {
            currentInputModule: null,
            selectedObject: null
        },
        ctors: {
            ctor: function (eventSystem) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseEventData#ctor", this ); }

                this.$initialize();
                UnityEngine.EventSystems.AbstractEventData.ctor.call(this);
            }
        }
    });
    /*UnityEngine.EventSystems.BaseEventData end.*/

    /*UnityEngine.EventSystems.BaseInput start.*/
    Bridge.define("UnityEngine.EventSystems.BaseInput", {
        inherits: [UnityEngine.EventSystems.UIBehaviour],
        props: {
            /**
             * Interface to Input.compositionString. Can be overridden to provide custom input instead of using the Input class.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.EventSystems.BaseInput
             * @function compositionString
             * @type string
             */
            compositionString: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInput#compositionString#get", this ); }

                    return UnityEngine.Input.compositionString;
                }
            },
            /**
             * Interface to Input.imeCompositionMode. Can be overridden to provide custom input instead of using the Input class.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.BaseInput
             * @function imeCompositionMode
             * @type UnityEngine.IMECompositionMode
             */
            imeCompositionMode: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInput#imeCompositionMode#get", this ); }

                    return UnityEngine.Input.imeCompositionMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInput#imeCompositionMode#set", this ); }

                    UnityEngine.Input.imeCompositionMode = value;
                }
            },
            /**
             * Interface to Input.compositionCursorPos. Can be overridden to provide custom input instead of using the Input class.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.BaseInput
             * @function compositionCursorPos
             * @type UnityEngine.Vector2
             */
            compositionCursorPos: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInput#compositionCursorPos#get", this ); }

                    return UnityEngine.Input.compositionCursorPos.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInput#compositionCursorPos#set", this ); }

                    UnityEngine.Input.compositionCursorPos = value.$clone();
                }
            },
            /**
             * Interface to Input.mousePresent. Can be overridden to provide custom input instead of using the Input class.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.EventSystems.BaseInput
             * @function mousePresent
             * @type boolean
             */
            mousePresent: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInput#mousePresent#get", this ); }

                    return UnityEngine.Input.mousePresent;
                }
            },
            /**
             * Interface to Input.mousePosition. Can be overridden to provide custom input instead of using the Input class.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.EventSystems.BaseInput
             * @function mousePosition
             * @type UnityEngine.Vector3
             */
            mousePosition: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInput#mousePosition#get", this ); }

                    return UnityEngine.Input.mousePosition.$clone();
                }
            },
            /**
             * Interface to Input.mouseScrollDelta. Can be overridden to provide custom input instead of using the Input class.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.EventSystems.BaseInput
             * @function mouseScrollDelta
             * @type UnityEngine.Vector2
             */
            mouseScrollDelta: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInput#mouseScrollDelta#get", this ); }

                    return UnityEngine.Input.mouseScrollDelta.$clone();
                }
            },
            /**
             * Interface to Input.touchSupported. Can be overridden to provide custom input instead of using the Input class.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.EventSystems.BaseInput
             * @function touchSupported
             * @type boolean
             */
            touchSupported: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInput#touchSupported#get", this ); }

                    return UnityEngine.Input.touchSupported;
                }
            },
            /**
             * Interface to Input.touchCount. Can be overridden to provide custom input instead of using the Input class.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.EventSystems.BaseInput
             * @function touchCount
             * @type number
             */
            touchCount: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInput#touchCount#get", this ); }

                    return UnityEngine.Input.touchCount;
                }
            }
        },
        methods: {
            /*UnityEngine.EventSystems.BaseInput.GetMouseButtonDown start.*/
            /**
             * Interface to Input.GetMouseButtonDown. Can be overridden to provide custom input instead of using the Input class.
             *
             * @instance
             * @public
             * @this UnityEngine.EventSystems.BaseInput
             * @memberof UnityEngine.EventSystems.BaseInput
             * @param   {number}     button
             * @return  {boolean}
             */
            GetMouseButtonDown: function (button) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInput#GetMouseButtonDown", this ); }

                return UnityEngine.Input.GetMouseButtonDown(button);
            },
            /*UnityEngine.EventSystems.BaseInput.GetMouseButtonDown end.*/

            /*UnityEngine.EventSystems.BaseInput.GetMouseButtonUp start.*/
            /**
             * Interface to Input.GetMouseButtonUp. Can be overridden to provide custom input instead of using the Input class.
             *
             * @instance
             * @public
             * @this UnityEngine.EventSystems.BaseInput
             * @memberof UnityEngine.EventSystems.BaseInput
             * @param   {number}     button
             * @return  {boolean}
             */
            GetMouseButtonUp: function (button) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInput#GetMouseButtonUp", this ); }

                return UnityEngine.Input.GetMouseButtonUp(button);
            },
            /*UnityEngine.EventSystems.BaseInput.GetMouseButtonUp end.*/

            /*UnityEngine.EventSystems.BaseInput.GetMouseButton start.*/
            /**
             * Interface to Input.GetMouseButton. Can be overridden to provide custom input instead of using the Input class.
             *
             * @instance
             * @public
             * @this UnityEngine.EventSystems.BaseInput
             * @memberof UnityEngine.EventSystems.BaseInput
             * @param   {number}     button
             * @return  {boolean}
             */
            GetMouseButton: function (button) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInput#GetMouseButton", this ); }

                return UnityEngine.Input.GetMouseButton(button);
            },
            /*UnityEngine.EventSystems.BaseInput.GetMouseButton end.*/

            /*UnityEngine.EventSystems.BaseInput.GetTouch start.*/
            /**
             * Interface to Input.GetTouch. Can be overridden to provide custom input instead of using the Input class.
             *
             * @instance
             * @public
             * @this UnityEngine.EventSystems.BaseInput
             * @memberof UnityEngine.EventSystems.BaseInput
             * @param   {number}               index    Touch index to get
             * @return  {UnityEngine.Touch}
             */
            GetTouch: function (index) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInput#GetTouch", this ); }

                return UnityEngine.Input.GetTouch(index);
            },
            /*UnityEngine.EventSystems.BaseInput.GetTouch end.*/

            /*UnityEngine.EventSystems.BaseInput.GetAxisRaw start.*/
            /**
             * Interface to Input.GetAxisRaw. Can be overridden to provide custom input instead of using the Input class.
             *
             * @instance
             * @public
             * @this UnityEngine.EventSystems.BaseInput
             * @memberof UnityEngine.EventSystems.BaseInput
             * @param   {string}    axisName    Axis name to check
             * @return  {number}
             */
            GetAxisRaw: function (axisName) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInput#GetAxisRaw", this ); }

                return UnityEngine.Input.GetAxisRaw(axisName);
            },
            /*UnityEngine.EventSystems.BaseInput.GetAxisRaw end.*/

            /*UnityEngine.EventSystems.BaseInput.GetButtonDown start.*/
            /**
             * Interface to Input.GetButtonDown. Can be overridden to provide custom input instead of using the Input class.
             *
             * @instance
             * @public
             * @this UnityEngine.EventSystems.BaseInput
             * @memberof UnityEngine.EventSystems.BaseInput
             * @param   {string}     buttonName    Button name to get
             * @return  {boolean}
             */
            GetButtonDown: function (buttonName) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInput#GetButtonDown", this ); }

                return UnityEngine.Input.GetButtonDown(buttonName);
            },
            /*UnityEngine.EventSystems.BaseInput.GetButtonDown end.*/


        }
    });
    /*UnityEngine.EventSystems.BaseInput end.*/

    /*UnityEngine.EventSystems.BaseInputModule start.*/
    Bridge.define("UnityEngine.EventSystems.BaseInputModule", {
        inherits: [UnityEngine.EventSystems.UIBehaviour],
        statics: {
            methods: {
                /*UnityEngine.EventSystems.BaseInputModule.FindFirstRaycast:static start.*/
                /**
                 * Return the first valid RaycastResult.
                 *
                 * @static
                 * @protected
                 * @this UnityEngine.EventSystems.BaseInputModule
                 * @memberof UnityEngine.EventSystems.BaseInputModule
                 * @param   {System.Collections.Generic.List$1}         candidates
                 * @return  {UnityEngine.EventSystems.RaycastResult}
                 */
                FindFirstRaycast: function (candidates) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInputModule#FindFirstRaycast", this ); }

                    for (var i = 0; i < candidates.Count; ++i) {
                        if (UnityEngine.GameObject.op_Equality(candidates.getItem(i).$clone().gameObject, null)) {
                            continue;
                        }

                        return candidates.getItem(i).$clone();
                    }

                    return new UnityEngine.EventSystems.RaycastResult();
                },
                /*UnityEngine.EventSystems.BaseInputModule.FindFirstRaycast:static end.*/

                /*UnityEngine.EventSystems.BaseInputModule.DetermineMoveDirection:static start.*/
                /**
                 * Given an input movement, determine the best MoveDirection.
                 *
                 * @static
                 * @protected
                 * @this UnityEngine.EventSystems.BaseInputModule
                 * @memberof UnityEngine.EventSystems.BaseInputModule
                 * @param   {number}                                    x    X movement.
                 * @param   {number}                                    y    Y movement.
                 * @return  {UnityEngine.EventSystems.MoveDirection}
                 */
                DetermineMoveDirection: function (x, y) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInputModule#DetermineMoveDirection", this ); }

                    return UnityEngine.EventSystems.BaseInputModule.DetermineMoveDirection$1(x, y, 0.6);
                },
                /*UnityEngine.EventSystems.BaseInputModule.DetermineMoveDirection:static end.*/

                /*UnityEngine.EventSystems.BaseInputModule.DetermineMoveDirection$1:static start.*/
                /**
                 * Given an input movement, determine the best MoveDirection.
                 *
                 * @static
                 * @protected
                 * @this UnityEngine.EventSystems.BaseInputModule
                 * @memberof UnityEngine.EventSystems.BaseInputModule
                 * @param   {number}                                    x           X movement.
                 * @param   {number}                                    y           Y movement.
                 * @param   {number}                                    deadZone    Dead zone.
                 * @return  {UnityEngine.EventSystems.MoveDirection}
                 */
                DetermineMoveDirection$1: function (x, y, deadZone) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInputModule#DetermineMoveDirection$1", this ); }

                    // if vector is too small... just return
                    if (new pc.Vec2( x, y ).lengthSq() < deadZone * deadZone) {
                        return UnityEngine.EventSystems.MoveDirection.None;
                    }

                    if (Math.abs(x) > Math.abs(y)) {
                        if (x > 0) {
                            return UnityEngine.EventSystems.MoveDirection.Right;
                        }

                        return UnityEngine.EventSystems.MoveDirection.Left;
                    } else {
                        if (y > 0) {
                            return UnityEngine.EventSystems.MoveDirection.Up;
                        }

                        return UnityEngine.EventSystems.MoveDirection.Down;
                    }
                },
                /*UnityEngine.EventSystems.BaseInputModule.DetermineMoveDirection$1:static end.*/

                /*UnityEngine.EventSystems.BaseInputModule.FindCommonRoot:static start.*/
                /**
                 * Given 2 GameObjects, return a common root GameObject (or null).
                 *
                 * @static
                 * @protected
                 * @this UnityEngine.EventSystems.BaseInputModule
                 * @memberof UnityEngine.EventSystems.BaseInputModule
                 * @param   {UnityEngine.GameObject}    g1    GameObject to compare
                 * @param   {UnityEngine.GameObject}    g2    GameObject to compare
                 * @return  {UnityEngine.GameObject}
                 */
                FindCommonRoot: function (g1, g2) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInputModule#FindCommonRoot", this ); }

                    if (UnityEngine.GameObject.op_Equality(g1, null) || UnityEngine.GameObject.op_Equality(g2, null)) {
                        return null;
                    }

                    var t1 = g1.transform;
                    while (UnityEngine.Component.op_Inequality(t1, null)) {
                        var t2 = g2.transform;
                        while (UnityEngine.Component.op_Inequality(t2, null)) {
                            if (UnityEngine.Component.op_Equality(t1, t2)) {
                                return t1.gameObject;
                            }

                            t2 = t2.parent;
                        }

                        t1 = t1.parent;
                    }

                    return null;
                },
                /*UnityEngine.EventSystems.BaseInputModule.FindCommonRoot:static end.*/


            }
        },
        fields: {
            m_RaycastResultCache: null,
            m_AxisEventData: null,
            m_EventSystem: null,
            m_BaseEventData: null,
            m_InputOverride: null,
            m_DefaultInput: null
        },
        props: {
            /**
             * The current BaseInput being used by the input module.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.EventSystems.BaseInputModule
             * @function input
             * @type UnityEngine.EventSystems.BaseInput
             */
            input: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInputModule#input#get", this ); }

                    var $t;
                    if (UnityEngine.MonoBehaviour.op_Inequality(this.m_InputOverride, null)) {
                        return this.m_InputOverride;
                    }

                    if (UnityEngine.MonoBehaviour.op_Equality(this.m_DefaultInput, null)) {
                        var inputs = this.GetComponents(UnityEngine.EventSystems.BaseInput);
                        $t = Bridge.getEnumerator(inputs);
                        try {
                            while ($t.moveNext()) {
                                var baseInput = $t.Current;
                                // We dont want to use any classes that derrive from BaseInput for default.
                                if (UnityEngine.MonoBehaviour.op_Inequality(baseInput, null) && Bridge.referenceEquals(Bridge.getType(baseInput), UnityEngine.EventSystems.BaseInput)) {
                                    this.m_DefaultInput = baseInput;
                                    break;
                                }
                            }
                        } finally {
                            if (Bridge.is($t, System.IDisposable)) {
                                $t.System$IDisposable$Dispose();
                            }
                        }

                        if (UnityEngine.MonoBehaviour.op_Equality(this.m_DefaultInput, null)) {
                            this.m_DefaultInput = this.gameObject.AddComponent(UnityEngine.EventSystems.BaseInput);
                        }
                    }

                    return this.m_DefaultInput;
                }
            },
            /**
             * Used to override the default BaseInput for the input module.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.BaseInputModule
             * @function inputOverride
             * @type UnityEngine.EventSystems.BaseInput
             */
            inputOverride: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInputModule#inputOverride#get", this ); }

                    return this.m_InputOverride;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInputModule#inputOverride#set", this ); }

                    this.m_InputOverride = value;
                }
            },
            eventSystem: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInputModule#eventSystem#get", this ); }

                    return this.m_EventSystem;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInputModule#init", this ); }

                this.m_RaycastResultCache = new (System.Collections.Generic.List$1(UnityEngine.EventSystems.RaycastResult)).ctor();
            }
        },
        methods: {
            /*UnityEngine.EventSystems.BaseInputModule.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInputModule#OnEnable", this ); }

                UnityEngine.EventSystems.UIBehaviour.prototype.OnEnable.call(this);
                this.m_EventSystem = this.GetComponent(UnityEngine.EventSystems.EventSystem);
                this.m_EventSystem.UpdateModules();
            },
            /*UnityEngine.EventSystems.BaseInputModule.OnEnable end.*/

            /*UnityEngine.EventSystems.BaseInputModule.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInputModule#OnDisable", this ); }

                this.m_EventSystem.UpdateModules();
                UnityEngine.EventSystems.UIBehaviour.prototype.OnDisable.call(this);
            },
            /*UnityEngine.EventSystems.BaseInputModule.OnDisable end.*/

            /*UnityEngine.EventSystems.BaseInputModule.HandlePointerExitAndEnter start.*/
            HandlePointerExitAndEnter: function (currentPointerData, newEnterTarget) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInputModule#HandlePointerExitAndEnter", this ); }

                // if we have no target / pointerEnter has been deleted
                // just send exit events to anything we are tracking
                // then exit
                if (UnityEngine.GameObject.op_Equality(newEnterTarget, null) || UnityEngine.GameObject.op_Equality(currentPointerData.pointerEnter, null)) {
                    for (var i = 0; i < currentPointerData.hovered.Count; ++i) {
                        UnityEngine.EventSystems.ExecuteEvents.Execute(UnityEngine.EventSystems.IPointerExitHandler, currentPointerData.hovered.getItem(i), currentPointerData, UnityEngine.EventSystems.ExecuteEvents.pointerExitHandler);
                    }

                    currentPointerData.hovered.clear();

                    if (UnityEngine.GameObject.op_Equality(newEnterTarget, null)) {
                        currentPointerData.pointerEnter = null;
                        return;
                    }
                }

                // if we have not changed hover target
                if (UnityEngine.GameObject.op_Equality(currentPointerData.pointerEnter, newEnterTarget) && UnityEngine.Object.op_Implicit(newEnterTarget)) {
                    return;
                }

                var commonRoot = UnityEngine.EventSystems.BaseInputModule.FindCommonRoot(currentPointerData.pointerEnter, newEnterTarget);

                // and we already an entered object from last time
                if (UnityEngine.GameObject.op_Inequality(currentPointerData.pointerEnter, null)) {
                    // send exit handler call to all elements in the chain
                    // until we reach the new target, or null!
                    var t = currentPointerData.pointerEnter.transform;

                    while (UnityEngine.Component.op_Inequality(t, null)) {
                        // if we reach the common root break out!
                        if (UnityEngine.GameObject.op_Inequality(commonRoot, null) && UnityEngine.Component.op_Equality(commonRoot.transform, t)) {
                            break;
                        }

                        UnityEngine.EventSystems.ExecuteEvents.Execute(UnityEngine.EventSystems.IPointerExitHandler, t.gameObject, currentPointerData, UnityEngine.EventSystems.ExecuteEvents.pointerExitHandler);
                        currentPointerData.hovered.remove(t.gameObject);
                        t = t.parent;
                    }
                }

                // now issue the enter call up to but not including the common root
                currentPointerData.pointerEnter = newEnterTarget;
                if (UnityEngine.GameObject.op_Inequality(newEnterTarget, null)) {
                    var t1 = newEnterTarget.transform;

                    while (UnityEngine.Component.op_Inequality(t1, null) && UnityEngine.GameObject.op_Inequality(t1.gameObject, commonRoot)) {
                        UnityEngine.EventSystems.ExecuteEvents.Execute(UnityEngine.EventSystems.IPointerEnterHandler, t1.gameObject, currentPointerData, UnityEngine.EventSystems.ExecuteEvents.pointerEnterHandler);
                        currentPointerData.hovered.add(t1.gameObject);
                        t1 = t1.parent;
                    }
                }
            },
            /*UnityEngine.EventSystems.BaseInputModule.HandlePointerExitAndEnter end.*/

            /*UnityEngine.EventSystems.BaseInputModule.GetAxisEventData start.*/
            /**
             * Given some input data generate an AxisEventData that can be used by the event system.
             *
             * @instance
             * @protected
             * @this UnityEngine.EventSystems.BaseInputModule
             * @memberof UnityEngine.EventSystems.BaseInputModule
             * @param   {number}                                    x               X movement.
             * @param   {number}                                    y               Y movement.
             * @param   {number}                                    moveDeadZone
             * @return  {UnityEngine.EventSystems.AxisEventData}
             */
            GetAxisEventData: function (x, y, moveDeadZone) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInputModule#GetAxisEventData", this ); }

                if (this.m_AxisEventData == null) {
                    this.m_AxisEventData = new UnityEngine.EventSystems.AxisEventData(this.eventSystem);
                }

                this.m_AxisEventData.Reset();
                this.m_AxisEventData.moveVector = new pc.Vec2( x, y );
                this.m_AxisEventData.moveDir = UnityEngine.EventSystems.BaseInputModule.DetermineMoveDirection$1(x, y, moveDeadZone);
                return this.m_AxisEventData;
            },
            /*UnityEngine.EventSystems.BaseInputModule.GetAxisEventData end.*/

            /*UnityEngine.EventSystems.BaseInputModule.GetBaseEventData start.*/
            /**
             * Generate a BaseEventData that can be used by the EventSystem.
             *
             * @instance
             * @protected
             * @this UnityEngine.EventSystems.BaseInputModule
             * @memberof UnityEngine.EventSystems.BaseInputModule
             * @return  {UnityEngine.EventSystems.BaseEventData}
             */
            GetBaseEventData: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInputModule#GetBaseEventData", this ); }

                if (this.m_BaseEventData == null) {
                    this.m_BaseEventData = new UnityEngine.EventSystems.BaseEventData(this.eventSystem);
                }

                this.m_BaseEventData.Reset();
                return this.m_BaseEventData;
            },
            /*UnityEngine.EventSystems.BaseInputModule.GetBaseEventData end.*/

            /*UnityEngine.EventSystems.BaseInputModule.IsPointerOverGameObject start.*/
            /**
             * If the module is pointer based, then override this to return true if the pointer is over an event system object.
             *
             * @instance
             * @public
             * @this UnityEngine.EventSystems.BaseInputModule
             * @memberof UnityEngine.EventSystems.BaseInputModule
             * @param   {number}     pointerId    Pointer ID
             * @return  {boolean}                 Is the given pointer over an event system object?
             */
            IsPointerOverGameObject: function (pointerId) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInputModule#IsPointerOverGameObject", this ); }

                return false;
            },
            /*UnityEngine.EventSystems.BaseInputModule.IsPointerOverGameObject end.*/

            /*UnityEngine.EventSystems.BaseInputModule.ShouldActivateModule start.*/
            /**
             * Should the module be activated.
             *
             * @instance
             * @public
             * @this UnityEngine.EventSystems.BaseInputModule
             * @memberof UnityEngine.EventSystems.BaseInputModule
             * @return  {boolean}
             */
            ShouldActivateModule: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInputModule#ShouldActivateModule", this ); }

                return this.enabled && this.gameObject.activeInHierarchy;
            },
            /*UnityEngine.EventSystems.BaseInputModule.ShouldActivateModule end.*/

            /*UnityEngine.EventSystems.BaseInputModule.DeactivateModule start.*/
            /**
             * Called when the module is deactivated. Override this if you want custom code to execute when you deactivate your module.
             *
             * @instance
             * @public
             * @this UnityEngine.EventSystems.BaseInputModule
             * @memberof UnityEngine.EventSystems.BaseInputModule
             * @return  {void}
             */
            DeactivateModule: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInputModule#DeactivateModule", this ); }
 },
            /*UnityEngine.EventSystems.BaseInputModule.DeactivateModule end.*/

            /*UnityEngine.EventSystems.BaseInputModule.ActivateModule start.*/
            /**
             * Called when the module is activated. Override this if you want custom code to execute when you activate your module.
             *
             * @instance
             * @public
             * @this UnityEngine.EventSystems.BaseInputModule
             * @memberof UnityEngine.EventSystems.BaseInputModule
             * @return  {void}
             */
            ActivateModule: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInputModule#ActivateModule", this ); }
 },
            /*UnityEngine.EventSystems.BaseInputModule.ActivateModule end.*/

            /*UnityEngine.EventSystems.BaseInputModule.UpdateModule start.*/
            /**
             * Update the internal state of the Module.
             *
             * @instance
             * @public
             * @this UnityEngine.EventSystems.BaseInputModule
             * @memberof UnityEngine.EventSystems.BaseInputModule
             * @return  {void}
             */
            UpdateModule: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInputModule#UpdateModule", this ); }
 },
            /*UnityEngine.EventSystems.BaseInputModule.UpdateModule end.*/

            /*UnityEngine.EventSystems.BaseInputModule.IsModuleSupported start.*/
            /**
             * Check to see if the module is supported. Override this if you have a platform specific module (eg. TouchInputModule that you do not want to activate on standalone.)
             *
             * @instance
             * @public
             * @this UnityEngine.EventSystems.BaseInputModule
             * @memberof UnityEngine.EventSystems.BaseInputModule
             * @return  {boolean}        Is the module supported.
             */
            IsModuleSupported: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseInputModule#IsModuleSupported", this ); }

                return true;
            },
            /*UnityEngine.EventSystems.BaseInputModule.IsModuleSupported end.*/


        }
    });
    /*UnityEngine.EventSystems.BaseInputModule end.*/

    /*UnityEngine.EventSystems.BaseRaycaster start.*/
    /**
     * Base raycaster.
     *
     * @abstract
     * @public
     * @class UnityEngine.EventSystems.BaseRaycaster
     * @augments UnityEngine.EventSystems.UIBehaviour
     */
    Bridge.define("UnityEngine.EventSystems.BaseRaycaster", {
        inherits: [UnityEngine.EventSystems.UIBehaviour],
        fields: {
            _rootRaycaster: null
        },
        props: {
            /**
             * Gets the render order priority.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.EventSystems.BaseRaycaster
             * @function renderOrderPriority
             * @type number
             */
            renderOrderPriority: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseRaycaster#renderOrderPriority#get", this ); }

                    var $t;
                    if ((($t = this.handle.entity) != null ? $t.screen : null) == null) {
                        return -1;
                    }

                    return this.handle.entity.screen.sortingLayerIndex;
                }
            },
            /**
             * Gets the sort order priority.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.EventSystems.BaseRaycaster
             * @function sortOrderPriority
             * @type number
             */
            sortOrderPriority: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseRaycaster#sortOrderPriority#get", this ); }

                    var $t;
                    if ((($t = this.handle.entity) != null ? $t.screen : null) == null) {
                        return -1;
                    }

                    return this.handle.entity.screen.sortingOrder;
                }
            },
            /**
             * Raycaster on root canvas
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.EventSystems.BaseRaycaster
             * @function rootRaycaster
             * @type UnityEngine.EventSystems.BaseRaycaster
             */
            rootRaycaster: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseRaycaster#rootRaycaster#get", this ); }

                    if (UnityEngine.MonoBehaviour.op_Equality(this._rootRaycaster, null)) {
                        var baseRaycasters = this.GetComponentsInParent(UnityEngine.EventSystems.BaseRaycaster);
                        if (baseRaycasters.length !== 0) {
                            this._rootRaycaster = baseRaycasters[baseRaycasters.length - 1];
                        }
                    }

                    return this._rootRaycaster;
                }
            }
        },
        methods: {
            /*UnityEngine.EventSystems.BaseRaycaster.ConfigureForEntity start.*/
            /**
             * Configures for entity.
             *
             * @instance
             * @public
             * @override
             * @this UnityEngine.EventSystems.BaseRaycaster
             * @memberof UnityEngine.EventSystems.BaseRaycaster
             * @param   {pc.Entity}    entity    Entity.
             * @return  {void}
             */
            ConfigureForEntity: function (entity) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseRaycaster#ConfigureForEntity", this ); }

                this.entity = entity;
            },
            /*UnityEngine.EventSystems.BaseRaycaster.ConfigureForEntity end.*/

            /*UnityEngine.EventSystems.BaseRaycaster.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseRaycaster#OnEnable", this ); }

                UnityEngine.EventSystems.UIBehaviour.prototype.OnEnable.call(this);
                UnityEngine.EventSystems.RaycasterManager.AddRaycaster(this);
            },
            /*UnityEngine.EventSystems.BaseRaycaster.OnEnable end.*/

            /*UnityEngine.EventSystems.BaseRaycaster.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseRaycaster#OnDisable", this ); }

                UnityEngine.EventSystems.RaycasterManager.RemoveRaycasters(this);
                UnityEngine.EventSystems.UIBehaviour.prototype.OnDisable.call(this);
            },
            /*UnityEngine.EventSystems.BaseRaycaster.OnDisable end.*/

            /*UnityEngine.EventSystems.BaseRaycaster.OnCanvasHierarchyChanged start.*/
            OnCanvasHierarchyChanged: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseRaycaster#OnCanvasHierarchyChanged", this ); }

                UnityEngine.EventSystems.UIBehaviour.prototype.OnCanvasHierarchyChanged.call(this);
                this._rootRaycaster = null;
            },
            /*UnityEngine.EventSystems.BaseRaycaster.OnCanvasHierarchyChanged end.*/

            /*UnityEngine.EventSystems.BaseRaycaster.OnTransformParentChanged start.*/
            OnTransformParentChanged: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.BaseRaycaster#OnTransformParentChanged", this ); }

                UnityEngine.EventSystems.UIBehaviour.prototype.OnTransformParentChanged.call(this);
                this._rootRaycaster = null;
            },
            /*UnityEngine.EventSystems.BaseRaycaster.OnTransformParentChanged end.*/


        }
    });
    /*UnityEngine.EventSystems.BaseRaycaster end.*/

    /*UnityEngine.EventSystems.EventSystem start.*/
    Bridge.define("UnityEngine.EventSystems.EventSystem", {
        inherits: [UnityEngine.EventSystems.UIBehaviour],
        statics: {
            fields: {
                eventSystems: null,
                raycastComparer: null
            },
            props: {
                /**
                 * Return the current EventSystem.
                 *
                 * @static
                 * @public
                 * @memberof UnityEngine.EventSystems.EventSystem
                 * @function current
                 * @type UnityEngine.EventSystems.EventSystem
                 */
                current: {
                    get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventSystem#current#get", this ); }

                        return UnityEngine.EventSystems.EventSystem.eventSystems.Count > 0 ? UnityEngine.EventSystems.EventSystem.eventSystems.getItem(0) : null;
                    },
                    set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventSystem#current#set", this ); }

                        var index = UnityEngine.EventSystems.EventSystem.eventSystems.indexOf(value);
                        if (index >= 0) {
                            UnityEngine.EventSystems.EventSystem.eventSystems.removeAt(index);
                            UnityEngine.EventSystems.EventSystem.eventSystems.insert(0, value);
                        }
                    }
                }
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventSystem#init", this ); }

                    this.eventSystems = new (System.Collections.Generic.List$1(UnityEngine.EventSystems.EventSystem)).ctor();
                    this.raycastComparer = UnityEngine.EventSystems.EventSystem.RaycastComparer;
                }
            },
            methods: {
                /*UnityEngine.EventSystems.EventSystem.RaycastComparer:static start.*/
                RaycastComparer: function (lhs, rhs) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventSystem#RaycastComparer", this ); }

                    if (UnityEngine.MonoBehaviour.op_Inequality(lhs.module, rhs.module)) {
                        var lhsEventCamera = lhs.module.eventCamera;
                        var rhsEventCamera = rhs.module.eventCamera;
                        if (UnityEngine.Component.op_Inequality(lhsEventCamera, null) && UnityEngine.Component.op_Inequality(rhsEventCamera, null) && lhsEventCamera.depth !== rhsEventCamera.depth) {
                            // need to reverse the standard compareTo
                            if (lhsEventCamera.depth < rhsEventCamera.depth) {
                                return 1;
                            }

                            if (lhsEventCamera.depth === rhsEventCamera.depth) {
                                return 0;
                            }

                            return -1;
                        }

                        if (lhs.module.sortOrderPriority !== rhs.module.sortOrderPriority) {
                            return Bridge.compare(rhs.module.sortOrderPriority, lhs.module.sortOrderPriority);
                        }

                        if (lhs.module.renderOrderPriority !== rhs.module.renderOrderPriority) {
                            return Bridge.compare(rhs.module.renderOrderPriority, lhs.module.renderOrderPriority);
                        }
                    }

                    if (lhs.sortingLayer !== rhs.sortingLayer) {
                        // Uses the layer value to properly compare the relative order of the layers.
                        var rid = UnityEngine.SortingLayer.GetLayerValueFromID(rhs.sortingLayer);
                        var lid = UnityEngine.SortingLayer.GetLayerValueFromID(lhs.sortingLayer);
                        return Bridge.compare(rid, lid);
                    }

                    if (lhs.sortingOrder !== rhs.sortingOrder) {
                        return Bridge.compare(rhs.sortingOrder, lhs.sortingOrder);
                    }

                    // comparing depth only makes sense if the two raycast results have the same root canvas (case 912396)
                    if (lhs.depth !== rhs.depth && UnityEngine.MonoBehaviour.op_Equality(lhs.module.rootRaycaster, rhs.module.rootRaycaster)) {
                        return Bridge.compare(rhs.depth, lhs.depth);
                    }

                    if (lhs.distance !== rhs.distance) {
                        return Bridge.compare(lhs.distance, rhs.distance);
                    }

                    return Bridge.compare(lhs.index, rhs.index);
                },
                /*UnityEngine.EventSystems.EventSystem.RaycastComparer:static end.*/


            }
        },
        fields: {
            systemInputModules: null,
            _currentInputModule: null,
            firstSelected: null,
            _sendNavigationEvents: false,
            dragThreshold: 0,
            currentSelected: null,
            hasFocus: false,
            selectionGuard: false,
            dummyData: null
        },
        props: {
            /**
             * Should the EventSystem allow navigation events (move / submit / cancel).
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.EventSystem
             * @function sendNavigationEvents
             * @type boolean
             */
            sendNavigationEvents: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventSystem#sendNavigationEvents#get", this ); }

                    return this._sendNavigationEvents;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventSystem#sendNavigationEvents#set", this ); }

                    this._sendNavigationEvents = value;
                }
            },
            /**
             * The soft area for dragging in pixels.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.EventSystem
             * @function pixelDragThreshold
             * @type number
             */
            pixelDragThreshold: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventSystem#pixelDragThreshold#get", this ); }

                    return this.dragThreshold;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventSystem#pixelDragThreshold#set", this ); }

                    this.dragThreshold = value;
                }
            },
            /**
             * The currently active EventSystems.BaseInputModule.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.EventSystems.EventSystem
             * @function currentInputModule
             * @type UnityEngine.EventSystems.BaseInputModule
             */
            currentInputModule: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventSystem#currentInputModule#get", this ); }

                    return this._currentInputModule;
                }
            },
            /**
             * Only one object can be selected at a time. Think: controller-selected button.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.EventSystem
             * @function firstSelectedGameObject
             * @type UnityEngine.GameObject
             */
            firstSelectedGameObject: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventSystem#firstSelectedGameObject#get", this ); }

                    return this.firstSelected;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventSystem#firstSelectedGameObject#set", this ); }

                    this.firstSelected = value;
                }
            },
            /**
             * The GameObject currently considered active by the EventSystem.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.EventSystems.EventSystem
             * @function currentSelectedGameObject
             * @type UnityEngine.GameObject
             */
            currentSelectedGameObject: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventSystem#currentSelectedGameObject#get", this ); }

                    return this.currentSelected;
                }
            },
            lastSelectedGameObject: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventSystem#lastSelectedGameObject#get", this ); }

                    return null;
                }
            },
            /**
             * Flag to say whether the EventSystem thinks it should be paused or not based upon focused state.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.EventSystems.EventSystem
             * @function isFocused
             * @type boolean
             */
            isFocused: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventSystem#isFocused#get", this ); }

                    return this.hasFocus;
                }
            },
            /**
             * Returns true if the EventSystem is already in a SetSelectedGameObject.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.EventSystems.EventSystem
             * @function alreadySelecting
             * @type boolean
             */
            alreadySelecting: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventSystem#alreadySelecting#get", this ); }

                    return this.selectionGuard;
                }
            },
            baseEventDataCache: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventSystem#baseEventDataCache#get", this ); }

                    if (this.dummyData == null) {
                        this.dummyData = new UnityEngine.EventSystems.BaseEventData(this);
                    }

                    return this.dummyData;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventSystem#init", this ); }

                this.systemInputModules = new (System.Collections.Generic.List$1(UnityEngine.EventSystems.BaseInputModule)).ctor();
                this._sendNavigationEvents = true;
                this.dragThreshold = 10;
                this.hasFocus = true;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventSystem#ctor", this ); }

                this.$initialize();
                UnityEngine.EventSystems.UIBehaviour.ctor.call(this);
            }
        },
        methods: {
            /*UnityEngine.EventSystems.EventSystem.UpdateModules start.*/
            /**
             * Recalculate the internal list of BaseInputModules.
             *
             * @instance
             * @public
             * @this UnityEngine.EventSystems.EventSystem
             * @memberof UnityEngine.EventSystems.EventSystem
             * @return  {void}
             */
            UpdateModules: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventSystem#UpdateModules", this ); }

                this.GetComponents$2(UnityEngine.EventSystems.BaseInputModule, this.systemInputModules);
                for (var i = this.systemInputModules.Count - 1; i >= 0; i--) {
                    if (UnityEngine.Object.op_Implicit(this.systemInputModules.getItem(i)) && this.systemInputModules.getItem(i).IsActive()) {
                        continue;
                    }

                    this.systemInputModules.removeAt(i);
                }
            },
            /*UnityEngine.EventSystems.EventSystem.UpdateModules end.*/

            /*UnityEngine.EventSystems.EventSystem.SetSelectedGameObject$1 start.*/
            /**
             * Set the object as selected. Will send an OnDeselect the the old selected object and OnSelect to the new selected object.
             *
             * @instance
             * @public
             * @this UnityEngine.EventSystems.EventSystem
             * @memberof UnityEngine.EventSystems.EventSystem
             * @param   {UnityEngine.GameObject}                    selected    GameObject to select.
             * @param   {UnityEngine.EventSystems.BaseEventData}    pointer     Associated EventData.
             * @return  {void}
             */
            SetSelectedGameObject$1: function (selected, pointer) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventSystem#SetSelectedGameObject$1", this ); }

                if (this.selectionGuard) {
                    UnityEngine.Debug.LogError$2(System.String.concat("Attempting to select ", selected) + "while already selecting an object.");
                    return;
                }

                this.selectionGuard = true;
                if (UnityEngine.GameObject.op_Equality(selected, this.currentSelected)) {
                    this.selectionGuard = false;
                    return;
                }

                // Debug.Log("Selection: new (" + selected + ") old (" + currentSelected + ")");
                UnityEngine.EventSystems.ExecuteEvents.Execute(UnityEngine.EventSystems.IDeselectHandler, this.currentSelected, pointer, UnityEngine.EventSystems.ExecuteEvents.deselectHandler);
                this.currentSelected = selected;
                UnityEngine.EventSystems.ExecuteEvents.Execute(UnityEngine.EventSystems.ISelectHandler, this.currentSelected, pointer, UnityEngine.EventSystems.ExecuteEvents.selectHandler);
                this.selectionGuard = false;
            },
            /*UnityEngine.EventSystems.EventSystem.SetSelectedGameObject$1 end.*/

            /*UnityEngine.EventSystems.EventSystem.SetSelectedGameObject start.*/
            /**
             * Set the object as selected. Will send an OnDeselect the the old selected object and OnSelect to the new selected object.
             *
             * @instance
             * @public
             * @this UnityEngine.EventSystems.EventSystem
             * @memberof UnityEngine.EventSystems.EventSystem
             * @param   {UnityEngine.GameObject}    selected    GameObject to select.
             * @return  {void}
             */
            SetSelectedGameObject: function (selected) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventSystem#SetSelectedGameObject", this ); }

                this.SetSelectedGameObject$1(selected, this.baseEventDataCache);
            },
            /*UnityEngine.EventSystems.EventSystem.SetSelectedGameObject end.*/

            /*UnityEngine.EventSystems.EventSystem.RaycastAll start.*/
            /**
             * Raycast into the scene using all configured BaseRaycasters.
             *
             * @instance
             * @public
             * @this UnityEngine.EventSystems.EventSystem
             * @memberof UnityEngine.EventSystems.EventSystem
             * @param   {UnityEngine.EventSystems.PointerEventData}    eventData         Current pointer data.
             * @param   {System.Collections.Generic.List$1}            raycastResults    List of 'hits' to populate.
             * @return  {void}
             */
            RaycastAll: function (eventData, raycastResults) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventSystem#RaycastAll", this ); }

                raycastResults.clear();
                var modules = UnityEngine.EventSystems.RaycasterManager.GetRaycasters();
                for (var i = 0; i < modules.Count; ++i) {
                    var module = modules.getItem(i);
                    if (UnityEngine.MonoBehaviour.op_Equality(module, null) || !module.IsActive()) {
                        continue;
                    }

                    module.Raycast(eventData, raycastResults);
                }

                raycastResults.Sort$2(UnityEngine.EventSystems.EventSystem.raycastComparer);
            },
            /*UnityEngine.EventSystems.EventSystem.RaycastAll end.*/

            /*UnityEngine.EventSystems.EventSystem.IsPointerOverGameObject start.*/
            /**
             * Is the pointer with the given ID over an EventSystem object?
             *
             * @instance
             * @public
             * @this UnityEngine.EventSystems.EventSystem
             * @memberof UnityEngine.EventSystems.EventSystem
             * @return  {boolean}
             */
            IsPointerOverGameObject: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventSystem#IsPointerOverGameObject", this ); }

                return this.IsPointerOverGameObject$1(UnityEngine.EventSystems.PointerInputModule.kMouseLeftId);
            },
            /*UnityEngine.EventSystems.EventSystem.IsPointerOverGameObject end.*/

            /*UnityEngine.EventSystems.EventSystem.IsPointerOverGameObject$1 start.*/
            /**
             * Is the pointer with the given ID over an EventSystem object?
             *
             * @instance
             * @public
             * @this UnityEngine.EventSystems.EventSystem
             * @memberof UnityEngine.EventSystems.EventSystem
             * @example
             *
             * using UnityEngine;
             * using System.Collections;
             * using UnityEngine.EventSystems;
             * public class MouseExample : MonoBehaviour
             * {
             * void Update()
             * {
             *     // Check if the left mouse button was clicked
             *     if (Input.GetMouseButtonDown(0))
             *     {
             *         // Check if the mouse was clicked over a UI element
             *         if (EventSystem.current.IsPointerOverGameObject())
             *         {
             *             Debug.Log("Clicked on the UI");
             *         }
             *     }
             * }
             * }
             * 
             *
             *
             * @param   {number}     pointerId
             * @return  {boolean}
             */
            IsPointerOverGameObject$1: function (pointerId) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventSystem#IsPointerOverGameObject$1", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this._currentInputModule, null)) {
                    return false;
                }

                return this._currentInputModule.IsPointerOverGameObject(pointerId);
            },
            /*UnityEngine.EventSystems.EventSystem.IsPointerOverGameObject$1 end.*/

            /*UnityEngine.EventSystems.EventSystem.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventSystem#OnEnable", this ); }

                UnityEngine.EventSystems.UIBehaviour.prototype.OnEnable.call(this);
                UnityEngine.EventSystems.EventSystem.eventSystems.add(this);
            },
            /*UnityEngine.EventSystems.EventSystem.OnEnable end.*/

            /*UnityEngine.EventSystems.EventSystem.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventSystem#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this._currentInputModule, null)) {
                    this._currentInputModule.DeactivateModule();
                    this._currentInputModule = null;
                }

                UnityEngine.EventSystems.EventSystem.eventSystems.remove(this);

                UnityEngine.EventSystems.UIBehaviour.prototype.OnDisable.call(this);
            },
            /*UnityEngine.EventSystems.EventSystem.OnDisable end.*/

            /*UnityEngine.EventSystems.EventSystem.TickModules start.*/
            TickModules: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventSystem#TickModules", this ); }

                for (var i = 0; i < this.systemInputModules.Count; i++) {
                    if (UnityEngine.MonoBehaviour.op_Inequality(this.systemInputModules.getItem(i), null)) {
                        this.systemInputModules.getItem(i).UpdateModule();
                    }
                }
            },
            /*UnityEngine.EventSystems.EventSystem.TickModules end.*/

            /*UnityEngine.EventSystems.EventSystem.OnApplicationFocus start.*/
            OnApplicationFocus: function (hasFocus) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventSystem#OnApplicationFocus", this ); }

                this.hasFocus = hasFocus;
            },
            /*UnityEngine.EventSystems.EventSystem.OnApplicationFocus end.*/

            /*UnityEngine.EventSystems.EventSystem.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventSystem#Update", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(UnityEngine.EventSystems.EventSystem.current, this)) {
                    return;
                }

                this.TickModules();

                var changedModule = false;
                for (var i = 0; i < this.systemInputModules.Count; i++) {
                    var module = this.systemInputModules.getItem(i);
                    if (module.IsModuleSupported() && module.ShouldActivateModule()) {
                        if (UnityEngine.MonoBehaviour.op_Inequality(this._currentInputModule, module)) {
                            this.ChangeEventModule(module);
                            changedModule = true;
                        }

                        break;
                    }
                }

                // no event module set... set the first valid one...
                if (UnityEngine.MonoBehaviour.op_Equality(this._currentInputModule, null)) {
                    for (var i1 = 0; i1 < this.systemInputModules.Count; i1++) {
                        var module1 = this.systemInputModules.getItem(i1);
                        if (module1.IsModuleSupported()) {
                            this.ChangeEventModule(module1);
                            changedModule = true;
                            break;
                        }
                    }
                }

                if (!changedModule && UnityEngine.MonoBehaviour.op_Inequality(this._currentInputModule, null)) {
                    this._currentInputModule.Process();
                }
            },
            /*UnityEngine.EventSystems.EventSystem.Update end.*/

            /*UnityEngine.EventSystems.EventSystem.ChangeEventModule start.*/
            ChangeEventModule: function (module) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventSystem#ChangeEventModule", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this._currentInputModule, module)) {
                    return;
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this._currentInputModule, null)) {
                    this._currentInputModule.DeactivateModule();
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(module, null)) {
                    module.ActivateModule();
                }

                this._currentInputModule = module;
            },
            /*UnityEngine.EventSystems.EventSystem.ChangeEventModule end.*/

            /*UnityEngine.EventSystems.EventSystem.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventSystem#toString", this ); }

                var sb = new System.Text.StringBuilder();
                sb.appendLine(System.String.concat("<b>Selected:</b>", this.currentSelectedGameObject));
                sb.appendLine();
                sb.appendLine();
                sb.appendLine(UnityEngine.MonoBehaviour.op_Inequality(this._currentInputModule, null) ? Bridge.toString(this._currentInputModule) : "No module");
                return sb.toString();
            },
            /*UnityEngine.EventSystems.EventSystem.toString end.*/


        },
        overloads: {
            "SetSelectedGameObject(GameObject, BaseEventData)": "SetSelectedGameObject$1",
            "IsPointerOverGameObject(int)": "IsPointerOverGameObject$1",
            "ToString()": "toString"
        }
    });
    /*UnityEngine.EventSystems.EventSystem end.*/

    /*UnityEngine.EventSystems.ICancelHandler start.*/
    Bridge.define("UnityEngine.EventSystems.ICancelHandler", {
        inherits: [UnityEngine.EventSystems.IEventSystemHandler],
        $kind: 3
    });
    /*UnityEngine.EventSystems.ICancelHandler end.*/

    /*UnityEngine.EventSystems.ISubmitHandler start.*/
    /**
     * Submit handler.
     *
     * @abstract
     * @public
     * @class UnityEngine.EventSystems.ISubmitHandler
     * @implements  UnityEngine.EventSystems.IEventSystemHandler
     */
    Bridge.define("UnityEngine.EventSystems.ISubmitHandler", {
        inherits: [UnityEngine.EventSystems.IEventSystemHandler],
        $kind: 3
    });
    /*UnityEngine.EventSystems.ISubmitHandler end.*/

    /*UnityEngine.EventSystems.IMoveHandler start.*/
    Bridge.define("UnityEngine.EventSystems.IMoveHandler", {
        inherits: [UnityEngine.EventSystems.IEventSystemHandler],
        $kind: 3
    });
    /*UnityEngine.EventSystems.IMoveHandler end.*/

    /*UnityEngine.EventSystems.IDeselectHandler start.*/
    Bridge.define("UnityEngine.EventSystems.IDeselectHandler", {
        inherits: [UnityEngine.EventSystems.IEventSystemHandler],
        $kind: 3
    });
    /*UnityEngine.EventSystems.IDeselectHandler end.*/

    /*UnityEngine.EventSystems.ISelectHandler start.*/
    Bridge.define("UnityEngine.EventSystems.ISelectHandler", {
        inherits: [UnityEngine.EventSystems.IEventSystemHandler],
        $kind: 3
    });
    /*UnityEngine.EventSystems.ISelectHandler end.*/

    /*UnityEngine.EventSystems.IUpdateSelectedHandler start.*/
    Bridge.define("UnityEngine.EventSystems.IUpdateSelectedHandler", {
        inherits: [UnityEngine.EventSystems.IEventSystemHandler],
        $kind: 3
    });
    /*UnityEngine.EventSystems.IUpdateSelectedHandler end.*/

    /*UnityEngine.EventSystems.IScrollHandler start.*/
    Bridge.define("UnityEngine.EventSystems.IScrollHandler", {
        inherits: [UnityEngine.EventSystems.IEventSystemHandler],
        $kind: 3
    });
    /*UnityEngine.EventSystems.IScrollHandler end.*/

    /*UnityEngine.EventSystems.IDropHandler start.*/
    Bridge.define("UnityEngine.EventSystems.IDropHandler", {
        inherits: [UnityEngine.EventSystems.IEventSystemHandler],
        $kind: 3
    });
    /*UnityEngine.EventSystems.IDropHandler end.*/

    /*UnityEngine.EventSystems.IEndDragHandler start.*/
    /**
     * End drag handler.
     *
     * @abstract
     * @public
     * @class UnityEngine.EventSystems.IEndDragHandler
     * @implements  UnityEngine.EventSystems.IEventSystemHandler
     */
    Bridge.define("UnityEngine.EventSystems.IEndDragHandler", {
        inherits: [UnityEngine.EventSystems.IEventSystemHandler],
        $kind: 3
    });
    /*UnityEngine.EventSystems.IEndDragHandler end.*/

    /*UnityEngine.EventSystems.IDragHandler start.*/
    Bridge.define("UnityEngine.EventSystems.IDragHandler", {
        inherits: [UnityEngine.EventSystems.IEventSystemHandler],
        $kind: 3
    });
    /*UnityEngine.EventSystems.IDragHandler end.*/

    /*UnityEngine.EventSystems.IBeginDragHandler start.*/
    Bridge.define("UnityEngine.EventSystems.IBeginDragHandler", {
        inherits: [UnityEngine.EventSystems.IEventSystemHandler],
        $kind: 3
    });
    /*UnityEngine.EventSystems.IBeginDragHandler end.*/

    /*UnityEngine.EventSystems.IInitializePotentialDragHandler start.*/
    Bridge.define("UnityEngine.EventSystems.IInitializePotentialDragHandler", {
        inherits: [UnityEngine.EventSystems.IEventSystemHandler],
        $kind: 3
    });
    /*UnityEngine.EventSystems.IInitializePotentialDragHandler end.*/

    /*UnityEngine.EventSystems.IPointerClickHandler start.*/
    Bridge.define("UnityEngine.EventSystems.IPointerClickHandler", {
        inherits: [UnityEngine.EventSystems.IEventSystemHandler],
        $kind: 3
    });
    /*UnityEngine.EventSystems.IPointerClickHandler end.*/

    /*UnityEngine.EventSystems.IPointerUpHandler start.*/
    Bridge.define("UnityEngine.EventSystems.IPointerUpHandler", {
        inherits: [UnityEngine.EventSystems.IEventSystemHandler],
        $kind: 3
    });
    /*UnityEngine.EventSystems.IPointerUpHandler end.*/

    /*UnityEngine.EventSystems.IPointerDownHandler start.*/
    Bridge.define("UnityEngine.EventSystems.IPointerDownHandler", {
        inherits: [UnityEngine.EventSystems.IEventSystemHandler],
        $kind: 3
    });
    /*UnityEngine.EventSystems.IPointerDownHandler end.*/

    /*UnityEngine.EventSystems.IPointerExitHandler start.*/
    Bridge.define("UnityEngine.EventSystems.IPointerExitHandler", {
        inherits: [UnityEngine.EventSystems.IEventSystemHandler],
        $kind: 3
    });
    /*UnityEngine.EventSystems.IPointerExitHandler end.*/

    /*UnityEngine.EventSystems.IPointerEnterHandler start.*/
    Bridge.define("UnityEngine.EventSystems.IPointerEnterHandler", {
        inherits: [UnityEngine.EventSystems.IEventSystemHandler],
        $kind: 3
    });
    /*UnityEngine.EventSystems.IPointerEnterHandler end.*/

    /*UnityEngine.UI.AspectRatioFitter start.*/
    Bridge.define("UnityEngine.UI.AspectRatioFitter", {
        inherits: [UnityEngine.EventSystems.UIBehaviour],
        fields: {
            /**
             * The m aspect mode.
             *
             * @instance
             * @protected
             * @memberof UnityEngine.UI.AspectRatioFitter
             * @type number
             */
            m_AspectMode: 0,
            /**
             * The m aspect ratio.
             *
             * @instance
             * @protected
             * @memberof UnityEngine.UI.AspectRatioFitter
             * @default 1.0
             * @type number
             */
            m_AspectRatio: 0,
            /**
             * The m rect.
             *
             * @instance
             * @protected
             * @memberof UnityEngine.UI.AspectRatioFitter
             * @type UnityEngine.RectTransform
             */
            m_Rect: null
        },
        props: {
            /**
             * Gets or sets the aspect mode.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.AspectRatioFitter
             * @function aspectMode
             * @type number
             */
            aspectMode: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.AspectRatioFitter#aspectMode#get", this ); }

                    return this.m_AspectMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.AspectRatioFitter#aspectMode#set", this ); }

                    this.m_AspectMode = value;
                }
            },
            /**
             * Gets or sets the aspect ratio.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.AspectRatioFitter
             * @function aspectRatio
             * @type number
             */
            aspectRatio: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.AspectRatioFitter#aspectRatio#get", this ); }

                    return this.m_AspectRatio;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.AspectRatioFitter#aspectRatio#set", this ); }

                    this.m_AspectRatio = value;
                }
            },
            /**
             * Gets the rect transform.
             *
             * @instance
             * @protected
             * @readonly
             * @memberof UnityEngine.UI.AspectRatioFitter
             * @function rectTransform
             * @type UnityEngine.RectTransform
             */
            rectTransform: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.AspectRatioFitter#rectTransform#get", this ); }

                    if (UnityEngine.Component.op_Equality(this.m_Rect, null)) {
                        this.m_Rect = this.GetComponent(UnityEngine.RectTransform);
                    }

                    return this.m_Rect;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.AspectRatioFitter#init", this ); }

                this.m_AspectMode = UnityEngine.UI.AspectRatioFitter.AspectMode.None;
                this.m_AspectRatio = 1.0;
            }
        },
        methods: {
            /*UnityEngine.UI.AspectRatioFitter.UpdateRect start.*/
            /**
             * Updates the rect.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.AspectRatioFitter
             * @memberof UnityEngine.UI.AspectRatioFitter
             * @return  {void}
             */
            UpdateRect: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.AspectRatioFitter#UpdateRect", this ); }

                if (!this.IsActive()) {
                    return;
                }

                switch (this.m_AspectMode) {
                    case UnityEngine.UI.AspectRatioFitter.AspectMode.HeightControlsWidth: 
                        {
                            this.rectTransform.SetSizeWithCurrentAnchors(UnityEngine.RectTransform.Axis.Horizontal, this.rectTransform.rect.height * this.m_AspectRatio);
                            break;
                        }
                    case UnityEngine.UI.AspectRatioFitter.AspectMode.WidthControlsHeight: 
                        {
                            this.rectTransform.SetSizeWithCurrentAnchors(UnityEngine.RectTransform.Axis.Vertical, this.rectTransform.rect.width / this.m_AspectRatio);
                            break;
                        }
                    case UnityEngine.UI.AspectRatioFitter.AspectMode.FitInParent: 
                    case UnityEngine.UI.AspectRatioFitter.AspectMode.EnvelopeParent: 
                        {
                            this.rectTransform.anchorMin = pc.Vec2.ZERO.clone();
                            this.rectTransform.anchorMax = pc.Vec2.ONE.clone();
                            this.rectTransform.anchoredPosition = pc.Vec2.ZERO.clone();

                            var sizeDelta = pc.Vec2.ZERO.clone();
                            var parentSize = this.GetParentSize();
                            if ((parentSize.y * this.aspectRatio < parentSize.x) != (this.m_AspectMode === UnityEngine.UI.AspectRatioFitter.AspectMode.FitInParent)) {
                                sizeDelta.y = this.GetSizeDeltaToProduceSize(parentSize.x / this.aspectRatio, 1);
                            } else {
                                sizeDelta.x = this.GetSizeDeltaToProduceSize(parentSize.y * this.aspectRatio, 0);
                            }

                            this.rectTransform.sizeDelta = sizeDelta.$clone();

                            break;
                        }
                }
            },
            /*UnityEngine.UI.AspectRatioFitter.UpdateRect end.*/

            /*UnityEngine.UI.AspectRatioFitter.GetSizeDeltaToProduceSize start.*/
            /**
             * Gets the size of the size delta to produce.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.AspectRatioFitter
             * @memberof UnityEngine.UI.AspectRatioFitter
             * @param   {number}    size    Size.
             * @param   {number}    axis    Axis.
             * @return  {number}            The size delta to produce size.
             */
            GetSizeDeltaToProduceSize: function (size, axis) {
if ( TRACE ) { TRACE( "UnityEngine.UI.AspectRatioFitter#GetSizeDeltaToProduceSize", this ); }

                return size - this.GetParentSize().getitem(axis) * (this.rectTransform.anchorMax.getitem(axis) - this.rectTransform.anchorMin.getitem(axis));
            },
            /*UnityEngine.UI.AspectRatioFitter.GetSizeDeltaToProduceSize end.*/

            /*UnityEngine.UI.AspectRatioFitter.GetParentSize start.*/
            /**
             * Gets the size of the parent.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.AspectRatioFitter
             * @memberof UnityEngine.UI.AspectRatioFitter
             * @return  {UnityEngine.Vector2}        The parent size.
             */
            GetParentSize: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.AspectRatioFitter#GetParentSize", this ); }

                var parent = Bridge.as(this.rectTransform.parent, UnityEngine.RectTransform);

                if (!UnityEngine.Object.op_Implicit(parent)) {
                    return pc.Vec2.ZERO.clone();
                }

                return parent.rect.size.$clone();
            },
            /*UnityEngine.UI.AspectRatioFitter.GetParentSize end.*/

            /*UnityEngine.UI.AspectRatioFitter.OnEnable start.*/
            /**
             * Handles enabled status change of the fitter by dirtfying its layout.
             *
             * @instance
             * @protected
             * @override
             * @this UnityEngine.UI.AspectRatioFitter
             * @memberof UnityEngine.UI.AspectRatioFitter
             * @return  {void}
             */
            OnEnable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.AspectRatioFitter#OnEnable", this ); }

                UnityEngine.EventSystems.UIBehaviour.prototype.OnEnable.call(this);
                this.SetDirty();
            },
            /*UnityEngine.UI.AspectRatioFitter.OnEnable end.*/

            /*UnityEngine.UI.AspectRatioFitter.SetDirty start.*/
            /**
             * Marks the fitter as dirty.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.AspectRatioFitter
             * @memberof UnityEngine.UI.AspectRatioFitter
             * @return  {void}
             */
            SetDirty: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.AspectRatioFitter#SetDirty", this ); }

                this.UpdateRect();
            },
            /*UnityEngine.UI.AspectRatioFitter.SetDirty end.*/

            /*UnityEngine.UI.AspectRatioFitter.OnRectTransformDimensionsChange start.*/
            /**
             * Function called when this RectTransform or parent RectTransform has changed dimensions.
             *
             * @instance
             * @protected
             * @override
             * @this UnityEngine.UI.AspectRatioFitter
             * @memberof UnityEngine.UI.AspectRatioFitter
             * @return  {void}
             */
            OnRectTransformDimensionsChange: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.AspectRatioFitter#OnRectTransformDimensionsChange", this ); }

                this.UpdateRect();
            },
            /*UnityEngine.UI.AspectRatioFitter.OnRectTransformDimensionsChange end.*/


        }
    });
    /*UnityEngine.UI.AspectRatioFitter end.*/

    /*UnityEngine.UI.BaseMeshEffect start.*/
    Bridge.define("UnityEngine.UI.BaseMeshEffect", {
        inherits: [UnityEngine.EventSystems.UIBehaviour,UnityEngine.UI.IMeshModifier],
        fields: {
            m_Graphic: null
        },
        props: {
            /**
             * The graphic component that the Mesh Effect will aplly to.
             *
             * @instance
             * @protected
             * @readonly
             * @memberof UnityEngine.UI.BaseMeshEffect
             * @function graphic
             * @type UnityEngine.UI.Graphic
             */
            graphic: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.BaseMeshEffect#graphic#get", this ); }

                    if (UnityEngine.MonoBehaviour.op_Equality(this.m_Graphic, null)) {
                        this.m_Graphic = this.GetComponent(UnityEngine.UI.Graphic);
                    }

                    return this.m_Graphic;
                }
            }
        },
        alias: ["ModifyMesh", "UnityEngine$UI$IMeshModifier$ModifyMesh"],
        methods: {
            /*UnityEngine.UI.BaseMeshEffect.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.BaseMeshEffect#OnEnable", this ); }

                UnityEngine.EventSystems.UIBehaviour.prototype.OnEnable.call(this);
                if (UnityEngine.MonoBehaviour.op_Inequality(this.graphic, null)) {
                    this.graphic.SetVerticesDirty();
                }
            },
            /*UnityEngine.UI.BaseMeshEffect.OnEnable end.*/

            /*UnityEngine.UI.BaseMeshEffect.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.BaseMeshEffect#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.graphic, null)) {
                    this.graphic.SetVerticesDirty();
                }

                UnityEngine.EventSystems.UIBehaviour.prototype.OnDisable.call(this);
            },
            /*UnityEngine.UI.BaseMeshEffect.OnDisable end.*/

            /*UnityEngine.UI.BaseMeshEffect.OnDidApplyAnimationProperties start.*/
            /**
             * Called from the native side any time a animation property is changed.
             *
             * @instance
             * @protected
             * @override
             * @this UnityEngine.UI.BaseMeshEffect
             * @memberof UnityEngine.UI.BaseMeshEffect
             * @return  {void}
             */
            OnDidApplyAnimationProperties: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.BaseMeshEffect#OnDidApplyAnimationProperties", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.graphic, null)) {
                    this.graphic.SetVerticesDirty();
                }

                UnityEngine.EventSystems.UIBehaviour.prototype.OnDidApplyAnimationProperties.call(this);
            },
            /*UnityEngine.UI.BaseMeshEffect.OnDidApplyAnimationProperties end.*/

            /*UnityEngine.UI.BaseMeshEffect.ModifyMesh start.*/
            /**
             * Function that is called when the Graphic is populating the mesh.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.BaseMeshEffect
             * @memberof UnityEngine.UI.BaseMeshEffect
             * @param   {UnityEngine.Mesh}    mesh    The generated mesh of the Graphic element that needs modification.
             * @return  {void}
             */
            ModifyMesh: function (mesh) {
if ( TRACE ) { TRACE( "UnityEngine.UI.BaseMeshEffect#ModifyMesh", this ); }

                var vh = new UnityEngine.UI.VertexHelper.$ctor1(mesh);
                try {
                    this.ModifyMesh$1(vh);
                    vh.FillMesh(mesh);
                }
                finally {
                    if (Bridge.hasValue(vh)) {
                        vh.System$IDisposable$Dispose();
                    }
                }
            },
            /*UnityEngine.UI.BaseMeshEffect.ModifyMesh end.*/


        }
    });
    /*UnityEngine.UI.BaseMeshEffect end.*/

    /*UnityEngine.UI.CanvasScaler start.*/
    Bridge.define("UnityEngine.UI.CanvasScaler", {
        inherits: [UnityEngine.EventSystems.UIBehaviour],
        fields: {
            /**
             * The m scale factor.
             *
             * @instance
             * @protected
             * @memberof UnityEngine.UI.CanvasScaler
             * @type number
             */
            m_MatchWidthOrHeight: 0,
            /**
             * The m reference pixels per unit.
             *
             * @instance
             * @protected
             * @memberof UnityEngine.UI.CanvasScaler
             * @type number
             */
            m_ReferencePixelsPerUnit: 0,
            /**
             * The m reference resolution.
             *
             * @instance
             * @protected
             * @memberof UnityEngine.UI.CanvasScaler
             * @type UnityEngine.Vector2
             */
            m_ReferenceResolution: null,
            /**
             * The m scale factor.
             *
             * @instance
             * @protected
             * @memberof UnityEngine.UI.CanvasScaler
             * @default 1
             * @type number
             */
            m_ScaleFactor: 0,
            m_ScreenMatchMode: 0,
            /**
             * The m user interface scale mode.
             *
             * @instance
             * @protected
             * @memberof UnityEngine.UI.CanvasScaler
             * @type number
             */
            m_UiScaleMode: 0
        },
        props: {
            /**
             * Gets or sets the user interface scale mode.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.CanvasScaler
             * @function uiScaleMode
             * @type number
             */
            uiScaleMode: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CanvasScaler#uiScaleMode#get", this ); }

                    return this.m_UiScaleMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.CanvasScaler#uiScaleMode#set", this ); }

                    this.m_UiScaleMode = value;
                    this.UpdateScreenMatchMode();
                }
            },
            /**
             * Gets or sets the scale factor.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.CanvasScaler
             * @function screenMatchMode
             * @type number
             */
            screenMatchMode: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CanvasScaler#screenMatchMode#get", this ); }

                    return this.m_ScreenMatchMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.CanvasScaler#screenMatchMode#set", this ); }

                    this.m_ScreenMatchMode = value;
                    this.UpdateScreenMatchMode();
                }
            },
            /**
             * Gets or sets the reference resolution.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.CanvasScaler
             * @function referenceResolution
             * @type UnityEngine.Vector2
             */
            referenceResolution: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CanvasScaler#referenceResolution#get", this ); }

                    return this.m_ReferenceResolution.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.CanvasScaler#referenceResolution#set", this ); }

                    this.m_ReferenceResolution = value.$clone();
                    this.handle.entity.screen.referenceResolution = value.$clone();
                }
            },
            /**
             * Gets or sets the scale factor.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.CanvasScaler
             * @function scaleFactor
             * @type number
             */
            scaleFactor: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CanvasScaler#scaleFactor#get", this ); }

                    return this.handle.entity.screen.scale;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.CanvasScaler#scaleFactor#set", this ); }

                    this.m_ScaleFactor = value;
                    this.handle.entity.screen.scaleFactor = value;
                }
            },
            /**
             * Gets or sets the scale factor.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.CanvasScaler
             * @function matchWidthOrHeight
             * @type number
             */
            matchWidthOrHeight: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CanvasScaler#matchWidthOrHeight#get", this ); }

                    return this.m_MatchWidthOrHeight;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.CanvasScaler#matchWidthOrHeight#set", this ); }

                    this.m_MatchWidthOrHeight = value;
                    this.handle.entity.screen.scaleBlend = this.m_ScreenMatchMode === UnityEngine.UI.CanvasScaler.ScreenMatchMode.MatchWidthOrHeight ? value : 0;
                }
            },
            /**
             * Gets the reference pixels per unit.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.CanvasScaler
             * @function referencePixelsPerUnit
             * @type number
             */
            referencePixelsPerUnit: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CanvasScaler#referencePixelsPerUnit#get", this ); }

                    return this.m_ReferencePixelsPerUnit;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.CanvasScaler#referencePixelsPerUnit#set", this ); }

                    this.m_ReferencePixelsPerUnit = value;
                    this.handle.entity.screen.referencePixelsPerUnit = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CanvasScaler#init", this ); }

                this.m_ReferenceResolution = new UnityEngine.Vector2();
                this.m_ReferenceResolution = pc.Vec2.ZERO.clone();
                this.m_ScaleFactor = 1;
                this.m_ScreenMatchMode = UnityEngine.UI.CanvasScaler.ScreenMatchMode.MatchWidthOrHeight;
                this.m_UiScaleMode = UnityEngine.UI.CanvasScaler.ScaleMode.ConstantPhysicalSize;
            }
        },
        methods: {
            /*UnityEngine.UI.CanvasScaler.Awake start.*/
            /**
             * Awake this instance.
             *
             * @instance
             * @protected
             * @override
             * @this UnityEngine.UI.CanvasScaler
             * @memberof UnityEngine.UI.CanvasScaler
             * @return  {void}
             */
            Awake: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CanvasScaler#Awake", this ); }

                UnityEngine.EventSystems.UIBehaviour.prototype.Awake.call(this);

                this.handle.entity.screen.referenceResolution = this.m_ReferenceResolution.$clone();
                this.handle.entity.screen.referencePixelsPerUnit = this.m_ReferencePixelsPerUnit;
                this.handle.entity.screen.scaleBlend = this.m_ScreenMatchMode === UnityEngine.UI.CanvasScaler.ScreenMatchMode.MatchWidthOrHeight ? this.m_MatchWidthOrHeight : 0;
                this.handle.entity.screen.scaleFactor = this.m_ScaleFactor;

                this.UpdateScreenMatchMode();
            },
            /*UnityEngine.UI.CanvasScaler.Awake end.*/

            /*UnityEngine.UI.CanvasScaler.ConfigureForEntity start.*/
            /**
             * Configures for entity.
             *
             * @instance
             * @public
             * @override
             * @this UnityEngine.UI.CanvasScaler
             * @memberof UnityEngine.UI.CanvasScaler
             * @param   {pc.Entity}    entity    Entity.
             * @return  {void}
             */
            ConfigureForEntity: function (entity) {
if ( TRACE ) { TRACE( "UnityEngine.UI.CanvasScaler#ConfigureForEntity", this ); }

                UnityEngine.EventSystems.UIBehaviour.prototype.ConfigureForEntity.call(this, entity);
                this.entity.element["__UnityEngine.UI.CanvasScaler"] = this;
            },
            /*UnityEngine.UI.CanvasScaler.ConfigureForEntity end.*/

            /*UnityEngine.UI.CanvasScaler.HandleScaleWithScreenSize start.*/
            /**
             * <p>Handles canvas scaling that scales with the screen size.</p>
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.CanvasScaler
             * @memberof UnityEngine.UI.CanvasScaler
             * @return  {void}
             */
            HandleScaleWithScreenSize: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CanvasScaler#HandleScaleWithScreenSize", this ); }

                throw new System.NotImplementedException.ctor();
            },
            /*UnityEngine.UI.CanvasScaler.HandleScaleWithScreenSize end.*/

            /*UnityEngine.UI.CanvasScaler.UpdateScreenMatchMode start.*/
            /**
             * Updates the screen match mode.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.CanvasScaler
             * @memberof UnityEngine.UI.CanvasScaler
             * @return  {void}
             */
            UpdateScreenMatchMode: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CanvasScaler#UpdateScreenMatchMode", this ); }

                if (this.m_UiScaleMode !== UnityEngine.UI.CanvasScaler.ScaleMode.ScaleWithScreenSize) {
                    this.handle.entity.screen.scaleMode = pc.ScreenComponent.SCALEMODE_NONE;
                    return;
                }

                switch (this.m_ScreenMatchMode) {
                    case UnityEngine.UI.CanvasScaler.ScreenMatchMode.MatchWidthOrHeight: 
                        {
                            this.handle.entity.screen.scaleMode = pc.ScreenComponent.SCALEMODE_BLEND;
                            break;
                        }
                    case UnityEngine.UI.CanvasScaler.ScreenMatchMode.Expand: 
                        {
                            this.handle.entity.screen.scaleMode = pc.ScreenComponent.SCALEMODE_EXPAND;
                            break;
                        }
                    case UnityEngine.UI.CanvasScaler.ScreenMatchMode.Shrink: 
                        {
                            this.handle.entity.screen.scaleMode = pc.ScreenComponent.SCALEMODE_SHRINK;
                            break;
                        }
                }
            },
            /*UnityEngine.UI.CanvasScaler.UpdateScreenMatchMode end.*/


        }
    });
    /*UnityEngine.UI.CanvasScaler end.*/

    /*UnityEngine.UI.ILayoutSelfController start.*/
    /**
     * ILayoutSelfController is an ILayoutController that should drive its own RectTransform.
     *
     * @abstract
     * @public
     * @class UnityEngine.UI.ILayoutSelfController
     * @implements  UnityEngine.UI.ILayoutController
     */
    Bridge.define("UnityEngine.UI.ILayoutSelfController", {
        inherits: [UnityEngine.UI.ILayoutController],
        $kind: 3
    });
    /*UnityEngine.UI.ILayoutSelfController end.*/

    /*UnityEngine.UI.CoroutineTween.ColorTween start.*/
    Bridge.define("UnityEngine.UI.CoroutineTween.ColorTween", {
        inherits: [UnityEngine.UI.CoroutineTween.ITweenValue],
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.ColorTween#getDefaultValue", this ); }
 return new UnityEngine.UI.CoroutineTween.ColorTween(); }
            }
        },
        fields: {
            m_Target: null,
            m_StartColor: null,
            m_TargetColor: null,
            m_TweenMode: 0,
            m_Duration: 0,
            m_IgnoreTimeScale: false
        },
        props: {
            startColor: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.ColorTween#startColor#get", this ); }

                    return this.m_StartColor.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.ColorTween#startColor#set", this ); }

                    this.m_StartColor = value.$clone();
                }
            },
            targetColor: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.ColorTween#targetColor#get", this ); }

                    return this.m_TargetColor.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.ColorTween#targetColor#set", this ); }

                    this.m_TargetColor = value.$clone();
                }
            },
            tweenMode: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.ColorTween#tweenMode#get", this ); }

                    return this.m_TweenMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.ColorTween#tweenMode#set", this ); }

                    this.m_TweenMode = value;
                }
            },
            duration: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.ColorTween#duration#get", this ); }

                    return this.m_Duration;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.ColorTween#duration#set", this ); }

                    this.m_Duration = value;
                }
            },
            ignoreTimeScale: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.ColorTween#ignoreTimeScale#get", this ); }

                    return this.m_IgnoreTimeScale;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.ColorTween#ignoreTimeScale#set", this ); }

                    this.m_IgnoreTimeScale = value;
                }
            }
        },
        alias: [
            "duration", "UnityEngine$UI$CoroutineTween$ITweenValue$duration",
            "ignoreTimeScale", "UnityEngine$UI$CoroutineTween$ITweenValue$ignoreTimeScale",
            "TweenValue", "UnityEngine$UI$CoroutineTween$ITweenValue$TweenValue",
            "ValidTarget", "UnityEngine$UI$CoroutineTween$ITweenValue$ValidTarget"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.ColorTween#init", this ); }

                this.m_StartColor = new UnityEngine.Color();
                this.m_TargetColor = new UnityEngine.Color();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.ColorTween#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*UnityEngine.UI.CoroutineTween.ColorTween.TweenValue start.*/
            TweenValue: function (floatPercentage) {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.ColorTween#TweenValue", this ); }

                if (!this.ValidTarget()) {
                    return;
                }

                var color = pc.Color.lerp( this.m_StartColor, this.m_TargetColor, floatPercentage );
                if (this.m_TweenMode === UnityEngine.UI.CoroutineTween.ColorTween.ColorTweenMode.Alpha) {
                    color.r = this.m_StartColor.r;
                    color.g = this.m_StartColor.g;
                    color.b = this.m_StartColor.b;
                } else if (this.m_TweenMode === UnityEngine.UI.CoroutineTween.ColorTween.ColorTweenMode.RGB) {
                    color.a = this.m_StartColor.a;
                }

                this.m_Target.Invoke(color.$clone());
            },
            /*UnityEngine.UI.CoroutineTween.ColorTween.TweenValue end.*/

            /*UnityEngine.UI.CoroutineTween.ColorTween.AddOnChangedCallback start.*/
            AddOnChangedCallback: function (callback) {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.ColorTween#AddOnChangedCallback", this ); }

                if (this.m_Target == null) {
                    this.m_Target = new UnityEngine.UI.CoroutineTween.ColorTween.ColorTweenCallback();
                }

                this.m_Target.AddListener(callback);
            },
            /*UnityEngine.UI.CoroutineTween.ColorTween.AddOnChangedCallback end.*/

            /*UnityEngine.UI.CoroutineTween.ColorTween.GetIgnoreTimescale start.*/
            GetIgnoreTimescale: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.ColorTween#GetIgnoreTimescale", this ); }

                return this.m_IgnoreTimeScale;
            },
            /*UnityEngine.UI.CoroutineTween.ColorTween.GetIgnoreTimescale end.*/

            /*UnityEngine.UI.CoroutineTween.ColorTween.GetDuration start.*/
            GetDuration: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.ColorTween#GetDuration", this ); }

                return this.m_Duration;
            },
            /*UnityEngine.UI.CoroutineTween.ColorTween.GetDuration end.*/

            /*UnityEngine.UI.CoroutineTween.ColorTween.ValidTarget start.*/
            ValidTarget: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.ColorTween#ValidTarget", this ); }

                return this.m_Target != null;
            },
            /*UnityEngine.UI.CoroutineTween.ColorTween.ValidTarget end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.ColorTween#getHashCode", this ); }

                var h = Bridge.addHash([3571724826, this.m_Target, this.m_StartColor, this.m_TargetColor, this.m_TweenMode, this.m_Duration, this.m_IgnoreTimeScale]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.ColorTween#equals", this ); }

                if (!Bridge.is(o, UnityEngine.UI.CoroutineTween.ColorTween)) {
                    return false;
                }
                return Bridge.equals(this.m_Target, o.m_Target) && Bridge.equals(this.m_StartColor, o.m_StartColor) && Bridge.equals(this.m_TargetColor, o.m_TargetColor) && Bridge.equals(this.m_TweenMode, o.m_TweenMode) && Bridge.equals(this.m_Duration, o.m_Duration) && Bridge.equals(this.m_IgnoreTimeScale, o.m_IgnoreTimeScale);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.ColorTween#$clone", this ); }

                var s = to || new UnityEngine.UI.CoroutineTween.ColorTween();
                s.m_Target = this.m_Target;
                s.m_StartColor = this.m_StartColor.$clone();
                s.m_TargetColor = this.m_TargetColor.$clone();
                s.m_TweenMode = this.m_TweenMode;
                s.m_Duration = this.m_Duration;
                s.m_IgnoreTimeScale = this.m_IgnoreTimeScale;
                return s;
            }
        }
    });
    /*UnityEngine.UI.CoroutineTween.ColorTween end.*/

    /*UnityEngine.UI.CoroutineTween.FloatTween start.*/
    Bridge.define("UnityEngine.UI.CoroutineTween.FloatTween", {
        inherits: [UnityEngine.UI.CoroutineTween.ITweenValue],
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.FloatTween#getDefaultValue", this ); }
 return new UnityEngine.UI.CoroutineTween.FloatTween(); }
            }
        },
        fields: {
            m_Target: null,
            m_StartValue: 0,
            m_TargetValue: 0,
            m_Duration: 0,
            m_IgnoreTimeScale: false
        },
        props: {
            startValue: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.FloatTween#startValue#get", this ); }

                    return this.m_StartValue;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.FloatTween#startValue#set", this ); }

                    this.m_StartValue = value;
                }
            },
            targetValue: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.FloatTween#targetValue#get", this ); }

                    return this.m_TargetValue;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.FloatTween#targetValue#set", this ); }

                    this.m_TargetValue = value;
                }
            },
            duration: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.FloatTween#duration#get", this ); }

                    return this.m_Duration;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.FloatTween#duration#set", this ); }

                    this.m_Duration = value;
                }
            },
            ignoreTimeScale: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.FloatTween#ignoreTimeScale#get", this ); }

                    return this.m_IgnoreTimeScale;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.FloatTween#ignoreTimeScale#set", this ); }

                    this.m_IgnoreTimeScale = value;
                }
            }
        },
        alias: [
            "duration", "UnityEngine$UI$CoroutineTween$ITweenValue$duration",
            "ignoreTimeScale", "UnityEngine$UI$CoroutineTween$ITweenValue$ignoreTimeScale",
            "TweenValue", "UnityEngine$UI$CoroutineTween$ITweenValue$TweenValue",
            "ValidTarget", "UnityEngine$UI$CoroutineTween$ITweenValue$ValidTarget"
        ],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.FloatTween#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*UnityEngine.UI.CoroutineTween.FloatTween.TweenValue start.*/
            TweenValue: function (floatPercentage) {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.FloatTween#TweenValue", this ); }

                if (!this.ValidTarget()) {
                    return;
                }

                this.m_Target.Invoke(pc.math.lerp(this.m_StartValue, this.m_TargetValue, floatPercentage));
            },
            /*UnityEngine.UI.CoroutineTween.FloatTween.TweenValue end.*/

            /*UnityEngine.UI.CoroutineTween.FloatTween.AddOnChangedCallback start.*/
            AddOnChangedCallback: function (callback) {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.FloatTween#AddOnChangedCallback", this ); }

                if (this.m_Target == null) {
                    this.m_Target = new UnityEngine.UI.CoroutineTween.FloatTween.FloatTweenCallback();
                }

                this.m_Target.AddListener(callback);
            },
            /*UnityEngine.UI.CoroutineTween.FloatTween.AddOnChangedCallback end.*/

            /*UnityEngine.UI.CoroutineTween.FloatTween.GetIgnoreTimescale start.*/
            GetIgnoreTimescale: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.FloatTween#GetIgnoreTimescale", this ); }

                return this.m_IgnoreTimeScale;
            },
            /*UnityEngine.UI.CoroutineTween.FloatTween.GetIgnoreTimescale end.*/

            /*UnityEngine.UI.CoroutineTween.FloatTween.GetDuration start.*/
            GetDuration: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.FloatTween#GetDuration", this ); }

                return this.m_Duration;
            },
            /*UnityEngine.UI.CoroutineTween.FloatTween.GetDuration end.*/

            /*UnityEngine.UI.CoroutineTween.FloatTween.ValidTarget start.*/
            ValidTarget: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.FloatTween#ValidTarget", this ); }

                return this.m_Target != null;
            },
            /*UnityEngine.UI.CoroutineTween.FloatTween.ValidTarget end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.FloatTween#getHashCode", this ); }

                var h = Bridge.addHash([3337039647, this.m_Target, this.m_StartValue, this.m_TargetValue, this.m_Duration, this.m_IgnoreTimeScale]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.FloatTween#equals", this ); }

                if (!Bridge.is(o, UnityEngine.UI.CoroutineTween.FloatTween)) {
                    return false;
                }
                return Bridge.equals(this.m_Target, o.m_Target) && Bridge.equals(this.m_StartValue, o.m_StartValue) && Bridge.equals(this.m_TargetValue, o.m_TargetValue) && Bridge.equals(this.m_Duration, o.m_Duration) && Bridge.equals(this.m_IgnoreTimeScale, o.m_IgnoreTimeScale);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.FloatTween#$clone", this ); }

                var s = to || new UnityEngine.UI.CoroutineTween.FloatTween();
                s.m_Target = this.m_Target;
                s.m_StartValue = this.m_StartValue;
                s.m_TargetValue = this.m_TargetValue;
                s.m_Duration = this.m_Duration;
                s.m_IgnoreTimeScale = this.m_IgnoreTimeScale;
                return s;
            }
        }
    });
    /*UnityEngine.UI.CoroutineTween.FloatTween end.*/

    /*UnityEngine.UI.CoroutineTween.TweenRunner$1 start.*/
    Bridge.define("UnityEngine.UI.CoroutineTween.TweenRunner$1", function (T) { return {
        statics: {
            methods: {
                /*UnityEngine.UI.CoroutineTween.TweenRunner$1.Start:static start.*/
                Start: function (tweenInfo) {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.TweenRunner$1#Start", this ); }

                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        elapsedTime,
                        percentage,
                        $async_e;

                    var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        if (!Bridge.rValue(tweenInfo).UnityEngine$UI$CoroutineTween$ITweenValue$ValidTarget()) {
                                                $step = 1;
                                                continue;
                                            } 
                                            $step = 2;
                                            continue;
                                    }
                                    case 1: {
                                        return false;
                                    }
                                    case 2: {
                                        elapsedTime = 0.0;
                                        $step = 3;
                                        continue;
                                    }
                                    case 3: {
                                        if ( elapsedTime < Bridge.rValue(tweenInfo).UnityEngine$UI$CoroutineTween$ITweenValue$duration ) {
                                                $step = 4;
                                                continue;
                                            } 
                                            $step = 6;
                                            continue;
                                    }
                                    case 4: {
                                        elapsedTime += Bridge.rValue(tweenInfo).UnityEngine$UI$CoroutineTween$ITweenValue$ignoreTimeScale ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime;
                                            percentage = Math.max(0, Math.min(1, elapsedTime / Bridge.rValue(tweenInfo).UnityEngine$UI$CoroutineTween$ITweenValue$duration));
                                        Bridge.rValue(    tweenInfo).UnityEngine$UI$CoroutineTween$ITweenValue$TweenValue(percentage);
                                            $enumerator.current = null;
                                            $step = 5;
                                            return true;
                                    }
                                    case 5: {
                                        
                                            $step = 3;
                                            continue;
                                    }
                                    case 6: {
                                        Bridge.rValue(tweenInfo).UnityEngine$UI$CoroutineTween$ITweenValue$TweenValue(1.0);

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            throw $async_e;
                        }
                    }));
                    return $enumerator;
                },
                /*UnityEngine.UI.CoroutineTween.TweenRunner$1.Start:static end.*/


            }
        },
        fields: {
            m_CoroutineContainer: null,
            m_Tween: null
        },
        methods: {
            /*UnityEngine.UI.CoroutineTween.TweenRunner$1.Init start.*/
            Init: function (coroutineContainer) {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.TweenRunner$1#Init", this ); }

                this.m_CoroutineContainer = coroutineContainer;
            },
            /*UnityEngine.UI.CoroutineTween.TweenRunner$1.Init end.*/

            /*UnityEngine.UI.CoroutineTween.TweenRunner$1.StartTween start.*/
            StartTween: function (info) {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.TweenRunner$1#StartTween", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.m_CoroutineContainer, null)) {
                    UnityEngine.Debug.LogWarning$1("Coroutine container not configured... did you forget to call Init?");
                    return;
                }

                this.StopTween();

                if (!this.m_CoroutineContainer.gameObject.activeInHierarchy) {
Bridge.rValue(                    info).UnityEngine$UI$CoroutineTween$ITweenValue$TweenValue(1.0);
                    return;
                }

                this.m_Tween = UnityEngine.UI.CoroutineTween.TweenRunner$1(T).Start(Bridge.rValue(info));
                this.m_CoroutineContainer.StartCoroutine$1(this.m_Tween);
            },
            /*UnityEngine.UI.CoroutineTween.TweenRunner$1.StartTween end.*/

            /*UnityEngine.UI.CoroutineTween.TweenRunner$1.StopTween start.*/
            StopTween: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.CoroutineTween.TweenRunner$1#StopTween", this ); }

                if (this.m_Tween != null) {
                    this.m_CoroutineContainer.StopCoroutine(this.m_Tween);
                    this.m_Tween = null;
                }
            },
            /*UnityEngine.UI.CoroutineTween.TweenRunner$1.StopTween end.*/


        }
    }; });
    /*UnityEngine.UI.CoroutineTween.TweenRunner$1 end.*/
    /** @namespace UnityEngine.Events */

    /**
     * @memberof UnityEngine.Events
     * @callback UnityEngine.Events.UnityAction
     * @return  {void}
     */


    /*UnityEngine.UI.Graphic start.*/
    Bridge.define("UnityEngine.UI.Graphic", {
        inherits: [UnityEngine.EventSystems.UIBehaviour,UnityEngine.UI.ICanvasElement],
        statics: {
            fields: {
                s_DefaultUI: null,
                s_WhiteTexture: null,
                s_VertexHelper: null
            },
            props: {
                /**
                 * <p>Default material used to draw UI elements if no explicit material was specified.</p>
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof UnityEngine.UI.Graphic
                 * @function defaultGraphicMaterial
                 * @type UnityEngine.Material
                 */
                defaultGraphicMaterial: {
                    get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#defaultGraphicMaterial#get", this ); }

                        if (this.s_DefaultUI === null) {
                            UnityEngine.UI.Graphic.s_DefaultUI = UnityEngine.Canvas.GetDefaultCanvasMaterial();
                        }

                        return UnityEngine.UI.Graphic.s_DefaultUI;
                    }
                }
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#init", this ); }

                    this.s_DefaultUI = null;
                    this.s_WhiteTexture = null;
                    this.s_VertexHelper = new UnityEngine.UI.VertexHelper.ctor();
                }
            },
            methods: {
                /*UnityEngine.UI.Graphic.CreateColorFromAlpha:static start.*/
                CreateColorFromAlpha: function (alpha) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#CreateColorFromAlpha", this ); }

                    var black = new pc.Color( 0, 0, 0, 1 );
                    black.a = alpha;
                    return black.$clone();
                },
                /*UnityEngine.UI.Graphic.CreateColorFromAlpha:static end.*/


            }
        },
        fields: {
            m_CanvasRenderer: null,
            m_ColorTweenRunner: null,
            m_OnDirtyMaterialCallback: null,
            m_OnDirtyVertsCallback: null,
            m_OnDirtyLayoutCallback: null,
            m_SkipLayoutUpdate: false,
            m_SkipMaterialUpdate: false,
            m_VertsDirty: false,
            m_MaterialDirty: false,
            useLegacyMeshGeneration: false,
            /**
             * The m material.
             *
             * @instance
             * @protected
             * @memberof UnityEngine.UI.Graphic
             * @type UnityEngine.Material
             */
            m_Material: null,
            m_RaycastTarget: false,
            groupBlocksRaycasts: false,
            /**
             * The color of the m.
             *
             * @instance
             * @protected
             * @memberof UnityEngine.UI.Graphic
             * @type UnityEngine.Color
             */
            m_Color: null,
            lastSetColor: null,
            modifiedMesh: null
        },
        props: {
            /**
             * Gets the canvas.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.Graphic
             * @function canvas
             * @type UnityEngine.Canvas
             */
            canvas: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#canvas#get", this ); }

                    return UnityEngine.Object.FromHandle(UnityEngine.Canvas, this.handle.entity.element._nearestScreen);
                }
            },
            /**
             * The material that will be sent for Rendering.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.Graphic
             * @function materialForRendering
             * @type UnityEngine.Material
             */
            materialForRendering: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#materialForRendering#get", this ); }

                    var modifiedMaterial = this.material;

                    
                var modifyMaterialMethods = this.gameObject.handle._magicMethods 
                    ? this.gameObject.handle._magicMethods[ 'UnityEngine$UI$IMaterialModifier$GetModifiedMaterial' ] 
                    : null;

                if ( modifyMaterialMethods ) {
                    for( var i = 0; i < modifyMaterialMethods.length; i++ ) {
                       modifiedMaterial = modifyMaterialMethods[ i ].code[ 'UnityEngine$UI$IMaterialModifier$GetModifiedMaterial' ]( modifiedMaterial );
                    }
                };

                    return modifiedMaterial;
                }
            },
            /**
             * <p>Returns the default material for the graphic.</p>
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.Graphic
             * @function defaultMaterial
             * @type UnityEngine.Material
             */
            defaultMaterial: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#defaultMaterial#get", this ); }

                    return UnityEngine.UI.Graphic.defaultGraphicMaterial;
                }
            },
            /**
             * <p>The CanvasRenderer used by this Graphic.</p>
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.Graphic
             * @function canvasRenderer
             * @type UnityEngine.CanvasRenderer
             */
            canvasRenderer: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#canvasRenderer#get", this ); }

                    if (this.m_CanvasRenderer === null) {
                        this.m_CanvasRenderer = this.GetComponent(UnityEngine.CanvasRenderer);
                    }

                    return this.m_CanvasRenderer;
                }
            },
            /**
             * Gets or sets the rect transform.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Graphic
             * @function rectTransform
             * @type UnityEngine.RectTransform
             */
            rectTransform: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#rectTransform#get", this ); }

                    return UnityEngine.Object.FromHandle(UnityEngine.RectTransform, this.handle.entity);
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#rectTransform#set", this ); }

                    throw new System.NotImplementedException.ctor();
                }
            },
            /**
             * Gets the main texture.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.Graphic
             * @function mainTexture
             * @type UnityEngine.Texture
             */
            mainTexture: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#mainTexture#get", this ); }

                    return this.defaultMaterial.mainTexture;
                }
            },
            /**
             * Absolute depth of the graphic, used by rendering and events -- lowest to highest.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.Graphic
             * @function depth
             * @type number
             * @example The depth is relative to the first root canvas.
             Canvas
              Graphic - 1
              Graphic - 2
              Nested Canvas
                 Graphic - 3
                 Graphic - 4
              Graphic - 5
             This value is used to determine draw and event ordering.
             *
             *
             */
            depth: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#depth#get", this ); }

                    return this.canvasRenderer.absoluteDepth;
                }
            },
            /**
             * Gets or sets the material.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Graphic
             * @function material
             * @type UnityEngine.Material
             */
            material: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#material#get", this ); }

                    return this.m_Material != null ? this.m_Material : this.defaultMaterial;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#material#set", this ); }

                    if (Bridge.referenceEquals(this.m_Material, value)) {
                        return;
                    }

                    this.m_Material = value;
                    this.handle.entity.element.material = value != null ? value.handle : null;
                    this.SetMaterialDirty();
                }
            },
            /**
             * Gets or sets a value indicating whether this {@link } raycast target.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Graphic
             * @function raycastTarget
             * @type boolean
             */
            raycastTarget: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#raycastTarget#get", this ); }

                    return this.m_RaycastTarget && this.groupBlocksRaycasts;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#raycastTarget#set", this ); }

                    this.m_RaycastTarget = value;
                }
            },
            /**
             * Gets or sets the color.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Graphic
             * @function color
             * @type UnityEngine.Color
             */
            color: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#color#get", this ); }

                    return this.m_Color.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#color#set", this ); }

                    this.lastSetColor.copy( value.$clone() );
                    this.m_Color.copy( value.$clone() );
                    this.entity.element.color = this.m_Color.$clone();
                    this.SetVerticesDirty();
                }
            }
        },
        alias: [
            "Rebuild", "UnityEngine$UI$ICanvasElement$Rebuild",
            "LayoutComplete", "UnityEngine$UI$ICanvasElement$LayoutComplete",
            "GraphicUpdateComplete", "UnityEngine$UI$ICanvasElement$GraphicUpdateComplete",
            "IsDestroyed", "UnityEngine$UI$ICanvasElement$IsDestroyed",
            "transform", "UnityEngine$UI$ICanvasElement$transform"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#init", this ); }

                this.m_Color = new UnityEngine.Color();
                this.lastSetColor = new UnityEngine.Color();
                this.m_VertsDirty = false;
                this.m_MaterialDirty = false;
                this.m_RaycastTarget = true;
                this.groupBlocksRaycasts = true;
                this.m_Color = new pc.Color( 1, 1, 1, 1 );
                this.lastSetColor = new pc.Color( 1, 1, 1, 1 );
            },
            /**
             * Initializes a new instance of the {@link } class.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.Graphic
             * @memberof UnityEngine.UI.Graphic
             * @return  {void}
             */
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#ctor", this ); }

                this.$initialize();
                UnityEngine.EventSystems.UIBehaviour.$ctor1.call(this, null);
                if (this.m_ColorTweenRunner == null) {
                    this.m_ColorTweenRunner = new (UnityEngine.UI.CoroutineTween.TweenRunner$1(UnityEngine.UI.CoroutineTween.ColorTween))();
                }

                this.m_ColorTweenRunner.Init(this);
                this.useLegacyMeshGeneration = true;
            },
            /**
             * Initializes a new instance of the {@link } class.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.Graphic
             * @memberof UnityEngine.UI.Graphic
             * @param   {pc.ElementComponent}    handle    Handle.
             * @return  {void}
             */
            $ctor1: function (handle) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#$ctor1", this ); }

                this.$initialize();
                UnityEngine.EventSystems.UIBehaviour.$ctor1.call(this, handle);
                if (this.m_ColorTweenRunner == null) {
                    this.m_ColorTweenRunner = new (UnityEngine.UI.CoroutineTween.TweenRunner$1(UnityEngine.UI.CoroutineTween.ColorTween))();
                }

                this.m_ColorTweenRunner.Init(this);
                this.useLegacyMeshGeneration = true;
            }
        },
        methods: {
            /*UnityEngine.UI.Graphic.AssignDefaultFont start.*/
            AssignDefaultFont: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#AssignDefaultFont", this ); }

                UnityEngine.Debug.LogWarning$1("Not Implement In Luna");
            },
            /*UnityEngine.UI.Graphic.AssignDefaultFont end.*/

            /*UnityEngine.UI.Graphic.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#Awake", this ); }

                UnityEngine.EventSystems.UIBehaviour.prototype.Awake.call(this);
                var isImageOrText = !!( this.entity.element._image || this.entity.element._text );
                if (isImageOrText) {
                    return;
                }

                this.OnPopulateMesh(UnityEngine.UI.Graphic.s_VertexHelper);
                var mesh = new UnityEngine.Mesh.ctor();
                UnityEngine.UI.Graphic.s_VertexHelper.FillMesh(mesh);
                this.canvasRenderer.SetMesh(mesh);
            },
            /*UnityEngine.UI.Graphic.Awake end.*/

            /*UnityEngine.UI.Graphic.SetNativeSize start.*/
            /**
             * Sets the size of the native.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Graphic
             * @memberof UnityEngine.UI.Graphic
             * @return  {void}
             */
            SetNativeSize: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#SetNativeSize", this ); }

                UnityEngine.Debug.LogWarning$1("Not Implemented In Luna");
                //throw new NotImplementedException();
            },
            /*UnityEngine.UI.Graphic.SetNativeSize end.*/

            /*UnityEngine.UI.Graphic.OnPopulateMesh start.*/
            /**
             * Ons the populate mesh.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.Graphic
             * @memberof UnityEngine.UI.Graphic
             * @param   {UnityEngine.UI.VertexHelper}    vh    Vh.
             * @return  {void}
             */
            OnPopulateMesh: function (vh) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#OnPopulateMesh", this ); }

                // we skip this method in UpdateGeometry - but use that as default method for derived types
                var pixelAdjustedRect = this.GetPixelAdjustedRect();
                var vector4 = new pc.Vec4( pixelAdjustedRect.x, pixelAdjustedRect.y, pixelAdjustedRect.x + pixelAdjustedRect.width, pixelAdjustedRect.y + pixelAdjustedRect.height );
                var color = UnityEngine.Color32.op_Implicit$1(this.color);
                vh.Clear();
                vh.AddVert$1(new pc.Vec3( vector4.x, vector4.y, 0 ), color.$clone(), new pc.Vec2( 0.0, 0.0 ));
                vh.AddVert$1(new pc.Vec3( vector4.x, vector4.w, 0 ), color.$clone(), new pc.Vec2( 0.0, 1.0 ));
                vh.AddVert$1(new pc.Vec3( vector4.z, vector4.w, 0 ), color.$clone(), new pc.Vec2( 1.0, 1.0 ));
                vh.AddVert$1(new pc.Vec3( vector4.z, vector4.y, 0 ), color.$clone(), new pc.Vec2( 1.0, 0.0 ));
                vh.AddTriangle(0, 1, 2);
                vh.AddTriangle(2, 3, 0);
            },
            /*UnityEngine.UI.Graphic.OnPopulateMesh end.*/

            /*UnityEngine.UI.Graphic.SetMaterialDirty start.*/
            /**
             * Sets the material dirty.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Graphic
             * @memberof UnityEngine.UI.Graphic
             * @return  {void}
             */
            SetMaterialDirty: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#SetMaterialDirty", this ); }

                if (!this.IsActive()) {
                    return;
                }

                this.m_MaterialDirty = true;
                UnityEngine.UI.CanvasUpdateRegistry.RegisterCanvasElementForGraphicRebuild(this);

                if (!Bridge.staticEquals(this.m_OnDirtyMaterialCallback, null)) {
                    this.m_OnDirtyMaterialCallback();
                }
            },
            /*UnityEngine.UI.Graphic.SetMaterialDirty end.*/

            /*UnityEngine.UI.Graphic.SetAllDirty start.*/
            /**
             * Sets all dirty.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Graphic
             * @memberof UnityEngine.UI.Graphic
             * @return  {void}
             */
            SetAllDirty: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#SetAllDirty", this ); }

                // Optimization: Graphic layout doesn't need recalculation if
                // the underlying Sprite is the same size with the same texture.
                // (e.g. Sprite sheet texture animation)

                if (this.m_SkipLayoutUpdate) {
                    this.m_SkipLayoutUpdate = false;
                } else {
                    this.SetLayoutDirty();
                }

                if (this.m_SkipMaterialUpdate) {
                    this.m_SkipMaterialUpdate = false;
                } else {
                    this.SetMaterialDirty();
                }

                this.SetVerticesDirty();
            },
            /*UnityEngine.UI.Graphic.SetAllDirty end.*/

            /*UnityEngine.UI.Graphic.Rebuild start.*/
            Rebuild: function (update) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#Rebuild", this ); }

                if (UnityEngine.Component.op_Equality(this.canvasRenderer, null) || this.canvasRenderer.cull) {
                    return;
                }

                if (update !== UnityEngine.UI.CanvasUpdate.PreRender) {
                    return;
                }

                switch (update) {
                    case UnityEngine.UI.CanvasUpdate.PreRender: 
                        if (this.m_VertsDirty) {
                            this.UpdateGeometry();
                            this.m_VertsDirty = false;
                        }
                        if (this.m_MaterialDirty) {
                            this.UpdateMaterial();
                            this.m_MaterialDirty = false;
                        }
                        break;
                }
            },
            /*UnityEngine.UI.Graphic.Rebuild end.*/

            /*UnityEngine.UI.Graphic.GetPixelAdjustedRect start.*/
            /**
             * Gets the pixel adjusted rect.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Graphic
             * @memberof UnityEngine.UI.Graphic
             * @return  {UnityEngine.Rect}        The pixel adjusted rect.
             */
            GetPixelAdjustedRect: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#GetPixelAdjustedRect", this ); }

                if (!UnityEngine.Object.op_Implicit(this.canvas) || this.canvas.renderMode === UnityEngine.RenderMode.WorldSpace || this.canvas.scaleFactor === 0.0 || !this.canvas.pixelPerfect) {
                    return this.rectTransform.rect.$clone();
                } else {
                    return UnityEngine.RectTransformUtility.PixelAdjustRect(this.rectTransform, this.canvas);
                }
            },
            /*UnityEngine.UI.Graphic.GetPixelAdjustedRect end.*/

            /*UnityEngine.UI.Graphic.OnSelect start.*/
            /**
             * Ons the select.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Graphic
             * @memberof UnityEngine.UI.Graphic
             * @param   {UnityEngine.EventSystems.BaseEventData}    eventData    Event data.
             * @return  {void}
             */
            OnSelect: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#OnSelect", this ); }
 },
            /*UnityEngine.UI.Graphic.OnSelect end.*/

            /*UnityEngine.UI.Graphic.OnDeselect start.*/
            /**
             * Ons the deselect.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Graphic
             * @memberof UnityEngine.UI.Graphic
             * @param   {UnityEngine.EventSystems.BaseEventData}    eventData    Event data.
             * @return  {void}
             */
            OnDeselect: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#OnDeselect", this ); }
 },
            /*UnityEngine.UI.Graphic.OnDeselect end.*/

            /*UnityEngine.UI.Graphic.OnSubmit start.*/
            /**
             * Ons the submit.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Graphic
             * @memberof UnityEngine.UI.Graphic
             * @param   {UnityEngine.EventSystems.BaseEventData}    eventData    Event data.
             * @return  {void}
             */
            OnSubmit: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#OnSubmit", this ); }
 },
            /*UnityEngine.UI.Graphic.OnSubmit end.*/

            /*UnityEngine.UI.Graphic.OnMove start.*/
            /**
             * Ons the move.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Graphic
             * @memberof UnityEngine.UI.Graphic
             * @param   {UnityEngine.EventSystems.AxisEventData}    eventData    Event data.
             * @return  {void}
             */
            OnMove: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#OnMove", this ); }
 },
            /*UnityEngine.UI.Graphic.OnMove end.*/

            /*UnityEngine.UI.Graphic.RegisterDirtyVerticesCallback start.*/
            /**
             * <p>Add a listener to receive notification when the graphics vertices are dirtied.</p>
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Graphic
             * @memberof UnityEngine.UI.Graphic
             * @param   {UnityEngine.Events.UnityAction}    action
             * @return  {void}
             */
            RegisterDirtyVerticesCallback: function (action) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#RegisterDirtyVerticesCallback", this ); }

                this.m_OnDirtyVertsCallback = Bridge.fn.combine(this.m_OnDirtyVertsCallback, action);
            },
            /*UnityEngine.UI.Graphic.RegisterDirtyVerticesCallback end.*/

            /*UnityEngine.UI.Graphic.UnregisterDirtyVerticesCallback start.*/
            /**
             * <p>Remove a listener from receiving notifications when the graphics vertices are dirtied.</p>
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Graphic
             * @memberof UnityEngine.UI.Graphic
             * @param   {UnityEngine.Events.UnityAction}    action    The delegate function to remove.
             * @return  {void}
             */
            UnregisterDirtyVerticesCallback: function (action) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#UnregisterDirtyVerticesCallback", this ); }

                this.m_OnDirtyVertsCallback = Bridge.fn.remove(this.m_OnDirtyVertsCallback, action);
            },
            /*UnityEngine.UI.Graphic.UnregisterDirtyVerticesCallback end.*/

            /*UnityEngine.UI.Graphic.RegisterDirtyMaterialCallback start.*/
            /**
             * <p>Add a listener to receive notification when the graphics material is dirtied.</p>
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Graphic
             * @memberof UnityEngine.UI.Graphic
             * @param   {UnityEngine.Events.UnityAction}    action
             * @return  {void}
             */
            RegisterDirtyMaterialCallback: function (action) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#RegisterDirtyMaterialCallback", this ); }

                this.m_OnDirtyMaterialCallback = Bridge.fn.combine(this.m_OnDirtyMaterialCallback, action);
            },
            /*UnityEngine.UI.Graphic.RegisterDirtyMaterialCallback end.*/

            /*UnityEngine.UI.Graphic.UnregisterDirtyMaterialCallback start.*/
            /**
             * <p>Remove a listener from receiving notifications when the graphics material is dirtied.</p>
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Graphic
             * @memberof UnityEngine.UI.Graphic
             * @param   {UnityEngine.Events.UnityAction}    action
             * @return  {void}
             */
            UnregisterDirtyMaterialCallback: function (action) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#UnregisterDirtyMaterialCallback", this ); }

                this.m_OnDirtyMaterialCallback = Bridge.fn.remove(this.m_OnDirtyMaterialCallback, action);
            },
            /*UnityEngine.UI.Graphic.UnregisterDirtyMaterialCallback end.*/

            /*UnityEngine.UI.Graphic.ConfigureForEntity start.*/
            /**
             * Configures for entity.
             *
             * @instance
             * @public
             * @override
             * @this UnityEngine.UI.Graphic
             * @memberof UnityEngine.UI.Graphic
             * @param   {pc.Entity}    entity    Entity.
             * @return  {void}
             */
            ConfigureForEntity: function (entity) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#ConfigureForEntity", this ); }

                UnityEngine.EventSystems.UIBehaviour.prototype.ConfigureForEntity.call(this, entity);
                entity.element["UnityEngine.UI.Graphic"] = this;
            },
            /*UnityEngine.UI.Graphic.ConfigureForEntity end.*/

            /*UnityEngine.UI.Graphic.CrossFadeAlpha start.*/
            /**
             * <p>Tweens the alpha of the CanvasRenderer color associated with this Graphic.</p>
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Graphic
             * @memberof UnityEngine.UI.Graphic
             * @param   {number}     alpha              Target alpha.
             * @param   {number}     duration           Duration of the tween in seconds.
             * @param   {boolean}    ignoreTimeScale    Should ignore Time.scale?
             * @return  {void}
             */
            CrossFadeAlpha: function (alpha, duration, ignoreTimeScale) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#CrossFadeAlpha", this ); }

                this.CrossFadeColor$1(UnityEngine.UI.Graphic.CreateColorFromAlpha(alpha), duration, ignoreTimeScale, true, false);
            },
            /*UnityEngine.UI.Graphic.CrossFadeAlpha end.*/

            /*UnityEngine.UI.Graphic.CrossFadeColor start.*/
            /**
             * <p>Tweens the CanvasRenderer color associated with this Graphic.</p>
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Graphic
             * @memberof UnityEngine.UI.Graphic
             * @param   {UnityEngine.Color}    targetColor        Target color.
             * @param   {number}               duration           Tween duration.
             * @param   {boolean}              ignoreTimeScale    Should ignore Time.scale?
             * @param   {boolean}              useAlpha           Should also Tween the alpha channel?
             * @return  {void}
             */
            CrossFadeColor: function (targetColor, duration, ignoreTimeScale, useAlpha) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#CrossFadeColor", this ); }

                this.CrossFadeColor$1(targetColor.$clone(), duration, ignoreTimeScale, useAlpha, true);
            },
            /*UnityEngine.UI.Graphic.CrossFadeColor end.*/

            /*UnityEngine.UI.Graphic.CrossFadeColor$1 start.*/
            CrossFadeColor$1: function (targetColor, duration, ignoreTimeScale, useAlpha, useRGB) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#CrossFadeColor$1", this ); }

                var $t;
                if (UnityEngine.Component.op_Equality(this.canvasRenderer, null) || !useRGB && !useAlpha) {
                    return;
                }

                if (this.canvasRenderer.GetColor().strictEquals( targetColor )) {
                    this.m_ColorTweenRunner.StopTween();
                } else {
                    var colorTweenMode = !useRGB || !useAlpha ? !useRGB ? UnityEngine.UI.CoroutineTween.ColorTween.ColorTweenMode.Alpha : UnityEngine.UI.CoroutineTween.ColorTween.ColorTweenMode.RGB : UnityEngine.UI.CoroutineTween.ColorTween.ColorTweenMode.All;
                    var info = ($t = new UnityEngine.UI.CoroutineTween.ColorTween(), $t.duration = duration, $t.startColor = this.canvasRenderer.GetColor(), $t.targetColor = targetColor.$clone(), $t);

                    info.AddOnChangedCallback(Bridge.fn.cacheBind(this.canvasRenderer, this.canvasRenderer.SetColor));
                    info.ignoreTimeScale = ignoreTimeScale;
                    info.tweenMode = colorTweenMode;
                    this.m_ColorTweenRunner.StartTween(info.$clone());
                }
            },
            /*UnityEngine.UI.Graphic.CrossFadeColor$1 end.*/

            /*UnityEngine.UI.Graphic.SetLayoutDirty start.*/
            /**
             * Marks the layout as dirty and requiring a layout pass.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Graphic
             * @memberof UnityEngine.UI.Graphic
             * @return  {void}
             */
            SetLayoutDirty: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#SetLayoutDirty", this ); }

                if (!this.IsActive()) {
                    return;
                }

                UnityEngine.UI.LayoutRebuilder.MarkLayoutForRebuild(this.rectTransform);

                if (!Bridge.staticEquals(this.m_OnDirtyLayoutCallback, null)) {
                    this.m_OnDirtyLayoutCallback();
                }
            },
            /*UnityEngine.UI.Graphic.SetLayoutDirty end.*/

            /*UnityEngine.UI.Graphic.SetVerticesDirty start.*/
            /**
             * Mark the vertices as dirty and needing rebuilt.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Graphic
             * @memberof UnityEngine.UI.Graphic
             * @return  {void}
             */
            SetVerticesDirty: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#SetVerticesDirty", this ); }

                if (!this.IsActive()) {
                    return;
                }

                this.m_VertsDirty = true;
                UnityEngine.UI.CanvasUpdateRegistry.RegisterCanvasElementForGraphicRebuild(this);

                if (!Bridge.staticEquals(this.m_OnDirtyVertsCallback, null)) {
                    this.m_OnDirtyVertsCallback();
                }
            },
            /*UnityEngine.UI.Graphic.SetVerticesDirty end.*/

            /*UnityEngine.UI.Graphic.UpdateGeometry start.*/
            /**
             * Updates the geometry.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.Graphic
             * @memberof UnityEngine.UI.Graphic
             * @return  {void}
             */
            UpdateGeometry: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#UpdateGeometry", this ); }

                this.handle.entity.element.setVerticesDirty();
                
                var modifyMeshMethods = this.gameObject.handle._magicMethods ? this.gameObject.handle._magicMethods[ 'UnityEngine$UI$IMeshModifier$ModifyMesh$1' ] : null;
                var hasOnPopulateMesh = this.OnPopulateMesh !== UnityEngine.UI.Graphic.prototype.OnPopulateMesh;
                var hasMeshModifications = ( modifyMeshMethods || hasOnPopulateMesh );

                if (!hasMeshModifications) {
                    return;
                }

                // update the mesh
                var mesh = UnityEngine.Object.FromHandle(UnityEngine.Mesh, this.entity.element._image ? this.entity.element._image._mesh : ( this.entity.element._text ? this.entity.element._text._mesh : null )) || new UnityEngine.Mesh.ctor();
                // check that we have a valid override of the method
                if (hasOnPopulateMesh) {
                    // invoke the OnPopulateMesh() callback
                    this.OnPopulateMesh(UnityEngine.UI.Graphic.s_VertexHelper);
                } else {
                    UnityEngine.UI.Graphic.s_VertexHelper.FromMesh(mesh);
                }

                this.modifiedMesh = this.modifiedMesh || new UnityEngine.Mesh.ctor();

                
            if ( modifyMeshMethods ) {
                for( var i = 0; i < modifyMeshMethods.length; i++ ) {
                   modifyMeshMethods[ i ].code[ 'UnityEngine$UI$IMeshModifier$ModifyMesh$1' ]( UnityEngine.UI.Graphic.s_VertexHelper );
                }
            };

                UnityEngine.UI.Graphic.s_VertexHelper.FillMesh(this.modifiedMesh);
                this.canvasRenderer.SetMesh(this.modifiedMesh);

                // make sure the material is set as well
                if (this.canvasRenderer.materialCount === 0) {
                    this.canvasRenderer.SetMaterial(UnityEngine.UI.Graphic.defaultGraphicMaterial, 0);
                }
            },
            /*UnityEngine.UI.Graphic.UpdateGeometry end.*/

            /*UnityEngine.UI.Graphic.UpdateMaterial start.*/
            /**
             * Call to update the Material of the graphic onto the CanvasRenderer.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.Graphic
             * @memberof UnityEngine.UI.Graphic
             * @return  {void}
             */
            UpdateMaterial: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#UpdateMaterial", this ); }

                this.canvasRenderer.materialCount = 1;
                this.canvasRenderer.SetMaterial(this.materialForRendering, 0);
                this.canvasRenderer.SetTexture(this.mainTexture);
            },
            /*UnityEngine.UI.Graphic.UpdateMaterial end.*/

            /*UnityEngine.UI.Graphic.OnCanvasGroupChanged start.*/
            /**
             * Callback that's called after canvas groups in hierarchy is changed.
             *
             * @instance
             * @protected
             * @override
             * @this UnityEngine.UI.Graphic
             * @memberof UnityEngine.UI.Graphic
             * @return  {void}
             */
            OnCanvasGroupChanged: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#OnCanvasGroupChanged", this ); }

                this.groupBlocksRaycasts = UnityEngine.CanvasGroup.ExtractBlocksRaycast(this.handle.entity.element._canvasGroups);
                this.SetVerticesDirty();
            },
            /*UnityEngine.UI.Graphic.OnCanvasGroupChanged end.*/

            /*UnityEngine.UI.Graphic.Raycast start.*/
            /**
             * When a GraphicRaycaster is raycasting into the scene it does two things. First it filters the elements using their RectTransform rect. Then it uses this Raycast function to determine the elements hit by the raycast.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Graphic
             * @memberof UnityEngine.UI.Graphic
             * @param   {UnityEngine.Vector2}    screenPoint    Screen point being tested
             * @param   {UnityEngine.Camera}     eventCamera    Camera that is being used for the testing.
             * @return  {boolean}                               True if the provided point is a valid location for GraphicRaycaster raycasts.
             */
            Raycast: function (screenPoint, eventCamera) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#Raycast", this ); }

                
                if (!this.isActiveAndEnabled) {
                    return false;
                }

                var screenPointTmp = new pc.Vec2();
                var entity = this.entity;

                var ignoreParentGroups = false;
                var continueTraversal = true;

                while ( entity ) {
                    var element = entity.element;
                    var screen = element ? element._nearestScreen : null;
                    var canvasGroups = entity._canvasGroups;
                    var raycastFilters = entity._magicMethods ? entity._magicMethods[ 'UnityEngine$ICanvasRaycastFilter$IsRaycastLocationValid' ] || []: [];
                    if ( screen && !screen.enabled ) {
                        return false;
                    }
                    if ( screen && screen.overrideSorting ) {
                        continueTraversal = false;
                    }

                    for ( var i = 0; i < raycastFilters.length; i++ ) {
                        var filter = raycastFilters[ i ];
                        var raycastValid = true;
                        screenPointTmp.copy( screenPoint );
                        var group = canvasGroups.length === 0 ? null : canvasGroups[ 0 ];
                        group = group && group.gameObject.handle === entity ? group : null;
                        if ( group ) {
                            if ( ignoreParentGroups === false && group.ignoreParentGroups ) {
                                ignoreParentGroups = true;
                                raycastValid = filter.code.IsRaycastLocationValid( screenPointTmp, eventCamera );
                            } else if (!ignoreParentGroups) {
                                raycastValid = filter.code.IsRaycastLocationValid( screenPointTmp, eventCamera );
                            }
                        } else {
                            raycastValid = filter.code.IsRaycastLocationValid( screenPointTmp, eventCamera );
                        }

                        if ( !raycastValid ) {
                            return false;
                        }
                    }

                    entity = continueTraversal ? entity.parent : null;
                }

                return true;
                return true;
            },
            /*UnityEngine.UI.Graphic.Raycast end.*/

            /*UnityEngine.UI.Graphic.LayoutComplete start.*/
            LayoutComplete: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#LayoutComplete", this ); }
 },
            /*UnityEngine.UI.Graphic.LayoutComplete end.*/

            /*UnityEngine.UI.Graphic.GraphicUpdateComplete start.*/
            GraphicUpdateComplete: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#GraphicUpdateComplete", this ); }
 },
            /*UnityEngine.UI.Graphic.GraphicUpdateComplete end.*/

            /*UnityEngine.UI.Graphic.OnRectTransformDimensionsChange start.*/
            /**
             * Handles rect transform resize.
             *
             * @instance
             * @protected
             * @override
             * @this UnityEngine.UI.Graphic
             * @memberof UnityEngine.UI.Graphic
             * @return  {void}
             */
            OnRectTransformDimensionsChange: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#OnRectTransformDimensionsChange", this ); }

                if (this.gameObject.activeInHierarchy) {
                    // prevent double dirtying...
                    if (UnityEngine.UI.CanvasUpdateRegistry.IsRebuildingLayout()) {
                        this.SetVerticesDirty();
                    } else {
                        this.SetVerticesDirty();
                        this.SetLayoutDirty();
                    }
                }
            },
            /*UnityEngine.UI.Graphic.OnRectTransformDimensionsChange end.*/

            /*UnityEngine.UI.Graphic.OnDidApplyAnimationProperties start.*/
            OnDidApplyAnimationProperties: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#OnDidApplyAnimationProperties", this ); }

                // [EN-1288] Graphic.OnDidApplyAnimationProperty check all fields update. Check called every frame by animator, even if rect is not changed
                // SetAllDirty();
                if (!this.lastSetColor.strictEquals( this.m_Color )) {
                    // as in animator we change m_Color field, we need to make sure
                    // that vertices is dirty now and color passed to element
                    this.color = this.m_Color.$clone();
                }
            },
            /*UnityEngine.UI.Graphic.OnDidApplyAnimationProperties end.*/

            /*UnityEngine.UI.Graphic.OnTransformParentChanged start.*/
            /**
             * Handles the change in parent node.
             *
             * @instance
             * @protected
             * @override
             * @this UnityEngine.UI.Graphic
             * @memberof UnityEngine.UI.Graphic
             * @return  {void}
             */
            OnTransformParentChanged: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#OnTransformParentChanged", this ); }

                UnityEngine.EventSystems.UIBehaviour.prototype.OnTransformParentChanged.call(this);

                if (!this.IsActive()) {
                    return;
                }

                UnityEngine.UI.GraphicRegistry.RegisterGraphicForCanvas(this.canvas, this);
                this.SetAllDirty();
            },
            /*UnityEngine.UI.Graphic.OnTransformParentChanged end.*/

            /*UnityEngine.UI.Graphic.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#OnEnable", this ); }

                UnityEngine.EventSystems.UIBehaviour.prototype.OnEnable.call(this);
                UnityEngine.UI.GraphicRegistry.RegisterGraphicForCanvas(this.canvas, this);
                this.SetAllDirty();
            },
            /*UnityEngine.UI.Graphic.OnEnable end.*/

            /*UnityEngine.UI.Graphic.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#OnDisable", this ); }

                UnityEngine.UI.GraphicRegistry.UnregisterGraphicForCanvas(this.canvas, this);
                UnityEngine.UI.CanvasUpdateRegistry.UnRegisterCanvasElementForRebuild(this);

                UnityEngine.UI.LayoutRebuilder.MarkLayoutForRebuild(this.rectTransform);

                UnityEngine.EventSystems.UIBehaviour.prototype.OnDisable.call(this);
            },
            /*UnityEngine.UI.Graphic.OnDisable end.*/

            /*UnityEngine.UI.Graphic.OnCanvasChanged start.*/
            /**
             * Called from JS when parent canvas has changed to update graphic in registry
             *
             * @instance
             * @private
             * @this UnityEngine.UI.Graphic
             * @memberof UnityEngine.UI.Graphic
             * @param   {UnityEngine.Canvas}    previousCanvas    Previous parent canvas to unregister from
             * @param   {UnityEngine.Canvas}    newCanvas         New parent canvas to register to
             * @return  {void}
             */
            OnCanvasChanged: function (previousCanvas, newCanvas) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#OnCanvasChanged", this ); }

                UnityEngine.UI.GraphicRegistry.UnregisterGraphicForCanvas(previousCanvas, this);
                UnityEngine.UI.GraphicRegistry.RegisterGraphicForCanvas(newCanvas, this);

                this.OnCanvasHierarchyChanged();
            },
            /*UnityEngine.UI.Graphic.OnCanvasChanged end.*/

            /*UnityEngine.UI.Graphic.PixelAdjustPoint start.*/
            /**
             * Adjusts the given pixel to be pixel perfect.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Graphic
             * @memberof UnityEngine.UI.Graphic
             * @param   {UnityEngine.Vector2}    point    Local space point.
             * @return  {UnityEngine.Vector2}             Pixel perfect adjusted point.
             */
            PixelAdjustPoint: function (point) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Graphic#PixelAdjustPoint", this ); }

                if (!UnityEngine.Object.op_Implicit(this.canvas) || this.canvas.renderMode === UnityEngine.RenderMode.WorldSpace || this.canvas.scaleFactor === 0.0 || !this.canvas.pixelPerfect) {
                    return point.$clone();
                } else {
                    return UnityEngine.RectTransformUtility.PixelAdjustPoint(point.$clone(), this.transform, this.canvas);
                }
            },
            /*UnityEngine.UI.Graphic.PixelAdjustPoint end.*/


        },
        overloads: {
            "CrossFadeColor(Color, float, bool, bool, bool)": "CrossFadeColor$1"
        }
    });
    /*UnityEngine.UI.Graphic end.*/

    /*UnityEngine.UI.ILayoutGroup start.*/
    /**
     * ILayoutGroup is an ILayoutController that should drive the RectTransforms of its children.
     *
     * @abstract
     * @public
     * @class UnityEngine.UI.ILayoutGroup
     * @implements  UnityEngine.UI.ILayoutController
     */
    Bridge.define("UnityEngine.UI.ILayoutGroup", {
        inherits: [UnityEngine.UI.ILayoutController],
        $kind: 3
    });
    /*UnityEngine.UI.ILayoutGroup end.*/

    /*UnityEngine.UI.LayoutElement start.*/
    Bridge.define("UnityEngine.UI.LayoutElement", {
        inherits: [UnityEngine.EventSystems.UIBehaviour,UnityEngine.UI.ILayoutElement,UnityEngine.UI.ILayoutIgnorer],
        fields: {
            m_FlexibleHeight: 0,
            m_FlexibleWidth: 0,
            m_IgnoreLayout: false,
            m_MinHeight: 0,
            m_MinWidth: 0,
            m_PreferredHeight: 0,
            m_PreferredWidth: 0
        },
        props: {
            minWidth: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutElement#minWidth#get", this ); }

                    return this.m_MinWidth;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutElement#minWidth#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetStruct(System.Single, Bridge.ref(this, "m_MinWidth"), value)) {
                        this.SetDirty();
                    }
                }
            },
            minHeight: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutElement#minHeight#get", this ); }

                    return this.m_MinHeight;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutElement#minHeight#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetStruct(System.Single, Bridge.ref(this, "m_MinHeight"), value)) {
                        this.SetDirty();
                    }
                }
            },
            preferredWidth: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutElement#preferredWidth#get", this ); }

                    return this.m_PreferredWidth;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutElement#preferredWidth#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetStruct(System.Single, Bridge.ref(this, "m_PreferredWidth"), value)) {
                        this.SetDirty();
                    }
                }
            },
            preferredHeight: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutElement#preferredHeight#get", this ); }

                    return this.m_PreferredHeight;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutElement#preferredHeight#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetStruct(System.Single, Bridge.ref(this, "m_PreferredHeight"), value)) {
                        this.SetDirty();
                    }
                }
            },
            flexibleWidth: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutElement#flexibleWidth#get", this ); }

                    return this.m_FlexibleWidth;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutElement#flexibleWidth#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetStruct(System.Single, Bridge.ref(this, "m_FlexibleWidth"), value)) {
                        this.SetDirty();
                    }
                }
            },
            flexibleHeight: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutElement#flexibleHeight#get", this ); }

                    return this.m_FlexibleHeight;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutElement#flexibleHeight#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetStruct(System.Single, Bridge.ref(this, "m_FlexibleHeight"), value)) {
                        this.SetDirty();
                    }
                }
            },
            layoutPriority: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutElement#layoutPriority#get", this ); }

                    return 1;
                }
            },
            ignoreLayout: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutElement#ignoreLayout#get", this ); }

                    return this.m_IgnoreLayout;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutElement#ignoreLayout#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetStruct(System.Boolean, Bridge.ref(this, "m_IgnoreLayout"), value)) {
                        this.SetDirty();
                    }
                }
            }
        },
        alias: [
            "CalculateLayoutInputHorizontal", "UnityEngine$UI$ILayoutElement$CalculateLayoutInputHorizontal",
            "CalculateLayoutInputVertical", "UnityEngine$UI$ILayoutElement$CalculateLayoutInputVertical",
            "minWidth", "UnityEngine$UI$ILayoutElement$minWidth",
            "minHeight", "UnityEngine$UI$ILayoutElement$minHeight",
            "preferredWidth", "UnityEngine$UI$ILayoutElement$preferredWidth",
            "preferredHeight", "UnityEngine$UI$ILayoutElement$preferredHeight",
            "flexibleWidth", "UnityEngine$UI$ILayoutElement$flexibleWidth",
            "flexibleHeight", "UnityEngine$UI$ILayoutElement$flexibleHeight",
            "layoutPriority", "UnityEngine$UI$ILayoutElement$layoutPriority",
            "ignoreLayout", "UnityEngine$UI$ILayoutIgnorer$ignoreLayout"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutElement#init", this ); }

                this.m_FlexibleHeight = -1;
                this.m_FlexibleWidth = -1;
                this.m_MinHeight = -1;
                this.m_MinWidth = -1;
                this.m_PreferredHeight = -1;
                this.m_PreferredWidth = -1;
            }
        },
        methods: {
            /*UnityEngine.UI.LayoutElement.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutElement#OnEnable", this ); }

                UnityEngine.EventSystems.UIBehaviour.prototype.OnEnable.call(this);
                this.SetDirty();
            },
            /*UnityEngine.UI.LayoutElement.OnEnable end.*/

            /*UnityEngine.UI.LayoutElement.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutElement#OnDisable", this ); }

                this.SetDirty();
                UnityEngine.EventSystems.UIBehaviour.prototype.OnDisable.call(this);
            },
            /*UnityEngine.UI.LayoutElement.OnDisable end.*/

            /*UnityEngine.UI.LayoutElement.OnDidApplyAnimationProperties start.*/
            OnDidApplyAnimationProperties: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutElement#OnDidApplyAnimationProperties", this ); }

                this.SetDirty();
            },
            /*UnityEngine.UI.LayoutElement.OnDidApplyAnimationProperties end.*/

            /*UnityEngine.UI.LayoutElement.OnTransformParentChanged start.*/
            OnTransformParentChanged: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutElement#OnTransformParentChanged", this ); }

                this.SetDirty();
            },
            /*UnityEngine.UI.LayoutElement.OnTransformParentChanged end.*/

            /*UnityEngine.UI.LayoutElement.CalculateLayoutInputHorizontal start.*/
            CalculateLayoutInputHorizontal: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutElement#CalculateLayoutInputHorizontal", this ); }
 },
            /*UnityEngine.UI.LayoutElement.CalculateLayoutInputHorizontal end.*/

            /*UnityEngine.UI.LayoutElement.CalculateLayoutInputVertical start.*/
            CalculateLayoutInputVertical: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutElement#CalculateLayoutInputVertical", this ); }
 },
            /*UnityEngine.UI.LayoutElement.CalculateLayoutInputVertical end.*/

            /*UnityEngine.UI.LayoutElement.SetDirty start.*/
            SetDirty: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutElement#SetDirty", this ); }

                if (!this.IsActive()) {
                    return;
                }

                UnityEngine.UI.LayoutRebuilder.MarkLayoutForRebuild(Bridge.as(this.transform, UnityEngine.RectTransform));
            },
            /*UnityEngine.UI.LayoutElement.SetDirty end.*/


        }
    });
    /*UnityEngine.UI.LayoutElement end.*/

    /*UnityEngine.UI.LayoutRebuilder start.*/
    Bridge.define("UnityEngine.UI.LayoutRebuilder", {
        inherits: [UnityEngine.UI.ICanvasElement],
        statics: {
            fields: {
                /**
                 * Contains the pool of rebuilder objects.
                 *
                 * @static
                 * @protected
                 * @memberof UnityEngine.UI.LayoutRebuilder
                 * @type Array.<UnityEngine.UI.LayoutRebuilder>
                 */
                rebuilderPool: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutRebuilder#init", this ); }

                    this.rebuilderPool = System.Array.init(0, null, UnityEngine.UI.LayoutRebuilder);
                }
            },
            methods: {
                /*UnityEngine.UI.LayoutRebuilder.MarkLayoutForRebuild:static start.*/
                /**
                 * Marks the layout for rebuild.
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.LayoutRebuilder
                 * @memberof UnityEngine.UI.LayoutRebuilder
                 * @param   {UnityEngine.RectTransform}    rect    Rect.
                 * @return  {void}
                 */
                MarkLayoutForRebuild: function (rect) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutRebuilder#MarkLayoutForRebuild", this ); }

                    // check that the recttransform is a valid one.
                    if (UnityEngine.Component.op_Equality(rect, null)) {
                        return;
                    }

                    // now, we need to find proper layout root. once a rebuild is
                    // trigerred in a subtree residing under some layout group, it should
                    // never be marked dirty - instead, top-most layout parent should, so
                    // we have to find it.

                    // this is our starting point: we gonna be rebuilding the rect itself,
                    // unless we find a better candidate
                    var layoutRoot = rect;
                    var validLayoutGroup = true;

                    // take parent
                    var parent = UnityEngine.Component.op_Equality(rect.parent, null) ? null : UnityEngine.UI.LayoutRebuilder.GetRectTransform(rect.parent);

                    // while we haven't run into a "gap" (which is easier non-layout parent
                    // or scene root), walk the hierarchy up.
                    while (validLayoutGroup && !(UnityEngine.Component.op_Equality(parent, null))) {
                        // let's assume it's a gap
                        validLayoutGroup = false;

                        // check that the current node has a valid controller on it.
                        if (UnityEngine.UI.LayoutRebuilder.HasValidLayoutController(parent)) {
                            validLayoutGroup = true;
                            layoutRoot = parent;
                        }

                        // try the parent upwards
                        parent = UnityEngine.UI.LayoutRebuilder.GetRectTransform(parent.parent);
                    }

                    // we know the layout root is valid if it's not the same as the rect,
                    // since we checked that above. but if they're the same we still need to check.
                    if (UnityEngine.Component.op_Equality(layoutRoot, rect) && !UnityEngine.UI.LayoutRebuilder.HasValidLayoutController(layoutRoot)) {
                        return;
                    }

                    UnityEngine.UI.LayoutRebuilder.MarkLayoutRootForRebuild(layoutRoot);
                },
                /*UnityEngine.UI.LayoutRebuilder.MarkLayoutForRebuild:static end.*/

                /*UnityEngine.UI.LayoutRebuilder.ForceRebuildLayoutImmediate:static start.*/
                /**
                 * Marks the rect transform as needing rebuild and starts the rebuild routine
                 immediately.
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.LayoutRebuilder
                 * @memberof UnityEngine.UI.LayoutRebuilder
                 * @param   {UnityEngine.RectTransform}    rect
                 * @return  {void}
                 */
                ForceRebuildLayoutImmediate: function (rect) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutRebuilder#ForceRebuildLayoutImmediate", this ); }

                    // gather rebuilder instance
                    var rebuilder = UnityEngine.UI.LayoutRebuilder.Allocate(rect);

                    // run the rebuild
                    rebuilder.Rebuild(UnityEngine.UI.CanvasUpdate.Layout);

                    // notify re completion
                    rebuilder.LayoutComplete();
                },
                /*UnityEngine.UI.LayoutRebuilder.ForceRebuildLayoutImmediate:static end.*/

                /*UnityEngine.UI.LayoutRebuilder.Allocate:static start.*/
                /**
                 * Allocates a new one or takes an existing one from the pool.
                 *
                 * @static
                 * @protected
                 * @this UnityEngine.UI.LayoutRebuilder
                 * @memberof UnityEngine.UI.LayoutRebuilder
                 * @param   {UnityEngine.RectTransform}         root
                 * @return  {UnityEngine.UI.LayoutRebuilder}
                 */
                Allocate: function (root) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutRebuilder#Allocate", this ); }

                    var rebuilder = UnityEngine.UI.LayoutRebuilder.rebuilderPool.length > 0 ? UnityEngine.UI.LayoutRebuilder.rebuilderPool[UnityEngine.UI.LayoutRebuilder.rebuilderPool.length - 1] : new UnityEngine.UI.LayoutRebuilder();
                    UnityEngine.UI.LayoutRebuilder.rebuilderPool.length = Math.max( 0, UnityEngine.UI.LayoutRebuilder.rebuilderPool.length - 1 );

                    rebuilder.transform = root;

                    return rebuilder;
                },
                /*UnityEngine.UI.LayoutRebuilder.Allocate:static end.*/

                /*UnityEngine.UI.LayoutRebuilder.MarkLayoutRootForRebuild:static start.*/
                /**
                 * Marks the element for layout rebuild, uncoditionally.
                 *
                 * @static
                 * @protected
                 * @this UnityEngine.UI.LayoutRebuilder
                 * @memberof UnityEngine.UI.LayoutRebuilder
                 * @param   {UnityEngine.RectTransform}    rect
                 * @return  {void}
                 */
                MarkLayoutRootForRebuild: function (rect) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutRebuilder#MarkLayoutRootForRebuild", this ); }

                    // gather rebuilder instance
                    var rebuilder = UnityEngine.UI.LayoutRebuilder.Allocate(rect);
                    UnityEngine.UI.CanvasUpdateRegistry.RegisterCanvasElementForLayoutRebuild(rebuilder);
                },
                /*UnityEngine.UI.LayoutRebuilder.MarkLayoutRootForRebuild:static end.*/

                /*UnityEngine.UI.LayoutRebuilder.HasValidLayoutController:static start.*/
                /**
                 * Returns true if rect transform has an active layout controller attached.
                 *
                 * @static
                 * @protected
                 * @this UnityEngine.UI.LayoutRebuilder
                 * @memberof UnityEngine.UI.LayoutRebuilder
                 * @param   {UnityEngine.RectTransform}    rect
                 * @return  {boolean}
                 */
                HasValidLayoutController: function (rect) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutRebuilder#HasValidLayoutController", this ); }

                    // unpack arrays
                    var layoutSelfControllers = rect.handle._layoutSelfControllers;
                    var layoutControllers = rect.handle._layoutControllers;

                    // try finding a layout controller or self layout controller
                    for (var i = 0; i < layoutSelfControllers.length; i++) {
                        // get the controller
                        var controller = layoutSelfControllers[i];
                        // use it if it's good
                        if (controller["m_Enabled"]) {
                            return true;
                        }
                    }

                    // unless we found a good candidate within self controllers, we have
                    // to continue the search
                    for (var i1 = 0; i1 < layoutControllers.length; i1++) {
                        // get the controller
                        var controller1 = layoutControllers[i1];
                        // use it if it's good
                        if (controller1["m_Enabled"]) {
                            return true;
                        }
                    }

                    return false;
                },
                /*UnityEngine.UI.LayoutRebuilder.HasValidLayoutController:static end.*/

                /*UnityEngine.UI.LayoutRebuilder.GetRectTransform:static start.*/
                /**
                 * Ultra-fast (because - no casting needed) getter for rect transform, if the transform
                 is in fact a rect transform.
                 *
                 * @static
                 * @protected
                 * @this UnityEngine.UI.LayoutRebuilder
                 * @memberof UnityEngine.UI.LayoutRebuilder
                 * @param   {UnityEngine.Transform}        maybeRectTransform
                 * @return  {UnityEngine.RectTransform}
                 */
                GetRectTransform: function (maybeRectTransform) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutRebuilder#GetRectTransform", this ); }

                    return ( maybeRectTransform && maybeRectTransform.handle.element ) ? maybeRectTransform : null;
                },
                /*UnityEngine.UI.LayoutRebuilder.GetRectTransform:static end.*/


            }
        },
        fields: {
            /**
             * Get the transform associated with the ICanvasElement.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.LayoutRebuilder
             * @function transform
             * @type UnityEngine.Transform
             */
            transform: null
        },
        alias: [
            "transform", "UnityEngine$UI$ICanvasElement$transform",
            "LayoutComplete", "UnityEngine$UI$ICanvasElement$LayoutComplete",
            "GraphicUpdateComplete", "UnityEngine$UI$ICanvasElement$GraphicUpdateComplete",
            "IsDestroyed", "UnityEngine$UI$ICanvasElement$IsDestroyed",
            "Rebuild", "UnityEngine$UI$ICanvasElement$Rebuild"
        ],
        methods: {
            /*UnityEngine.UI.LayoutRebuilder.LayoutComplete start.*/
            /**
             * Callback sent when this ICanvasElement has completed layout.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.LayoutRebuilder
             * @memberof UnityEngine.UI.LayoutRebuilder
             * @return  {void}
             */
            LayoutComplete: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutRebuilder#LayoutComplete", this ); }

                this.transform = null;
                UnityEngine.UI.LayoutRebuilder.rebuilderPool.push(this);
            },
            /*UnityEngine.UI.LayoutRebuilder.LayoutComplete end.*/

            /*UnityEngine.UI.LayoutRebuilder.GraphicUpdateComplete start.*/
            /**
             * Just a nooop for rebuilder.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.LayoutRebuilder
             * @memberof UnityEngine.UI.LayoutRebuilder
             * @return  {void}
             */
            GraphicUpdateComplete: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutRebuilder#GraphicUpdateComplete", this ); }
 },
            /*UnityEngine.UI.LayoutRebuilder.GraphicUpdateComplete end.*/

            /*UnityEngine.UI.LayoutRebuilder.IsDestroyed start.*/
            IsDestroyed: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutRebuilder#IsDestroyed", this ); }

                return false;
            },
            /*UnityEngine.UI.LayoutRebuilder.IsDestroyed end.*/

            /*UnityEngine.UI.LayoutRebuilder.Rebuild start.*/
            /**
             * Rebuild the element for the given stage.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.LayoutRebuilder
             * @memberof UnityEngine.UI.LayoutRebuilder
             * @param   {UnityEngine.UI.CanvasUpdate}    phase    The current CanvasUpdate stage being rebuild.
             * @return  {void}
             */
            Rebuild: function (phase) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutRebuilder#Rebuild", this ); }

                
                if ( phase !== UnityEngine.UI.CanvasUpdate.Layout ) {
                    return;
                }
                var root = this.transform.handle;
                this.PerformCalculateLayoutInputHorizontal( root );
                this.PerformSetLayoutHorizontal( root );
                this.PerformCalculateLayoutInputVertical( root );
                this.PerformSetLayoutVertical( root );
                root.syncHierarchy();
            },
            /*UnityEngine.UI.LayoutRebuilder.Rebuild end.*/

            /*UnityEngine.UI.LayoutRebuilder.PerformCalculateLayoutInputHorizontal start.*/
            PerformCalculateLayoutInputHorizontal: function (root) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutRebuilder#PerformCalculateLayoutInputHorizontal", this ); }

                
                // leave if no elements attached or the root is disabled
                if ( !root.enabled || root._layoutElements.length === 0 ) {
                    return;
                }
                // depth-first walk
                var children = root._children;
                for ( var i = 0; i < children.length; i++ ) {
                    this.PerformCalculateLayoutInputHorizontal( children[ i ] );
                }
                // actual invokation
                var layoutElements = root._layoutElements;
                for ( var i = 0; i < layoutElements.length; i++ ) {
                    var layoutElement = layoutElements[ i ];
                    if ( layoutElement.m_Enabled ) {
                        layoutElement.CalculateLayoutInputHorizontal();
                    }
                }
            },
            /*UnityEngine.UI.LayoutRebuilder.PerformCalculateLayoutInputHorizontal end.*/

            /*UnityEngine.UI.LayoutRebuilder.PerformCalculateLayoutInputVertical start.*/
            PerformCalculateLayoutInputVertical: function (root) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutRebuilder#PerformCalculateLayoutInputVertical", this ); }

                
                // leave if no elements attached or the root is disabled
                if ( !root.enabled || root._layoutElements.length === 0 ) {
                    return;
                }
                // depth-first walk
                var children = root._children;
                for ( var i = 0; i < children.length; i++ ) {
                    this.PerformCalculateLayoutInputVertical( children[ i ] );
                }
                // actual invokation
                var layoutElements = root._layoutElements;
                for ( var i = 0; i < layoutElements.length; i++ ) {
                    var layoutElement = layoutElements[ i ];
                    if ( layoutElement.m_Enabled ) {
                        layoutElement.CalculateLayoutInputVertical();
                    }
                }
            },
            /*UnityEngine.UI.LayoutRebuilder.PerformCalculateLayoutInputVertical end.*/

            /*UnityEngine.UI.LayoutRebuilder.PerformSetLayoutHorizontal start.*/
            PerformSetLayoutHorizontal: function (root) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutRebuilder#PerformSetLayoutHorizontal", this ); }

                
                if ( !root.enabled || ( root._layoutSelfControllers.length + root._layoutControllers.length ) === 0 ) {
                    return;
                }
                var controllers = root._layoutSelfControllers;
                for ( var i = 0; i < controllers.length; i++ ) {
                    var layoutController = controllers[ i ];
                    if ( layoutController != null && layoutController.m_Enabled ) {
                        layoutController.SetLayoutHorizontal();
                    }
                }
                controllers = root._layoutControllers;
                for ( var i = 0; i < controllers.length; i++ ) {
                    var layoutController = controllers[ i ];
                    if ( layoutController != null && layoutController.m_Enabled ) {
                        layoutController.SetLayoutHorizontal();
                    }
                }
                var children = root._children;
                for ( var i = 0; i < children.length; i++ ) {
                    this.PerformSetLayoutHorizontal( children[ i ] );
                };
            },
            /*UnityEngine.UI.LayoutRebuilder.PerformSetLayoutHorizontal end.*/

            /*UnityEngine.UI.LayoutRebuilder.PerformSetLayoutVertical start.*/
            PerformSetLayoutVertical: function (root) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutRebuilder#PerformSetLayoutVertical", this ); }

                
                if ( !root.enabled || ( root._layoutSelfControllers.length + root._layoutControllers.length ) === 0 ) {
                    return;
                }
                var controllers = root._layoutSelfControllers;
                for ( var i = 0; i < controllers.length; i++ ) {
                    var layoutController = controllers[ i ];
                    if ( layoutController != null && layoutController.m_Enabled ) {
                        layoutController.SetLayoutVertical();
                    }
                }
                controllers = root._layoutControllers;
                for ( var i = 0; i < controllers.length; i++ ) {
                    var layoutController = controllers[ i ];
                    if ( layoutController != null && layoutController.m_Enabled ) {
                        layoutController.SetLayoutVertical();
                    }
                }
                var children = root._children;
                for ( var i = 0; i < children.length; i++ ) {
                    this.PerformSetLayoutVertical( children[ i ] );
                };
            },
            /*UnityEngine.UI.LayoutRebuilder.PerformSetLayoutVertical end.*/


        }
    });
    /*UnityEngine.UI.LayoutRebuilder end.*/

    /*UnityEngine.UI.Mask start.*/
    Bridge.define("UnityEngine.UI.Mask", {
        inherits: [UnityEngine.EventSystems.UIBehaviour,UnityEngine.ICanvasRaycastFilter,UnityEngine.UI.IMaterialModifier],
        fields: {
            m_RectTransform: null,
            m_Graphic: null,
            m_MaskMaterial: null,
            m_UnmaskMaterial: null,
            /**
             * The m show mask graphic.
             *
             * @instance
             * @protected
             * @memberof UnityEngine.UI.Mask
             * @default false
             * @type boolean
             */
            m_ShowMaskGraphic: false
        },
        props: {
            graphic: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Mask#graphic#get", this ); }

                    return this.m_Graphic || ((this.m_Graphic = this.GetComponent(UnityEngine.UI.Graphic)));
                }
            },
            rectTransform: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Mask#rectTransform#get", this ); }

                    return this.m_RectTransform || ((this.m_RectTransform = this.GetComponent(UnityEngine.RectTransform)));
                }
            },
            /**
             * Gets or sets a value indicating whether this {@link } show mask graphic.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Mask
             * @function showMaskGraphic
             * @type boolean
             */
            showMaskGraphic: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Mask#showMaskGraphic#get", this ); }

                    return this.m_ShowMaskGraphic;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Mask#showMaskGraphic#set", this ); }

                    this.m_ShowMaskGraphic = value;
                    this.UpdateMaskGraphicSettings();
                }
            }
        },
        alias: [
            "GetModifiedMaterial", "UnityEngine$UI$IMaterialModifier$GetModifiedMaterial",
            "IsRaycastLocationValid", "UnityEngine$ICanvasRaycastFilter$IsRaycastLocationValid"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Mask#init", this ); }

                this.m_ShowMaskGraphic = false;
            },
            /**
             * Initializes a new instance of the {@link } class.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Mask
             * @memberof UnityEngine.UI.Mask
             * @param   {pc.ElementComponent}    handle    Handle.
             * @return  {void}
             */
            $ctor1: function (handle) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Mask#$ctor1", this ); }

                this.$initialize();
                UnityEngine.EventSystems.UIBehaviour.$ctor1.call(this, handle);
            },
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Mask#ctor", this ); }

                this.$initialize();
                UnityEngine.EventSystems.UIBehaviour.$ctor1.call(this, null);
            }
        },
        methods: {
            /*UnityEngine.UI.Mask.MaskEnabled start.*/
            /**
             * Checks if mask is enabled and has effect.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Mask
             * @memberof UnityEngine.UI.Mask
             * @return  {boolean}        <pre><code>true</code></pre>, if enabled, <pre><code>false</code></pre> otherwise.
             */
            MaskEnabled: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Mask#MaskEnabled", this ); }

                return this.IsActive() && UnityEngine.MonoBehaviour.op_Inequality(this.graphic, null);
            },
            /*UnityEngine.UI.Mask.MaskEnabled end.*/

            /*UnityEngine.UI.Mask.Awake start.*/
            /**
             * Awake this instance.
             *
             * @instance
             * @protected
             * @override
             * @this UnityEngine.UI.Mask
             * @memberof UnityEngine.UI.Mask
             * @return  {void}
             */
            Awake: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Mask#Awake", this ); }

                UnityEngine.EventSystems.UIBehaviour.prototype.Awake.call(this);

                if (this.handle._activeSelf) {
                    if (this.handle.entity.element._image == null) {
                        return;
                    }

                    this.handle.entity.element.masksChildren = true;
                    this.UpdateMaskGraphicSettings();
                }
            },
            /*UnityEngine.UI.Mask.Awake end.*/

            /*UnityEngine.UI.Mask.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Mask#OnEnable", this ); }

                UnityEngine.EventSystems.UIBehaviour.prototype.OnEnable.call(this);

                // if mask is detroyed - reset image state to be able to render plain graphics
                if (this.handle.entity.element != null) {
                    if (this.handle.entity.element._image == null && this.handle.entity.element._text == null) {
                        return;
                    }

                    this.handle.entity.element.masksChildren = true;
                    this.UpdateMaskGraphicSettings();
                }

                UnityEngine.UI.MaskUtilities.NotifyStencilStateChanged(this);
            },
            /*UnityEngine.UI.Mask.OnEnable end.*/

            /*UnityEngine.UI.Mask.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Mask#OnDisable", this ); }

                UnityEngine.EventSystems.UIBehaviour.prototype.OnDisable.call(this);

                // if mask is detroyed - reset image state to be able to render plain graphics
                if (this.handle.entity.element != null) {
                    this.handle.entity.element.masksChildren = false;
                    this.handle.entity.element.showMaskGraphics = true;
                }

                UnityEngine.UI.StencilMaterial.Remove(this.m_MaskMaterial);
                this.m_MaskMaterial = null;
                UnityEngine.UI.StencilMaterial.Remove(this.m_UnmaskMaterial);
                this.m_UnmaskMaterial = null;
                UnityEngine.UI.MaskUtilities.NotifyStencilStateChanged(this);
            },
            /*UnityEngine.UI.Mask.OnDisable end.*/

            /*UnityEngine.UI.Mask.UpdateMaskGraphicSettings start.*/
            /**
             * Updates the mask graphic settings.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.Mask
             * @memberof UnityEngine.UI.Mask
             * @return  {void}
             */
            UpdateMaskGraphicSettings: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Mask#UpdateMaskGraphicSettings", this ); }

                this.handle.entity.element.showMaskGraphics = this.m_ShowMaskGraphic;
                if (UnityEngine.MonoBehaviour.op_Inequality(this.graphic, null)) {
                    this.graphic.SetMaterialDirty();
                }
            },
            /*UnityEngine.UI.Mask.UpdateMaskGraphicSettings end.*/

            /*UnityEngine.UI.Mask.GetModifiedMaterial start.*/
            /**
             * @instance
             * @public
             * @this UnityEngine.UI.Mask
             * @memberof UnityEngine.UI.Mask
             * @param   {UnityEngine.Material}    baseMaterial
             * @return  {UnityEngine.Material}
             */
            GetModifiedMaterial: function (baseMaterial) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Mask#GetModifiedMaterial", this ); }

                if (!this.MaskEnabled()) {
                    return baseMaterial;
                }

                var rootSortCanvas = UnityEngine.UI.MaskUtilities.FindRootSortOverrideCanvas(this.transform);
                var stencilDepth = UnityEngine.UI.MaskUtilities.GetStencilDepth(this.transform, rootSortCanvas);
                if (stencilDepth >= 8) {
                    UnityEngine.Debug.LogWarning$1("Attempting to use a stencil mask with depth > 8", this.gameObject);
                    return baseMaterial;
                }

                var desiredStencilBit = 1 << stencilDepth;

                // if we are at the first level...
                // we want to destroy what is there
                if (desiredStencilBit === 1) {
                    var maskMaterial = UnityEngine.UI.StencilMaterial.Add$1(baseMaterial, 1, UnityEngine.Rendering.StencilOp.Replace, UnityEngine.Rendering.CompareFunction.Always, this.m_ShowMaskGraphic ? UnityEngine.Rendering.ColorWriteMask.All : 0);
                    UnityEngine.UI.StencilMaterial.Remove(this.m_MaskMaterial);
                    this.m_MaskMaterial = maskMaterial;

                    var unmaskMaterial = UnityEngine.UI.StencilMaterial.Add$1(baseMaterial, 1, UnityEngine.Rendering.StencilOp.Zero, UnityEngine.Rendering.CompareFunction.Always, 0);
                    UnityEngine.UI.StencilMaterial.Remove(this.m_UnmaskMaterial);
                    this.m_UnmaskMaterial = unmaskMaterial;
                    this.graphic.canvasRenderer.popMaterialCount = 1;
                    this.graphic.canvasRenderer.SetPopMaterial(this.m_UnmaskMaterial, 0);

                    return this.m_MaskMaterial;
                }

                //otherwise we need to be a bit smarter and set some read / write masks
                var maskMaterial2 = UnityEngine.UI.StencilMaterial.Add$2(baseMaterial, desiredStencilBit | (desiredStencilBit - 1), UnityEngine.Rendering.StencilOp.Replace, UnityEngine.Rendering.CompareFunction.Equal, this.m_ShowMaskGraphic ? UnityEngine.Rendering.ColorWriteMask.All : 0, desiredStencilBit - 1, desiredStencilBit | (desiredStencilBit - 1));
                UnityEngine.UI.StencilMaterial.Remove(this.m_MaskMaterial);
                this.m_MaskMaterial = maskMaterial2;

                this.graphic.canvasRenderer.hasPopInstruction = true;
                var unmaskMaterial2 = UnityEngine.UI.StencilMaterial.Add$2(baseMaterial, desiredStencilBit - 1, UnityEngine.Rendering.StencilOp.Replace, UnityEngine.Rendering.CompareFunction.Equal, 0, desiredStencilBit - 1, desiredStencilBit | (desiredStencilBit - 1));
                UnityEngine.UI.StencilMaterial.Remove(this.m_UnmaskMaterial);
                this.m_UnmaskMaterial = unmaskMaterial2;
                this.graphic.canvasRenderer.popMaterialCount = 1;
                this.graphic.canvasRenderer.SetPopMaterial(this.m_UnmaskMaterial, 0);

                return this.m_MaskMaterial;
            },
            /*UnityEngine.UI.Mask.GetModifiedMaterial end.*/

            /*UnityEngine.UI.Mask.IsRaycastLocationValid start.*/
            IsRaycastLocationValid: function (sp, eventCamera) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Mask#IsRaycastLocationValid", this ); }

                if (!this.isActiveAndEnabled) {
                    return true;
                }

                return UnityEngine.RectTransformUtility.RectangleContainsScreenPoint$1(this.rectTransform, sp, eventCamera);
            },
            /*UnityEngine.UI.Mask.IsRaycastLocationValid end.*/


        }
    });
    /*UnityEngine.UI.Mask end.*/

    /*UnityEngine.UI.RectMask2D start.*/
    Bridge.define("UnityEngine.UI.RectMask2D", {
        inherits: [UnityEngine.EventSystems.UIBehaviour,UnityEngine.UI.IClipper,UnityEngine.ICanvasRaycastFilter],
        fields: {
            m_VertexClipper: null,
            m_RectTransform: null,
            m_MaskableTargets: null,
            m_ClipTargets: null,
            m_ShouldRecalculateClipRects: false,
            m_Clippers: null,
            m_LastClipRectCanvasSpace: null,
            m_ForceClip: false,
            /**
             * @instance
             * @private
             * @memberof UnityEngine.UI.RectMask2D
             * @type UnityEngine.Canvas
             */
            m_Canvas: null,
            m_Corners: null
        },
        props: {
            Canvas: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.RectMask2D#Canvas#get", this ); }

                    if (UnityEngine.Component.op_Equality(this.m_Canvas, null)) {
                        var list = UnityEngine.UI.ListPool$1(UnityEngine.Canvas).Get();
                        this.gameObject.GetComponentsInParent$1(UnityEngine.Canvas, false, list);
                        if (list.Count > 0) {
                            this.m_Canvas = list.getItem(list.Count - 1);
                        } else {
                            this.m_Canvas = null;
                        }

                        UnityEngine.UI.ListPool$1(UnityEngine.Canvas).Release(list);
                    }

                    return this.m_Canvas;
                }
            },
            /**
             * Get the Rect for the mask in canvas space.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.RectMask2D
             * @function canvasRect
             * @type UnityEngine.Rect
             */
            canvasRect: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.RectMask2D#canvasRect#get", this ); }

                    return this.m_VertexClipper.GetCanvasRect(this.rectTransform, this.Canvas);
                }
            },
            /**
             * Helper function to get the RectTransform for the mask.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.RectMask2D
             * @function rectTransform
             * @type UnityEngine.RectTransform
             */
            rectTransform: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.RectMask2D#rectTransform#get", this ); }

                    return this.m_RectTransform || ((this.m_RectTransform = this.GetComponent(UnityEngine.RectTransform)));
                }
            },
            rootCanvasRect: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.RectMask2D#rootCanvasRect#get", this ); }

                    this.rectTransform.GetWorldCorners(this.m_Corners);

                    if (!Bridge.referenceEquals(this.Canvas, null)) {
                        var rootCanvas = this.Canvas.rootCanvas;
                        for (var i = 0; i < 4; ++i) {
                            this.m_Corners[i] = rootCanvas.transform.InverseTransformPoint(this.m_Corners[i]);
                        }
                    }

                    return new UnityEngine.Rect.$ctor1(this.m_Corners[0].x, this.m_Corners[0].y, this.m_Corners[2].x - this.m_Corners[0].x, this.m_Corners[2].y - this.m_Corners[0].y);
                }
            }
        },
        alias: [
            "IsRaycastLocationValid", "UnityEngine$ICanvasRaycastFilter$IsRaycastLocationValid",
            "PerformClipping", "UnityEngine$UI$IClipper$PerformClipping"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.RectMask2D#init", this ); }

                this.m_LastClipRectCanvasSpace = new UnityEngine.Rect();
                this.m_VertexClipper = new UnityEngine.UI.RectangularVertexClipper();
                this.m_MaskableTargets = new (System.Collections.Generic.HashSet$1(UnityEngine.UI.MaskableGraphic)).ctor();
                this.m_ClipTargets = new (System.Collections.Generic.HashSet$1(UnityEngine.UI.IClippable)).ctor();
                this.m_Clippers = new (System.Collections.Generic.List$1(UnityEngine.UI.RectMask2D)).ctor();
                this.m_Corners = System.Array.init(4, function (){
                    return new UnityEngine.Vector3();
                }, UnityEngine.Vector3);
            },
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.RectMask2D#ctor", this ); }

                this.$initialize();
                UnityEngine.EventSystems.UIBehaviour.ctor.call(this);
            }
        },
        methods: {
            /*UnityEngine.UI.RectMask2D.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.RectMask2D#OnEnable", this ); }

                UnityEngine.EventSystems.UIBehaviour.prototype.OnEnable.call(this);
                this.m_ShouldRecalculateClipRects = true;
                UnityEngine.UI.ClipperRegistry.Register(this);
                UnityEngine.UI.MaskUtilities.Notify2DMaskStateChanged(this);
            },
            /*UnityEngine.UI.RectMask2D.OnEnable end.*/

            /*UnityEngine.UI.RectMask2D.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.RectMask2D#OnDisable", this ); }

                // we call base OnDisable first here
                // as we need to have the IsActive return the
                // correct value when we notify the children
                // that the mask state has changed.
                UnityEngine.EventSystems.UIBehaviour.prototype.OnDisable.call(this);
                this.m_ClipTargets.clear();
                this.m_MaskableTargets.clear();
                this.m_Clippers.clear();
                UnityEngine.UI.ClipperRegistry.Unregister(this);
                UnityEngine.UI.MaskUtilities.Notify2DMaskStateChanged(this);
            },
            /*UnityEngine.UI.RectMask2D.OnDisable end.*/

            /*UnityEngine.UI.RectMask2D.IsRaycastLocationValid start.*/
            IsRaycastLocationValid: function (sp, eventCamera) {
if ( TRACE ) { TRACE( "UnityEngine.UI.RectMask2D#IsRaycastLocationValid", this ); }

                if (!this.isActiveAndEnabled) {
                    return true;
                }

                return UnityEngine.RectTransformUtility.RectangleContainsScreenPoint$1(this.rectTransform, sp, eventCamera);
            },
            /*UnityEngine.UI.RectMask2D.IsRaycastLocationValid end.*/

            /*UnityEngine.UI.RectMask2D.PerformClipping start.*/
            PerformClipping: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.RectMask2D#PerformClipping", this ); }

                var $t, $t1, $t2, $t3, $t4;
                if (Bridge.referenceEquals(this.Canvas, null)) {
                    return;
                }

                //TODO See if an IsActive() test would work well here or whether it might cause unexpected side effects (re case 776771)

                // if the parents are changed
                // or something similar we
                // do a recalculate here
                if (this.m_ShouldRecalculateClipRects) {
                    UnityEngine.UI.MaskUtilities.GetRectMasksForClip(this, this.m_Clippers);
                    this.m_ShouldRecalculateClipRects = false;
                }

                // get the compound rects from
                // the clippers that are valid
                var validRect = { v : true };
                var clipRect = UnityEngine.UI.Clipping.FindCullAndClipWorldRect(this.m_Clippers, validRect);

                // If the mask is in ScreenSpaceOverlay/Camera render mode, its content is only rendered when its rect
                // overlaps that of the root canvas.
                var renderMode = this.Canvas.rootCanvas.renderMode;
                var maskIsCulled = (renderMode === UnityEngine.RenderMode.ScreenSpaceCamera || renderMode === UnityEngine.RenderMode.ScreenSpaceOverlay) && !clipRect.Overlaps$1(this.rootCanvasRect.$clone(), true);

                if (maskIsCulled) {
                    // Children are only displayed when inside the mask. If the mask is culled, then the children
                    // inside the mask are also culled. In that situation, we pass an invalid rect to allow callees
                    // to avoid some processing.
                    clipRect = UnityEngine.Rect.zero.$clone();
                    validRect.v = false;
                }

                if (UnityEngine.Rect.op_Inequality(clipRect.$clone(), this.m_LastClipRectCanvasSpace.$clone())) {
                    $t = Bridge.getEnumerator(this.m_ClipTargets);
                    try {
                        while ($t.moveNext()) {
                            var clipTarget = $t.Current;
                            clipTarget.UnityEngine$UI$IClippable$SetClipRect(clipRect.$clone(), validRect.v);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    $t1 = Bridge.getEnumerator(this.m_MaskableTargets);
                    try {
                        while ($t1.moveNext()) {
                            var maskableTarget = $t1.Current;
                            maskableTarget.SetClipRect(clipRect.$clone(), validRect.v);
                            maskableTarget.Cull(clipRect.$clone(), validRect.v);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                } else if (this.m_ForceClip) {
                    $t2 = Bridge.getEnumerator(this.m_ClipTargets);
                    try {
                        while ($t2.moveNext()) {
                            var clipTarget1 = $t2.Current;
                            clipTarget1.UnityEngine$UI$IClippable$SetClipRect(clipRect.$clone(), validRect.v);
                        }
                    } finally {
                        if (Bridge.is($t2, System.IDisposable)) {
                            $t2.System$IDisposable$Dispose();
                        }
                    }

                    $t3 = Bridge.getEnumerator(this.m_MaskableTargets);
                    try {
                        while ($t3.moveNext()) {
                            var maskableTarget1 = $t3.Current;
                            maskableTarget1.SetClipRect(clipRect.$clone(), validRect.v);

                            if (maskableTarget1.canvasRenderer.hasMoved) {
                                maskableTarget1.Cull(clipRect.$clone(), validRect.v);
                            }
                        }
                    } finally {
                        if (Bridge.is($t3, System.IDisposable)) {
                            $t3.System$IDisposable$Dispose();
                        }
                    }
                } else {
                    $t4 = Bridge.getEnumerator(this.m_MaskableTargets);
                    try {
                        while ($t4.moveNext()) {
                            var maskableTarget2 = $t4.Current;
                            if (maskableTarget2.canvasRenderer.hasMoved) {
                                maskableTarget2.Cull(clipRect.$clone(), validRect.v);
                            }
                        }
                    } finally {
                        if (Bridge.is($t4, System.IDisposable)) {
                            $t4.System$IDisposable$Dispose();
                        }
                    }
                }

                this.m_LastClipRectCanvasSpace = clipRect.$clone();
                this.m_ForceClip = false;
            },
            /*UnityEngine.UI.RectMask2D.PerformClipping end.*/

            /*UnityEngine.UI.RectMask2D.AddClippable start.*/
            /**
             * Add a IClippable to be tracked by the mask.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.RectMask2D
             * @memberof UnityEngine.UI.RectMask2D
             * @param   {UnityEngine.UI.IClippable}    clippable    Add the clippable object for this mask
             * @return  {void}
             */
            AddClippable: function (clippable) {
if ( TRACE ) { TRACE( "UnityEngine.UI.RectMask2D#AddClippable", this ); }

                if (clippable == null) {
                    return;
                }

                this.m_ShouldRecalculateClipRects = true;
                var maskable = Bridge.as(clippable, UnityEngine.UI.MaskableGraphic);

                if (UnityEngine.MonoBehaviour.op_Equality(maskable, null)) {
                    this.m_ClipTargets.add(clippable);
                } else {
                    this.m_MaskableTargets.add(maskable);
                }

                this.m_ForceClip = true;
            },
            /*UnityEngine.UI.RectMask2D.AddClippable end.*/

            /*UnityEngine.UI.RectMask2D.RemoveClippable start.*/
            /**
             * Remove an IClippable from being tracked by the mask.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.RectMask2D
             * @memberof UnityEngine.UI.RectMask2D
             * @param   {UnityEngine.UI.IClippable}    clippable    Remove the clippable object from this mask
             * @return  {void}
             */
            RemoveClippable: function (clippable) {
if ( TRACE ) { TRACE( "UnityEngine.UI.RectMask2D#RemoveClippable", this ); }

                if (clippable == null) {
                    return;
                }

                this.m_ShouldRecalculateClipRects = true;
                clippable.UnityEngine$UI$IClippable$SetClipRect(new UnityEngine.Rect.ctor(), false);

                var maskable = Bridge.as(clippable, UnityEngine.UI.MaskableGraphic);

                if (UnityEngine.MonoBehaviour.op_Equality(maskable, null)) {
                    this.m_ClipTargets.remove(clippable);
                } else {
                    this.m_MaskableTargets.remove(maskable);
                }

                this.m_ForceClip = true;
            },
            /*UnityEngine.UI.RectMask2D.RemoveClippable end.*/

            /*UnityEngine.UI.RectMask2D.OnTransformParentChanged start.*/
            OnTransformParentChanged: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.RectMask2D#OnTransformParentChanged", this ); }

                UnityEngine.EventSystems.UIBehaviour.prototype.OnTransformParentChanged.call(this);
                this.m_ShouldRecalculateClipRects = true;
            },
            /*UnityEngine.UI.RectMask2D.OnTransformParentChanged end.*/

            /*UnityEngine.UI.RectMask2D.OnCanvasHierarchyChanged start.*/
            OnCanvasHierarchyChanged: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.RectMask2D#OnCanvasHierarchyChanged", this ); }

                this.m_Canvas = null;
                UnityEngine.EventSystems.UIBehaviour.prototype.OnCanvasHierarchyChanged.call(this);
                this.m_ShouldRecalculateClipRects = true;
            },
            /*UnityEngine.UI.RectMask2D.OnCanvasHierarchyChanged end.*/


        }
    });
    /*UnityEngine.UI.RectMask2D end.*/

    /*UnityEngine.UI.ToggleGroup start.*/
    /**
     * A component that represents a group of UI.Toggles.
     *
     * @public
     * @class UnityEngine.UI.ToggleGroup
     * @augments UnityEngine.EventSystems.UIBehaviour
     */
    Bridge.define("UnityEngine.UI.ToggleGroup", {
        inherits: [UnityEngine.EventSystems.UIBehaviour],
        fields: {
            m_AllowSwitchOff: false,
            _toggles: null
        },
        props: {
            /**
             * Is it allowed that no toggle is switched on?
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.ToggleGroup
             * @function allowSwitchOff
             * @type boolean
             */
            allowSwitchOff: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ToggleGroup#allowSwitchOff#get", this ); }

                    return this.m_AllowSwitchOff;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ToggleGroup#allowSwitchOff#set", this ); }

                    this.m_AllowSwitchOff = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ToggleGroup#init", this ); }

                this.m_AllowSwitchOff = false;
                this._toggles = new (System.Collections.Generic.List$1(UnityEngine.UI.Toggle)).ctor();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ToggleGroup#ctor", this ); }

                this.$initialize();
                UnityEngine.EventSystems.UIBehaviour.ctor.call(this);
            }
        },
        methods: {
            /*UnityEngine.UI.ToggleGroup.ValidateToggleIsInGroup start.*/
            ValidateToggleIsInGroup: function (toggle) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ToggleGroup#ValidateToggleIsInGroup", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(toggle, null) || !this._toggles.contains(toggle)) {
                    throw new System.ArgumentException.$ctor1(System.String.format.apply(System.String, ["Toggle {0} is not part of ToggleGroup {1}"].concat(System.Array.init([toggle, this], System.Object))));
                }
            },
            /*UnityEngine.UI.ToggleGroup.ValidateToggleIsInGroup end.*/

            /*UnityEngine.UI.ToggleGroup.NotifyToggleOn start.*/
            /**
             * Notify the group that the given toggle is enabled.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.ToggleGroup
             * @memberof UnityEngine.UI.ToggleGroup
             * @param   {UnityEngine.UI.Toggle}    toggle          The toggle that got triggered on
             * @param   {boolean}                  sendCallback
             * @return  {void}
             */
            NotifyToggleOn: function (toggle, sendCallback) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ToggleGroup#NotifyToggleOn", this ); }

                if (sendCallback === void 0) { sendCallback = true; }
                this.ValidateToggleIsInGroup(toggle);
                // disable all toggles in the group
                for (var i = 0; i < this._toggles.Count; i++) {
                    if (UnityEngine.MonoBehaviour.op_Equality(this._toggles.getItem(i), toggle)) {
                        continue;
                    }

                    if (sendCallback) {
                        this._toggles.getItem(i).isOn = false;
                    } else {
                        this._toggles.getItem(i).SetIsOnWithoutNotify(false);
                    }
                }
            },
            /*UnityEngine.UI.ToggleGroup.NotifyToggleOn end.*/

            /*UnityEngine.UI.ToggleGroup.UnregisterToggle start.*/
            /**
             * Unregister a toggle from the group.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.ToggleGroup
             * @memberof UnityEngine.UI.ToggleGroup
             * @param   {UnityEngine.UI.Toggle}    toggle    The toggle to remove.
             * @return  {void}
             */
            UnregisterToggle: function (toggle) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ToggleGroup#UnregisterToggle", this ); }

                if (this._toggles.contains(toggle)) {
                    this._toggles.remove(toggle);
                }

                if (!this.allowSwitchOff && !this.AnyTogglesOn() && this._toggles.Count !== 0) {
                    this._toggles.getItem(0).isOn = true;
                    this.NotifyToggleOn(this._toggles.getItem(0));
                }
            },
            /*UnityEngine.UI.ToggleGroup.UnregisterToggle end.*/

            /*UnityEngine.UI.ToggleGroup.RegisterToggle start.*/
            /**
             * Register a toggle with the toggle group so it is watched for changes and notified if another toggle in the group changes.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.ToggleGroup
             * @memberof UnityEngine.UI.ToggleGroup
             * @param   {UnityEngine.UI.Toggle}    toggle    The toggle to register with the group.
             * @return  {void}
             */
            RegisterToggle: function (toggle) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ToggleGroup#RegisterToggle", this ); }

                if (!this._toggles.contains(toggle)) {
                    this._toggles.add(toggle);
                }

                if (!this.allowSwitchOff && !this.AnyTogglesOn()) {
                    toggle.isOn = true;
                    this.NotifyToggleOn(toggle);
                }
            },
            /*UnityEngine.UI.ToggleGroup.RegisterToggle end.*/

            /*UnityEngine.UI.ToggleGroup.AnyTogglesOn start.*/
            /**
             * Are any of the toggles on?
             *
             * @instance
             * @public
             * @this UnityEngine.UI.ToggleGroup
             * @memberof UnityEngine.UI.ToggleGroup
             * @return  {boolean}        Are and of the toggles on?
             */
            AnyTogglesOn: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ToggleGroup#AnyTogglesOn", this ); }

                return UnityEngine.MonoBehaviour.op_Inequality(this._toggles.Find(function (x) {
                    return x.isOn;
                }), null);
            },
            /*UnityEngine.UI.ToggleGroup.AnyTogglesOn end.*/

            /*UnityEngine.UI.ToggleGroup.ActiveToggles start.*/
            /**
             * Returns the toggles in this group that are active.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.ToggleGroup
             * @memberof UnityEngine.UI.ToggleGroup
             * @return  {System.Collections.Generic.IEnumerable$1}        The active toggles in the group.
             */
            ActiveToggles: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ToggleGroup#ActiveToggles", this ); }

                return System.Linq.Enumerable.from(this._toggles, UnityEngine.UI.Toggle).where(function (x) {
                        return x.isOn;
                    });
            },
            /*UnityEngine.UI.ToggleGroup.ActiveToggles end.*/

            /*UnityEngine.UI.ToggleGroup.SetAllTogglesOff start.*/
            /**
             * Switch all toggles off.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.ToggleGroup
             * @memberof UnityEngine.UI.ToggleGroup
             * @param   {boolean}    sendCallback
             * @return  {void}
             */
            SetAllTogglesOff: function (sendCallback) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ToggleGroup#SetAllTogglesOff", this ); }

                if (sendCallback === void 0) { sendCallback = true; }
                var oldAllowSwitchOff = this.m_AllowSwitchOff;
                this.m_AllowSwitchOff = true;

                if (sendCallback) {
                    for (var i = 0; i < this._toggles.Count; i++) {
                        this._toggles.getItem(i).isOn = false;
                    }
                } else {
                    for (var i1 = 0; i1 < this._toggles.Count; i1++) {
                        this._toggles.getItem(i1).SetIsOnWithoutNotify(false);
                    }
                }

                this.m_AllowSwitchOff = oldAllowSwitchOff;
            },
            /*UnityEngine.UI.ToggleGroup.SetAllTogglesOff end.*/


        }
    });
    /*UnityEngine.UI.ToggleGroup end.*/

    /*UnityEngine.EventSystems.AxisEventData start.*/
    Bridge.define("UnityEngine.EventSystems.AxisEventData", {
        inherits: [UnityEngine.EventSystems.BaseEventData],
        fields: {
            /**
             * Gets or sets the move dir.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.AxisEventData
             * @function moveDir
             * @type UnityEngine.EventSystems.MoveDirection
             */
            moveDir: 0,
            /**
             * Gets or sets the move vector.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.AxisEventData
             * @function moveVector
             * @type UnityEngine.Vector2
             */
            moveVector: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.AxisEventData#init", this ); }

                this.moveVector = new UnityEngine.Vector2();
            },
            /**
             * Initializes a new instance of the {@link } class.
             *
             * @instance
             * @public
             * @this UnityEngine.EventSystems.AxisEventData
             * @memberof UnityEngine.EventSystems.AxisEventData
             * @param   {UnityEngine.EventSystems.EventSystem}    eventSystem    Event system.
             * @return  {void}
             */
            ctor: function (eventSystem) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.AxisEventData#ctor", this ); }

                this.$initialize();
                UnityEngine.EventSystems.BaseEventData.ctor.call(this, eventSystem);
            }
        }
    });
    /*UnityEngine.EventSystems.AxisEventData end.*/

    /*UnityEngine.EventSystems.EventTrigger start.*/
    /**
     * Event trigger component (Unity port).
     *
     * @public
     * @class UnityEngine.EventSystems.EventTrigger
     * @augments UnityEngine.MonoBehaviour
     * @implements  UnityEngine.EventSystems.IPointerEnterHandler
     * @implements  UnityEngine.EventSystems.IPointerExitHandler
     * @implements  UnityEngine.EventSystems.IPointerDownHandler
     * @implements  UnityEngine.EventSystems.IPointerUpHandler
     * @implements  UnityEngine.EventSystems.IPointerClickHandler
     * @implements  UnityEngine.EventSystems.IInitializePotentialDragHandler
     * @implements  UnityEngine.EventSystems.IBeginDragHandler
     * @implements  UnityEngine.EventSystems.IDragHandler
     * @implements  UnityEngine.EventSystems.IEndDragHandler
     * @implements  UnityEngine.EventSystems.IDropHandler
     * @implements  UnityEngine.EventSystems.IScrollHandler
     * @implements  UnityEngine.EventSystems.IUpdateSelectedHandler
     * @implements  UnityEngine.EventSystems.ISelectHandler
     * @implements  UnityEngine.EventSystems.IDeselectHandler
     * @implements  UnityEngine.EventSystems.IMoveHandler
     * @implements  UnityEngine.EventSystems.ISubmitHandler
     * @implements  UnityEngine.EventSystems.ICancelHandler
     * @implements  UnityEngine.EventSystems.IEventSystemHandler
     */
    Bridge.define("UnityEngine.EventSystems.EventTrigger", {
        inherits: [UnityEngine.MonoBehaviour,UnityEngine.EventSystems.IPointerEnterHandler,UnityEngine.EventSystems.IPointerExitHandler,UnityEngine.EventSystems.IPointerDownHandler,UnityEngine.EventSystems.IPointerUpHandler,UnityEngine.EventSystems.IPointerClickHandler,UnityEngine.EventSystems.IInitializePotentialDragHandler,UnityEngine.EventSystems.IBeginDragHandler,UnityEngine.EventSystems.IDragHandler,UnityEngine.EventSystems.IEndDragHandler,UnityEngine.EventSystems.IDropHandler,UnityEngine.EventSystems.IScrollHandler,UnityEngine.EventSystems.IUpdateSelectedHandler,UnityEngine.EventSystems.ISelectHandler,UnityEngine.EventSystems.IDeselectHandler,UnityEngine.EventSystems.IMoveHandler,UnityEngine.EventSystems.ISubmitHandler,UnityEngine.EventSystems.ICancelHandler,UnityEngine.EventSystems.IEventSystemHandler],
        fields: {
            m_Delegates: null
        },
        props: {
            triggers: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventTrigger#triggers#get", this ); }

                    return this.m_Delegates || ((this.m_Delegates = new (System.Collections.Generic.List$1(UnityEngine.EventSystems.EventTrigger.Entry)).ctor()));
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventTrigger#triggers#set", this ); }

                    this.m_Delegates = value || new (System.Collections.Generic.List$1(UnityEngine.EventSystems.EventTrigger.Entry)).ctor();
                }
            }
        },
        alias: [
            "OnPointerEnter", "UnityEngine$EventSystems$IPointerEnterHandler$OnPointerEnter",
            "OnPointerExit", "UnityEngine$EventSystems$IPointerExitHandler$OnPointerExit",
            "OnDrag", "UnityEngine$EventSystems$IDragHandler$OnDrag",
            "OnDrop", "UnityEngine$EventSystems$IDropHandler$OnDrop",
            "OnPointerDown", "UnityEngine$EventSystems$IPointerDownHandler$OnPointerDown",
            "OnPointerUp", "UnityEngine$EventSystems$IPointerUpHandler$OnPointerUp",
            "OnPointerClick", "UnityEngine$EventSystems$IPointerClickHandler$OnPointerClick",
            "OnSelect", "UnityEngine$EventSystems$ISelectHandler$OnSelect",
            "OnDeselect", "UnityEngine$EventSystems$IDeselectHandler$OnDeselect",
            "OnScroll", "UnityEngine$EventSystems$IScrollHandler$OnScroll",
            "OnMove", "UnityEngine$EventSystems$IMoveHandler$OnMove",
            "OnUpdateSelected", "UnityEngine$EventSystems$IUpdateSelectedHandler$OnUpdateSelected",
            "OnInitializePotentialDrag", "UnityEngine$EventSystems$IInitializePotentialDragHandler$OnInitializePotentialDrag",
            "OnBeginDrag", "UnityEngine$EventSystems$IBeginDragHandler$OnBeginDrag",
            "OnEndDrag", "UnityEngine$EventSystems$IEndDragHandler$OnEndDrag",
            "OnSubmit", "UnityEngine$EventSystems$ISubmitHandler$OnSubmit",
            "OnCancel", "UnityEngine$EventSystems$ICancelHandler$OnCancel"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventTrigger#init", this ); }

                this.m_Delegates = new (System.Collections.Generic.List$1(UnityEngine.EventSystems.EventTrigger.Entry)).ctor();
            }
        },
        methods: {
            /*UnityEngine.EventSystems.EventTrigger.OnPointerEnter start.*/
            OnPointerEnter: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventTrigger#OnPointerEnter", this ); }

                this.Execute(UnityEngine.EventSystems.EventTriggerType.PointerEnter, eventData);
            },
            /*UnityEngine.EventSystems.EventTrigger.OnPointerEnter end.*/

            /*UnityEngine.EventSystems.EventTrigger.OnPointerExit start.*/
            OnPointerExit: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventTrigger#OnPointerExit", this ); }

                this.Execute(UnityEngine.EventSystems.EventTriggerType.PointerExit, eventData);
            },
            /*UnityEngine.EventSystems.EventTrigger.OnPointerExit end.*/

            /*UnityEngine.EventSystems.EventTrigger.OnDrag start.*/
            OnDrag: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventTrigger#OnDrag", this ); }

                this.Execute(UnityEngine.EventSystems.EventTriggerType.Drag, eventData);
            },
            /*UnityEngine.EventSystems.EventTrigger.OnDrag end.*/

            /*UnityEngine.EventSystems.EventTrigger.OnDrop start.*/
            OnDrop: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventTrigger#OnDrop", this ); }

                this.Execute(UnityEngine.EventSystems.EventTriggerType.Drop, eventData);
            },
            /*UnityEngine.EventSystems.EventTrigger.OnDrop end.*/

            /*UnityEngine.EventSystems.EventTrigger.OnPointerDown start.*/
            OnPointerDown: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventTrigger#OnPointerDown", this ); }

                this.Execute(UnityEngine.EventSystems.EventTriggerType.PointerDown, eventData);
            },
            /*UnityEngine.EventSystems.EventTrigger.OnPointerDown end.*/

            /*UnityEngine.EventSystems.EventTrigger.OnPointerUp start.*/
            OnPointerUp: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventTrigger#OnPointerUp", this ); }

                this.Execute(UnityEngine.EventSystems.EventTriggerType.PointerUp, eventData);
            },
            /*UnityEngine.EventSystems.EventTrigger.OnPointerUp end.*/

            /*UnityEngine.EventSystems.EventTrigger.OnPointerClick start.*/
            OnPointerClick: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventTrigger#OnPointerClick", this ); }

                this.Execute(UnityEngine.EventSystems.EventTriggerType.PointerClick, eventData);
            },
            /*UnityEngine.EventSystems.EventTrigger.OnPointerClick end.*/

            /*UnityEngine.EventSystems.EventTrigger.OnSelect start.*/
            OnSelect: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventTrigger#OnSelect", this ); }

                this.Execute(UnityEngine.EventSystems.EventTriggerType.Select, eventData);
            },
            /*UnityEngine.EventSystems.EventTrigger.OnSelect end.*/

            /*UnityEngine.EventSystems.EventTrigger.OnDeselect start.*/
            OnDeselect: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventTrigger#OnDeselect", this ); }

                this.Execute(UnityEngine.EventSystems.EventTriggerType.Deselect, eventData);
            },
            /*UnityEngine.EventSystems.EventTrigger.OnDeselect end.*/

            /*UnityEngine.EventSystems.EventTrigger.OnScroll start.*/
            OnScroll: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventTrigger#OnScroll", this ); }

                this.Execute(UnityEngine.EventSystems.EventTriggerType.Scroll, eventData);
            },
            /*UnityEngine.EventSystems.EventTrigger.OnScroll end.*/

            /*UnityEngine.EventSystems.EventTrigger.OnMove start.*/
            OnMove: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventTrigger#OnMove", this ); }

                this.Execute(UnityEngine.EventSystems.EventTriggerType.Move, eventData);
            },
            /*UnityEngine.EventSystems.EventTrigger.OnMove end.*/

            /*UnityEngine.EventSystems.EventTrigger.OnUpdateSelected start.*/
            OnUpdateSelected: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventTrigger#OnUpdateSelected", this ); }

                this.Execute(UnityEngine.EventSystems.EventTriggerType.UpdateSelected, eventData);
            },
            /*UnityEngine.EventSystems.EventTrigger.OnUpdateSelected end.*/

            /*UnityEngine.EventSystems.EventTrigger.OnInitializePotentialDrag start.*/
            OnInitializePotentialDrag: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventTrigger#OnInitializePotentialDrag", this ); }

                this.Execute(UnityEngine.EventSystems.EventTriggerType.InitializePotentialDrag, eventData);
            },
            /*UnityEngine.EventSystems.EventTrigger.OnInitializePotentialDrag end.*/

            /*UnityEngine.EventSystems.EventTrigger.OnBeginDrag start.*/
            OnBeginDrag: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventTrigger#OnBeginDrag", this ); }

                this.Execute(UnityEngine.EventSystems.EventTriggerType.BeginDrag, eventData);
            },
            /*UnityEngine.EventSystems.EventTrigger.OnBeginDrag end.*/

            /*UnityEngine.EventSystems.EventTrigger.OnEndDrag start.*/
            OnEndDrag: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventTrigger#OnEndDrag", this ); }

                this.Execute(UnityEngine.EventSystems.EventTriggerType.EndDrag, eventData);
            },
            /*UnityEngine.EventSystems.EventTrigger.OnEndDrag end.*/

            /*UnityEngine.EventSystems.EventTrigger.OnSubmit start.*/
            OnSubmit: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventTrigger#OnSubmit", this ); }

                this.Execute(UnityEngine.EventSystems.EventTriggerType.Submit, eventData);
            },
            /*UnityEngine.EventSystems.EventTrigger.OnSubmit end.*/

            /*UnityEngine.EventSystems.EventTrigger.OnCancel start.*/
            OnCancel: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventTrigger#OnCancel", this ); }

                this.Execute(UnityEngine.EventSystems.EventTriggerType.Cancel, eventData);
            },
            /*UnityEngine.EventSystems.EventTrigger.OnCancel end.*/

            /*UnityEngine.EventSystems.EventTrigger.Execute start.*/
            Execute: function (id, eventData) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.EventTrigger#Execute", this ); }

                for (var i = 0, imax = this.triggers.Count; i < imax; ++i) {
                    var ent = { v : this.triggers.getItem(i) };
                    if (ent.v.eventID === id) {
                        ent.v.callback != null ? ent.v.callback.Invoke(eventData) : null;
                    }
                }
            },
            /*UnityEngine.EventSystems.EventTrigger.Execute end.*/


        }
    });
    /*UnityEngine.EventSystems.EventTrigger end.*/

    /*UnityEngine.EventSystems.EventTrigger+TriggerEvent start.*/
    Bridge.define("UnityEngine.EventSystems.EventTrigger.TriggerEvent", {
        inherits: [UnityEngine.Events.UnityEvent$1(UnityEngine.EventSystems.BaseEventData)],
        $kind: 1002
    });
    /*UnityEngine.EventSystems.EventTrigger+TriggerEvent end.*/

    /*UnityEngine.EventSystems.PhysicsRaycaster start.*/
    Bridge.define("UnityEngine.EventSystems.PhysicsRaycaster", {
        inherits: [UnityEngine.EventSystems.BaseRaycaster],
        statics: {
            fields: {
                /**
                 * Const to use for clarity when no event mask is set
                 *
                 * @static
                 * @protected
                 * @memberof UnityEngine.EventSystems.PhysicsRaycaster
                 * @constant
                 * @default -1
                 * @type number
                 */
                kNoEventMaskSet: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PhysicsRaycaster#init", this ); }

                    this.kNoEventMaskSet = -1;
                }
            }
        },
        fields: {
            m_EventCamera: null,
            /**
             * Layer mask used to filter events. Always combined with the camera's culling mask if a camera is used.
             *
             * @instance
             * @protected
             * @memberof UnityEngine.EventSystems.PhysicsRaycaster
             * @type UnityEngine.LayerMask
             */
            m_EventMask: null,
            /**
             * The max number of intersections allowed. 0 = allocating version anything else is non alloc.
             *
             * @instance
             * @protected
             * @memberof UnityEngine.EventSystems.PhysicsRaycaster
             * @default 0
             * @type number
             */
            m_MaxRayIntersections: 0,
            m_LastMaxRayIntersections: 0,
            hits: null
        },
        props: {
            eventCamera: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PhysicsRaycaster#eventCamera#get", this ); }

                    if (UnityEngine.Component.op_Equality(this.m_EventCamera, null)) {
                        this.m_EventCamera = this.GetComponent(UnityEngine.Camera);
                    }

                    return this.m_EventCamera || UnityEngine.Camera.main;
                }
            },
            /**
             * Depth used to determine the order of event processing.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.EventSystems.PhysicsRaycaster
             * @function depth
             * @type number
             */
            depth: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PhysicsRaycaster#depth#get", this ); }

                    return UnityEngine.Component.op_Inequality(this.eventCamera, null) ? this.eventCamera.depth : 16777215;
                }
            },
            /**
             * Event mask used to determine which objects will receive events.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.EventSystems.PhysicsRaycaster
             * @function finalEventMask
             * @type number
             */
            finalEventMask: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PhysicsRaycaster#finalEventMask#get", this ); }

                    return UnityEngine.Component.op_Inequality(this.eventCamera, null) ? UnityEngine.LayerMask.op_Implicit((UnityEngine.LayerMask.op_BitwiseAnd(UnityEngine.LayerMask.op_Implicit$1(this.eventCamera.cullingMask), this.m_EventMask.$clone()))) : UnityEngine.EventSystems.PhysicsRaycaster.kNoEventMaskSet;
                }
            },
            /**
             * Layer mask used to filter events. Always combined with the camera's culling mask if a camera is used.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.PhysicsRaycaster
             * @function eventMask
             * @type UnityEngine.LayerMask
             */
            eventMask: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PhysicsRaycaster#eventMask#get", this ); }

                    return this.m_EventMask.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PhysicsRaycaster#eventMask#set", this ); }

                    this.m_EventMask = value.$clone();
                }
            },
            /**
             * Max number of ray intersection allowed to be found.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.PhysicsRaycaster
             * @function maxRayIntersections
             * @type number
             */
            maxRayIntersections: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PhysicsRaycaster#maxRayIntersections#get", this ); }

                    return this.m_MaxRayIntersections;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PhysicsRaycaster#maxRayIntersections#set", this ); }

                    this.m_MaxRayIntersections = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PhysicsRaycaster#init", this ); }

                this.m_EventMask = new UnityEngine.LayerMask();
                this.m_EventMask = UnityEngine.LayerMask.op_Implicit$1(-1);
                this.m_MaxRayIntersections = 0;
                this.m_LastMaxRayIntersections = 0;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PhysicsRaycaster#ctor", this ); }

                this.$initialize();
                UnityEngine.EventSystems.BaseRaycaster.ctor.call(this);
            }
        },
        methods: {
            /*UnityEngine.EventSystems.PhysicsRaycaster.ComputeRayAndDistance start.*/
            /**
             * Returns a ray going from camera through the event position and the distance between the near and far clipping planes along that ray.
             *
             * @instance
             * @protected
             * @this UnityEngine.EventSystems.PhysicsRaycaster
             * @memberof UnityEngine.EventSystems.PhysicsRaycaster
             * @param   {UnityEngine.EventSystems.PointerEventData}    eventData              The pointer event for which we will cast a ray.
             * @param   {UnityEngine.Ray}                              ray                    The ray to use.
             * @param   {System.Single}                                distanceToClipPlane    The distance between the near and far clipping planes along the ray.
             * @return  {boolean}                                                             True if the operation was successful. false if it was not possible to compute, such as the eventPosition being outside of the view.
             */
            ComputeRayAndDistance: function (eventData, ray, distanceToClipPlane) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PhysicsRaycaster#ComputeRayAndDistance", this ); }

                if (UnityEngine.Component.op_Equality(this.eventCamera, null)) {
                    return false;
                }

                var eventPosition = UnityEngine.Display.RelativeMouseAt(UnityEngine.Vector3.FromVector2(eventData.position.$clone()));
                if (!pc.Vec3.equals( eventPosition, pc.Vec3.ZERO.clone() )) {
                    // We support multiple display and display identification based on event position.
                    var eventDisplayIndex = eventPosition.z;

                    // Discard events that are not part of this display so the user does not interact with multiple displays at once.
                    if (eventDisplayIndex !== this.eventCamera.targetDisplay) {
                        return false;
                    }
                } else {
                    // The multiple display system is not supported on all platforms, when it is not supported the returned position
                    // will be all zeros so when the returned index is 0 we will default to the event data to be safe.
                    eventPosition = UnityEngine.Vector3.FromVector2(eventData.position.$clone());
                }

                // Cull ray casts that are outside of the view rect. (case 636595)
                if (!this.eventCamera.pixelRect.Contains$1(eventPosition.$clone())) {
                    return false;
                }

                ray.v = this.eventCamera.ScreenPointToRay(eventPosition.$clone());
                // compensate far plane distance - see MouseEvents.cs
                var projectionDirection = ray.v.m_Direction.z;
                distanceToClipPlane.v = UnityEngine.Mathf.Approximately(0.0, projectionDirection) ? window.Infinity : Math.abs((this.eventCamera.farClipPlane - this.eventCamera.nearClipPlane) / projectionDirection);
                return true;
            },
            /*UnityEngine.EventSystems.PhysicsRaycaster.ComputeRayAndDistance end.*/

            /*UnityEngine.EventSystems.PhysicsRaycaster.Raycast start.*/
            Raycast: function (eventData, resultAppendList) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PhysicsRaycaster#Raycast", this ); }

                var $t;
                var ray = { v : new UnityEngine.Ray.ctor() };
                var distanceToClipPlane = { v : 0 };
                if (!this.ComputeRayAndDistance(eventData, ray, distanceToClipPlane)) {
                    return;
                }

                var hitCount = 0;

                if (this.m_MaxRayIntersections === 0) {
                    /* if ( ReflectionMethodsCache.Singleton.raycast3DAll == null ) {
                       return;
                    }*/

                    this.hits = UnityEngine.Physics.RaycastAll(ray.v.$clone(), distanceToClipPlane.v, this.finalEventMask); //ReflectionMethodsCache.Singleton.raycast3DAll( ray, distanceToClipPlane, finalEventMask );
                    hitCount = this.hits.length;
                } else {
                    /* if ( ReflectionMethodsCache.Singleton.getRaycastNonAlloc == null ) {
                       return;
                    }*/

                    if (this.m_LastMaxRayIntersections !== this.m_MaxRayIntersections) {
                        this.hits = System.Array.init(this.m_MaxRayIntersections, function (){
                            return new UnityEngine.RaycastHit();
                        }, UnityEngine.RaycastHit);
                        this.m_LastMaxRayIntersections = this.m_MaxRayIntersections;
                    }

                    for (var index = 0; index < this.hits.length; index++) {
                        this.hits[index].distance = Number.POSITIVE_INFINITY;
                    }

                    hitCount = UnityEngine.Physics.RaycastNonAlloc(ray.v, this.hits, distanceToClipPlane.v, this.finalEventMask);
                    /* ReflectionMethodsCache.Singleton.getRaycastNonAlloc( ray, hits, distanceToClipPlane, finalEventMask );*/
                }

                if (hitCount > 1) {
                    System.Array.sort(this.hits, function (r1, r2) {
                            return Bridge.compare(r1.distance, r2.distance);
                        });
                }

                if (hitCount !== 0) {
                    for (var b = 0, bmax = hitCount; b < bmax; ++b) {
                        var result = ($t = new UnityEngine.EventSystems.RaycastResult(), $t.gameObject = this.hits[b].collider.gameObject, $t.module = this, $t.distance = this.hits[b].distance, $t.worldPosition = this.hits[b].point.$clone(), $t.worldNormal = this.hits[b].normal.$clone(), $t.screenPosition = eventData.position.$clone(), $t.index = resultAppendList.Count, $t.sortingLayer = 0, $t.sortingOrder = 0, $t);
                        resultAppendList.add(result.$clone());
                    }
                }
            },
            /*UnityEngine.EventSystems.PhysicsRaycaster.Raycast end.*/


        }
    });
    /*UnityEngine.EventSystems.PhysicsRaycaster end.*/

    /*UnityEngine.EventSystems.PointerEventData start.*/
    /**
     * Each touch event creates one of these containing all the relevant information.
     *
     * @public
     * @class UnityEngine.EventSystems.PointerEventData
     * @augments UnityEngine.EventSystems.BaseEventData
     */
    Bridge.define("UnityEngine.EventSystems.PointerEventData", {
        inherits: [UnityEngine.EventSystems.BaseEventData],
        fields: {
            /**
             * The object that received 'OnPointerEnter'.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.PointerEventData
             * @function pointerEnter
             * @type UnityEngine.GameObject
             */
            pointerEnter: null,
            _pointerPress: null,
            /**
             * The raw GameObject for the last press event. This means that it is the 'pressed' GameObject even if it can not receive the press event itself.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.PointerEventData
             * @function lastPress
             * @type UnityEngine.GameObject
             */
            lastPress: null,
            /**
             * The object that the press happened on even if it can not handle the press event.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.PointerEventData
             * @function rawPointerPress
             * @type UnityEngine.GameObject
             */
            rawPointerPress: null,
            /**
             * The object that is receiving 'OnDrag'.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.PointerEventData
             * @function pointerDrag
             * @type UnityEngine.GameObject
             */
            pointerDrag: null,
            /**
             * RaycastResult associated with the current event.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.PointerEventData
             * @function pointerCurrentRaycast
             * @type UnityEngine.EventSystems.RaycastResult
             */
            pointerCurrentRaycast: null,
            /**
             * RaycastResult associated with the pointer press.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.PointerEventData
             * @function pointerPressRaycast
             * @type UnityEngine.EventSystems.RaycastResult
             */
            pointerPressRaycast: null,
            hovered: null,
            /**
             * Is it possible to click this frame
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.PointerEventData
             * @function eligibleForClick
             * @type boolean
             */
            eligibleForClick: false,
            /**
             * Id of the pointer (touch id).
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.PointerEventData
             * @function pointerId
             * @type number
             */
            pointerId: 0,
            /**
             * Current pointer position.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.PointerEventData
             * @function position
             * @type UnityEngine.Vector2
             */
            position: null,
            /**
             * Pointer delta since last update.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.PointerEventData
             * @function delta
             * @type UnityEngine.Vector2
             */
            delta: null,
            /**
             * Position of the press.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.PointerEventData
             * @function pressPosition
             * @type UnityEngine.Vector2
             */
            pressPosition: null,
            /**
             * World-space position where a ray cast into the screen hits something
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.PointerEventData
             * @function worldPosition
             * @type UnityEngine.Vector3
             */
            worldPosition: null,
            /**
             * World-space normal where a ray cast into the screen hits something
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.PointerEventData
             * @function worldNormal
             * @type UnityEngine.Vector3
             */
            worldNormal: null,
            /**
             * The last time a click event was sent. Used for double click
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.PointerEventData
             * @function clickTime
             * @type number
             */
            clickTime: 0,
            /**
             * Number of clicks in a row.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.PointerEventData
             * @function clickCount
             * @type number
             */
            clickCount: 0,
            /**
             * The amount of scroll since the last update.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.PointerEventData
             * @function scrollDelta
             * @type UnityEngine.Vector2
             */
            scrollDelta: null,
            /**
             * Should a drag threshold be used?
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.PointerEventData
             * @function useDragThreshold
             * @type boolean
             */
            useDragThreshold: false,
            /**
             * Is a drag operation currently occuring.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.PointerEventData
             * @function dragging
             * @type boolean
             */
            dragging: false,
            /**
             * The EventSystems.PointerEventData.InputButton for this event.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.PointerEventData
             * @function button
             * @type number
             */
            button: 0
        },
        props: {
            /**
             * The camera associated with the last OnPointerEnter event.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.EventSystems.PointerEventData
             * @function enterEventCamera
             * @type UnityEngine.Camera
             */
            enterEventCamera: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerEventData#enterEventCamera#get", this ); }

                    return UnityEngine.MonoBehaviour.op_Equality(this.pointerCurrentRaycast.module, null) ? null : this.pointerCurrentRaycast.module.eventCamera;
                }
            },
            /**
             * The camera associated with the last OnPointerPress event.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.EventSystems.PointerEventData
             * @function pressEventCamera
             * @type UnityEngine.Camera
             */
            pressEventCamera: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerEventData#pressEventCamera#get", this ); }

                    return UnityEngine.MonoBehaviour.op_Equality(this.pointerPressRaycast.module, null) ? null : this.pointerPressRaycast.module.eventCamera;
                }
            },
            /**
             * The GameObject that received the OnPointerDown.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.PointerEventData
             * @function pointerPress
             * @type UnityEngine.GameObject
             */
            pointerPress: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerEventData#pointerPress#get", this ); }

                    return this._pointerPress;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerEventData#pointerPress#set", this ); }

                    if (UnityEngine.GameObject.op_Equality(this._pointerPress, value)) {
                        return;
                    }

                    this.lastPress = this._pointerPress;
                    this._pointerPress = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerEventData#init", this ); }

                this.pointerCurrentRaycast = new UnityEngine.EventSystems.RaycastResult();
                this.pointerPressRaycast = new UnityEngine.EventSystems.RaycastResult();
                this.position = new UnityEngine.Vector2();
                this.delta = new UnityEngine.Vector2();
                this.pressPosition = new UnityEngine.Vector2();
                this.worldPosition = new UnityEngine.Vector3();
                this.worldNormal = new UnityEngine.Vector3();
                this.scrollDelta = new UnityEngine.Vector2();
                this.hovered = new (System.Collections.Generic.List$1(UnityEngine.GameObject)).ctor();
            },
            ctor: function (eventSystem) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerEventData#ctor", this ); }

                this.$initialize();
                UnityEngine.EventSystems.BaseEventData.ctor.call(this, eventSystem);
                this.eligibleForClick = false;

                this.pointerId = -1;
                this.position = pc.Vec2.ZERO.clone(); // Current position of the mouse or touch event
                this.delta = pc.Vec2.ZERO.clone(); // Delta since last update
                this.pressPosition = pc.Vec2.ZERO.clone(); // Delta since the event started being tracked
                this.clickTime = 0.0; // The last time a click event was sent out (used for double-clicks)
                this.clickCount = 0; // Number of clicks in a row. 2 for a double-click for example.

                this.scrollDelta = pc.Vec2.ZERO.clone();
                this.useDragThreshold = true;
                this.dragging = false;
                this.button = UnityEngine.EventSystems.PointerEventData.InputButton.Left;
            }
        },
        methods: {
            /*UnityEngine.EventSystems.PointerEventData.IsPointerMoving start.*/
            /**
             * Is the pointer moving.
             *
             * @instance
             * @public
             * @this UnityEngine.EventSystems.PointerEventData
             * @memberof UnityEngine.EventSystems.PointerEventData
             * @return  {boolean}
             */
            IsPointerMoving: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerEventData#IsPointerMoving", this ); }

                return this.delta.lengthSq() > 0.0;
            },
            /*UnityEngine.EventSystems.PointerEventData.IsPointerMoving end.*/

            /*UnityEngine.EventSystems.PointerEventData.IsScrolling start.*/
            /**
             * Is scroll being used on the input device.
             *
             * @instance
             * @public
             * @this UnityEngine.EventSystems.PointerEventData
             * @memberof UnityEngine.EventSystems.PointerEventData
             * @return  {boolean}
             */
            IsScrolling: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerEventData#IsScrolling", this ); }

                return this.scrollDelta.lengthSq() > 0.0;
            },
            /*UnityEngine.EventSystems.PointerEventData.IsScrolling end.*/

            /*UnityEngine.EventSystems.PointerEventData.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerEventData#toString", this ); }

                var sb = new System.Text.StringBuilder();
                sb.appendLine("<b>Position</b>: " + this.position);
                sb.appendLine("<b>delta</b>: " + this.delta);
                sb.appendLine("<b>eligibleForClick</b>: " + System.Boolean.toString(this.eligibleForClick));
                sb.appendLine(System.String.concat("<b>pointerEnter</b>: ", this.pointerEnter));
                sb.appendLine(System.String.concat("<b>pointerPress</b>: ", this.pointerPress));
                sb.appendLine(System.String.concat("<b>lastPointerPress</b>: ", this.lastPress));
                sb.appendLine(System.String.concat("<b>pointerDrag</b>: ", this.pointerDrag));
                sb.appendLine("<b>Use Drag Threshold</b>: " + System.Boolean.toString(this.useDragThreshold));
                sb.appendLine("<b>Current Raycast:</b>");
                sb.appendLine(Bridge.toString(this.pointerCurrentRaycast));
                sb.appendLine("<b>Press Raycast:</b>");
                sb.appendLine(Bridge.toString(this.pointerPressRaycast));
                return sb.toString();
            },
            /*UnityEngine.EventSystems.PointerEventData.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*UnityEngine.EventSystems.PointerEventData end.*/

    /*UnityEngine.EventSystems.PointerInputModule start.*/
    Bridge.define("UnityEngine.EventSystems.PointerInputModule", {
        inherits: [UnityEngine.EventSystems.BaseInputModule],
        statics: {
            fields: {
                /**
                 * Id of the cached left mouse pointer event.
                 *
                 * @static
                 * @public
                 * @memberof UnityEngine.EventSystems.PointerInputModule
                 * @constant
                 * @default -1
                 * @type number
                 */
                kMouseLeftId: 0,
                /**
                 * Id of the cached right mouse pointer event.
                 *
                 * @static
                 * @public
                 * @memberof UnityEngine.EventSystems.PointerInputModule
                 * @constant
                 * @default -2
                 * @type number
                 */
                kMouseRightId: 0,
                /**
                 * Id of the cached middle mouse pointer event.
                 *
                 * @static
                 * @public
                 * @memberof UnityEngine.EventSystems.PointerInputModule
                 * @constant
                 * @default -3
                 * @type number
                 */
                kMouseMiddleId: 0,
                /**
                 * Touch id for when simulating touches on a non touch device.
                 *
                 * @static
                 * @public
                 * @memberof UnityEngine.EventSystems.PointerInputModule
                 * @constant
                 * @default -4
                 * @type number
                 */
                kFakeTouchesId: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerInputModule#init", this ); }

                    this.kMouseLeftId = -1;
                    this.kMouseRightId = -2;
                    this.kMouseMiddleId = -3;
                    this.kFakeTouchesId = -4;
                }
            },
            methods: {
                /*UnityEngine.EventSystems.PointerInputModule.ShouldStartDrag:static start.*/
                ShouldStartDrag: function (pressPos, currentPos, threshold, useDragThreshold) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerInputModule#ShouldStartDrag", this ); }

                    if (!useDragThreshold) {
                        return true;
                    }

                    return (pressPos.$clone().sub( currentPos )).lengthSq() >= threshold * threshold;
                },
                /*UnityEngine.EventSystems.PointerInputModule.ShouldStartDrag:static end.*/


            }
        },
        fields: {
            m_PointerData: null,
            m_MouseState: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerInputModule#init", this ); }

                this.m_PointerData = new (System.Collections.Generic.Dictionary$2(System.Int32,UnityEngine.EventSystems.PointerEventData)).ctor();
                this.m_MouseState = new UnityEngine.EventSystems.PointerInputModule.MouseState();
            }
        },
        methods: {
            /*UnityEngine.EventSystems.PointerInputModule.GetPointerData start.*/
            /**
             * Search the cache for currently active pointers, return true if found.
             *
             * @instance
             * @protected
             * @this UnityEngine.EventSystems.PointerInputModule
             * @memberof UnityEngine.EventSystems.PointerInputModule
             * @param   {number}                                       id        Touch ID
             * @param   {UnityEngine.EventSystems.PointerEventData}    data      Found data
             * @param   {boolean}                                      create    If not found should it be created
             * @return  {boolean}                                                True if pointer is found.
             */
            GetPointerData: function (id, data, create) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerInputModule#GetPointerData", this ); }

                var $t;
                if (!this.m_PointerData.tryGetValue(id, data) && create) {
                    data.v = ($t = new UnityEngine.EventSystems.PointerEventData(this.eventSystem), $t.pointerId = id, $t);
                    this.m_PointerData.add(id, data.v);
                    return true;
                }

                return false;
            },
            /*UnityEngine.EventSystems.PointerInputModule.GetPointerData end.*/

            /*UnityEngine.EventSystems.PointerInputModule.RemovePointerData start.*/
            /**
             * Remove the PointerEventData from the cache.
             *
             * @instance
             * @protected
             * @this UnityEngine.EventSystems.PointerInputModule
             * @memberof UnityEngine.EventSystems.PointerInputModule
             * @param   {UnityEngine.EventSystems.PointerEventData}    data
             * @return  {void}
             */
            RemovePointerData: function (data) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerInputModule#RemovePointerData", this ); }

                this.m_PointerData.remove(data.pointerId);
            },
            /*UnityEngine.EventSystems.PointerInputModule.RemovePointerData end.*/

            /*UnityEngine.EventSystems.PointerInputModule.GetTouchPointerEventData start.*/
            /**
             * Given a touch populate the PointerEventData and return if we are pressed or released.
             *
             * @instance
             * @protected
             * @this UnityEngine.EventSystems.PointerInputModule
             * @memberof UnityEngine.EventSystems.PointerInputModule
             * @param   {UnityEngine.Touch}                            input       Touch being processed
             * @param   {System.Boolean}                               pressed     Are we pressed this frame
             * @param   {System.Boolean}                               released    Are we released this frame
             * @return  {UnityEngine.EventSystems.PointerEventData}
             */
            GetTouchPointerEventData: function (input, pressed, released) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerInputModule#GetTouchPointerEventData", this ); }

                var pointerData = { };
                var created = this.GetPointerData(input.fingerId, pointerData, true);

                pointerData.v.Reset();

                pressed.v = created || input.phase === UnityEngine.TouchPhase.Began;
                released.v = input.phase === UnityEngine.TouchPhase.Canceled || input.phase === UnityEngine.TouchPhase.Ended;

                if (created) {
                    pointerData.v.position = input.position.$clone();
                }

                if (pressed.v) {
                    pointerData.v.delta = pc.Vec2.ZERO.clone();
                } else {
                    pointerData.v.delta = input.position.$clone().sub( pointerData.v.position );
                }

                pointerData.v.position = input.position.$clone();

                pointerData.v.button = UnityEngine.EventSystems.PointerEventData.InputButton.Left;

                if (input.phase === UnityEngine.TouchPhase.Canceled) {
                    pointerData.v.pointerCurrentRaycast = new UnityEngine.EventSystems.RaycastResult();
                } else {
                    this.eventSystem.RaycastAll(pointerData.v, this.m_RaycastResultCache);

                    var raycast = UnityEngine.EventSystems.BaseInputModule.FindFirstRaycast(this.m_RaycastResultCache);
                    pointerData.v.pointerCurrentRaycast = raycast.$clone();
                    this.m_RaycastResultCache.clear();
                }

                return pointerData.v;
            },
            /*UnityEngine.EventSystems.PointerInputModule.GetTouchPointerEventData end.*/

            /*UnityEngine.EventSystems.PointerInputModule.CopyFromTo start.*/
            /**
             * Copy one PointerEventData to another.
             *
             * @instance
             * @protected
             * @this UnityEngine.EventSystems.PointerInputModule
             * @memberof UnityEngine.EventSystems.PointerInputModule
             * @param   {UnityEngine.EventSystems.PointerEventData}    from    
             * @param   {UnityEngine.EventSystems.PointerEventData}    to
             * @return  {void}
             */
            CopyFromTo: function (from, to) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerInputModule#CopyFromTo", this ); }

                to.position.copy( from.position );
                to.delta.copy( from.delta );
                to.scrollDelta.copy( from.scrollDelta );
                to.pointerCurrentRaycast = from.pointerCurrentRaycast.$clone();
                to.pointerEnter = from.pointerEnter;
            },
            /*UnityEngine.EventSystems.PointerInputModule.CopyFromTo end.*/

            /*UnityEngine.EventSystems.PointerInputModule.StateForMouseButton start.*/
            /**
             * Given a mouse button return the current state for the frame.
             *
             * @instance
             * @protected
             * @this UnityEngine.EventSystems.PointerInputModule
             * @memberof UnityEngine.EventSystems.PointerInputModule
             * @param   {number}    buttonId    Mouse button ID
             * @return  {number}
             */
            StateForMouseButton: function (buttonId) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerInputModule#StateForMouseButton", this ); }

                var pressed = this.input.GetMouseButtonDown(buttonId);
                var released = this.input.GetMouseButtonUp(buttonId);
                if (pressed && released) {
                    return UnityEngine.EventSystems.PointerEventData.FramePressState.PressedAndReleased;
                }

                if (pressed) {
                    return UnityEngine.EventSystems.PointerEventData.FramePressState.Pressed;
                }

                if (released) {
                    return UnityEngine.EventSystems.PointerEventData.FramePressState.Released;
                }

                return UnityEngine.EventSystems.PointerEventData.FramePressState.NotChanged;
            },
            /*UnityEngine.EventSystems.PointerInputModule.StateForMouseButton end.*/

            /*UnityEngine.EventSystems.PointerInputModule.GetMousePointerEventData start.*/
            /**
             * Return the current MouseState. Using the default pointer.
             *
             * @instance
             * @protected
             * @this UnityEngine.EventSystems.PointerInputModule
             * @memberof UnityEngine.EventSystems.PointerInputModule
             * @return  {UnityEngine.EventSystems.PointerInputModule.MouseState}
             */
            GetMousePointerEventData: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerInputModule#GetMousePointerEventData", this ); }

                return this.GetMousePointerEventData$1(0);
            },
            /*UnityEngine.EventSystems.PointerInputModule.GetMousePointerEventData end.*/

            /*UnityEngine.EventSystems.PointerInputModule.GetMousePointerEventData$1 start.*/
            /**
             * Return the current MouseState.
             *
             * @instance
             * @protected
             * @this UnityEngine.EventSystems.PointerInputModule
             * @memberof UnityEngine.EventSystems.PointerInputModule
             * @param   {number}                                                    id
             * @return  {UnityEngine.EventSystems.PointerInputModule.MouseState}
             */
            GetMousePointerEventData$1: function (id) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerInputModule#GetMousePointerEventData$1", this ); }

                var $t;
                // Populate the left button...
                var leftData = { };
                var created = this.GetPointerData(UnityEngine.EventSystems.PointerInputModule.kMouseLeftId, leftData, true);

                leftData.v.Reset();

                if (created) {
                    leftData.v.position = UnityEngine.Vector2.FromVector3(this.input.mousePosition.$clone());
                }

                var pos = this.input.mousePosition.$clone();
                if (UnityEngine.Cursor.lockState === UnityEngine.CursorLockMode.Locked) {
                    // We don't want to do ANY cursor-based interaction when the mouse is locked
                    leftData.v.position = new pc.Vec2( -1.0, -1.0 );
                    leftData.v.delta = pc.Vec2.ZERO.clone();
                } else {
                    leftData.v.delta = UnityEngine.Vector2.FromVector3(($t = leftData.v.position, pos.$clone().subScalars( $t.x, $t.y, 0 )));
                    leftData.v.position = UnityEngine.Vector2.FromVector3(pos.$clone());
                }

                leftData.v.scrollDelta = this.input.mouseScrollDelta.$clone();
                leftData.v.button = UnityEngine.EventSystems.PointerEventData.InputButton.Left;
                this.eventSystem.RaycastAll(leftData.v, this.m_RaycastResultCache);
                var raycast = UnityEngine.EventSystems.BaseInputModule.FindFirstRaycast(this.m_RaycastResultCache);
                leftData.v.pointerCurrentRaycast = raycast.$clone();
                this.m_RaycastResultCache.clear();

                // Copy the apropriate data into right and middle slots
                var rightData = { };
                this.GetPointerData(UnityEngine.EventSystems.PointerInputModule.kMouseRightId, rightData, true);
                this.CopyFromTo(leftData.v, rightData.v);
                rightData.v.button = UnityEngine.EventSystems.PointerEventData.InputButton.Right;

                var middleData = { };
                this.GetPointerData(UnityEngine.EventSystems.PointerInputModule.kMouseMiddleId, middleData, true);
                this.CopyFromTo(leftData.v, middleData.v);
                middleData.v.button = UnityEngine.EventSystems.PointerEventData.InputButton.Middle;

                this.m_MouseState.SetButtonState(UnityEngine.EventSystems.PointerEventData.InputButton.Left, this.StateForMouseButton(0), leftData.v);
                this.m_MouseState.SetButtonState(UnityEngine.EventSystems.PointerEventData.InputButton.Right, this.StateForMouseButton(1), rightData.v);
                this.m_MouseState.SetButtonState(UnityEngine.EventSystems.PointerEventData.InputButton.Middle, this.StateForMouseButton(2), middleData.v);

                return this.m_MouseState;
            },
            /*UnityEngine.EventSystems.PointerInputModule.GetMousePointerEventData$1 end.*/

            /*UnityEngine.EventSystems.PointerInputModule.GetLastPointerEventData start.*/
            /**
             * Return the last PointerEventData for the given touch / mouse id.
             *
             * @instance
             * @protected
             * @this UnityEngine.EventSystems.PointerInputModule
             * @memberof UnityEngine.EventSystems.PointerInputModule
             * @param   {number}                                       id
             * @return  {UnityEngine.EventSystems.PointerEventData}
             */
            GetLastPointerEventData: function (id) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerInputModule#GetLastPointerEventData", this ); }

                var data = { };
                this.GetPointerData(id, data, false);
                return data.v;
            },
            /*UnityEngine.EventSystems.PointerInputModule.GetLastPointerEventData end.*/

            /*UnityEngine.EventSystems.PointerInputModule.ProcessMove start.*/
            /**
             * Process movement for the current frame with the given pointer event.
             *
             * @instance
             * @protected
             * @this UnityEngine.EventSystems.PointerInputModule
             * @memberof UnityEngine.EventSystems.PointerInputModule
             * @param   {UnityEngine.EventSystems.PointerEventData}    pointerEvent
             * @return  {void}
             */
            ProcessMove: function (pointerEvent) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerInputModule#ProcessMove", this ); }

                var targetGO = UnityEngine.Cursor.lockState === UnityEngine.CursorLockMode.Locked ? null : pointerEvent.pointerCurrentRaycast.gameObject;
                this.HandlePointerExitAndEnter(pointerEvent, targetGO);
            },
            /*UnityEngine.EventSystems.PointerInputModule.ProcessMove end.*/

            /*UnityEngine.EventSystems.PointerInputModule.ProcessDrag start.*/
            /**
             * Process the drag for the current frame with the given pointer event.
             *
             * @instance
             * @protected
             * @this UnityEngine.EventSystems.PointerInputModule
             * @memberof UnityEngine.EventSystems.PointerInputModule
             * @param   {UnityEngine.EventSystems.PointerEventData}    pointerEvent
             * @return  {void}
             */
            ProcessDrag: function (pointerEvent) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerInputModule#ProcessDrag", this ); }

                if (!pointerEvent.IsPointerMoving() || UnityEngine.Cursor.lockState === UnityEngine.CursorLockMode.Locked || UnityEngine.GameObject.op_Equality(pointerEvent.pointerDrag, null)) {
                    return;
                }

                if (!pointerEvent.dragging && UnityEngine.EventSystems.PointerInputModule.ShouldStartDrag(pointerEvent.pressPosition.$clone(), pointerEvent.position.$clone(), this.eventSystem.pixelDragThreshold, pointerEvent.useDragThreshold)) {
                    UnityEngine.EventSystems.ExecuteEvents.Execute(UnityEngine.EventSystems.IBeginDragHandler, pointerEvent.pointerDrag, pointerEvent, UnityEngine.EventSystems.ExecuteEvents.beginDragHandler);
                    pointerEvent.dragging = true;
                }

                // Drag notification
                if (pointerEvent.dragging) {
                    // Before doing drag we should cancel any pointer down state
                    // And clear selection!
                    if (UnityEngine.GameObject.op_Inequality(pointerEvent.pointerPress, pointerEvent.pointerDrag)) {
                        UnityEngine.EventSystems.ExecuteEvents.Execute(UnityEngine.EventSystems.IPointerUpHandler, pointerEvent.pointerPress, pointerEvent, UnityEngine.EventSystems.ExecuteEvents.pointerUpHandler);

                        pointerEvent.eligibleForClick = false;
                        pointerEvent.pointerPress = null;
                        pointerEvent.rawPointerPress = null;
                    }

                    UnityEngine.EventSystems.ExecuteEvents.Execute(UnityEngine.EventSystems.IDragHandler, pointerEvent.pointerDrag, pointerEvent, UnityEngine.EventSystems.ExecuteEvents.dragHandler);
                }
            },
            /*UnityEngine.EventSystems.PointerInputModule.ProcessDrag end.*/

            /*UnityEngine.EventSystems.PointerInputModule.IsPointerOverGameObject start.*/
            IsPointerOverGameObject: function (pointerId) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerInputModule#IsPointerOverGameObject", this ); }

                var lastPointer = this.GetLastPointerEventData(pointerId);
                if (lastPointer != null) {
                    return UnityEngine.GameObject.op_Inequality(lastPointer.pointerEnter, null);
                }

                return false;
            },
            /*UnityEngine.EventSystems.PointerInputModule.IsPointerOverGameObject end.*/

            /*UnityEngine.EventSystems.PointerInputModule.ClearSelection start.*/
            /**
             * Clear all pointers and deselect any selected objects in the EventSystem.
             *
             * @instance
             * @protected
             * @this UnityEngine.EventSystems.PointerInputModule
             * @memberof UnityEngine.EventSystems.PointerInputModule
             * @return  {void}
             */
            ClearSelection: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerInputModule#ClearSelection", this ); }

                var $t;
                var baseEventData = this.GetBaseEventData();

                $t = Bridge.getEnumerator(this.m_PointerData.Values);
                try {
                    while ($t.moveNext()) {
                        var pointer = $t.Current;
                        // Clear all selection
                        this.HandlePointerExitAndEnter(pointer, null);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                this.m_PointerData.clear();
                this.eventSystem.SetSelectedGameObject$1(null, baseEventData);
            },
            /*UnityEngine.EventSystems.PointerInputModule.ClearSelection end.*/

            /*UnityEngine.EventSystems.PointerInputModule.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerInputModule#toString", this ); }

                var $t;
                var sb = new System.Text.StringBuilder(System.String.concat("<b>Pointer Input Module of type: </b>", Bridge.getTypeName(Bridge.getType(this))));
                sb.appendLine();
                $t = Bridge.getEnumerator(this.m_PointerData);
                try {
                    while ($t.moveNext()) {
                        var pointer = $t.Current;
                        if (pointer.value == null) {
                            continue;
                        }

                        sb.appendLine("<B>Pointer:</b> " + pointer.key);
                        sb.appendLine(pointer.value.toString());
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                return sb.toString();
            },
            /*UnityEngine.EventSystems.PointerInputModule.toString end.*/

            /*UnityEngine.EventSystems.PointerInputModule.DeselectIfSelectionChanged start.*/
            /**
             * Deselect the current selected GameObject if the currently pointed-at GameObject is different.
             *
             * @instance
             * @protected
             * @this UnityEngine.EventSystems.PointerInputModule
             * @memberof UnityEngine.EventSystems.PointerInputModule
             * @param   {UnityEngine.GameObject}                    currentOverGo    The GameObject the pointer is currently over.
             * @param   {UnityEngine.EventSystems.BaseEventData}    pointerEvent     Current event data.
             * @return  {void}
             */
            DeselectIfSelectionChanged: function (currentOverGo, pointerEvent) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.PointerInputModule#DeselectIfSelectionChanged", this ); }

                // Selection tracking
                var selectHandlerGO = UnityEngine.EventSystems.ExecuteEvents.GetEventHandler(UnityEngine.EventSystems.ISelectHandler, currentOverGo);
                // If we have clicked something new, deselect the old thing
                // Leave 'selection handling' up to the press event though.
                if (UnityEngine.GameObject.op_Inequality(selectHandlerGO, this.eventSystem.currentSelectedGameObject)) {
                    this.eventSystem.SetSelectedGameObject$1(null, pointerEvent);
                }
            },
            /*UnityEngine.EventSystems.PointerInputModule.DeselectIfSelectionChanged end.*/


        },
        overloads: {
            "GetMousePointerEventData(int)": "GetMousePointerEventData$1",
            "ToString()": "toString"
        }
    });
    /*UnityEngine.EventSystems.PointerInputModule end.*/

    /*UnityEngine.UI.Selectable start.*/
    /**
     * Simple selectable object - derived from to create a selectable control.
     *
     * @public
     * @class UnityEngine.UI.Selectable
     * @augments UnityEngine.EventSystems.UIBehaviour
     * @implements  UnityEngine.EventSystems.IMoveHandler
     * @implements  UnityEngine.EventSystems.IPointerDownHandler
     * @implements  UnityEngine.EventSystems.IPointerUpHandler
     * @implements  UnityEngine.EventSystems.IPointerEnterHandler
     * @implements  UnityEngine.EventSystems.IPointerExitHandler
     * @implements  UnityEngine.EventSystems.ISelectHandler
     * @implements  UnityEngine.EventSystems.IDeselectHandler
     */
    Bridge.define("UnityEngine.UI.Selectable", {
        inherits: [UnityEngine.EventSystems.UIBehaviour,UnityEngine.EventSystems.IMoveHandler,UnityEngine.EventSystems.IPointerDownHandler,UnityEngine.EventSystems.IPointerUpHandler,UnityEngine.EventSystems.IPointerEnterHandler,UnityEngine.EventSystems.IPointerExitHandler,UnityEngine.EventSystems.ISelectHandler,UnityEngine.EventSystems.IDeselectHandler],
        statics: {
            fields: {
                selectables: null,
                selectableCount: 0,
                isDirty: false
            },
            props: {
                /**
                 * Copy of the array of all the selectable objects currently active in the scene.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof UnityEngine.UI.Selectable
                 * @function allSelectablesArray
                 * @type Array.<UnityEngine.UI.Selectable>
                 */
                allSelectablesArray: {
                    get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#allSelectablesArray#get", this ); }

                        if (UnityEngine.UI.Selectable.isDirty) {
                            UnityEngine.UI.Selectable.RemoveInvalidSelectables();
                        }

                        var temp = System.Array.init(UnityEngine.UI.Selectable.selectableCount, null, UnityEngine.UI.Selectable);
                        System.Array.copy(UnityEngine.UI.Selectable.selectables, 0, temp, 0, UnityEngine.UI.Selectable.selectableCount);
                        return temp;
                    }
                },
                /**
                 * How many selectable elements are currently active.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof UnityEngine.UI.Selectable
                 * @function allSelectableCount
                 * @type number
                 */
                allSelectableCount: {
                    get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#allSelectableCount#get", this ); }

                        return UnityEngine.UI.Selectable.selectableCount;
                    }
                },
                /**
                 * A List instance of the allSelectablesArray to maintain API compatibility.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof UnityEngine.UI.Selectable
                 * @function allSelectables
                 * @type System.Collections.Generic.List$1
                 */
                allSelectables: {
                    get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#allSelectables#get", this ); }

                        return new (System.Collections.Generic.List$1(UnityEngine.UI.Selectable)).$ctor1(UnityEngine.UI.Selectable.allSelectablesArray);
                    }
                }
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#init", this ); }

                    this.selectables = System.Array.init(10, null, UnityEngine.UI.Selectable);
                    this.selectableCount = 0;
                    this.isDirty = false;
                }
            },
            methods: {
                /*UnityEngine.UI.Selectable.AllSelectablesNoAlloc:static start.*/
                /**
                 * Non allocating version for getting the all selectables.
                 If selectables.Length is less then selectableCount only selectables.Length elements will be copied which
                 could result in a incomplete list of elements.
                 *
                 * @static
                 * @public
                 * @this UnityEngine.UI.Selectable
                 * @memberof UnityEngine.UI.Selectable
                 * @param   {Array.<UnityEngine.UI.Selectable>}    selectables    The array to be filled with current selectable objects
                 * @return  {number}                                              The number of element copied.
                 */
                AllSelectablesNoAlloc: function (selectables) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#AllSelectablesNoAlloc", this ); }

                    if (UnityEngine.UI.Selectable.isDirty) {
                        UnityEngine.UI.Selectable.RemoveInvalidSelectables();
                    }

                    var copyCount = selectables.length < UnityEngine.UI.Selectable.selectableCount ? selectables.length : UnityEngine.UI.Selectable.selectableCount;
                    System.Array.copy(UnityEngine.UI.Selectable.selectables, 0, selectables, 0, copyCount);

                    return copyCount;
                },
                /*UnityEngine.UI.Selectable.AllSelectablesNoAlloc:static end.*/

                /*UnityEngine.UI.Selectable.RemoveInvalidSelectables:static start.*/
                RemoveInvalidSelectables: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#RemoveInvalidSelectables", this ); }

                    for (var i = UnityEngine.UI.Selectable.selectableCount - 1; i >= 0; --i) {
                        // Swap last element in array with element to be removed
                        if (UnityEngine.MonoBehaviour.op_Equality(UnityEngine.UI.Selectable.selectables[i], null) || UnityEngine.UI.Selectable.selectables[i]._willRemove) {
                            UnityEngine.UI.Selectable.selectables[i] = UnityEngine.UI.Selectable.selectables[--UnityEngine.UI.Selectable.selectableCount];
                        }
                    }

                    UnityEngine.UI.Selectable.isDirty = false;
                },
                /*UnityEngine.UI.Selectable.RemoveInvalidSelectables:static end.*/

                /*UnityEngine.UI.Selectable.GetPointOnRectEdge:static start.*/
                GetPointOnRectEdge: function (rect, dir) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#GetPointOnRectEdge", this ); }

                    var $t, $t1;
                    if (UnityEngine.Component.op_Equality(rect, null)) {
                        return pc.Vec3.ZERO.clone();
                    }

                    if (!pc.Vec2.equals( dir, pc.Vec2.ZERO.clone() )) {
                        dir = dir.$clone().scale( 1.0 / ( UnityEngine.Mathf.Max(Math.abs(dir.x), Math.abs(dir.y)) ) );
                    }

                    dir = rect.rect.center.$clone().add( ($t = rect.rect.size, $t1 = dir.$clone().scale( 0.5 ), new pc.Vec2( $t.x * $t1.x, $t.y * $t1.y )) );
                    return UnityEngine.Vector3.FromVector2(dir.$clone());
                },
                /*UnityEngine.UI.Selectable.GetPointOnRectEdge:static end.*/


            }
        },
        fields: {
            m_Navigation: null,
            m_Transition: 0,
            m_Colors: null,
            m_SpriteState: null,
            m_AnimationTriggers: null,
            m_Interactable: false,
            m_TargetGraphic: null,
            _groupsAllowInteraction: false,
            _willRemove: false,
            isPointerInside: false,
            isPointerDown: false,
            hasSelection: false
        },
        props: {
            /**
             * The Navigation setting for this selectable object.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Selectable
             * @function navigation
             * @type UnityEngine.UI.Navigation
             */
            navigation: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#navigation#get", this ); }

                    return this.m_Navigation.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#navigation#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetStruct(UnityEngine.UI.Navigation, Bridge.ref(this, "m_Navigation"), value.$clone())) {
                        this.OnSetProperty();
                    }
                }
            },
            /**
             * The type of transition that will be applied to the targetGraphic when the state changes.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Selectable
             * @function transition
             * @type number
             */
            transition: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#transition#get", this ); }

                    return this.m_Transition;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#transition#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetStruct(UnityEngine.UI.Selectable.Transition, Bridge.ref(this, "m_Transition"), value)) {
                        this.OnSetProperty();
                    }
                }
            },
            /**
             * The ColorBlock for this selectable object.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Selectable
             * @function colors
             * @type UnityEngine.UI.ColorBlock
             */
            colors: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#colors#get", this ); }

                    return this.m_Colors.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#colors#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetStruct(UnityEngine.UI.ColorBlock, Bridge.ref(this, "m_Colors"), value.$clone())) {
                        this.OnSetProperty();
                    }
                }
            },
            /**
             * The SpriteState for this selectable object.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Selectable
             * @function spriteState
             * @type UnityEngine.UI.SpriteState
             */
            spriteState: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#spriteState#get", this ); }

                    return this.m_SpriteState.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#spriteState#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetStruct(UnityEngine.UI.SpriteState, Bridge.ref(this, "m_SpriteState"), value.$clone())) {
                        this.OnSetProperty();
                    }
                }
            },
            /**
             * The AnimationTriggers for this selectable object.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Selectable
             * @function animationTriggers
             * @type UnityEngine.UI.AnimationTriggers
             */
            animationTriggers: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#animationTriggers#get", this ); }

                    return this.m_AnimationTriggers;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#animationTriggers#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetClass(UnityEngine.UI.AnimationTriggers, Bridge.ref(this, "m_AnimationTriggers"), value)) {
                        this.OnSetProperty();
                    }
                }
            },
            /**
             * Graphic that will be transitioned upon.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Selectable
             * @function targetGraphic
             * @type UnityEngine.UI.Graphic
             */
            targetGraphic: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#targetGraphic#get", this ); }

                    return this.m_TargetGraphic;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#targetGraphic#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetClass(UnityEngine.UI.Graphic, Bridge.ref(this, "m_TargetGraphic"), value)) {
                        this.OnSetProperty();
                    }
                }
            },
            /**
             * Is this object interactable.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Selectable
             * @function interactable
             * @type boolean
             */
            interactable: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#interactable#get", this ); }

                    return this.IsInteractable();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#interactable#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetStruct(System.Boolean, Bridge.ref(this, "m_Interactable"), value)) {
                        if (!this.m_Interactable && UnityEngine.MonoBehaviour.op_Inequality(UnityEngine.EventSystems.EventSystem.current, null) && UnityEngine.GameObject.op_Equality(UnityEngine.EventSystems.EventSystem.current.currentSelectedGameObject, this.gameObject)) {
                            UnityEngine.EventSystems.EventSystem.current.SetSelectedGameObject(null);
                        }

                        this.OnSetProperty();
                    }
                }
            },
            /**
             * Convenience function that converts the referenced Graphic to a Image, if possible.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Selectable
             * @function image
             * @type UnityEngine.UI.Image
             */
            image: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#image#get", this ); }

                    return Bridge.as(this.m_TargetGraphic, UnityEngine.UI.Image);
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#image#set", this ); }

                    this.m_TargetGraphic = value;
                }
            },
            /**
             * Convenience function to get the Animator component on the GameObject.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.Selectable
             * @function animator
             * @type UnityEngine.Animator
             */
            animator: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#animator#get", this ); }

                    return this.GetComponent(UnityEngine.Animator);
                }
            },
            currentSelectionState: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#currentSelectionState#get", this ); }

                    if (!this.IsInteractable()) {
                        return UnityEngine.UI.Selectable.SelectionState.Disabled;
                    }

                    if (this.isPointerDown) {
                        return UnityEngine.UI.Selectable.SelectionState.Pressed;
                    }

                    if (this.hasSelection) {
                        return UnityEngine.UI.Selectable.SelectionState.Selected;
                    }

                    if (this.isPointerInside) {
                        return UnityEngine.UI.Selectable.SelectionState.Highlighted;
                    }

                    return UnityEngine.UI.Selectable.SelectionState.Normal;
                }
            }
        },
        alias: [
            "OnMove", "UnityEngine$EventSystems$IMoveHandler$OnMove",
            "OnPointerDown", "UnityEngine$EventSystems$IPointerDownHandler$OnPointerDown",
            "OnPointerUp", "UnityEngine$EventSystems$IPointerUpHandler$OnPointerUp",
            "OnPointerEnter", "UnityEngine$EventSystems$IPointerEnterHandler$OnPointerEnter",
            "OnPointerExit", "UnityEngine$EventSystems$IPointerExitHandler$OnPointerExit",
            "OnSelect", "UnityEngine$EventSystems$ISelectHandler$OnSelect",
            "OnDeselect", "UnityEngine$EventSystems$IDeselectHandler$OnDeselect"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#init", this ); }

                this.m_Navigation = new UnityEngine.UI.Navigation();
                this.m_Colors = new UnityEngine.UI.ColorBlock();
                this.m_SpriteState = new UnityEngine.UI.SpriteState();
                this.m_Navigation = UnityEngine.UI.Navigation.defaultNavigation.$clone();
                this.m_Transition = UnityEngine.UI.Selectable.Transition.ColorTint;
                this.m_Colors = UnityEngine.UI.ColorBlock.defaultColorBlock.$clone();
                this.m_AnimationTriggers = new UnityEngine.UI.AnimationTriggers();
                this.m_Interactable = true;
                this._groupsAllowInteraction = true;
                this._willRemove = false;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#ctor", this ); }

                this.$initialize();
                UnityEngine.EventSystems.UIBehaviour.ctor.call(this);
            },
            /**
             * Initializes a new instance of the {@link } class.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Selectable
             * @memberof UnityEngine.UI.Selectable
             * @param   {pc.MonoBehaviourComponent}    handle    Handle.
             * @return  {void}
             */
            $ctor1: function (handle) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#$ctor1", this ); }

                this.$initialize();
                UnityEngine.EventSystems.UIBehaviour.$ctor1.call(this, handle);
            }
        },
        methods: {
            /*UnityEngine.UI.Selectable.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#Awake", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.m_TargetGraphic, null)) {
                    this.m_TargetGraphic = this.GetComponent(UnityEngine.UI.Graphic);
                }

                // because of order of callbacks, Element.CanvasGroups is not init yet and OnCanvasGroupChanged will be called later,
                // but we need it to get interactable state, and it will be set in OnEnable as state instantly
                this._groupsAllowInteraction = UnityEngine.CanvasGroup.ExtractInteractable(this.GetComponentsInParent(UnityEngine.CanvasGroup));
            },
            /*UnityEngine.UI.Selectable.Awake end.*/

            /*UnityEngine.UI.Selectable.OnCanvasGroupChanged start.*/
            OnCanvasGroupChanged: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#OnCanvasGroupChanged", this ); }

                // Figure out if parent groups allow interaction
                // If no interaction is allowed... then we need
                // to not do that :)
                // Unity's implementation is way too heavy, so let's use our implementation as we cache all parent canvasGroups
                var groupAllowInteraction = UnityEngine.CanvasGroup.ExtractInteractable(this.handle.entity.element._canvasGroups);
                if (groupAllowInteraction !== this._groupsAllowInteraction) {
                    this._groupsAllowInteraction = groupAllowInteraction;
                    this.OnSetProperty();
                }
            },
            /*UnityEngine.UI.Selectable.OnCanvasGroupChanged end.*/

            /*UnityEngine.UI.Selectable.IsInteractable start.*/
            /**
             * Is the object interactable.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Selectable
             * @memberof UnityEngine.UI.Selectable
             * @return  {boolean}
             */
            IsInteractable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#IsInteractable", this ); }

                return this._groupsAllowInteraction && this.m_Interactable;
            },
            /*UnityEngine.UI.Selectable.IsInteractable end.*/

            /*UnityEngine.UI.Selectable.OnDidApplyAnimationProperties start.*/
            OnDidApplyAnimationProperties: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#OnDidApplyAnimationProperties", this ); }

                this.OnSetProperty();
            },
            /*UnityEngine.UI.Selectable.OnDidApplyAnimationProperties end.*/

            /*UnityEngine.UI.Selectable.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#OnEnable", this ); }

                UnityEngine.EventSystems.UIBehaviour.prototype.OnEnable.call(this);

                if (UnityEngine.UI.Selectable.isDirty) {
                    UnityEngine.UI.Selectable.RemoveInvalidSelectables();
                }

                this._willRemove = false;

                if (UnityEngine.UI.Selectable.selectableCount === UnityEngine.UI.Selectable.selectables.length) {
                    var temp = System.Array.init(UnityEngine.UI.Selectable.selectables.length * 2, null, UnityEngine.UI.Selectable);
                    System.Array.copy(UnityEngine.UI.Selectable.selectables, 0, temp, 0, UnityEngine.UI.Selectable.selectables.length);
                    UnityEngine.UI.Selectable.selectables = temp;
                }

                UnityEngine.UI.Selectable.selectables[UnityEngine.UI.Selectable.selectableCount++] = this;
                this.isPointerDown = false;
                this.DoStateTransition(this.currentSelectionState, true);
            },
            /*UnityEngine.UI.Selectable.OnEnable end.*/

            /*UnityEngine.UI.Selectable.OnTransformParentChanged start.*/
            OnTransformParentChanged: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#OnTransformParentChanged", this ); }

                UnityEngine.EventSystems.UIBehaviour.prototype.OnTransformParentChanged.call(this);

                // If our parenting changes figure out if we are under a new CanvasGroup.
                this.OnCanvasGroupChanged();
            },
            /*UnityEngine.UI.Selectable.OnTransformParentChanged end.*/

            /*UnityEngine.UI.Selectable.OnSetProperty start.*/
            OnSetProperty: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#OnSetProperty", this ); }

                this.DoStateTransition(this.currentSelectionState, false);
            },
            /*UnityEngine.UI.Selectable.OnSetProperty end.*/

            /*UnityEngine.UI.Selectable.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#OnDisable", this ); }

                this._willRemove = true;
                UnityEngine.UI.Selectable.isDirty = true;

                this.InstantClearState();
                UnityEngine.EventSystems.UIBehaviour.prototype.OnDisable.call(this);
            },
            /*UnityEngine.UI.Selectable.OnDisable end.*/

            /*UnityEngine.UI.Selectable.InstantClearState start.*/
            InstantClearState: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#InstantClearState", this ); }

                var triggerName = this.m_AnimationTriggers.normalTrigger;

                this.isPointerInside = false;
                this.isPointerDown = false;
                this.hasSelection = false;

                switch (this.m_Transition) {
                    case UnityEngine.UI.Selectable.Transition.ColorTint: 
                        this.StartColorTween(new pc.Color( 1, 1, 1, 1 ), true);
                        break;
                    case UnityEngine.UI.Selectable.Transition.SpriteSwap: 
                        this.DoSpriteSwap(null);
                        break;
                    case UnityEngine.UI.Selectable.Transition.Animation: 
                        this.TriggerAnimation(triggerName);
                        break;
                }
            },
            /*UnityEngine.UI.Selectable.InstantClearState end.*/

            /*UnityEngine.UI.Selectable.DoStateTransition start.*/
            /**
             * Transition the Selectable to the entered state.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.Selectable
             * @memberof UnityEngine.UI.Selectable
             * @param   {number}     state      State to transition to
             * @param   {boolean}    instant    Should the transition occur instantly.
             * @return  {void}
             */
            DoStateTransition: function (state, instant) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#DoStateTransition", this ); }

                var $t;
                if (!this.gameObject.activeInHierarchy) {
                    return;
                }

                var tintColor = new pc.Color.ctor();
                var transitionSprite;
                var triggerName;

                //Because we won't support any unity version below 2018.2
                //And this feature implemented in unity 2019 this check will be enough
                if (System.String.contains(UnityEngine.Application.unityVersion,"2018")) {
                    if (state === UnityEngine.UI.Selectable.SelectionState.Selected) {
                        state = UnityEngine.UI.Selectable.SelectionState.Highlighted;
                    }
                }

                switch (state) {
                    case UnityEngine.UI.Selectable.SelectionState.Normal: 
                        tintColor = this.m_Colors.normalColor.$clone();
                        transitionSprite = null;
                        triggerName = this.m_AnimationTriggers.normalTrigger;
                        break;
                    case UnityEngine.UI.Selectable.SelectionState.Highlighted: 
                        tintColor = this.m_Colors.highlightedColor.$clone();
                        transitionSprite = this.m_SpriteState.highlightedSprite;
                        triggerName = this.m_AnimationTriggers.highlightedTrigger;
                        break;
                    case UnityEngine.UI.Selectable.SelectionState.Pressed: 
                        tintColor = this.m_Colors.pressedColor.$clone();
                        transitionSprite = this.m_SpriteState.pressedSprite;
                        triggerName = this.m_AnimationTriggers.pressedTrigger;
                        break;
                    case UnityEngine.UI.Selectable.SelectionState.Selected: 
                        tintColor = this.m_Colors.selectedColor.$clone();
                        transitionSprite = this.m_SpriteState.selectedSprite;
                        triggerName = this.m_AnimationTriggers.selectedTrigger;
                        break;
                    case UnityEngine.UI.Selectable.SelectionState.Disabled: 
                        tintColor = this.m_Colors.disabledColor.$clone();
                        transitionSprite = this.m_SpriteState.disabledSprite;
                        triggerName = this.m_AnimationTriggers.disabledTrigger;
                        break;
                    default: 
                        tintColor = new pc.Color( 0, 0, 0, 1 );
                        transitionSprite = null;
                        triggerName = "";
                        break;
                }

                switch (this.m_Transition) {
                    case UnityEngine.UI.Selectable.Transition.ColorTint: 
                        this.StartColorTween(($t = this.m_Colors.colorMultiplier, new pc.Color( tintColor.r * $t, tintColor.g * $t, tintColor.b * $t, tintColor.a * $t )), instant);
                        break;
                    case UnityEngine.UI.Selectable.Transition.SpriteSwap: 
                        this.DoSpriteSwap(transitionSprite);
                        break;
                    case UnityEngine.UI.Selectable.Transition.Animation: 
                        this.TriggerAnimation(triggerName);
                        break;
                }
            },
            /*UnityEngine.UI.Selectable.DoStateTransition end.*/

            /*UnityEngine.UI.Selectable.FindSelectable start.*/
            /**
             * Finds the selectable object next to this one.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Selectable
             * @memberof UnityEngine.UI.Selectable
             * @param   {UnityEngine.Vector3}          dir    The direction in which to search for a neighbouring Selectable object.
             * @return  {UnityEngine.UI.Selectable}           The neighbouring Selectable object. Null if none found.
             */
            FindSelectable: function (dir) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#FindSelectable", this ); }

                dir = dir.clone().normalize().$clone();
                var localDir = this.transform.rotation.clone().invert().transformVector( dir );
                var pos = this.transform.TransformPoint$1(UnityEngine.UI.Selectable.GetPointOnRectEdge(Bridge.as(this.transform, UnityEngine.RectTransform), UnityEngine.Vector2.FromVector3(localDir.$clone())));
                var maxScore = (-window.Infinity);
                var bestPick = null;

                if (UnityEngine.UI.Selectable.isDirty) {
                    UnityEngine.UI.Selectable.RemoveInvalidSelectables();
                }

                for (var i = 0; i < UnityEngine.UI.Selectable.selectableCount; ++i) {
                    var sel = UnityEngine.UI.Selectable.selectables[i];

                    if (UnityEngine.MonoBehaviour.op_Equality(sel, this)) {
                        continue;
                    }

                    if (!sel.IsInteractable() || sel.navigation.mode === UnityEngine.UI.Navigation.Mode.None) {
                        continue;
                    }

                    var selRect = Bridge.as(sel.transform, UnityEngine.RectTransform);
                    var selCenter = UnityEngine.Component.op_Inequality(selRect, null) ? UnityEngine.Vector3.FromVector2(selRect.rect.center) : pc.Vec3.ZERO.clone();
                    var myVector = sel.transform.TransformPoint$1(selCenter).sub( pos );

                    // Value that is the distance out along the direction.
                    var dot = dir.dot( myVector );

                    // Skip elements that are in the wrong direction or which have zero distance.
                    // This also ensures that the scoring formula below will not have a division by zero error.
                    if (dot <= 0) {
                        continue;
                    }

                    // This scoring function has two priorities:
                    // - Score higher for positions that are closer.
                    // - Score higher for positions that are located in the right direction.
                    // This scoring function combines both of these criteria.
                    // It can be seen as this:
                    //   Dot (dir, myVector.normalized) / myVector.magnitude
                    // The first part equals 1 if the direction of myVector is the same as dir, and 0 if it's orthogonal.
                    // The second part scores lower the greater the distance is by dividing by the distance.
                    // The formula below is equivalent but more optimized.
                    //
                    // If a given score is chosen, the positions that evaluate to that score will form a circle
                    // that touches pos and whose center is located along dir. A way to visualize the resulting functionality is this:
                    // From the position pos, blow up a circular balloon so it grows in the direction of dir.
                    // The first Selectable whose center the circular balloon touches is the one that's chosen.
                    var score = dot / myVector.lengthSq();

                    if (score > maxScore) {
                        maxScore = score;
                        bestPick = sel;
                    }
                }

                return bestPick;
            },
            /*UnityEngine.UI.Selectable.FindSelectable end.*/

            /*UnityEngine.UI.Selectable.Navigate start.*/
            Navigate: function (eventData, sel) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#Navigate", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(sel, null) && sel.IsActive()) {
                    eventData.selectedObject = sel.gameObject;
                }
            },
            /*UnityEngine.UI.Selectable.Navigate end.*/

            /*UnityEngine.UI.Selectable.FindSelectableOnLeft start.*/
            /**
             * Find the selectable object to the left of this one.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Selectable
             * @memberof UnityEngine.UI.Selectable
             * @return  {UnityEngine.UI.Selectable}
             */
            FindSelectableOnLeft: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#FindSelectableOnLeft", this ); }

                if (this.m_Navigation.mode === UnityEngine.UI.Navigation.Mode.Explicit) {
                    return this.m_Navigation.selectOnLeft;
                }

                if ((this.m_Navigation.mode & UnityEngine.UI.Navigation.Mode.Horizontal) !== 0) {
                    return this.FindSelectable(this.transform.rotation.transformVector( pc.Vec3.LEFT.clone() ));
                }

                return null;
            },
            /*UnityEngine.UI.Selectable.FindSelectableOnLeft end.*/

            /*UnityEngine.UI.Selectable.FindSelectableOnRight start.*/
            /**
             * Find the selectable object to the right of this one.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Selectable
             * @memberof UnityEngine.UI.Selectable
             * @return  {UnityEngine.UI.Selectable}
             */
            FindSelectableOnRight: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#FindSelectableOnRight", this ); }

                if (this.m_Navigation.mode === UnityEngine.UI.Navigation.Mode.Explicit) {
                    return this.m_Navigation.selectOnRight;
                }

                if ((this.m_Navigation.mode & UnityEngine.UI.Navigation.Mode.Horizontal) !== 0) {
                    return this.FindSelectable(this.transform.rotation.transformVector( pc.Vec3.RIGHT.clone() ));
                }

                return null;
            },
            /*UnityEngine.UI.Selectable.FindSelectableOnRight end.*/

            /*UnityEngine.UI.Selectable.FindSelectableOnUp start.*/
            /**
             * The Selectable object above current
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Selectable
             * @memberof UnityEngine.UI.Selectable
             * @return  {UnityEngine.UI.Selectable}
             */
            FindSelectableOnUp: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#FindSelectableOnUp", this ); }

                if (this.m_Navigation.mode === UnityEngine.UI.Navigation.Mode.Explicit) {
                    return this.m_Navigation.selectOnUp;
                }

                if ((this.m_Navigation.mode & UnityEngine.UI.Navigation.Mode.Vertical) !== 0) {
                    return this.FindSelectable(this.transform.rotation.transformVector( pc.Vec3.UP.clone() ));
                }

                return null;
            },
            /*UnityEngine.UI.Selectable.FindSelectableOnUp end.*/

            /*UnityEngine.UI.Selectable.FindSelectableOnDown start.*/
            /**
             * Find the selectable object below this one.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Selectable
             * @memberof UnityEngine.UI.Selectable
             * @return  {UnityEngine.UI.Selectable}
             */
            FindSelectableOnDown: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#FindSelectableOnDown", this ); }

                if (this.m_Navigation.mode === UnityEngine.UI.Navigation.Mode.Explicit) {
                    return this.m_Navigation.selectOnDown;
                }

                if ((this.m_Navigation.mode & UnityEngine.UI.Navigation.Mode.Vertical) !== 0) {
                    return this.FindSelectable(this.transform.rotation.transformVector( pc.Vec3.DOWN.clone() ));
                }

                return null;
            },
            /*UnityEngine.UI.Selectable.FindSelectableOnDown end.*/

            /*UnityEngine.UI.Selectable.OnMove start.*/
            /**
             * Determine in which of the 4 move directions the next selectable object should be found.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Selectable
             * @memberof UnityEngine.UI.Selectable
             * @param   {UnityEngine.EventSystems.AxisEventData}    eventData
             * @return  {void}
             */
            OnMove: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#OnMove", this ); }

                switch (eventData.moveDir) {
                    case UnityEngine.EventSystems.MoveDirection.Right: 
                        this.Navigate(eventData, this.FindSelectableOnRight());
                        break;
                    case UnityEngine.EventSystems.MoveDirection.Up: 
                        this.Navigate(eventData, this.FindSelectableOnUp());
                        break;
                    case UnityEngine.EventSystems.MoveDirection.Left: 
                        this.Navigate(eventData, this.FindSelectableOnLeft());
                        break;
                    case UnityEngine.EventSystems.MoveDirection.Down: 
                        this.Navigate(eventData, this.FindSelectableOnDown());
                        break;
                }
            },
            /*UnityEngine.UI.Selectable.OnMove end.*/

            /*UnityEngine.UI.Selectable.StartColorTween start.*/
            StartColorTween: function (targetColor, instant) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#StartColorTween", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.m_TargetGraphic, null)) {
                    return;
                }

                this.m_TargetGraphic.CrossFadeColor(targetColor.$clone(), instant ? 0.0 : this.m_Colors.fadeDuration, true, true);
            },
            /*UnityEngine.UI.Selectable.StartColorTween end.*/

            /*UnityEngine.UI.Selectable.DoSpriteSwap start.*/
            DoSpriteSwap: function (newSprite) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#DoSpriteSwap", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.image, null)) {
                    return;
                }

                this.image.overrideSprite = newSprite;
            },
            /*UnityEngine.UI.Selectable.DoSpriteSwap end.*/

            /*UnityEngine.UI.Selectable.TriggerAnimation start.*/
            TriggerAnimation: function (triggername) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#TriggerAnimation", this ); }

                if (this.transition !== UnityEngine.UI.Selectable.Transition.Animation || UnityEngine.Component.op_Equality(this.animator, null) || !this.animator.isActiveAndEnabled || !this.animator.hasBoundPlayables || System.String.isNullOrEmpty(triggername)) {
                    return;
                }

                this.animator.ResetTrigger(this.m_AnimationTriggers.normalTrigger);
                this.animator.ResetTrigger(this.m_AnimationTriggers.highlightedTrigger);
                this.animator.ResetTrigger(this.m_AnimationTriggers.pressedTrigger);
                this.animator.ResetTrigger(this.m_AnimationTriggers.selectedTrigger);
                this.animator.ResetTrigger(this.m_AnimationTriggers.disabledTrigger);

                this.animator.SetTrigger$1(triggername);
            },
            /*UnityEngine.UI.Selectable.TriggerAnimation end.*/

            /*UnityEngine.UI.Selectable.IsHighlighted start.*/
            /**
             * Returns whether the selectable is currently 'highlighted' or not.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.Selectable
             * @memberof UnityEngine.UI.Selectable
             * @return  {boolean}
             */
            IsHighlighted: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#IsHighlighted", this ); }

                if (!this.IsActive() || !this.IsInteractable()) {
                    return false;
                }

                return this.isPointerInside && !this.isPointerDown && !this.hasSelection;
            },
            /*UnityEngine.UI.Selectable.IsHighlighted end.*/

            /*UnityEngine.UI.Selectable.IsPressed start.*/
            /**
             * Whether the current selectable is being pressed.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.Selectable
             * @memberof UnityEngine.UI.Selectable
             * @return  {boolean}
             */
            IsPressed: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#IsPressed", this ); }

                if (!this.IsActive() || !this.IsInteractable()) {
                    return false;
                }

                return this.isPointerDown;
            },
            /*UnityEngine.UI.Selectable.IsPressed end.*/

            /*UnityEngine.UI.Selectable.EvaluateAndTransitionToSelectionState start.*/
            EvaluateAndTransitionToSelectionState: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#EvaluateAndTransitionToSelectionState", this ); }

                if (!this.IsActive() || !this.IsInteractable()) {
                    return;
                }

                this.DoStateTransition(this.currentSelectionState, false);
            },
            /*UnityEngine.UI.Selectable.EvaluateAndTransitionToSelectionState end.*/

            /*UnityEngine.UI.Selectable.OnPointerDown start.*/
            /**
             * Evaluate current state and transition to pressed state.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Selectable
             * @memberof UnityEngine.UI.Selectable
             * @param   {UnityEngine.EventSystems.PointerEventData}    eventData
             * @return  {void}
             */
            OnPointerDown: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#OnPointerDown", this ); }

                if (eventData.button !== UnityEngine.EventSystems.PointerEventData.InputButton.Left) {
                    return;
                }

                // Selection tracking
                if (this.IsInteractable() && this.navigation.mode !== UnityEngine.UI.Navigation.Mode.None && UnityEngine.MonoBehaviour.op_Inequality(UnityEngine.EventSystems.EventSystem.current, null)) {
                    UnityEngine.EventSystems.EventSystem.current.SetSelectedGameObject$1(this.gameObject, eventData);
                }

                this.isPointerDown = true;
                this.EvaluateAndTransitionToSelectionState();
            },
            /*UnityEngine.UI.Selectable.OnPointerDown end.*/

            /*UnityEngine.UI.Selectable.OnPointerUp start.*/
            /**
             * Evaluate eventData and transition to appropriate state.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Selectable
             * @memberof UnityEngine.UI.Selectable
             * @param   {UnityEngine.EventSystems.PointerEventData}    eventData
             * @return  {void}
             */
            OnPointerUp: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#OnPointerUp", this ); }

                if (eventData.button !== UnityEngine.EventSystems.PointerEventData.InputButton.Left) {
                    return;
                }

                this.isPointerDown = false;
                this.EvaluateAndTransitionToSelectionState();
            },
            /*UnityEngine.UI.Selectable.OnPointerUp end.*/

            /*UnityEngine.UI.Selectable.OnPointerEnter start.*/
            /**
             * Evaluate current state and transition to appropriate state.
             New state could be pressed or hover depending on pressed state.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Selectable
             * @memberof UnityEngine.UI.Selectable
             * @param   {UnityEngine.EventSystems.PointerEventData}    eventData
             * @return  {void}
             */
            OnPointerEnter: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#OnPointerEnter", this ); }

                this.isPointerInside = true;
                this.EvaluateAndTransitionToSelectionState();
            },
            /*UnityEngine.UI.Selectable.OnPointerEnter end.*/

            /*UnityEngine.UI.Selectable.OnPointerExit start.*/
            /**
             * Evaluate current state and transition to normal state.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Selectable
             * @memberof UnityEngine.UI.Selectable
             * @param   {UnityEngine.EventSystems.PointerEventData}    eventData
             * @return  {void}
             */
            OnPointerExit: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#OnPointerExit", this ); }

                this.isPointerInside = false;
                this.EvaluateAndTransitionToSelectionState();
            },
            /*UnityEngine.UI.Selectable.OnPointerExit end.*/

            /*UnityEngine.UI.Selectable.OnSelect start.*/
            /**
             * Set selection and transition to appropriate state.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Selectable
             * @memberof UnityEngine.UI.Selectable
             * @param   {UnityEngine.EventSystems.BaseEventData}    eventData
             * @return  {void}
             */
            OnSelect: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#OnSelect", this ); }

                this.hasSelection = true;
                this.EvaluateAndTransitionToSelectionState();
            },
            /*UnityEngine.UI.Selectable.OnSelect end.*/

            /*UnityEngine.UI.Selectable.OnDeselect start.*/
            /**
             * Unset selection and transition to appropriate state.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Selectable
             * @memberof UnityEngine.UI.Selectable
             * @param   {UnityEngine.EventSystems.BaseEventData}    eventData
             * @return  {void}
             */
            OnDeselect: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#OnDeselect", this ); }

                this.hasSelection = false;
                this.EvaluateAndTransitionToSelectionState();
            },
            /*UnityEngine.UI.Selectable.OnDeselect end.*/

            /*UnityEngine.UI.Selectable.Select start.*/
            /**
             * Selects this Selectable.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Selectable
             * @memberof UnityEngine.UI.Selectable
             * @return  {void}
             */
            Select: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Selectable#Select", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(UnityEngine.EventSystems.EventSystem.current, null) || UnityEngine.EventSystems.EventSystem.current.alreadySelecting) {
                    return;
                }

                UnityEngine.EventSystems.EventSystem.current.SetSelectedGameObject(this.gameObject);
            },
            /*UnityEngine.UI.Selectable.Select end.*/


        }
    });
    /*UnityEngine.UI.Selectable end.*/

    /*UnityEngine.UI.ContentSizeFitter start.*/
    Bridge.define("UnityEngine.UI.ContentSizeFitter", {
        inherits: [UnityEngine.EventSystems.UIBehaviour,UnityEngine.UI.ILayoutSelfController],
        fields: {
            m_HorizontalFit: 0,
            m_VerticalFit: 0,
            m_Rect: null,
            m_Tracker: null
        },
        props: {
            horizontalFit: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ContentSizeFitter#horizontalFit#get", this ); }

                    return this.m_HorizontalFit;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ContentSizeFitter#horizontalFit#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetStruct(UnityEngine.UI.ContentSizeFitter.FitMode, Bridge.ref(this, "m_HorizontalFit"), value)) {
                        this.SetDirty();
                    }
                }
            },
            verticalFit: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ContentSizeFitter#verticalFit#get", this ); }

                    return this.m_VerticalFit;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ContentSizeFitter#verticalFit#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetStruct(UnityEngine.UI.ContentSizeFitter.FitMode, Bridge.ref(this, "m_VerticalFit"), value)) {
                        this.SetDirty();
                    }
                }
            },
            rectTransform: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ContentSizeFitter#rectTransform#get", this ); }

                    if (UnityEngine.Component.op_Equality(this.m_Rect, null)) {
                        this.m_Rect = this.GetComponent(UnityEngine.RectTransform);
                    }

                    return this.m_Rect;
                }
            }
        },
        alias: [
            "SetLayoutHorizontal", "UnityEngine$UI$ILayoutController$SetLayoutHorizontal",
            "SetLayoutVertical", "UnityEngine$UI$ILayoutController$SetLayoutVertical"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ContentSizeFitter#init", this ); }

                this.m_Tracker = new ( pc.stubProxy.generateConstructorFor( 'UnityEngine.DrivenRectTransformTracker' ) )();
                this.m_HorizontalFit = UnityEngine.UI.ContentSizeFitter.FitMode.Unconstrained;
                this.m_VerticalFit = UnityEngine.UI.ContentSizeFitter.FitMode.Unconstrained;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ContentSizeFitter#ctor", this ); }

                this.$initialize();
                UnityEngine.EventSystems.UIBehaviour.ctor.call(this);
            }
        },
        methods: {
            /*UnityEngine.UI.ContentSizeFitter.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ContentSizeFitter#OnEnable", this ); }

                UnityEngine.EventSystems.UIBehaviour.prototype.OnEnable.call(this);
                this.SetDirty();
            },
            /*UnityEngine.UI.ContentSizeFitter.OnEnable end.*/

            /*UnityEngine.UI.ContentSizeFitter.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ContentSizeFitter#OnDisable", this ); }

                UnityEngine.UI.LayoutRebuilder.MarkLayoutForRebuild(this.rectTransform);
                UnityEngine.EventSystems.UIBehaviour.prototype.OnDisable.call(this);
            },
            /*UnityEngine.UI.ContentSizeFitter.OnDisable end.*/

            /*UnityEngine.UI.ContentSizeFitter.OnRectTransformDimensionsChange start.*/
            OnRectTransformDimensionsChange: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ContentSizeFitter#OnRectTransformDimensionsChange", this ); }

                this.SetDirty();
            },
            /*UnityEngine.UI.ContentSizeFitter.OnRectTransformDimensionsChange end.*/

            /*UnityEngine.UI.ContentSizeFitter.HandleSelfFittingAlongAxis start.*/
            HandleSelfFittingAlongAxis: function (axis) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ContentSizeFitter#HandleSelfFittingAlongAxis", this ); }

                var fitting = axis === 0 ? this.horizontalFit : this.verticalFit;

                if (fitting === UnityEngine.UI.ContentSizeFitter.FitMode.Unconstrained) {
                    return;
                }

                // Set size to min or preferred size
                if (fitting === UnityEngine.UI.ContentSizeFitter.FitMode.MinSize) {
                    this.rectTransform.SetSizeWithCurrentAnchors(axis, UnityEngine.UI.LayoutUtility.GetMinSize(this.m_Rect, axis));
                } else {
                    this.rectTransform.SetSizeWithCurrentAnchors(axis, UnityEngine.UI.LayoutUtility.GetPreferredSize(this.m_Rect, axis));
                }
            },
            /*UnityEngine.UI.ContentSizeFitter.HandleSelfFittingAlongAxis end.*/

            /*UnityEngine.UI.ContentSizeFitter.SetLayoutHorizontal start.*/
            SetLayoutHorizontal: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ContentSizeFitter#SetLayoutHorizontal", this ); }

                this.HandleSelfFittingAlongAxis(0);
            },
            /*UnityEngine.UI.ContentSizeFitter.SetLayoutHorizontal end.*/

            /*UnityEngine.UI.ContentSizeFitter.SetLayoutVertical start.*/
            SetLayoutVertical: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ContentSizeFitter#SetLayoutVertical", this ); }

                this.HandleSelfFittingAlongAxis(1);
            },
            /*UnityEngine.UI.ContentSizeFitter.SetLayoutVertical end.*/

            /*UnityEngine.UI.ContentSizeFitter.SetDirty start.*/
            SetDirty: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ContentSizeFitter#SetDirty", this ); }

                if (!this.IsActive()) {
                    return;
                }

                UnityEngine.UI.LayoutRebuilder.MarkLayoutForRebuild(this.rectTransform);
            },
            /*UnityEngine.UI.ContentSizeFitter.SetDirty end.*/


        }
    });
    /*UnityEngine.UI.ContentSizeFitter end.*/

    /*UnityEngine.UI.Dropdown+DropdownItem start.*/
    Bridge.define("UnityEngine.UI.Dropdown.DropdownItem", {
        inherits: [UnityEngine.MonoBehaviour,UnityEngine.EventSystems.IPointerEnterHandler,UnityEngine.EventSystems.ICancelHandler],
        $kind: 1002,
        fields: {
            m_Text: null,
            m_Image: null,
            m_RectTransform: null,
            m_Toggle: null
        },
        props: {
            text: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown.DropdownItem#text#get", this ); }

                    return this.m_Text;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown.DropdownItem#text#set", this ); }

                    this.m_Text = value;
                }
            },
            image: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown.DropdownItem#image#get", this ); }

                    return this.m_Image;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown.DropdownItem#image#set", this ); }

                    this.m_Image = value;
                }
            },
            rectTransform: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown.DropdownItem#rectTransform#get", this ); }

                    return this.m_RectTransform;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown.DropdownItem#rectTransform#set", this ); }

                    this.m_RectTransform = value;
                }
            },
            toggle: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown.DropdownItem#toggle#get", this ); }

                    return this.m_Toggle;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown.DropdownItem#toggle#set", this ); }

                    this.m_Toggle = value;
                }
            }
        },
        alias: [
            "OnPointerEnter", "UnityEngine$EventSystems$IPointerEnterHandler$OnPointerEnter",
            "OnCancel", "UnityEngine$EventSystems$ICancelHandler$OnCancel"
        ],
        methods: {
            /*UnityEngine.UI.Dropdown+DropdownItem.OnPointerEnter start.*/
            OnPointerEnter: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown.DropdownItem#OnPointerEnter", this ); }

                UnityEngine.EventSystems.EventSystem.current.SetSelectedGameObject(this.gameObject);
            },
            /*UnityEngine.UI.Dropdown+DropdownItem.OnPointerEnter end.*/

            /*UnityEngine.UI.Dropdown+DropdownItem.OnCancel start.*/
            OnCancel: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown.DropdownItem#OnCancel", this ); }

                var dropdown = this.GetComponentInParent(UnityEngine.UI.Dropdown);
                if (UnityEngine.Object.op_Implicit(dropdown)) {
                    dropdown.Hide();
                }
            },
            /*UnityEngine.UI.Dropdown+DropdownItem.OnCancel end.*/


        }
    });
    /*UnityEngine.UI.Dropdown+DropdownItem end.*/

    /*UnityEngine.UI.GraphicRaycaster start.*/
    Bridge.define("UnityEngine.UI.GraphicRaycaster", {
        inherits: [UnityEngine.EventSystems.BaseRaycaster],
        statics: {
            fields: {
                kNoEventMaskSet: 0,
                /**
                 * Perform a raycast into the screen and collect all graphics underneath it.
                 *
                 * @static
                 * @private
                 * @readonly
                 * @memberof UnityEngine.UI.GraphicRaycaster
                 * @type System.Collections.Generic.List$1
                 */
                sortedGraphics: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.GraphicRaycaster#init", this ); }

                    this.kNoEventMaskSet = -1;
                    this.sortedGraphics = new (System.Collections.Generic.List$1(UnityEngine.UI.Graphic)).ctor();
                }
            },
            methods: {
                /*UnityEngine.UI.GraphicRaycaster.Raycast:static start.*/
                /**
                 * Performs the main heavy liftin of raycating graphics: walks over the collection of found graphics and performs
                 all the routine checks. As soon as a target is found, a Graphic-specific raycast is performed again to determine
                 how the pointer event should be handled.
                 *
                 * @static
                 * @private
                 * @this UnityEngine.UI.GraphicRaycaster
                 * @memberof UnityEngine.UI.GraphicRaycaster
                 * @param   {UnityEngine.Canvas}                   canvas             
                 * @param   {UnityEngine.Camera}                   eventCamera        
                 * @param   {UnityEngine.Vector2}                  pointerPosition    
                 * @param   {Set}                                  foundGraphics      
                 * @param   {System.Collections.Generic.List$1}    results
                 * @return  {void}
                 */
                Raycast: function (canvas, eventCamera, pointerPosition, foundGraphics, results) {
if ( TRACE ) { TRACE( "UnityEngine.UI.GraphicRaycaster#Raycast", this ); }

                    
            var hasCamera = eventCamera !== null;
            var sortedGraphics = UnityEngine.UI.GraphicRaycaster.sortedGraphics;
            var farClipPlane = hasCamera ? eventCamera.farClipPlane : 0;
            const pointInRectangle = UnityEngine.RectTransformUtility.PointInRectangle;
            for ( var graphic of foundGraphics ) {
                var graphicEntity = graphic.entity;
                var canvasRenderer = graphic.canvasRenderer;
                // -1 means it hasn't been processed by the canvas, which means it isn't actually drawn
                if ( !graphicEntity._enabledInHierarchy || !graphic.raycastTarget || canvasRenderer.absoluteDepth < 0 || canvasRenderer.cull ) {
                    continue;
                }
                if ( graphicEntity.getLossyScale().lengthSq() < 0.0000001 ) {
                    continue;
                }
                if ( !pointInRectangle( pointerPosition, graphicEntity, eventCamera ) ) {
                    continue;
                }
                const position = graphicEntity.getPosition();
                if ( hasCamera && eventCamera.WorldToScreenPoint( position ).z > farClipPlane ) {
                    continue;
                }
                if ( graphic.Raycast( pointerPosition, eventCamera ) ) {
                    sortedGraphics.add( graphic );
                }
            }
            const depthCompare = function (g1, g2) {
                return g2.depth - g1.depth;
            }
            sortedGraphics.Sort$2( depthCompare );
            results.AddRange( sortedGraphics );
            sortedGraphics.clear();
                },
                /*UnityEngine.UI.GraphicRaycaster.Raycast:static end.*/


            }
        },
        fields: {
            _blockingObjects: 0,
            _ignoreReversedGraphics: false,
            m_BlockingMask: null,
            _raycastResults: null,
            _canvas: null,
            cachedMainCamera: null
        },
        props: {
            canvas: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.GraphicRaycaster#canvas#get", this ); }

                    if (UnityEngine.Component.op_Inequality(this._canvas, null)) {
                        return this._canvas;
                    }

                    this._canvas = this.GetComponent(UnityEngine.Canvas);
                    return this._canvas;
                }
            },
            ignoreReversedGraphics: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.GraphicRaycaster#ignoreReversedGraphics#get", this ); }

                    return this._ignoreReversedGraphics;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.GraphicRaycaster#ignoreReversedGraphics#set", this ); }

                    this._ignoreReversedGraphics = value;
                }
            },
            /**
             * Type of objects that will be check for to determine if they are blocking block graphic raycasts.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.GraphicRaycaster
             * @function blockingObjects
             * @type number
             */
            blockingObjects: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.GraphicRaycaster#blockingObjects#get", this ); }

                    return this._blockingObjects;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.GraphicRaycaster#blockingObjects#set", this ); }

                    this._blockingObjects = value;
                }
            },
            eventCamera: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.GraphicRaycaster#eventCamera#get", this ); }

                    // red
                    if (this.canvas.renderMode === 0 || this.canvas.renderMode === 1 && UnityEngine.Component.op_Equality(this.canvas.worldCamera, null)) {
                        return null;
                    }

                    return UnityEngine.Component.op_Inequality(this.canvas.worldCamera, null) ? this.canvas.worldCamera : this.GetMainCamera();
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.GraphicRaycaster#init", this ); }

                this.m_BlockingMask = new UnityEngine.LayerMask();
                this._blockingObjects = UnityEngine.UI.GraphicRaycaster.BlockingObjects.None;
                this._ignoreReversedGraphics = true;
                this.m_BlockingMask = UnityEngine.LayerMask.op_Implicit$1(-1);
                this._raycastResults = new (System.Collections.Generic.List$1(UnityEngine.UI.Graphic)).ctor();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.GraphicRaycaster#ctor", this ); }

                this.$initialize();
                UnityEngine.EventSystems.BaseRaycaster.ctor.call(this);
            }
        },
        methods: {
            /*UnityEngine.UI.GraphicRaycaster.Raycast start.*/
            /**
             * Perform the raycast against the list of graphics associated with the Canvas.
             *
             * @instance
             * @public
             * @override
             * @this UnityEngine.UI.GraphicRaycaster
             * @memberof UnityEngine.UI.GraphicRaycaster
             * @param   {UnityEngine.EventSystems.PointerEventData}    eventData           Current event data
             * @param   {System.Collections.Generic.List$1}            resultAppendList    List of hit objects to append new results to.
             * @return  {void}
             */
            Raycast: function (eventData, resultAppendList) {
if ( TRACE ) { TRACE( "UnityEngine.UI.GraphicRaycaster#Raycast", this ); }

                var $t;
                var canvas = this.canvas;
                if (UnityEngine.Component.op_Equality(canvas, null)) {
                    return;
                }

                var canvasGraphics = UnityEngine.UI.GraphicRegistry.GetGraphicsForCanvasInternal(canvas);
                if (canvasGraphics == null || canvasGraphics.size === 0) {
                    return;
                }

                var displayIndex;
                var currentEventCamera = this.eventCamera; // Property can call Camera.main, so cache the reference

                if (canvas.renderMode === 0 || UnityEngine.Component.op_Equality(currentEventCamera, null)) {
                    displayIndex = canvas.targetDisplay;
                } else {
                    displayIndex = currentEventCamera.targetDisplay;
                }

                var eventPosition = UnityEngine.Display.RelativeMouseAt(UnityEngine.Vector3.FromVector2(eventData.position.$clone()));
                if (!pc.Vec3.equals( eventPosition, pc.Vec3.ZERO.clone() )) {
                    // We support multiple display and display identification based on event position.

                    var eventDisplayIndex = eventPosition.z;

                    // Discard events that are not part of this display so the user does not interact with multiple displays at once.
                    if (eventDisplayIndex !== displayIndex) {
                        return;
                    }
                } else {
                    // The multiple display system is not supported on all platforms, when it is not supported the returned position
                    // will be all zeros so when the returned index is 0 we will default to the event data to be safe.
                    eventPosition = UnityEngine.Vector3.FromVector2(eventData.position.$clone());

                    // We dont really know in which display the event occured. We will process the event assuming it occured in our display.
                }

                // Convert to view space
                var pos = new pc.Vec2.ctor();
                if (UnityEngine.Component.op_Equality(currentEventCamera, null)) {
                    // Multiple display support only when not the main display. For display 0 the reported
                    // resolution is always the desktops resolution since its part of the display API,
                    // so we use the standard none multiple display method. (case 741751)
                    var w = UnityEngine.Screen.width;
                    var h = UnityEngine.Screen.height;
                    if (displayIndex > 0 && displayIndex < UnityEngine.Display.displays.length) {
                        w = UnityEngine.Display.displays[displayIndex].systemWidth;
                        h = UnityEngine.Display.displays[displayIndex].systemHeight;
                    }

                    pos.set( eventPosition.x / w, eventPosition.y / h );
                } else {
                    pos = UnityEngine.Vector2.FromVector3(currentEventCamera.ScreenToViewportPoint(eventPosition.$clone()));
                }

                // If it's outside the camera's viewport, do nothing
                if (pos.x < 0.0 || pos.x > 1.0 || pos.y < 0.0 || pos.y > 1.0) {
                    return;
                }

                var hitDistance = 3.40282347E+38;

                var ray = new UnityEngine.Ray.ctor();

                if (UnityEngine.Component.op_Inequality(currentEventCamera, null)) {
                    ray = currentEventCamera.ScreenPointToRay(eventPosition.$clone());
                }

                if (canvas.renderMode !== 0 && this.blockingObjects !== 0) {
                    var distanceToClipPlane = 100.0;

                    if (UnityEngine.Component.op_Inequality(currentEventCamera, null)) {
                        var projectionDirection = ray.direction.z;
                        distanceToClipPlane = UnityEngine.Mathf.Approximately(0.0, projectionDirection) ? window.Infinity : Math.abs((currentEventCamera.farClipPlane - currentEventCamera.nearClipPlane) / projectionDirection);
                    }

                    if (this.blockingObjects === UnityEngine.UI.GraphicRaycaster.BlockingObjects.ThreeD || this.blockingObjects === UnityEngine.UI.GraphicRaycaster.BlockingObjects.All) {
                        if (!Bridge.staticEquals(UnityEngine.UI.ReflectionMethodsCache.Singleton.raycast3D, null)) {
                            var hits = UnityEngine.UI.ReflectionMethodsCache.Singleton.raycast3DAll(ray.$clone(), distanceToClipPlane, UnityEngine.LayerMask.op_Implicit(this.m_BlockingMask));
                            if (hits.length > 0) {
                                hitDistance = hits[0].distance;
                            }
                        }
                    }

                    if (this.blockingObjects === UnityEngine.UI.GraphicRaycaster.BlockingObjects.TwoD || this.blockingObjects === UnityEngine.UI.GraphicRaycaster.BlockingObjects.All) {
                        if (!Bridge.staticEquals(UnityEngine.UI.ReflectionMethodsCache.Singleton.raycast2D, null)) {
                            var hits1 = UnityEngine.UI.ReflectionMethodsCache.Singleton.getRayIntersectionAll(ray.$clone(), distanceToClipPlane, UnityEngine.LayerMask.op_Implicit(this.m_BlockingMask));
                            if (hits1.length > 0) {
                                hitDistance = hits1[0].distance;
                            }
                        }
                    }
                }

                this._raycastResults.clear();

                UnityEngine.UI.GraphicRaycaster.Raycast(canvas, currentEventCamera, UnityEngine.Vector2.FromVector3(eventPosition), canvasGraphics, this._raycastResults);

                var totalCount = this._raycastResults.Count;
                for (var index = 0; index < totalCount; index++) {
                    var go = this._raycastResults.getItem(index).gameObject;
                    var appendGraphic = true;

                    if (this.ignoreReversedGraphics) {
                        if (UnityEngine.Component.op_Equality(currentEventCamera, null)) {
                            // If we dont have a camera we know that we should always be facing forward
                            var dir = go.transform.rotation.transformVector( new pc.Vec3( 0, 0, 1 ) );
                            appendGraphic = new pc.Vec3( 0, 0, 1 ).dot( dir ) > 0;
                        } else {
                            // If we have a camera compare the direction against the cameras forward.
                            var cameraFoward = currentEventCamera.transform.rotation.transformVector( new pc.Vec3( 0, 0, 1 ) );
                            var dir1 = go.transform.rotation.transformVector( new pc.Vec3( 0, 0, 1 ) );
                            appendGraphic = cameraFoward.dot( dir1 ) > 0;
                        }
                    }

                    if (appendGraphic) {
                        var distance = 0;
                        var trans = go.transform;
                        var transForward = trans.forward.$clone();

                        if (UnityEngine.Component.op_Equality(currentEventCamera, null) || canvas.renderMode === 0) {
                            distance = 0;
                        } else {
                            // http://geomalgorithms.com/a06-_intersect-2.html
                            distance = transForward.dot( trans.position.$clone().sub( ray.m_Origin ) ) / transForward.dot( ray.m_Direction );

                            // Check to see if the go is behind the camera.
                            if (distance < 0) {
                                continue;
                            }
                        }

                        if (distance >= hitDistance) {
                            continue;
                        }

                        var castResult = ($t = new UnityEngine.EventSystems.RaycastResult(), $t.gameObject = go, $t.module = this, $t.distance = distance, $t.screenPosition = UnityEngine.Vector2.FromVector3(eventPosition.$clone()), $t.index = resultAppendList.Count, $t.depth = this._raycastResults.getItem(index).depth, $t.sortingLayer = canvas.sortingLayerID, $t.sortingOrder = canvas.sortingOrder, $t.worldPosition = ray.origin.$clone().add( ray.direction.$clone().clone().scale( distance ) ), $t.worldNormal = transForward.$clone().scale( -1 ), $t);
                        resultAppendList.add(castResult.$clone());
                    }
                }
            },
            /*UnityEngine.UI.GraphicRaycaster.Raycast end.*/

            /*UnityEngine.UI.GraphicRaycaster.GetMainCamera start.*/
            GetMainCamera: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.GraphicRaycaster#GetMainCamera", this ); }

                if (UnityEngine.Component.op_Equality(this.cachedMainCamera, null) || !this.cachedMainCamera.enabled) {
                    this.cachedMainCamera = UnityEngine.Camera.main;
                }

                return this.cachedMainCamera;
            },
            /*UnityEngine.UI.GraphicRaycaster.GetMainCamera end.*/


        }
    });
    /*UnityEngine.UI.GraphicRaycaster end.*/

    /*UnityEngine.UI.LayoutGroup start.*/
    Bridge.define("UnityEngine.UI.LayoutGroup", {
        inherits: [UnityEngine.EventSystems.UIBehaviour,UnityEngine.UI.ILayoutElement,UnityEngine.UI.ILayoutGroup],
        fields: {
            m_Tracker: null,
            m_TotalMinSize: null,
            m_TotalPreferredSize: null,
            m_TotalFlexibleSize: null,
            m_Rect: null,
            m_ChildAlignment: 0,
            m_Padding: null,
            m_RectChildren: null
        },
        props: {
            childAlignment: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutGroup#childAlignment#get", this ); }

                    return this.m_ChildAlignment;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutGroup#childAlignment#set", this ); }

                    this.m_ChildAlignment = value;
                }
            },
            padding: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutGroup#padding#get", this ); }

                    return this.m_Padding;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutGroup#padding#set", this ); }

                    this.m_Padding = value;
                }
            },
            minWidth: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutGroup#minWidth#get", this ); }

                    return this.GetTotalMinSize(0);
                }
            },
            preferredWidth: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutGroup#preferredWidth#get", this ); }

                    return this.GetTotalPreferredSize(0);
                }
            },
            flexibleWidth: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutGroup#flexibleWidth#get", this ); }

                    return this.GetTotalFlexibleSize(0);
                }
            },
            minHeight: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutGroup#minHeight#get", this ); }

                    return this.GetTotalMinSize(1);
                }
            },
            preferredHeight: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutGroup#preferredHeight#get", this ); }

                    return this.GetTotalPreferredSize(1);
                }
            },
            flexibleHeight: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutGroup#flexibleHeight#get", this ); }

                    return this.GetTotalFlexibleSize(1);
                }
            },
            layoutPriority: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutGroup#layoutPriority#get", this ); }

                    return 0;
                }
            },
            rectChildren: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutGroup#rectChildren#get", this ); }

                    var $t;
                    return ($t = UnityEngine.RectTransform, System.Linq.Enumerable.from(this.m_RectChildren, $t).toList($t));
                }
            },
            rectTransform: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutGroup#rectTransform#get", this ); }

                    if (Bridge.referenceEquals(Bridge.cast(this.m_Rect, UnityEngine.Object), null)) {
                        this.m_Rect = this.GetComponent(UnityEngine.RectTransform);
                    }

                    return this.m_Rect;
                }
            },
            /**
             * Returns true if the parent is absent OR it does not have layout group.
             *
             * @instance
             * @private
             * @readonly
             * @memberof UnityEngine.UI.LayoutGroup
             * @function isRootLayoutGroup
             * @type boolean
             */
            isRootLayoutGroup: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutGroup#isRootLayoutGroup#get", this ); }

                    var parent = this.transform.parent;

                    if (UnityEngine.Component.op_Equality(parent, null)) {
                        return true;
                    }

                    // FIXME potentially someone might implement ILayoutGroup interface - not sure
                    // how this will play with it it's not descendint UIBehaviour...
                    var handle = parent.handle;
                    return handle._layoutControllers.length === 0 && handle._layoutSelfControllers.length === 0;
                }
            }
        },
        alias: [
            "minWidth", "UnityEngine$UI$ILayoutElement$minWidth",
            "preferredWidth", "UnityEngine$UI$ILayoutElement$preferredWidth",
            "flexibleWidth", "UnityEngine$UI$ILayoutElement$flexibleWidth",
            "minHeight", "UnityEngine$UI$ILayoutElement$minHeight",
            "preferredHeight", "UnityEngine$UI$ILayoutElement$preferredHeight",
            "flexibleHeight", "UnityEngine$UI$ILayoutElement$flexibleHeight",
            "layoutPriority", "UnityEngine$UI$ILayoutElement$layoutPriority",
            "CalculateLayoutInputHorizontal", "UnityEngine$UI$ILayoutElement$CalculateLayoutInputHorizontal"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutGroup#init", this ); }

                this.m_Tracker = new ( pc.stubProxy.generateConstructorFor( 'UnityEngine.DrivenRectTransformTracker' ) )();
                this.m_TotalMinSize = new UnityEngine.Vector2();
                this.m_TotalPreferredSize = new UnityEngine.Vector2();
                this.m_TotalFlexibleSize = new UnityEngine.Vector2();
                this.m_TotalMinSize = pc.Vec2.ZERO.clone();
                this.m_TotalPreferredSize = pc.Vec2.ZERO.clone();
                this.m_TotalFlexibleSize = pc.Vec2.ZERO.clone();
                this.m_ChildAlignment = UnityEngine.TextAnchor.UpperLeft;
                this.m_Padding = new UnityEngine.RectOffset.ctor();
                this.m_RectChildren = System.Array.init([], UnityEngine.RectTransform);
            }
        },
        methods: {
            /*UnityEngine.UI.LayoutGroup.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutGroup#OnEnable", this ); }

                UnityEngine.EventSystems.UIBehaviour.prototype.OnEnable.call(this);
                this.SetDirty();
            },
            /*UnityEngine.UI.LayoutGroup.OnEnable end.*/

            /*UnityEngine.UI.LayoutGroup.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutGroup#OnDisable", this ); }

                this.m_RectChildren.length = 0;
                UnityEngine.UI.LayoutRebuilder.MarkLayoutForRebuild(this.rectTransform);

                UnityEngine.EventSystems.UIBehaviour.prototype.OnDisable.call(this);
            },
            /*UnityEngine.UI.LayoutGroup.OnDisable end.*/

            /*UnityEngine.UI.LayoutGroup.CalculateLayoutInputHorizontal start.*/
            /**
             * Calculates the layout input horizontal.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.LayoutGroup
             * @memberof UnityEngine.UI.LayoutGroup
             * @return  {void}
             */
            CalculateLayoutInputHorizontal: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutGroup#CalculateLayoutInputHorizontal", this ); }

                this.m_RectChildren.length = 0;

                var children = this.handle.entity.children;

                for (var i = 0; i < children.length; i++) {
                    var child = children[i];

                    if (child.element == null || !child.enabled) {
                        continue;
                    }

                    var layoutElements = child._layoutElements;

                    if (layoutElements.length === 0) {
                        this.m_RectChildren.push(UnityEngine.Object.FromHandle(UnityEngine.RectTransform, child));
                        continue;
                    }

                    var ignoresLayout = false;

                    for (var j = 0; j < layoutElements.length; j++) {
                        ignoresLayout = layoutElements[j].getignoreLayout && layoutElements[j].getignoreLayout() ;
                        if (ignoresLayout) {
                            break;
                        }
                    }

                    if (!ignoresLayout) {
                        this.m_RectChildren.push(UnityEngine.Object.FromHandle(UnityEngine.RectTransform, child));
                    }
                }
            },
            /*UnityEngine.UI.LayoutGroup.CalculateLayoutInputHorizontal end.*/

            /*UnityEngine.UI.LayoutGroup.SetChildAlongAxis start.*/
            /**
             * Sets the child along axis.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.LayoutGroup
             * @memberof UnityEngine.UI.LayoutGroup
             * @param   {UnityEngine.RectTransform}    rect    Rect.
             * @param   {number}                       axis    Axis.
             * @param   {number}                       pos     Position.
             * @return  {void}
             */
            SetChildAlongAxis: function (rect, axis, pos) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutGroup#SetChildAlongAxis", this ); }

                if (UnityEngine.Component.op_Equality(rect, null)) {
                    return;
                }

                rect.SetInsetAndSizeFromParentEdge(axis === 0 ? UnityEngine.RectTransform.Edge.Left : UnityEngine.RectTransform.Edge.Top, pos, rect.sizeDelta.getitem(axis));
            },
            /*UnityEngine.UI.LayoutGroup.SetChildAlongAxis end.*/

            /*UnityEngine.UI.LayoutGroup.SetChildAlongAxis$1 start.*/
            /**
             * Sets the child along axis.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.LayoutGroup
             * @memberof UnityEngine.UI.LayoutGroup
             * @param   {UnityEngine.RectTransform}    rect    Rect.
             * @param   {number}                       axis    Axis.
             * @param   {number}                       pos     Position.
             * @param   {number}                       size    Size.
             * @return  {void}
             */
            SetChildAlongAxis$1: function (rect, axis, pos, size) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutGroup#SetChildAlongAxis$1", this ); }

                if (UnityEngine.Component.op_Equality(rect, null)) {
                    return;
                }

                rect.SetInsetAndSizeFromParentEdge(axis === 0 ? UnityEngine.RectTransform.Edge.Left : UnityEngine.RectTransform.Edge.Top, pos, size);
            },
            /*UnityEngine.UI.LayoutGroup.SetChildAlongAxis$1 end.*/

            /*UnityEngine.UI.LayoutGroup.SetLayoutInputForAxis start.*/
            /**
             * Sets the layout input for axis.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.LayoutGroup
             * @memberof UnityEngine.UI.LayoutGroup
             * @param   {number}    totalMin          Total minimum.
             * @param   {number}    totalPreferred    Total preferred.
             * @param   {number}    totalFlexible     Total flexible.
             * @param   {number}    axis              Axis.
             * @return  {void}
             */
            SetLayoutInputForAxis: function (totalMin, totalPreferred, totalFlexible, axis) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutGroup#SetLayoutInputForAxis", this ); }

                this.m_TotalMinSize.setitem(axis, totalMin);
                this.m_TotalPreferredSize.setitem(axis, totalPreferred);
                this.m_TotalFlexibleSize.setitem(axis, totalFlexible);
            },
            /*UnityEngine.UI.LayoutGroup.SetLayoutInputForAxis end.*/

            /*UnityEngine.UI.LayoutGroup.GetStartOffset start.*/
            GetStartOffset: function (axis, requiredSpaceWithoutPadding) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutGroup#GetStartOffset", this ); }

                var requiredSpace = requiredSpaceWithoutPadding + (axis === 0 ? this.padding.horizontal : this.padding.vertical);
                var availableSpace = this.rectTransform.rect.size.getitem(axis);
                var surplusSpace = availableSpace - requiredSpace;
                var alignmentOnAxis = this.GetAlignmentOnAxis(axis);

                return (axis === 0 ? this.padding.left : this.padding.top) + surplusSpace * alignmentOnAxis;
            },
            /*UnityEngine.UI.LayoutGroup.GetStartOffset end.*/

            /*UnityEngine.UI.LayoutGroup.GetAlignmentOnAxis start.*/
            GetAlignmentOnAxis: function (axis) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutGroup#GetAlignmentOnAxis", this ); }

                if (axis === 0) {
                    return this.m_ChildAlignment % 3 * 0.5;
                } else {
                    return Math.floor(this.m_ChildAlignment / 3.0) * 0.5;
                }
            },
            /*UnityEngine.UI.LayoutGroup.GetAlignmentOnAxis end.*/

            /*UnityEngine.UI.LayoutGroup.GetTotalMinSize start.*/
            GetTotalMinSize: function (axis) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutGroup#GetTotalMinSize", this ); }

                return this.m_TotalMinSize.getitem(axis);
            },
            /*UnityEngine.UI.LayoutGroup.GetTotalMinSize end.*/

            /*UnityEngine.UI.LayoutGroup.GetTotalPreferredSize start.*/
            GetTotalPreferredSize: function (axis) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutGroup#GetTotalPreferredSize", this ); }

                return this.m_TotalPreferredSize.getitem(axis);
            },
            /*UnityEngine.UI.LayoutGroup.GetTotalPreferredSize end.*/

            /*UnityEngine.UI.LayoutGroup.GetTotalFlexibleSize start.*/
            GetTotalFlexibleSize: function (axis) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutGroup#GetTotalFlexibleSize", this ); }

                return this.m_TotalFlexibleSize.getitem(axis);
            },
            /*UnityEngine.UI.LayoutGroup.GetTotalFlexibleSize end.*/

            /*UnityEngine.UI.LayoutGroup.SetProperty start.*/
            SetProperty: function (T, currentValue, newValue) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutGroup#SetProperty", this ); }

                if (Bridge.rValue(currentValue.v) == null && Bridge.rValue(newValue) == null || Bridge.rValue(currentValue.v) != null && Bridge.equals(Bridge.rValue(currentValue.v), Bridge.rValue(newValue))) {
                    return;
                }

                currentValue.v = Bridge.rValue(newValue);

                this.SetDirty();
            },
            /*UnityEngine.UI.LayoutGroup.SetProperty end.*/

            /*UnityEngine.UI.LayoutGroup.OnTransformChildrenChanged start.*/
            OnTransformChildrenChanged: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutGroup#OnTransformChildrenChanged", this ); }

                this.SetDirty();
            },
            /*UnityEngine.UI.LayoutGroup.OnTransformChildrenChanged end.*/

            /*UnityEngine.UI.LayoutGroup.OnRectTransformDimensionsChange start.*/
            OnRectTransformDimensionsChange: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutGroup#OnRectTransformDimensionsChange", this ); }

                UnityEngine.EventSystems.UIBehaviour.prototype.OnRectTransformDimensionsChange.call(this);

                if (this.isRootLayoutGroup) {
                    this.SetDirty();
                }
            },
            /*UnityEngine.UI.LayoutGroup.OnRectTransformDimensionsChange end.*/

            /*UnityEngine.UI.LayoutGroup.OnDidApplyAnimationProperties start.*/
            /**
             * Callback for when properties have been changed by animation.
             *
             * @instance
             * @protected
             * @override
             * @this UnityEngine.UI.LayoutGroup
             * @memberof UnityEngine.UI.LayoutGroup
             * @return  {void}
             */
            OnDidApplyAnimationProperties: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutGroup#OnDidApplyAnimationProperties", this ); }

                this.SetDirty();
            },
            /*UnityEngine.UI.LayoutGroup.OnDidApplyAnimationProperties end.*/

            /*UnityEngine.UI.LayoutGroup.SetDirty start.*/
            /**
             * <p>Mark the LayoutGroup as dirty.</p>
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.LayoutGroup
             * @memberof UnityEngine.UI.LayoutGroup
             * @return  {void}
             */
            SetDirty: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutGroup#SetDirty", this ); }

                if (!this.IsActive()) {
                    return;
                }

                if (!UnityEngine.UI.CanvasUpdateRegistry.IsRebuildingLayout()) {
                    this.m_RectChildren.length = 0;
                    UnityEngine.UI.LayoutRebuilder.MarkLayoutForRebuild(this.rectTransform);
                } else {
                    this.StartCoroutine$1(this.DelayedSetDirty(this.rectTransform));
                }
            },
            /*UnityEngine.UI.LayoutGroup.SetDirty end.*/

            /*UnityEngine.UI.LayoutGroup.DelayedSetDirty start.*/
            /**
             * Marks the layout for rebuild at next frame - just to make sure we don't
             end up in an endless loop is rebuild is in progress already.
             *
             * @instance
             * @private
             * @this UnityEngine.UI.LayoutGroup
             * @memberof UnityEngine.UI.LayoutGroup
             * @param   {UnityEngine.RectTransform}         rectTransform
             * @return  {System.Collections.IEnumerator}
             */
            DelayedSetDirty: function (rectTransform) {
if ( TRACE ) { TRACE( "UnityEngine.UI.LayoutGroup#DelayedSetDirty", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = null;
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    UnityEngine.UI.LayoutRebuilder.MarkLayoutForRebuild(rectTransform);

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*UnityEngine.UI.LayoutGroup.DelayedSetDirty end.*/


        },
        overloads: {
            "SetChildAlongAxis(RectTransform, int, float, float)": "SetChildAlongAxis$1"
        }
    });
    /*UnityEngine.UI.LayoutGroup end.*/

    /*UnityEngine.UI.MaskableGraphic start.*/
    /**
     * A Graphic that is capable of being masked out.
     *
     * @abstract
     * @public
     * @class UnityEngine.UI.MaskableGraphic
     * @augments UnityEngine.UI.Graphic
     * @implements  UnityEngine.UI.IClippable
     * @implements  UnityEngine.UI.IMaskable
     * @implements  UnityEngine.UI.IMaterialModifier
     */
    Bridge.define("UnityEngine.UI.MaskableGraphic", {
        inherits: [UnityEngine.UI.Graphic,UnityEngine.UI.IClippable,UnityEngine.UI.IMaskable,UnityEngine.UI.IMaterialModifier],
        fields: {
            m_ShouldRecalculateStencil: false,
            m_MaskMaterial: null,
            m_ParentMask: null,
            m_Maskable: false,
            m_IncludeForMasking: false,
            m_OnCullStateChanged: null,
            m_ShouldRecalculate: false,
            m_StencilValue: 0,
            m_Corners: null
        },
        props: {
            /**
             * Callback issued when culling changes.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.MaskableGraphic
             * @function onCullStateChanged
             * @type UnityEngine.UI.MaskableGraphic.CullStateChangedEvent
             */
            onCullStateChanged: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.MaskableGraphic#onCullStateChanged#get", this ); }

                    return this.m_OnCullStateChanged;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.MaskableGraphic#onCullStateChanged#set", this ); }

                    this.m_OnCullStateChanged = value;
                }
            },
            /**
             * Does this graphic allow masking.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.MaskableGraphic
             * @function maskable
             * @type boolean
             */
            maskable: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.MaskableGraphic#maskable#get", this ); }

                    return this.m_Maskable;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.MaskableGraphic#maskable#set", this ); }

                    if (value === this.m_Maskable) {
                        return;
                    }

                    this.m_Maskable = value;
                    this.m_ShouldRecalculateStencil = true;
                    this.SetMaterialDirty();
                }
            },
            rootCanvasRect: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.MaskableGraphic#rootCanvasRect#get", this ); }

                    this.rectTransform.GetWorldCorners(this.m_Corners);

                    if (UnityEngine.Object.op_Implicit(this.canvas)) {
                        var mat = this.canvas.rootCanvas.transform.worldToLocalMatrix.$clone();
                        for (var i = 0; i < 4; ++i) {
                            this.m_Corners[i] = mat.multiplyPoint( this.m_Corners[i] );
                        }
                    }

                    // bounding box is now based on the min and max of all corners (case 1013182)

                    var min = UnityEngine.Vector2.FromVector3(this.m_Corners[0].$clone());
                    var max = UnityEngine.Vector2.FromVector3(this.m_Corners[0].$clone());
                    for (var i1 = 1; i1 < 4; i1++) {
                        min.x = UnityEngine.Mathf.Min(this.m_Corners[i1].x, min.x);
                        min.y = UnityEngine.Mathf.Min(this.m_Corners[i1].y, min.y);
                        max.x = UnityEngine.Mathf.Max(this.m_Corners[i1].x, max.x);
                        max.y = UnityEngine.Mathf.Max(this.m_Corners[i1].y, max.y);
                    }

                    return new UnityEngine.Rect.$ctor3(min.$clone(), max.$clone().sub( min ));
                }
            }
        },
        alias: [
            "GetModifiedMaterial", "UnityEngine$UI$IMaterialModifier$GetModifiedMaterial",
            "Cull", "UnityEngine$UI$IClippable$Cull",
            "SetClipRect", "UnityEngine$UI$IClippable$SetClipRect",
            "RecalculateClipping", "UnityEngine$UI$IClippable$RecalculateClipping",
            "RecalculateMasking", "UnityEngine$UI$IMaskable$RecalculateMasking",
            "gameObject", "UnityEngine$UI$IClippable$gameObject",
            "rectTransform", "UnityEngine$UI$IClippable$rectTransform"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.MaskableGraphic#init", this ); }

                this.m_ShouldRecalculateStencil = true;
                this.m_Maskable = true;
                this.m_IncludeForMasking = false;
                this.m_OnCullStateChanged = new UnityEngine.UI.MaskableGraphic.CullStateChangedEvent();
                this.m_ShouldRecalculate = true;
                this.m_Corners = System.Array.init(4, function (){
                    return new UnityEngine.Vector3();
                }, UnityEngine.Vector3);
            },
            $ctor1: function (handle) {
if ( TRACE ) { TRACE( "UnityEngine.UI.MaskableGraphic#$ctor1", this ); }

                this.$initialize();
                UnityEngine.UI.Graphic.$ctor1.call(this, handle);
            },
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.MaskableGraphic#ctor", this ); }

                this.$initialize();
                UnityEngine.UI.Graphic.$ctor1.call(this, null);
            }
        },
        methods: {
            /*UnityEngine.UI.MaskableGraphic.GetModifiedMaterial start.*/
            /**
             * See IMaterialModifier.GetModifiedMaterial
             *
             * @instance
             * @public
             * @this UnityEngine.UI.MaskableGraphic
             * @memberof UnityEngine.UI.MaskableGraphic
             * @param   {UnityEngine.Material}    baseMaterial
             * @return  {UnityEngine.Material}
             */
            GetModifiedMaterial: function (baseMaterial) {
if ( TRACE ) { TRACE( "UnityEngine.UI.MaskableGraphic#GetModifiedMaterial", this ); }

                var toUse = baseMaterial;

                if (this.m_ShouldRecalculateStencil) {
                    var rootCanvas = UnityEngine.UI.MaskUtilities.FindRootSortOverrideCanvas(this.transform);
                    this.m_StencilValue = this.maskable ? UnityEngine.UI.MaskUtilities.GetStencilDepth(this.transform, rootCanvas) : 0;
                    this.m_ShouldRecalculateStencil = false;
                }

                // if we have a enabled Mask component then it will
                // generate the mask material. This is an optimisation
                // it adds some coupling between components though :(
                var maskComponent = this.GetComponent(UnityEngine.UI.Mask);
                if (this.m_StencilValue > 0 && (UnityEngine.MonoBehaviour.op_Equality(maskComponent, null) || !maskComponent.IsActive())) {
                    var maskMat = UnityEngine.UI.StencilMaterial.Add$2(toUse, (1 << this.m_StencilValue) - 1, UnityEngine.Rendering.StencilOp.Keep, UnityEngine.Rendering.CompareFunction.Equal, UnityEngine.Rendering.ColorWriteMask.All, (1 << this.m_StencilValue) - 1, 0);
                    UnityEngine.UI.StencilMaterial.Remove(this.m_MaskMaterial);
                    this.m_MaskMaterial = maskMat;
                    toUse = this.m_MaskMaterial;
                }

                return toUse;
            },
            /*UnityEngine.UI.MaskableGraphic.GetModifiedMaterial end.*/

            /*UnityEngine.UI.MaskableGraphic.Cull start.*/
            /**
             * See IClippable.Cull
             *
             * @instance
             * @public
             * @this UnityEngine.UI.MaskableGraphic
             * @memberof UnityEngine.UI.MaskableGraphic
             * @param   {UnityEngine.Rect}    clipRect     
             * @param   {boolean}             validRect
             * @return  {void}
             */
            Cull: function (clipRect, validRect) {
if ( TRACE ) { TRACE( "UnityEngine.UI.MaskableGraphic#Cull", this ); }

                var cull = !validRect || !clipRect.Overlaps$1(this.rootCanvasRect.$clone(), true);
                this.UpdateCull(cull);
            },
            /*UnityEngine.UI.MaskableGraphic.Cull end.*/

            /*UnityEngine.UI.MaskableGraphic.UpdateCull start.*/
            UpdateCull: function (cull) {
if ( TRACE ) { TRACE( "UnityEngine.UI.MaskableGraphic#UpdateCull", this ); }

                if (this.canvasRenderer.cull !== cull) {
                    this.canvasRenderer.cull = cull;
                    this.m_OnCullStateChanged.Invoke(cull);
                    // OnCullingChanged(); // TODO
                }
            },
            /*UnityEngine.UI.MaskableGraphic.UpdateCull end.*/

            /*UnityEngine.UI.MaskableGraphic.SetClipRect start.*/
            /**
             * See IClippable.SetClipRect
             *
             * @instance
             * @public
             * @this UnityEngine.UI.MaskableGraphic
             * @memberof UnityEngine.UI.MaskableGraphic
             * @param   {UnityEngine.Rect}    clipRect     
             * @param   {boolean}             validRect
             * @return  {void}
             */
            SetClipRect: function (clipRect, validRect) {
if ( TRACE ) { TRACE( "UnityEngine.UI.MaskableGraphic#SetClipRect", this ); }

                if (validRect) {
                    // canvasRenderer.EnableRectClipping(clipRect); // TODO
                } else {
                    this.canvasRenderer.DisableRectClipping();
                }
            },
            /*UnityEngine.UI.MaskableGraphic.SetClipRect end.*/

            /*UnityEngine.UI.MaskableGraphic.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.MaskableGraphic#OnEnable", this ); }

                UnityEngine.UI.Graphic.prototype.OnEnable.call(this);
                this.m_ShouldRecalculateStencil = true;
                this.UpdateClipParent();
                this.SetMaterialDirty();

                if (UnityEngine.MonoBehaviour.op_Inequality(this.GetComponent(UnityEngine.UI.Mask), null)) {
                    UnityEngine.UI.MaskUtilities.NotifyStencilStateChanged(this);
                }
            },
            /*UnityEngine.UI.MaskableGraphic.OnEnable end.*/

            /*UnityEngine.UI.MaskableGraphic.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.MaskableGraphic#OnDisable", this ); }

                UnityEngine.UI.Graphic.prototype.OnDisable.call(this);
                this.m_ShouldRecalculateStencil = true;
                this.SetMaterialDirty();
                this.UpdateClipParent();
                UnityEngine.UI.StencilMaterial.Remove(this.m_MaskMaterial);
                this.m_MaskMaterial = null;

                if (UnityEngine.MonoBehaviour.op_Inequality(this.GetComponent(UnityEngine.UI.Mask), null)) {
                    UnityEngine.UI.MaskUtilities.NotifyStencilStateChanged(this);
                }
            },
            /*UnityEngine.UI.MaskableGraphic.OnDisable end.*/

            /*UnityEngine.UI.MaskableGraphic.OnTransformParentChanged start.*/
            OnTransformParentChanged: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.MaskableGraphic#OnTransformParentChanged", this ); }

                UnityEngine.UI.Graphic.prototype.OnTransformParentChanged.call(this);

                if (!this.isActiveAndEnabled) {
                    return;
                }

                this.m_ShouldRecalculateStencil = true;
                this.UpdateClipParent();
                this.SetMaterialDirty();
            },
            /*UnityEngine.UI.MaskableGraphic.OnTransformParentChanged end.*/

            /*UnityEngine.UI.MaskableGraphic.ParentMaskStateChanged start.*/
            ParentMaskStateChanged: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.MaskableGraphic#ParentMaskStateChanged", this ); }
 },
            /*UnityEngine.UI.MaskableGraphic.ParentMaskStateChanged end.*/

            /*UnityEngine.UI.MaskableGraphic.OnCanvasHierarchyChanged start.*/
            OnCanvasHierarchyChanged: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.MaskableGraphic#OnCanvasHierarchyChanged", this ); }

                UnityEngine.UI.Graphic.prototype.OnCanvasHierarchyChanged.call(this);

                if (!this.isActiveAndEnabled) {
                    return;
                }

                this.m_ShouldRecalculateStencil = true;
                this.UpdateClipParent();
                this.SetMaterialDirty();
            },
            /*UnityEngine.UI.MaskableGraphic.OnCanvasHierarchyChanged end.*/

            /*UnityEngine.UI.MaskableGraphic.UpdateClipParent start.*/
            UpdateClipParent: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.MaskableGraphic#UpdateClipParent", this ); }

                var newParent = this.maskable && this.IsActive() ? UnityEngine.UI.MaskUtilities.GetRectMaskForClippable(this) : null;

                // if the new parent is different OR is now inactive
                if (UnityEngine.MonoBehaviour.op_Inequality(this.m_ParentMask, null) && (UnityEngine.MonoBehaviour.op_Inequality(newParent, this.m_ParentMask) || !newParent.IsActive())) {
                    this.m_ParentMask.RemoveClippable(this);
                    this.UpdateCull(false);
                }

                // don't re-add it if the newparent is inactive
                if (UnityEngine.MonoBehaviour.op_Inequality(newParent, null) && newParent.IsActive()) {
                    newParent.AddClippable(this);
                }

                this.m_ParentMask = newParent;
            },
            /*UnityEngine.UI.MaskableGraphic.UpdateClipParent end.*/

            /*UnityEngine.UI.MaskableGraphic.RecalculateClipping start.*/
            /**
             * See IClippable.RecalculateClipping
             *
             * @instance
             * @public
             * @this UnityEngine.UI.MaskableGraphic
             * @memberof UnityEngine.UI.MaskableGraphic
             * @return  {void}
             */
            RecalculateClipping: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.MaskableGraphic#RecalculateClipping", this ); }

                this.UpdateClipParent();
            },
            /*UnityEngine.UI.MaskableGraphic.RecalculateClipping end.*/

            /*UnityEngine.UI.MaskableGraphic.RecalculateMasking start.*/
            /**
             * See IMaskable.RecalculateMasking
             *
             * @instance
             * @public
             * @this UnityEngine.UI.MaskableGraphic
             * @memberof UnityEngine.UI.MaskableGraphic
             * @return  {void}
             */
            RecalculateMasking: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.MaskableGraphic#RecalculateMasking", this ); }

                // Remove the material reference as either the graphic of the mask has been enable/ disabled.
                // This will cause the material to be repopulated from the original if need be. (case 994413)
                UnityEngine.UI.StencilMaterial.Remove(this.m_MaskMaterial);
                this.m_MaskMaterial = null;
                this.m_ShouldRecalculateStencil = true;
                this.SetMaterialDirty();
            },
            /*UnityEngine.UI.MaskableGraphic.RecalculateMasking end.*/


        }
    });
    /*UnityEngine.UI.MaskableGraphic end.*/

    /*UnityEngine.UI.Shadow start.*/
    Bridge.define("UnityEngine.UI.Shadow", {
        inherits: [UnityEngine.UI.BaseMeshEffect],
        statics: {
            fields: {
                kMaxEffectDistance: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Shadow#init", this ); }

                    this.kMaxEffectDistance = 600.0;
                }
            }
        },
        fields: {
            m_EffectColor: null,
            m_EffectDistance: null,
            m_UseGraphicAlpha: false
        },
        props: {
            /**
             * Color for the effect
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Shadow
             * @function effectColor
             * @type UnityEngine.Color
             */
            effectColor: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Shadow#effectColor#get", this ); }

                    return this.m_EffectColor.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Shadow#effectColor#set", this ); }

                    this.m_EffectColor = value.$clone();
                    if (UnityEngine.MonoBehaviour.op_Inequality(this.graphic, null)) {
                        this.graphic.SetVerticesDirty();
                    }
                }
            },
            /**
             * How far is the shadow from the graphic.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Shadow
             * @function effectDistance
             * @type UnityEngine.Vector2
             */
            effectDistance: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Shadow#effectDistance#get", this ); }

                    return this.m_EffectDistance.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Shadow#effectDistance#set", this ); }

                    if (value.x > UnityEngine.UI.Shadow.kMaxEffectDistance) {
                        value.x = UnityEngine.UI.Shadow.kMaxEffectDistance;
                    }

                    if (value.x < -600.0) {
                        value.x = -600.0;
                    }

                    if (value.y > UnityEngine.UI.Shadow.kMaxEffectDistance) {
                        value.y = UnityEngine.UI.Shadow.kMaxEffectDistance;
                    }

                    if (value.y < -600.0) {
                        value.y = -600.0;
                    }

                    if (pc.Vec2.equals( this.m_EffectDistance, value )) {
                        return;
                    }

                    this.m_EffectDistance = value.$clone();
                    if (UnityEngine.MonoBehaviour.op_Inequality(this.graphic, null)) {
                        this.graphic.SetVerticesDirty();
                    }
                }
            },
            /**
             * Should the shadow inherit the alpha from the graphic?
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Shadow
             * @function useGraphicAlpha
             * @type boolean
             */
            useGraphicAlpha: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Shadow#useGraphicAlpha#get", this ); }

                    return this.m_UseGraphicAlpha;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Shadow#useGraphicAlpha#set", this ); }

                    this.m_UseGraphicAlpha = value;
                    if (UnityEngine.MonoBehaviour.op_Inequality(this.graphic, null)) {
                        this.graphic.SetVerticesDirty();
                    }
                }
            }
        },
        alias: ["ModifyMesh$1", "UnityEngine$UI$IMeshModifier$ModifyMesh$1"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Shadow#init", this ); }

                this.m_EffectColor = new UnityEngine.Color();
                this.m_EffectDistance = new UnityEngine.Vector2();
                this.m_EffectColor = new pc.Color( 0.0, 0.0, 0.0, 0.5 );
                this.m_EffectDistance = new pc.Vec2( 1.0, -1.0 );
                this.m_UseGraphicAlpha = true;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Shadow#ctor", this ); }

                this.$initialize();
                UnityEngine.UI.BaseMeshEffect.ctor.call(this);
            }
        },
        methods: {
            /*UnityEngine.UI.Shadow.ApplyShadowZeroAlloc start.*/
            ApplyShadowZeroAlloc: function (verts, color, start, end, x, y) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Shadow#ApplyShadowZeroAlloc", this ); }

                var vt = new UnityEngine.UIVertex();

                var neededCapacity = verts.Count + end - start;
                if (verts.Capacity < neededCapacity) {
                    verts.Capacity = neededCapacity;
                }

                for (var i = start; i < end; ++i) {
                    vt = verts.getItem(i).$clone();
                    verts.add(vt.$clone());

                    var v = vt.position.$clone();
                    v.x += x;
                    v.y += y;
                    vt.position = v.$clone();
                    var newColor = color.$clone();
                    if (this.m_UseGraphicAlpha) {
                        newColor.a = newColor.a * verts.getItem(i).$clone().color.a / 255;
                    }

                    vt.color = newColor.$clone();
                    verts.setItem(i, vt.$clone());
                }
            },
            /*UnityEngine.UI.Shadow.ApplyShadowZeroAlloc end.*/

            /*UnityEngine.UI.Shadow.ApplyShadow start.*/
            /**
             * Duplicate vertices from start to end and turn them into shadows with the given offset.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.Shadow
             * @memberof UnityEngine.UI.Shadow
             * @param   {System.Collections.Generic.List$1}    verts    Vert list to copy
             * @param   {UnityEngine.Color32}                  color    Shadow color
             * @param   {number}                               start    The start index in the verts list
             * @param   {number}                               end      The end index in the vers list
             * @param   {number}                               x        The shadows x offset
             * @param   {number}                               y        The shadows y offset
             * @return  {void}
             */
            ApplyShadow: function (verts, color, start, end, x, y) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Shadow#ApplyShadow", this ); }

                this.ApplyShadowZeroAlloc(verts, color.$clone(), start, end, x, y);
            },
            /*UnityEngine.UI.Shadow.ApplyShadow end.*/

            /*UnityEngine.UI.Shadow.ModifyMesh$1 start.*/
            ModifyMesh$1: function (vh) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Shadow#ModifyMesh$1", this ); }

                return;
                // if (!IsActive())
                //     return;
                //
                // var output = ListPool<UIVertex>.Get();
                // vh.GetUIVertexStream(output);
                //
                // ApplyShadow(output, effectColor, 0, output.Count, effectDistance.x, effectDistance.y);
                // vh.Clear();
                // vh.AddUIVertexTriangleStream(output);
                // ListPool<UIVertex>.Release(output);
            },
            /*UnityEngine.UI.Shadow.ModifyMesh$1 end.*/


        },
        overloads: {
            "ModifyMesh(VertexHelper)": "ModifyMesh$1"
        }
    });
    /*UnityEngine.UI.Shadow end.*/

    /*UnityEngine.UI.ScrollRect start.*/
    /**
     * A component for making a child RectTransform scroll.
     *
     * @public
     * @class UnityEngine.UI.ScrollRect
     * @augments UnityEngine.EventSystems.UIBehaviour
     * @implements  UnityEngine.EventSystems.IInitializePotentialDragHandler
     * @implements  UnityEngine.EventSystems.IBeginDragHandler
     * @implements  UnityEngine.EventSystems.IEndDragHandler
     * @implements  UnityEngine.EventSystems.IDragHandler
     * @implements  UnityEngine.EventSystems.IScrollHandler
     * @implements  UnityEngine.UI.ICanvasElement
     * @implements  UnityEngine.UI.ILayoutElement
     * @implements  UnityEngine.UI.ILayoutGroup
     */
    Bridge.define("UnityEngine.UI.ScrollRect", {
        inherits: [UnityEngine.EventSystems.UIBehaviour,UnityEngine.EventSystems.IInitializePotentialDragHandler,UnityEngine.EventSystems.IBeginDragHandler,UnityEngine.EventSystems.IEndDragHandler,UnityEngine.EventSystems.IDragHandler,UnityEngine.EventSystems.IScrollHandler,UnityEngine.UI.ICanvasElement,UnityEngine.UI.ILayoutElement,UnityEngine.UI.ILayoutGroup],
        statics: {
            methods: {
                /*UnityEngine.UI.ScrollRect.RubberDelta:static start.*/
                RubberDelta: function (overStretching, viewSize) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#RubberDelta", this ); }

                    return (1 - 1 / (Math.abs(overStretching) * 0.55 / viewSize + 1)) * viewSize * (overStretching === 0 ? 1 : Math.sign(overStretching));
                },
                /*UnityEngine.UI.ScrollRect.RubberDelta:static end.*/

                /*UnityEngine.UI.ScrollRect.UpdateOneScrollbarVisibility:static start.*/
                UpdateOneScrollbarVisibility: function (xScrollingNeeded, xAxisEnabled, scrollbarVisibility, scrollbar) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#UpdateOneScrollbarVisibility", this ); }

                    if (UnityEngine.Object.op_Implicit(scrollbar)) {
                        if (scrollbarVisibility === UnityEngine.UI.ScrollRect.ScrollbarVisibility.Permanent) {
                            if (scrollbar.gameObject.activeSelf !== xAxisEnabled) {
                                scrollbar.gameObject.SetActive(xAxisEnabled);
                            }
                        } else {
                            if (scrollbar.gameObject.activeSelf !== xScrollingNeeded) {
                                scrollbar.gameObject.SetActive(xScrollingNeeded);
                            }
                        }
                    }
                },
                /*UnityEngine.UI.ScrollRect.UpdateOneScrollbarVisibility:static end.*/

                /*UnityEngine.UI.ScrollRect.AdjustBounds:static start.*/
                AdjustBounds: function (viewBounds, contentPivot, contentSize, contentPos) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#AdjustBounds", this ); }

                    // Make sure content bounds are at least as large as view by adding padding if not.
                    // One might think at first that if the content is smaller than the view, scrolling should be allowed.
                    // However, that's not how scroll views normally work.
                    // Scrolling is *only* possible when content is *larger* than view.
                    // We use the pivot of the content rect to decide in which directions the content bounds should be expanded.
                    // E.g. if pivot is at top, bounds are expanded downwards.
                    // This also works nicely when ContentSizeFitter is used on the content.
                    var excess = viewBounds.halfExtents.$clone().scale( 2 ).$clone().sub( contentSize.v );
                    if (excess.x > 0) {
                        contentPos.v.x -= excess.x * (contentPivot.x - 0.5);
                        contentSize.v.x = viewBounds.halfExtents.$clone().scale( 2 ).x;
                    }

                    if (excess.y > 0) {
                        contentPos.v.y -= excess.y * (contentPivot.y - 0.5);
                        contentSize.v.y = viewBounds.halfExtents.$clone().scale( 2 ).y;
                    }
                },
                /*UnityEngine.UI.ScrollRect.AdjustBounds:static end.*/

                /*UnityEngine.UI.ScrollRect.InternalGetBounds:static start.*/
                InternalGetBounds: function (corners, viewWorldToLocalMatrix, bounds) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#InternalGetBounds", this ); }

                    var vMin = new pc.Vec3( 3.40282347E+38, 3.40282347E+38, 3.40282347E+38 );
                    var vMax = new pc.Vec3( -3.40282347E+38, -3.40282347E+38, -3.40282347E+38 );

                    for (var j = 0; j < 4; j++) {
                        var v = viewWorldToLocalMatrix.v.transformPoint( corners[j] );
                        vMin = new pc.Vec3( Math.min( v.x, vMin.x ), Math.min( v.y, vMin.y ), Math.min( v.z, vMin.z) );
                        vMax = new pc.Vec3( Math.max( v.x, vMax.x ), Math.max( v.y, vMax.y ), Math.max( v.z, vMax.z ) );
                    }

                    bounds.center = vMin.$clone();
                    bounds.halfExtents = pc.Vec3.ZERO.clone().$clone().scale( 0.5 );
                    bounds.expandToPoint( vMax.$clone() );
                    return bounds;
                },
                /*UnityEngine.UI.ScrollRect.InternalGetBounds:static end.*/

                /*UnityEngine.UI.ScrollRect.InternalCalculateOffset:static start.*/
                InternalCalculateOffset: function (viewBounds, contentBounds, horizontal, vertical, movementType, delta) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#InternalCalculateOffset", this ); }

                    var offset = pc.Vec2.ZERO.clone();
                    if (movementType === UnityEngine.UI.ScrollRect.MovementType.Unrestricted) {
                        return offset;
                    }

                    var min = contentBounds.v.min;
                    var max = contentBounds.v.max;

                    // min/max offset extracted to check if approximately 0 and avoid recalculating layout every frame (case 1010178)
                    if (horizontal) {
                        min.x += delta.v.x;
                        max.x += delta.v.x;

                        var maxOffset = viewBounds.v.max.x - max.x;
                        var minOffset = viewBounds.v.min.x - min.x;

                        if (minOffset < -0.001) {
                            offset.x = minOffset;
                        } else if (maxOffset > 0.001) {
                            offset.x = maxOffset;
                        }
                    }

                    if (vertical) {
                        min.y += delta.v.y;
                        max.y += delta.v.y;

                        var maxOffset1 = viewBounds.v.max.y - max.y;
                        var minOffset1 = viewBounds.v.min.y - min.y;

                        if (maxOffset1 > 0.001) {
                            offset.y = maxOffset1;
                        } else if (minOffset1 < -0.001) {
                            offset.y = minOffset1;
                        }
                    }

                    return offset;
                },
                /*UnityEngine.UI.ScrollRect.InternalCalculateOffset:static end.*/


            }
        },
        fields: {
            m_Content: null,
            m_Horizontal: false,
            m_Vertical: false,
            m_MovementType: 0,
            m_Elasticity: 0,
            m_Inertia: false,
            m_DecelerationRate: 0,
            m_ScrollSensitivity: 0,
            m_Viewport: null,
            m_HorizontalScrollbar: null,
            m_VerticalScrollbar: null,
            m_HorizontalScrollbarVisibility: 0,
            m_VerticalScrollbarVisibility: 0,
            m_HorizontalScrollbarSpacing: 0,
            m_VerticalScrollbarSpacing: 0,
            m_OnValueChanged: null,
            _pointerStartLocalCursor: null,
            m_ContentStartPosition: null,
            _viewRect: null,
            m_ContentBounds: null,
            _viewBounds: null,
            _velocity: null,
            _dragging: false,
            _scrolling: false,
            _prevPosition: null,
            _prevContentBounds: null,
            _prevViewBounds: null,
            _hasRebuiltLayout: false,
            _hSliderExpand: false,
            _vSliderExpand: false,
            _hSliderHeight: 0,
            _vSliderWidth: 0,
            _rect: null,
            _horizontalScrollbarRect: null,
            _verticalScrollbarRect: null,
            _tracker: null,
            m_Corners: null
        },
        props: {
            /**
             * The content that can be scrolled. It should be a child of the GameObject with ScrollRect on it.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.ScrollRect
             * @function content
             * @type UnityEngine.RectTransform
             */
            content: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#content#get", this ); }

                    return this.m_Content;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#content#set", this ); }

                    this.m_Content = value;
                }
            },
            /**
             * Should horizontal scrolling be enabled?
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.ScrollRect
             * @function horizontal
             * @type boolean
             */
            horizontal: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#horizontal#get", this ); }

                    return this.m_Horizontal;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#horizontal#set", this ); }

                    this.m_Horizontal = value;
                }
            },
            /**
             * Should vertical scrolling be enabled?
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.ScrollRect
             * @function vertical
             * @type boolean
             */
            vertical: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#vertical#get", this ); }

                    return this.m_Vertical;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#vertical#set", this ); }

                    this.m_Vertical = value;
                }
            },
            /**
             * The behavior to use when the content moves beyond the scroll rect.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.ScrollRect
             * @function movementType
             * @type number
             */
            movementType: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#movementType#get", this ); }

                    return this.m_MovementType;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#movementType#set", this ); }

                    this.m_MovementType = value;
                }
            },
            /**
             * The amount of elasticity to use when the content moves beyond the scroll rect.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.ScrollRect
             * @function elasticity
             * @type number
             */
            elasticity: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#elasticity#get", this ); }

                    return this.m_Elasticity;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#elasticity#set", this ); }

                    this.m_Elasticity = value;
                }
            },
            /**
             * Should movement inertia be enabled?
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.ScrollRect
             * @function inertia
             * @type boolean
             */
            inertia: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#inertia#get", this ); }

                    return this.m_Inertia;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#inertia#set", this ); }

                    this.m_Inertia = value;
                }
            },
            /**
             * The rate at which movement slows down.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.ScrollRect
             * @function decelerationRate
             * @type number
             */
            decelerationRate: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#decelerationRate#get", this ); }

                    return this.m_DecelerationRate;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#decelerationRate#set", this ); }

                    this.m_DecelerationRate = value;
                }
            },
            /**
             * The sensitivity to scroll wheel and track pad scroll events.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.ScrollRect
             * @function scrollSensitivity
             * @type number
             */
            scrollSensitivity: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#scrollSensitivity#get", this ); }

                    return this.m_ScrollSensitivity;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#scrollSensitivity#set", this ); }

                    this.m_ScrollSensitivity = value;
                }
            },
            /**
             * Reference to the viewport RectTransform that is the parent of the content RectTransform.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.ScrollRect
             * @function viewport
             * @type UnityEngine.RectTransform
             */
            viewport: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#viewport#get", this ); }

                    return this.m_Viewport;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#viewport#set", this ); }

                    this.m_Viewport = value;
                    this.SetDirtyCaching();
                }
            },
            /**
             * Optional Scrollbar object linked to the horizontal scrolling of the ScrollRect.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.ScrollRect
             * @function horizontalScrollbar
             * @type UnityEngine.UI.Scrollbar
             */
            horizontalScrollbar: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#horizontalScrollbar#get", this ); }

                    return this.m_HorizontalScrollbar;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#horizontalScrollbar#set", this ); }

                    if (UnityEngine.Object.op_Implicit(this.m_HorizontalScrollbar)) {
                        this.m_HorizontalScrollbar.onValueChanged.RemoveListener(Bridge.fn.cacheBind(this, this.SetHorizontalNormalizedPosition));
                    }

                    this.m_HorizontalScrollbar = value;
                    if (UnityEngine.Object.op_Implicit(this.m_HorizontalScrollbar)) {
                        this.m_HorizontalScrollbar.onValueChanged.AddListener(Bridge.fn.cacheBind(this, this.SetHorizontalNormalizedPosition));
                    }

                    this.SetDirtyCaching();
                }
            },
            /**
             * Optional Scrollbar object linked to the vertical scrolling of the ScrollRect.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.ScrollRect
             * @function verticalScrollbar
             * @type UnityEngine.UI.Scrollbar
             */
            verticalScrollbar: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#verticalScrollbar#get", this ); }

                    return this.m_VerticalScrollbar;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#verticalScrollbar#set", this ); }

                    if (UnityEngine.Object.op_Implicit(this.m_VerticalScrollbar)) {
                        this.m_VerticalScrollbar.onValueChanged.RemoveListener(Bridge.fn.cacheBind(this, this.SetVerticalNormalizedPosition));
                    }

                    this.m_VerticalScrollbar = value;
                    if (UnityEngine.Object.op_Implicit(this.m_VerticalScrollbar)) {
                        this.m_VerticalScrollbar.onValueChanged.AddListener(Bridge.fn.cacheBind(this, this.SetVerticalNormalizedPosition));
                    }

                    this.SetDirtyCaching();
                }
            },
            /**
             * The mode of visibility for the horizontal scrollbar.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.ScrollRect
             * @function horizontalScrollbarVisibility
             * @type number
             */
            horizontalScrollbarVisibility: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#horizontalScrollbarVisibility#get", this ); }

                    return this.m_HorizontalScrollbarVisibility;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#horizontalScrollbarVisibility#set", this ); }

                    this.m_HorizontalScrollbarVisibility = value;
                    this.SetDirtyCaching();
                }
            },
            /**
             * The mode of visibility for the vertical scrollbar.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.ScrollRect
             * @function verticalScrollbarVisibility
             * @type number
             */
            verticalScrollbarVisibility: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#verticalScrollbarVisibility#get", this ); }

                    return this.m_VerticalScrollbarVisibility;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#verticalScrollbarVisibility#set", this ); }

                    this.m_VerticalScrollbarVisibility = value;
                    this.SetDirtyCaching();
                }
            },
            /**
             * The space between the scrollbar and the viewport.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.ScrollRect
             * @function horizontalScrollbarSpacing
             * @type number
             */
            horizontalScrollbarSpacing: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#horizontalScrollbarSpacing#get", this ); }

                    return this.m_HorizontalScrollbarSpacing;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#horizontalScrollbarSpacing#set", this ); }

                    this.m_HorizontalScrollbarSpacing = value;
                    this.SetDirty();
                }
            },
            /**
             * The space between the scrollbar and the viewport.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.ScrollRect
             * @function verticalScrollbarSpacing
             * @type number
             */
            verticalScrollbarSpacing: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#verticalScrollbarSpacing#get", this ); }

                    return this.m_VerticalScrollbarSpacing;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#verticalScrollbarSpacing#set", this ); }

                    this.m_VerticalScrollbarSpacing = value;
                    this.SetDirty();
                }
            },
            /**
             * Callback executed when the position of the child changes.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.ScrollRect
             * @function onValueChanged
             * @type UnityEngine.UI.ScrollRect.ScrollRectEvent
             */
            onValueChanged: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#onValueChanged#get", this ); }

                    return this.m_OnValueChanged;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#onValueChanged#set", this ); }

                    this.m_OnValueChanged = value;
                }
            },
            viewRect: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#viewRect#get", this ); }

                    if (UnityEngine.Component.op_Equality(this._viewRect, null)) {
                        this._viewRect = this.m_Viewport;
                    }

                    if (UnityEngine.Component.op_Equality(this._viewRect, null)) {
                        this._viewRect = Bridge.cast(this.transform, UnityEngine.RectTransform);
                    }

                    return this._viewRect;
                }
            },
            /**
             * The current velocity of the content.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.ScrollRect
             * @function velocity
             * @type UnityEngine.Vector2
             */
            velocity: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#velocity#get", this ); }

                    return this._velocity.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#velocity#set", this ); }

                    this._velocity = value.$clone();
                }
            },
            rectTransform: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#rectTransform#get", this ); }

                    if (UnityEngine.Component.op_Equality(this._rect, null)) {
                        this._rect = this.GetComponent(UnityEngine.RectTransform);
                    }

                    return this._rect;
                }
            },
            /**
             * The scroll position as a Vector2 between (0,0) and (1,1) with (0,0) being the lower left corner.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.ScrollRect
             * @function normalizedPosition
             * @type UnityEngine.Vector2
             */
            normalizedPosition: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#normalizedPosition#get", this ); }

                    return new pc.Vec2( this.horizontalNormalizedPosition, this.verticalNormalizedPosition );
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#normalizedPosition#set", this ); }

                    this.SetNormalizedPosition(value.x, 0);
                    this.SetNormalizedPosition(value.y, 1);
                }
            },
            /**
             * The horizontal scroll position as a value between 0 and 1, with 0 being at the left.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.ScrollRect
             * @function horizontalNormalizedPosition
             * @type number
             */
            horizontalNormalizedPosition: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#horizontalNormalizedPosition#get", this ); }

                    this.UpdateBounds();
                    if (this.m_ContentBounds.halfExtents.$clone().scale( 2 ).x <= this._viewBounds.halfExtents.$clone().scale( 2 ).x || UnityEngine.Mathf.Approximately(this.m_ContentBounds.halfExtents.$clone().scale( 2 ).x, this._viewBounds.halfExtents.$clone().scale( 2 ).x)) {
                        return this._viewBounds.min.x > this.m_ContentBounds.min.x ? 1 : 0;
                    }

                    return (this._viewBounds.min.x - this.m_ContentBounds.min.x) / (this.m_ContentBounds.halfExtents.$clone().scale( 2 ).x - this._viewBounds.halfExtents.$clone().scale( 2 ).x);
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#horizontalNormalizedPosition#set", this ); }

                    this.SetNormalizedPosition(value, 0);
                }
            },
            /**
             * The vertical scroll position as a value between 0 and 1, with 0 being at the bottom.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.ScrollRect
             * @function verticalNormalizedPosition
             * @type number
             */
            verticalNormalizedPosition: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#verticalNormalizedPosition#get", this ); }

                    this.UpdateBounds();
                    if (this.m_ContentBounds.halfExtents.$clone().scale( 2 ).y <= this._viewBounds.halfExtents.$clone().scale( 2 ).y || UnityEngine.Mathf.Approximately(this.m_ContentBounds.halfExtents.$clone().scale( 2 ).y, this._viewBounds.halfExtents.$clone().scale( 2 ).y)) {
                        return this._viewBounds.min.y > this.m_ContentBounds.min.y ? 1 : 0;
                    }

                    return (this._viewBounds.min.y - this.m_ContentBounds.min.y) / (this.m_ContentBounds.halfExtents.$clone().scale( 2 ).y - this._viewBounds.halfExtents.$clone().scale( 2 ).y);
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#verticalNormalizedPosition#set", this ); }

                    this.SetNormalizedPosition(value, 1);
                }
            },
            hScrollingNeeded: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#hScrollingNeeded#get", this ); }

                    if (UnityEngine.Application.isPlaying) {
                        return this.m_ContentBounds.halfExtents.$clone().scale( 2 ).x > this._viewBounds.halfExtents.$clone().scale( 2 ).x + 0.01;
                    }

                    return true;
                }
            },
            vScrollingNeeded: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#vScrollingNeeded#get", this ); }

                    if (UnityEngine.Application.isPlaying) {
                        return this.m_ContentBounds.halfExtents.$clone().scale( 2 ).y > this._viewBounds.halfExtents.$clone().scale( 2 ).y + 0.01;
                    }

                    return true;
                }
            },
            /**
             * Called by the layout system.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.ScrollRect
             * @function minWidth
             * @type number
             */
            minWidth: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#minWidth#get", this ); }

                    return -1;
                }
            },
            /**
             * Called by the layout system.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.ScrollRect
             * @function preferredWidth
             * @type number
             */
            preferredWidth: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#preferredWidth#get", this ); }

                    return -1;
                }
            },
            /**
             * Called by the layout system.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.ScrollRect
             * @function flexibleWidth
             * @type number
             */
            flexibleWidth: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#flexibleWidth#get", this ); }

                    return -1;
                }
            },
            /**
             * Called by the layout system.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.ScrollRect
             * @function minHeight
             * @type number
             */
            minHeight: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#minHeight#get", this ); }

                    return -1;
                }
            },
            /**
             * Called by the layout system.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.ScrollRect
             * @function preferredHeight
             * @type number
             */
            preferredHeight: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#preferredHeight#get", this ); }

                    return -1;
                }
            },
            /**
             * Called by the layout system.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.ScrollRect
             * @function flexibleHeight
             * @type number
             */
            flexibleHeight: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#flexibleHeight#get", this ); }

                    return -1;
                }
            },
            /**
             * Called by the layout system.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.ScrollRect
             * @function layoutPriority
             * @type number
             */
            layoutPriority: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#layoutPriority#get", this ); }

                    return -1;
                }
            }
        },
        alias: [
            "Rebuild", "UnityEngine$UI$ICanvasElement$Rebuild",
            "LayoutComplete", "UnityEngine$UI$ICanvasElement$LayoutComplete",
            "GraphicUpdateComplete", "UnityEngine$UI$ICanvasElement$GraphicUpdateComplete",
            "OnScroll", "UnityEngine$EventSystems$IScrollHandler$OnScroll",
            "OnInitializePotentialDrag", "UnityEngine$EventSystems$IInitializePotentialDragHandler$OnInitializePotentialDrag",
            "OnBeginDrag", "UnityEngine$EventSystems$IBeginDragHandler$OnBeginDrag",
            "OnEndDrag", "UnityEngine$EventSystems$IEndDragHandler$OnEndDrag",
            "OnDrag", "UnityEngine$EventSystems$IDragHandler$OnDrag",
            "CalculateLayoutInputHorizontal", "UnityEngine$UI$ILayoutElement$CalculateLayoutInputHorizontal",
            "CalculateLayoutInputVertical", "UnityEngine$UI$ILayoutElement$CalculateLayoutInputVertical",
            "minWidth", "UnityEngine$UI$ILayoutElement$minWidth",
            "preferredWidth", "UnityEngine$UI$ILayoutElement$preferredWidth",
            "flexibleWidth", "UnityEngine$UI$ILayoutElement$flexibleWidth",
            "minHeight", "UnityEngine$UI$ILayoutElement$minHeight",
            "preferredHeight", "UnityEngine$UI$ILayoutElement$preferredHeight",
            "flexibleHeight", "UnityEngine$UI$ILayoutElement$flexibleHeight",
            "layoutPriority", "UnityEngine$UI$ILayoutElement$layoutPriority",
            "SetLayoutHorizontal", "UnityEngine$UI$ILayoutController$SetLayoutHorizontal",
            "SetLayoutVertical", "UnityEngine$UI$ILayoutController$SetLayoutVertical",
            "IsDestroyed", "UnityEngine$UI$ICanvasElement$IsDestroyed",
            "transform", "UnityEngine$UI$ICanvasElement$transform"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#init", this ); }

                this._pointerStartLocalCursor = new UnityEngine.Vector2();
                this.m_ContentStartPosition = new UnityEngine.Vector2();
                this.m_ContentBounds = new UnityEngine.Bounds();
                this._viewBounds = new UnityEngine.Bounds();
                this._velocity = new UnityEngine.Vector2();
                this._prevPosition = new UnityEngine.Vector2();
                this._prevContentBounds = new UnityEngine.Bounds();
                this._prevViewBounds = new UnityEngine.Bounds();
                this._tracker = new ( pc.stubProxy.generateConstructorFor( 'UnityEngine.DrivenRectTransformTracker' ) )();
                this.m_Horizontal = true;
                this.m_Vertical = true;
                this.m_MovementType = UnityEngine.UI.ScrollRect.MovementType.Elastic;
                this.m_Elasticity = 0.1;
                this.m_Inertia = true;
                this.m_DecelerationRate = 0.135;
                this.m_ScrollSensitivity = 1.0;
                this.m_OnValueChanged = new UnityEngine.UI.ScrollRect.ScrollRectEvent();
                this._pointerStartLocalCursor = pc.Vec2.ZERO.clone();
                this.m_ContentStartPosition = pc.Vec2.ZERO.clone();
                this._prevPosition = pc.Vec2.ZERO.clone();
                this._hasRebuiltLayout = false;
                this.m_Corners = System.Array.init(4, function (){
                    return new UnityEngine.Vector3();
                }, UnityEngine.Vector3);
            },
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#ctor", this ); }

                this.$initialize();
                UnityEngine.EventSystems.UIBehaviour.ctor.call(this);
            }
        },
        methods: {
            /*UnityEngine.UI.ScrollRect.Rebuild start.*/
            Rebuild: function (executing) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#Rebuild", this ); }

                if (executing === UnityEngine.UI.CanvasUpdate.Prelayout) {
                    this.UpdateCachedData();
                }

                if (executing === UnityEngine.UI.CanvasUpdate.PostLayout) {
                    this.UpdateBounds();
                    this.UpdateScrollbars(pc.Vec2.ZERO.clone());
                    this.UpdatePrevData();

                    this._hasRebuiltLayout = true;
                }
            },
            /*UnityEngine.UI.ScrollRect.Rebuild end.*/

            /*UnityEngine.UI.ScrollRect.LayoutComplete start.*/
            LayoutComplete: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#LayoutComplete", this ); }
 },
            /*UnityEngine.UI.ScrollRect.LayoutComplete end.*/

            /*UnityEngine.UI.ScrollRect.GraphicUpdateComplete start.*/
            GraphicUpdateComplete: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#GraphicUpdateComplete", this ); }
 },
            /*UnityEngine.UI.ScrollRect.GraphicUpdateComplete end.*/

            /*UnityEngine.UI.ScrollRect.UpdateCachedData start.*/
            UpdateCachedData: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#UpdateCachedData", this ); }

                var transform = this.transform;
                this._horizontalScrollbarRect = UnityEngine.MonoBehaviour.op_Equality(this.m_HorizontalScrollbar, null) ? null : Bridge.as(this.m_HorizontalScrollbar.transform, UnityEngine.RectTransform);
                this._verticalScrollbarRect = UnityEngine.MonoBehaviour.op_Equality(this.m_VerticalScrollbar, null) ? null : Bridge.as(this.m_VerticalScrollbar.transform, UnityEngine.RectTransform);

                // These are true if either the elements are children, or they don't exist at all.
                var viewIsChild = UnityEngine.Component.op_Equality(this.viewRect.parent, transform);
                var hScrollbarIsChild = !UnityEngine.Object.op_Implicit(this._horizontalScrollbarRect) || UnityEngine.Component.op_Equality(this._horizontalScrollbarRect.parent, transform);
                var vScrollbarIsChild = !UnityEngine.Object.op_Implicit(this._verticalScrollbarRect) || UnityEngine.Component.op_Equality(this._verticalScrollbarRect.parent, transform);
                var allAreChildren = viewIsChild && hScrollbarIsChild && vScrollbarIsChild;

                this._hSliderExpand = allAreChildren && UnityEngine.Object.op_Implicit(this._horizontalScrollbarRect) && this.horizontalScrollbarVisibility === UnityEngine.UI.ScrollRect.ScrollbarVisibility.AutoHideAndExpandViewport;
                this._vSliderExpand = allAreChildren && UnityEngine.Object.op_Implicit(this._verticalScrollbarRect) && this.verticalScrollbarVisibility === UnityEngine.UI.ScrollRect.ScrollbarVisibility.AutoHideAndExpandViewport;
                this._hSliderHeight = UnityEngine.Component.op_Equality(this._horizontalScrollbarRect, null) ? 0 : this._horizontalScrollbarRect.rect.height;
                this._vSliderWidth = UnityEngine.Component.op_Equality(this._verticalScrollbarRect, null) ? 0 : this._verticalScrollbarRect.rect.width;
            },
            /*UnityEngine.UI.ScrollRect.UpdateCachedData end.*/

            /*UnityEngine.UI.ScrollRect.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#OnEnable", this ); }

                UnityEngine.EventSystems.UIBehaviour.prototype.OnEnable.call(this);

                if (UnityEngine.Object.op_Implicit(this.m_HorizontalScrollbar)) {
                    this.m_HorizontalScrollbar.onValueChanged.AddListener(Bridge.fn.cacheBind(this, this.SetHorizontalNormalizedPosition));
                }

                if (UnityEngine.Object.op_Implicit(this.m_VerticalScrollbar)) {
                    this.m_VerticalScrollbar.onValueChanged.AddListener(Bridge.fn.cacheBind(this, this.SetVerticalNormalizedPosition));
                }

                UnityEngine.UI.CanvasUpdateRegistry.RegisterCanvasElementForLayoutRebuild(this);
                this.SetDirty();
            },
            /*UnityEngine.UI.ScrollRect.OnEnable end.*/

            /*UnityEngine.UI.ScrollRect.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#OnDisable", this ); }

                UnityEngine.UI.CanvasUpdateRegistry.UnRegisterCanvasElementForRebuild(this);

                if (UnityEngine.Object.op_Implicit(this.m_HorizontalScrollbar)) {
                    this.m_HorizontalScrollbar.onValueChanged.RemoveListener(Bridge.fn.cacheBind(this, this.SetHorizontalNormalizedPosition));
                }

                if (UnityEngine.Object.op_Implicit(this.m_VerticalScrollbar)) {
                    this.m_VerticalScrollbar.onValueChanged.RemoveListener(Bridge.fn.cacheBind(this, this.SetVerticalNormalizedPosition));
                }

                this._dragging = false;
                this._scrolling = false;
                this._hasRebuiltLayout = false;
                this._tracker.reportMethod( 'UnityEngine.DrivenRectTransformTracker.Clear', null );
                this._velocity = pc.Vec2.ZERO.clone();
                UnityEngine.UI.LayoutRebuilder.MarkLayoutForRebuild(this.rectTransform);
                UnityEngine.EventSystems.UIBehaviour.prototype.OnDisable.call(this);
            },
            /*UnityEngine.UI.ScrollRect.OnDisable end.*/

            /*UnityEngine.UI.ScrollRect.IsActive start.*/
            /**
             * See member in base class.
             *
             * @instance
             * @public
             * @override
             * @this UnityEngine.UI.ScrollRect
             * @memberof UnityEngine.UI.ScrollRect
             * @return  {boolean}
             */
            IsActive: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#IsActive", this ); }

                return UnityEngine.EventSystems.UIBehaviour.prototype.IsActive.call(this) && UnityEngine.Component.op_Inequality(this.m_Content, null);
            },
            /*UnityEngine.UI.ScrollRect.IsActive end.*/

            /*UnityEngine.UI.ScrollRect.EnsureLayoutHasRebuilt start.*/
            EnsureLayoutHasRebuilt: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#EnsureLayoutHasRebuilt", this ); }

                if (!this._hasRebuiltLayout && !UnityEngine.UI.CanvasUpdateRegistry.IsRebuildingLayout()) {
                    UnityEngine.Canvas.ForceUpdateCanvases();
                }
            },
            /*UnityEngine.UI.ScrollRect.EnsureLayoutHasRebuilt end.*/

            /*UnityEngine.UI.ScrollRect.StopMovement start.*/
            /**
             * Sets the velocity to zero on both axes so the content stops moving.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.ScrollRect
             * @memberof UnityEngine.UI.ScrollRect
             * @return  {void}
             */
            StopMovement: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#StopMovement", this ); }

                this._velocity = pc.Vec2.ZERO.clone();
            },
            /*UnityEngine.UI.ScrollRect.StopMovement end.*/

            /*UnityEngine.UI.ScrollRect.OnScroll start.*/
            OnScroll: function (data) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#OnScroll", this ); }

                if (!this.IsActive()) {
                    return;
                }

                this.EnsureLayoutHasRebuilt();
                this.UpdateBounds();

                var delta = data.scrollDelta.$clone();
                // Down is positive for scroll events, while in UI system up is positive.
                delta.y *= -1;
                if (this.vertical && !this.horizontal) {
                    if (Math.abs(delta.x) > Math.abs(delta.y)) {
                        delta.y = delta.x;
                    }

                    delta.x = 0;
                }

                if (this.horizontal && !this.vertical) {
                    if (Math.abs(delta.y) > Math.abs(delta.x)) {
                        delta.x = delta.y;
                    }

                    delta.y = 0;
                }

                if (data.IsScrolling()) {
                    this._scrolling = true;
                }

                var position = this.m_Content.anchoredPosition.$clone();
                position = position.$clone().add( delta.$clone().scale( this.m_ScrollSensitivity ) );
                if (this.m_MovementType === UnityEngine.UI.ScrollRect.MovementType.Clamped) {
                    position = position.$clone().add( this.CalculateOffset(position.$clone().sub( this.m_Content.anchoredPosition )) );
                }

                this.SetContentAnchoredPosition(position.$clone());
                this.UpdateBounds();
            },
            /*UnityEngine.UI.ScrollRect.OnScroll end.*/

            /*UnityEngine.UI.ScrollRect.OnInitializePotentialDrag start.*/
            OnInitializePotentialDrag: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#OnInitializePotentialDrag", this ); }

                if (eventData.button !== UnityEngine.EventSystems.PointerEventData.InputButton.Left) {
                    return;
                }

                this._velocity = pc.Vec2.ZERO.clone();
            },
            /*UnityEngine.UI.ScrollRect.OnInitializePotentialDrag end.*/

            /*UnityEngine.UI.ScrollRect.OnBeginDrag start.*/
            /**
             * Handling for when the content is beging being dragged.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.ScrollRect
             * @memberof UnityEngine.UI.ScrollRect
             * @param   {UnityEngine.EventSystems.PointerEventData}    eventData
             * @return  {void}
             */
            OnBeginDrag: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#OnBeginDrag", this ); }

                if (eventData.button !== UnityEngine.EventSystems.PointerEventData.InputButton.Left) {
                    return;
                }

                if (!this.IsActive()) {
                    return;
                }

                this.UpdateBounds();

                this._pointerStartLocalCursor = pc.Vec2.ZERO.clone();
                UnityEngine.RectTransformUtility.ScreenPointToLocalPointInRectangle(this.viewRect, eventData.position, eventData.pressEventCamera, Bridge.ref(this, "_pointerStartLocalCursor"));
                this.m_ContentStartPosition = this.m_Content.anchoredPosition.$clone();
                this._dragging = true;
            },
            /*UnityEngine.UI.ScrollRect.OnBeginDrag end.*/

            /*UnityEngine.UI.ScrollRect.OnEndDrag start.*/
            /**
             * Handling for when the content has finished being dragged.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.ScrollRect
             * @memberof UnityEngine.UI.ScrollRect
             * @param   {UnityEngine.EventSystems.PointerEventData}    eventData
             * @return  {void}
             */
            OnEndDrag: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#OnEndDrag", this ); }

                if (eventData.button !== UnityEngine.EventSystems.PointerEventData.InputButton.Left) {
                    return;
                }

                this._dragging = false;
            },
            /*UnityEngine.UI.ScrollRect.OnEndDrag end.*/

            /*UnityEngine.UI.ScrollRect.OnDrag start.*/
            /**
             * Handling for when the content is dragged.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.ScrollRect
             * @memberof UnityEngine.UI.ScrollRect
             * @param   {UnityEngine.EventSystems.PointerEventData}    eventData
             * @return  {void}
             */
            OnDrag: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#OnDrag", this ); }

                if (!this._dragging) {
                    return;
                }

                if (eventData.button !== UnityEngine.EventSystems.PointerEventData.InputButton.Left) {
                    return;
                }

                if (!this.IsActive()) {
                    return;
                }

                var localCursor = { v : new UnityEngine.Vector2() };
                if (!UnityEngine.RectTransformUtility.ScreenPointToLocalPointInRectangle(this.viewRect, eventData.position, eventData.pressEventCamera, localCursor)) {
                    return;
                }

                this.UpdateBounds();

                var pointerDelta = localCursor.v.$clone().sub( this._pointerStartLocalCursor );
                var position = this.m_ContentStartPosition.$clone().add( pointerDelta );

                // Offset to get content into place in the view.
                var offset = this.CalculateOffset(position.$clone().sub( this.m_Content.anchoredPosition ));
                position = position.$clone().add( offset.$clone() );
                if (this.m_MovementType === UnityEngine.UI.ScrollRect.MovementType.Elastic) {
                    if (offset.x !== 0) {
                        position.x = position.x - UnityEngine.UI.ScrollRect.RubberDelta(offset.x, this._viewBounds.halfExtents.$clone().scale( 2 ).x);
                    }

                    if (offset.y !== 0) {
                        position.y = position.y - UnityEngine.UI.ScrollRect.RubberDelta(offset.y, this._viewBounds.halfExtents.$clone().scale( 2 ).y);
                    }
                }

                this.SetContentAnchoredPosition(position.$clone());
            },
            /*UnityEngine.UI.ScrollRect.OnDrag end.*/

            /*UnityEngine.UI.ScrollRect.SetContentAnchoredPosition start.*/
            /**
             * Sets the anchored position of the content.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.ScrollRect
             * @memberof UnityEngine.UI.ScrollRect
             * @param   {UnityEngine.Vector2}    position
             * @return  {void}
             */
            SetContentAnchoredPosition: function (position) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#SetContentAnchoredPosition", this ); }

                if (!this.m_Horizontal) {
                    position.x = this.m_Content.anchoredPosition.x;
                }

                if (!this.m_Vertical) {
                    position.y = this.m_Content.anchoredPosition.y;
                }

                if (!pc.Vec2.equals( position, this.m_Content.anchoredPosition )) {
                    this.m_Content.anchoredPosition = position.$clone();
                    this.UpdateBounds();
                }
            },
            /*UnityEngine.UI.ScrollRect.SetContentAnchoredPosition end.*/

            /*UnityEngine.UI.ScrollRect.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#LateUpdate", this ); }

                if (!UnityEngine.Object.op_Implicit(this.m_Content)) {
                    return;
                }

                this.EnsureLayoutHasRebuilt();
                this.UpdateBounds();
                var deltaTime = UnityEngine.Time.unscaledDeltaTime;
                var offset = this.CalculateOffset(pc.Vec2.ZERO.clone());
                if (!this._dragging && (!pc.Vec2.equals( offset, pc.Vec2.ZERO.clone() ) || !pc.Vec2.equals( this._velocity, pc.Vec2.ZERO.clone() ))) {
                    var position = this.m_Content.anchoredPosition.$clone();
                    for (var axis = 0; axis < 2; axis++) {
                        // Apply spring physics if movement is elastic and content has an offset from the view.
                        if (this.m_MovementType === UnityEngine.UI.ScrollRect.MovementType.Elastic && offset.getitem(axis) !== 0) {
                            var speed = { v : this._velocity.getitem(axis) };
                            var smoothTime = this.m_Elasticity;
                            if (this._scrolling) {
                                smoothTime *= 3.0;
                            }

                            position.setitem(axis, UnityEngine.Mathf.SmoothDamp$1(this.m_Content.anchoredPosition.getitem(axis), this.m_Content.anchoredPosition.getitem(axis) + offset.getitem(axis), speed, smoothTime, window.Infinity, deltaTime));
                            if (Math.abs(speed.v) < 1) {
                                speed.v = 0;
                            }

                            this._velocity.setitem(axis, speed.v);
                        } else if (this.m_Inertia) {
                            this._velocity.setitem(axis, this._velocity.getitem(axis) *(Math.pow(this.m_DecelerationRate, deltaTime)));
                            if (Math.abs(this._velocity.getitem(axis)) < 1) {
                                this._velocity.setitem(axis, 0);
                            }

                            position.setitem(axis, position.getitem(axis) +(this._velocity.getitem(axis) * deltaTime));
                        } else {
                            this._velocity.setitem(axis, 0);
                        }
                    }

                    if (this.m_MovementType === UnityEngine.UI.ScrollRect.MovementType.Clamped) {
                        offset = this.CalculateOffset(position.$clone().sub( this.m_Content.anchoredPosition ));
                        position = position.$clone().add( offset.$clone() );
                    }

                    this.SetContentAnchoredPosition(position.$clone());
                }

                if (this._dragging && this.m_Inertia) {
                    var newVelocity = UnityEngine.Vector3.FromVector2((this.m_Content.anchoredPosition.$clone().sub( this._prevPosition )).scale( 1.0 / ( deltaTime ) ));
                    this._velocity = UnityEngine.Vector2.FromVector3(new pc.Vec3().lerp( UnityEngine.Vector3.FromVector2(this._velocity), newVelocity, deltaTime * 10 ));
                }

                if (!pc.BoundingBox.equals( this._viewBounds, this._prevViewBounds ) || !pc.BoundingBox.equals( this.m_ContentBounds, this._prevContentBounds ) || !pc.Vec2.equals( this.m_Content.anchoredPosition, this._prevPosition )) {
                    this.UpdateScrollbars(offset.$clone());
                    this.m_OnValueChanged.Invoke(this.normalizedPosition.$clone());
                    this.UpdatePrevData();
                }

                this.UpdateScrollbarVisibility();
                this._scrolling = false;
            },
            /*UnityEngine.UI.ScrollRect.LateUpdate end.*/

            /*UnityEngine.UI.ScrollRect.UpdatePrevData start.*/
            /**
             * Helper function to update the previous data fields on a ScrollRect. Call this before you change data in the ScrollRect.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.ScrollRect
             * @memberof UnityEngine.UI.ScrollRect
             * @return  {void}
             */
            UpdatePrevData: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#UpdatePrevData", this ); }

                if (UnityEngine.Component.op_Equality(this.m_Content, null)) {
                    this._prevPosition = pc.Vec2.ZERO.clone();
                } else {
                    this._prevPosition = this.m_Content.anchoredPosition.$clone();
                }

                this._prevViewBounds = this._viewBounds;
                this._prevContentBounds = this.m_ContentBounds;
            },
            /*UnityEngine.UI.ScrollRect.UpdatePrevData end.*/

            /*UnityEngine.UI.ScrollRect.UpdateScrollbars start.*/
            UpdateScrollbars: function (offset) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#UpdateScrollbars", this ); }

                if (UnityEngine.Object.op_Implicit(this.m_HorizontalScrollbar)) {
                    if (this.m_ContentBounds.halfExtents.$clone().scale( 2 ).x > 0) {
                        this.m_HorizontalScrollbar.size = Math.max(0, Math.min(1, (this._viewBounds.halfExtents.$clone().scale( 2 ).x - Math.abs(offset.x)) / this.m_ContentBounds.halfExtents.$clone().scale( 2 ).x));
                    } else {
                        this.m_HorizontalScrollbar.size = 1;
                    }

                    this.m_HorizontalScrollbar.value = this.horizontalNormalizedPosition;
                }

                if (UnityEngine.Object.op_Implicit(this.m_VerticalScrollbar)) {
                    if (this.m_ContentBounds.halfExtents.$clone().scale( 2 ).y > 0) {
                        this.m_VerticalScrollbar.size = Math.max(0, Math.min(1, (this._viewBounds.halfExtents.$clone().scale( 2 ).y - Math.abs(offset.y)) / this.m_ContentBounds.halfExtents.$clone().scale( 2 ).y));
                    } else {
                        this.m_VerticalScrollbar.size = 1;
                    }

                    this.m_VerticalScrollbar.value = this.verticalNormalizedPosition;
                }
            },
            /*UnityEngine.UI.ScrollRect.UpdateScrollbars end.*/

            /*UnityEngine.UI.ScrollRect.SetHorizontalNormalizedPosition start.*/
            SetHorizontalNormalizedPosition: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#SetHorizontalNormalizedPosition", this ); }

                this.SetNormalizedPosition(value, 0);
            },
            /*UnityEngine.UI.ScrollRect.SetHorizontalNormalizedPosition end.*/

            /*UnityEngine.UI.ScrollRect.SetVerticalNormalizedPosition start.*/
            SetVerticalNormalizedPosition: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#SetVerticalNormalizedPosition", this ); }

                this.SetNormalizedPosition(value, 1);
            },
            /*UnityEngine.UI.ScrollRect.SetVerticalNormalizedPosition end.*/

            /*UnityEngine.UI.ScrollRect.SetNormalizedPosition start.*/
            /**
             * &gt;Set the horizontal or vertical scroll position as a value between 0 and 1, with 0 being at the left or at the bottom.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.ScrollRect
             * @memberof UnityEngine.UI.ScrollRect
             * @param   {number}    value    The position to set, between 0 and 1.
             * @param   {number}    axis     The axis to set: 0 for horizontal, 1 for vertical.
             * @return  {void}
             */
            SetNormalizedPosition: function (value, axis) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#SetNormalizedPosition", this ); }

                this.EnsureLayoutHasRebuilt();
                this.UpdateBounds();
                // How much the content is larger than the view.
                var hiddenLength = this.m_ContentBounds.halfExtents.$clone().scale( 2 ).getitem(axis) - this._viewBounds.halfExtents.$clone().scale( 2 ).getitem(axis);
                // Where the position of the lower left corner of the content bounds should be, in the space of the view.
                var contentBoundsMinPosition = this._viewBounds.min.getitem(axis) - value * hiddenLength;
                // The new content localPosition, in the space of the view.
                var newLocalPosition = this.m_Content.localPosition.getitem(axis) + contentBoundsMinPosition - this.m_ContentBounds.min.getitem(axis);

                var localPosition = this.m_Content.localPosition.$clone();
                if (Math.abs(localPosition.getitem(axis) - newLocalPosition) > 0.01) {
                    localPosition.setitem(axis, newLocalPosition);
                    this.m_Content.localPosition = localPosition.$clone();
                    this._velocity.setitem(axis, 0);
                    this.UpdateBounds();
                }
            },
            /*UnityEngine.UI.ScrollRect.SetNormalizedPosition end.*/

            /*UnityEngine.UI.ScrollRect.OnRectTransformDimensionsChange start.*/
            OnRectTransformDimensionsChange: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#OnRectTransformDimensionsChange", this ); }

                this.SetDirty();
            },
            /*UnityEngine.UI.ScrollRect.OnRectTransformDimensionsChange end.*/

            /*UnityEngine.UI.ScrollRect.CalculateLayoutInputHorizontal start.*/
            /**
             * Called by the layout system.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.ScrollRect
             * @memberof UnityEngine.UI.ScrollRect
             * @return  {void}
             */
            CalculateLayoutInputHorizontal: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#CalculateLayoutInputHorizontal", this ); }
 },
            /*UnityEngine.UI.ScrollRect.CalculateLayoutInputHorizontal end.*/

            /*UnityEngine.UI.ScrollRect.CalculateLayoutInputVertical start.*/
            /**
             * Called by the layout system.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.ScrollRect
             * @memberof UnityEngine.UI.ScrollRect
             * @return  {void}
             */
            CalculateLayoutInputVertical: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#CalculateLayoutInputVertical", this ); }
 },
            /*UnityEngine.UI.ScrollRect.CalculateLayoutInputVertical end.*/

            /*UnityEngine.UI.ScrollRect.SetLayoutHorizontal start.*/
            SetLayoutHorizontal: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#SetLayoutHorizontal", this ); }

                this._tracker.reportMethod( 'UnityEngine.DrivenRectTransformTracker.Clear', null );

                if (pc.BoundingBox.equals( this.m_ContentBounds, null )) {
                    this.m_ContentBounds = new pc.BoundingBox.ctor();
                }

                if (pc.BoundingBox.equals( this._viewBounds, null )) {
                    this._viewBounds = new pc.BoundingBox.ctor();
                }

                if (this._hSliderExpand || this._vSliderExpand) {
                    this._tracker.reportMethod( 'UnityEngine.DrivenRectTransformTracker.Add', null );

                    // Make view full size to see if content fits.
                    this.viewRect.anchorMin.copy( pc.Vec2.ZERO.clone() );
                    this.viewRect.anchorMax.copy( pc.Vec2.ZERO.clone() );
                    this.viewRect.sizeDelta.copy( pc.Vec2.ZERO.clone() );
                    this.viewRect.anchoredPosition.copy( pc.Vec2.ZERO.clone() );

                    // Recalculate content layout with this size to see if it fits when there are no scrollbars.
                    UnityEngine.UI.LayoutRebuilder.ForceRebuildLayoutImmediate(this.content);
                    this._viewBounds = new pc.BoundingBox( UnityEngine.Vector3.FromVector2(this.viewRect.rect.center.$clone()), UnityEngine.Vector3.FromVector2(this.viewRect.rect.size.$clone()).scale( 0.5 ) );
                    this.m_ContentBounds = this.GetBounds(this.m_ContentBounds);
                }

                // If it doesn't fit vertically, enable vertical scrollbar and shrink view horizontally to make room for it.
                if (this._vSliderExpand && this.vScrollingNeeded) {
                    this.viewRect.sizeDelta = new pc.Vec2( -(this._vSliderWidth + this.m_VerticalScrollbarSpacing), this.viewRect.sizeDelta.y );

                    // Recalculate content layout with this size to see if it fits vertically
                    // when there is a vertical scrollbar (which may reflowed the content to make it taller).
                    UnityEngine.UI.LayoutRebuilder.ForceRebuildLayoutImmediate(this.content);
                    this._viewBounds = new pc.BoundingBox( UnityEngine.Vector3.FromVector2(this.viewRect.rect.center.$clone()), UnityEngine.Vector3.FromVector2(this.viewRect.rect.size.$clone()).scale( 0.5 ) );
                    this.m_ContentBounds = this.GetBounds(this.m_ContentBounds);
                }

                // If it doesn't fit horizontally, enable horizontal scrollbar and shrink view vertically to make room for it.
                if (this._hSliderExpand && this.hScrollingNeeded) {
                    this.viewRect.sizeDelta = new pc.Vec2( this.viewRect.sizeDelta.x, -(this._hSliderHeight + this.m_HorizontalScrollbarSpacing) );
                    this._viewBounds = new pc.BoundingBox( UnityEngine.Vector3.FromVector2(this.viewRect.rect.center.$clone()), UnityEngine.Vector3.FromVector2(this.viewRect.rect.size.$clone()).scale( 0.5 ) );
                    this.m_ContentBounds = this.GetBounds(this.m_ContentBounds);
                }

                // If the vertical slider didn't kick in the first time, and the horizontal one did,
                // we need to check again if the vertical slider now needs to kick in.
                // If it doesn't fit vertically, enable vertical scrollbar and shrink view horizontally to make room for it.
                if (this._vSliderExpand && this.vScrollingNeeded && this.viewRect.sizeDelta.x === 0 && this.viewRect.sizeDelta.y < 0) {
                    this.viewRect.sizeDelta = new pc.Vec2( -(this._vSliderWidth + this.m_VerticalScrollbarSpacing), this.viewRect.sizeDelta.y );
                }
            },
            /*UnityEngine.UI.ScrollRect.SetLayoutHorizontal end.*/

            /*UnityEngine.UI.ScrollRect.SetLayoutVertical start.*/
            SetLayoutVertical: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#SetLayoutVertical", this ); }

                this.UpdateScrollbarLayout();
                this._viewBounds = new pc.BoundingBox( UnityEngine.Vector3.FromVector2(this.viewRect.rect.center.$clone()), UnityEngine.Vector3.FromVector2(this.viewRect.rect.size.$clone()).scale( 0.5 ) );
                if (pc.BoundingBox.equals( this.m_ContentBounds, null )) {
                    this.m_ContentBounds = new pc.BoundingBox.ctor();
                }

                this.m_ContentBounds = this.GetBounds(this.m_ContentBounds);
            },
            /*UnityEngine.UI.ScrollRect.SetLayoutVertical end.*/

            /*UnityEngine.UI.ScrollRect.UpdateScrollbarVisibility start.*/
            UpdateScrollbarVisibility: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#UpdateScrollbarVisibility", this ); }

                UnityEngine.UI.ScrollRect.UpdateOneScrollbarVisibility(this.vScrollingNeeded, this.m_Vertical, this.m_VerticalScrollbarVisibility, this.m_VerticalScrollbar);
                UnityEngine.UI.ScrollRect.UpdateOneScrollbarVisibility(this.hScrollingNeeded, this.m_Horizontal, this.m_HorizontalScrollbarVisibility, this.m_HorizontalScrollbar);
            },
            /*UnityEngine.UI.ScrollRect.UpdateScrollbarVisibility end.*/

            /*UnityEngine.UI.ScrollRect.UpdateScrollbarLayout start.*/
            UpdateScrollbarLayout: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#UpdateScrollbarLayout", this ); }

                if (this._vSliderExpand && UnityEngine.Object.op_Implicit(this.m_HorizontalScrollbar)) {
                    this._tracker.reportMethod( 'UnityEngine.DrivenRectTransformTracker.Add', null );
                    this._horizontalScrollbarRect.anchorMin = new pc.Vec2( 0, this._horizontalScrollbarRect.anchorMin.y );
                    this._horizontalScrollbarRect.anchorMax = new pc.Vec2( 1, this._horizontalScrollbarRect.anchorMax.y );
                    this._horizontalScrollbarRect.anchoredPosition = new pc.Vec2( 0, this._horizontalScrollbarRect.anchoredPosition.y );
                    if (this.vScrollingNeeded) {
                        this._horizontalScrollbarRect.sizeDelta = new pc.Vec2( -(this._vSliderWidth + this.m_VerticalScrollbarSpacing), this._horizontalScrollbarRect.sizeDelta.y );
                    } else {
                        this._horizontalScrollbarRect.sizeDelta = new pc.Vec2( 0, this._horizontalScrollbarRect.sizeDelta.y );
                    }
                }

                if (this._hSliderExpand && UnityEngine.Object.op_Implicit(this.m_VerticalScrollbar)) {
                    this._tracker.reportMethod( 'UnityEngine.DrivenRectTransformTracker.Add', null );
                    this._verticalScrollbarRect.anchorMin = new pc.Vec2( this._verticalScrollbarRect.anchorMin.x, 0 );
                    this._verticalScrollbarRect.anchorMax = new pc.Vec2( this._verticalScrollbarRect.anchorMax.x, 1 );
                    this._verticalScrollbarRect.anchoredPosition = new pc.Vec2( this._verticalScrollbarRect.anchoredPosition.x, 0 );
                    if (this.hScrollingNeeded) {
                        this._verticalScrollbarRect.sizeDelta = new pc.Vec2( this._verticalScrollbarRect.sizeDelta.x, -(this._hSliderHeight + this.m_HorizontalScrollbarSpacing) );
                    } else {
                        this._verticalScrollbarRect.sizeDelta = new pc.Vec2( this._verticalScrollbarRect.sizeDelta.x, 0 );
                    }
                }
            },
            /*UnityEngine.UI.ScrollRect.UpdateScrollbarLayout end.*/

            /*UnityEngine.UI.ScrollRect.UpdateBounds start.*/
            /**
             * Calculate the bounds the ScrollRect should be using.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.ScrollRect
             * @memberof UnityEngine.UI.ScrollRect
             * @return  {void}
             */
            UpdateBounds: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#UpdateBounds", this ); }

                if (pc.BoundingBox.equals( this._viewBounds, null )) {
                    this._viewBounds = new pc.BoundingBox.ctor();
                }

                var rect = this.viewRect.cachedRect.$clone();

                this._viewBounds.center = UnityEngine.Vector3.FromVector2(rect.center.$clone());
                this._viewBounds.halfExtents = UnityEngine.Vector3.FromVector2(rect.size.$clone()).$clone().scale( 0.5 );

                if (pc.BoundingBox.equals( this.m_ContentBounds, null )) {
                    this.m_ContentBounds = new pc.BoundingBox.ctor();
                }

                this.m_ContentBounds = this.GetBounds(this.m_ContentBounds);

                if (UnityEngine.Component.op_Equality(this.m_Content, null)) {
                    return;
                }

                var contentSize = { v : this.m_ContentBounds.halfExtents.$clone().scale( 2 ).$clone() };
                var contentPos = { v : this.m_ContentBounds.center.$clone() };
                var contentPivot = this.m_Content.pivot.$clone();
                UnityEngine.UI.ScrollRect.AdjustBounds(this._viewBounds, contentPivot, contentSize, contentPos);
                this.m_ContentBounds.halfExtents = contentSize.v.$clone().$clone().scale( 0.5 );
                this.m_ContentBounds.center = contentPos.v.$clone();

                if (this.movementType === UnityEngine.UI.ScrollRect.MovementType.Clamped) {
                    // Adjust content so that content bounds bottom (right side) is never higher (to the left) than the view bounds bottom (right side).
                    // top (left side) is never lower (to the right) than the view bounds top (left side).
                    // All this can happen if content has shrunk.
                    // This works because content size is at least as big as view size (because of the call to InternalUpdateBounds above).
                    var delta = pc.Vec2.ZERO.clone();
                    if (this._viewBounds.max.x > this.m_ContentBounds.max.x) {
                        delta.x = Math.min(this._viewBounds.min.x - this.m_ContentBounds.min.x, this._viewBounds.max.x - this.m_ContentBounds.max.x);
                    } else if (this._viewBounds.min.x < this.m_ContentBounds.min.x) {
                        delta.x = Math.max(this._viewBounds.min.x - this.m_ContentBounds.min.x, this._viewBounds.max.x - this.m_ContentBounds.max.x);
                    }

                    if (this._viewBounds.min.y < this.m_ContentBounds.min.y) {
                        delta.y = Math.max(this._viewBounds.min.y - this.m_ContentBounds.min.y, this._viewBounds.max.y - this.m_ContentBounds.max.y);
                    } else if (this._viewBounds.max.y > this.m_ContentBounds.max.y) {
                        delta.y = Math.min(this._viewBounds.min.y - this.m_ContentBounds.min.y, this._viewBounds.max.y - this.m_ContentBounds.max.y);
                    }

                    if (delta.lengthSq() > 1.401298E-45) {
                        contentPos.v = UnityEngine.Vector3.FromVector2(this.m_Content.anchoredPosition.$clone().add( delta ));
                        if (!this.m_Horizontal) {
                            contentPos.v.x = this.m_Content.anchoredPosition.x;
                        }

                        if (!this.m_Vertical) {
                            contentPos.v.y = this.m_Content.anchoredPosition.y;
                        }

                        UnityEngine.UI.ScrollRect.AdjustBounds(this._viewBounds, contentPivot, contentSize, contentPos);
                    }
                }
            },
            /*UnityEngine.UI.ScrollRect.UpdateBounds end.*/

            /*UnityEngine.UI.ScrollRect.GetBounds start.*/
            GetBounds: function (bounds) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#GetBounds", this ); }

                if (UnityEngine.Component.op_Equality(this.m_Content, null)) {
                    return new pc.BoundingBox.ctor();
                }

                this.m_Content.GetWorldCorners(this.m_Corners);
                var viewWorldToLocalMatrix = { v : this.viewRect.worldToLocalMatrix.$clone() };
                return UnityEngine.UI.ScrollRect.InternalGetBounds(this.m_Corners, viewWorldToLocalMatrix, bounds);
            },
            /*UnityEngine.UI.ScrollRect.GetBounds end.*/

            /*UnityEngine.UI.ScrollRect.CalculateOffset start.*/
            CalculateOffset: function (delta) {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#CalculateOffset", this ); }

                delta = {v:delta};
                return UnityEngine.UI.ScrollRect.InternalCalculateOffset(Bridge.ref(this, "_viewBounds"), Bridge.ref(this, "m_ContentBounds"), this.m_Horizontal, this.m_Vertical, this.m_MovementType, delta);
            },
            /*UnityEngine.UI.ScrollRect.CalculateOffset end.*/

            /*UnityEngine.UI.ScrollRect.SetDirty start.*/
            /**
             * Override to alter or add to the code that keeps the appearance of the scroll rect synced with its data.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.ScrollRect
             * @memberof UnityEngine.UI.ScrollRect
             * @return  {void}
             */
            SetDirty: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#SetDirty", this ); }

                if (!this.IsActive()) {
                    return;
                }

                UnityEngine.UI.LayoutRebuilder.MarkLayoutForRebuild(this.rectTransform);
            },
            /*UnityEngine.UI.ScrollRect.SetDirty end.*/

            /*UnityEngine.UI.ScrollRect.SetDirtyCaching start.*/
            /**
             * Override to alter or add to the code that caches data to avoid repeated heavy operations.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.ScrollRect
             * @memberof UnityEngine.UI.ScrollRect
             * @return  {void}
             */
            SetDirtyCaching: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.ScrollRect#SetDirtyCaching", this ); }

                if (!this.IsActive()) {
                    return;
                }

                UnityEngine.UI.CanvasUpdateRegistry.RegisterCanvasElementForLayoutRebuild(this);
                UnityEngine.UI.LayoutRebuilder.MarkLayoutForRebuild(this.rectTransform);
            },
            /*UnityEngine.UI.ScrollRect.SetDirtyCaching end.*/


        }
    });
    /*UnityEngine.UI.ScrollRect end.*/

    /*UnityEngine.EventSystems.Physics2DRaycaster start.*/
    Bridge.define("UnityEngine.EventSystems.Physics2DRaycaster", {
        inherits: [UnityEngine.EventSystems.PhysicsRaycaster],
        fields: {
            hits$1: null
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.Physics2DRaycaster#ctor", this ); }

                this.$initialize();
                UnityEngine.EventSystems.PhysicsRaycaster.ctor.call(this);
            }
        },
        methods: {
            /*UnityEngine.EventSystems.Physics2DRaycaster.Raycast start.*/
            Raycast: function (eventData, resultAppendList) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.Physics2DRaycaster#Raycast", this ); }

                var $t;
                if (UnityEngine.Component.op_Equality(this.eventCamera, null)) {
                    return;
                }

                var ray = { v : new UnityEngine.Ray.ctor() };
                var distanceToClipPlane = { v : 0 };
                this.ComputeRayAndDistance(eventData, ray, distanceToClipPlane);
                var num;
                if (this.maxRayIntersections === 0) {
                    if (Bridge.staticEquals(UnityEngine.UI.ReflectionMethodsCache.Singleton.getRayIntersectionAll, null)) {
                        return;
                    }

                    this.hits$1 = UnityEngine.UI.ReflectionMethodsCache.Singleton.getRayIntersectionAll(ray.v.$clone(), distanceToClipPlane.v, this.finalEventMask);
                    num = this.hits$1.length;
                } else {
                    if (Bridge.staticEquals(UnityEngine.UI.ReflectionMethodsCache.Singleton.getRayIntersectionAllNonAlloc, null)) {
                        return;
                    }

                    if (this.m_LastMaxRayIntersections !== this.m_MaxRayIntersections) {
                        this.hits$1 = System.Array.init(this.maxRayIntersections, function (){
                            return new UnityEngine.RaycastHit2D();
                        }, UnityEngine.RaycastHit2D);
                        this.m_LastMaxRayIntersections = this.m_MaxRayIntersections;
                    }

                    num = UnityEngine.UI.ReflectionMethodsCache.Singleton.getRayIntersectionAllNonAlloc(ray.v.$clone(), this.hits$1, distanceToClipPlane.v, this.finalEventMask);
                }

                if (num === 0) {
                    return;
                }

                var index1 = 0;
                for (var index2 = num; index1 < index2; ++index1) {
                    var component = this.hits$1[index1].collider.gameObject.GetComponent(UnityEngine.SpriteRenderer);
                    var raycastResult = ($t = new UnityEngine.EventSystems.RaycastResult(), $t.gameObject = this.hits$1[index1].collider.gameObject, $t.module = this, $t.distance = pc.Vec3.distance( this.eventCamera.transform.position, UnityEngine.Vector3.FromVector2(this.hits$1[index1].point) ), $t.worldPosition = UnityEngine.Vector3.FromVector2(this.hits$1[index1].point.$clone()), $t.worldNormal = UnityEngine.Vector3.FromVector2(this.hits$1[index1].normal.$clone()), $t.screenPosition = eventData.position.$clone(), $t.index = resultAppendList.Count, $t.sortingLayer = UnityEngine.Component.op_Equality(component, null) ? 0 : component.sortingLayerID, $t.sortingOrder = UnityEngine.Component.op_Equality(component, null) ? 0 : component.sortingOrder, $t);
                    resultAppendList.add(raycastResult.$clone());
                }
            },
            /*UnityEngine.EventSystems.Physics2DRaycaster.Raycast end.*/


        }
    });
    /*UnityEngine.EventSystems.Physics2DRaycaster end.*/

    /*UnityEngine.EventSystems.StandaloneInputModule start.*/
    Bridge.define("UnityEngine.EventSystems.StandaloneInputModule", {
        inherits: [UnityEngine.EventSystems.PointerInputModule],
        fields: {
            prevActionTime: 0,
            lastMoveVector: null,
            consecutiveMoveCount: 0,
            lastMousePosition: null,
            mousePosition: null,
            currentFocusedGameObject: null,
            inputPointerEvent: null,
            _horizontalAxis: null,
            /**
             * Name of the vertical axis for movement (if axis events are used).
             *
             * @instance
             * @private
             * @memberof UnityEngine.EventSystems.StandaloneInputModule
             * @default "Vertical"
             * @type string
             */
            _verticalAxis: null,
            /**
             * Name of the submit button.
             *
             * @instance
             * @private
             * @memberof UnityEngine.EventSystems.StandaloneInputModule
             * @default "Submit"
             * @type string
             */
            _submitButton: null,
            /**
             * Name of the submit button.
             *
             * @instance
             * @private
             * @memberof UnityEngine.EventSystems.StandaloneInputModule
             * @default "Cancel"
             * @type string
             */
            _cancelButton: null,
            _inputActionsPerSecond: 0,
            _repeatDelay: 0,
            _forceModuleActive: false
        },
        props: {
            inputMode: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#inputMode#get", this ); }

                    return UnityEngine.EventSystems.StandaloneInputModule.InputMode.Mouse;
                }
            },
            allowActivationOnMobileDevice: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#allowActivationOnMobileDevice#get", this ); }

                    return this._forceModuleActive;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#allowActivationOnMobileDevice#set", this ); }

                    this._forceModuleActive = value;
                }
            },
            /**
             * Force this module to be active.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.StandaloneInputModule
             * @function forceModuleActive
             * @type boolean
             */
            forceModuleActive: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#forceModuleActive#get", this ); }

                    return this._forceModuleActive;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#forceModuleActive#set", this ); }

                    this._forceModuleActive = value;
                }
            },
            /**
             * Number of keyboard / controller inputs allowed per second.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.StandaloneInputModule
             * @function inputActionsPerSecond
             * @type number
             */
            inputActionsPerSecond: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#inputActionsPerSecond#get", this ); }

                    return this._inputActionsPerSecond;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#inputActionsPerSecond#set", this ); }

                    this._inputActionsPerSecond = value;
                }
            },
            /**
             * Delay in seconds before the input actions per second repeat rate takes effect.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.StandaloneInputModule
             * @function repeatDelay
             * @type number
             */
            repeatDelay: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#repeatDelay#get", this ); }

                    return this._repeatDelay;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#repeatDelay#set", this ); }

                    this._repeatDelay = value;
                }
            },
            /**
             * Name of the horizontal axis for movement (if axis events are used).
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.StandaloneInputModule
             * @function horizontalAxis
             * @type string
             */
            horizontalAxis: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#horizontalAxis#get", this ); }

                    return this._horizontalAxis;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#horizontalAxis#set", this ); }

                    this._horizontalAxis = value;
                }
            },
            /**
             * Name of the vertical axis for movement (if axis events are used).
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.StandaloneInputModule
             * @function verticalAxis
             * @type string
             */
            verticalAxis: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#verticalAxis#get", this ); }

                    return this._verticalAxis;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#verticalAxis#set", this ); }

                    this._verticalAxis = value;
                }
            },
            /**
             * Maximum number of input events handled per second.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.StandaloneInputModule
             * @function submitButton
             * @type string
             */
            submitButton: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#submitButton#get", this ); }

                    return this._submitButton;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#submitButton#set", this ); }

                    this._submitButton = value;
                }
            },
            /**
             * Input manager name for the 'cancel' button.
             *
             * @instance
             * @public
             * @memberof UnityEngine.EventSystems.StandaloneInputModule
             * @function cancelButton
             * @type string
             */
            cancelButton: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#cancelButton#get", this ); }

                    return this._cancelButton;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#cancelButton#set", this ); }

                    this._cancelButton = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#init", this ); }

                this.lastMoveVector = new UnityEngine.Vector3();
                this.lastMousePosition = new UnityEngine.Vector3();
                this.mousePosition = new UnityEngine.Vector3();
                this.consecutiveMoveCount = 0;
                this._horizontalAxis = "Horizontal";
                this._verticalAxis = "Vertical";
                this._submitButton = "Submit";
                this._cancelButton = "Cancel";
                this._inputActionsPerSecond = 10;
                this._repeatDelay = 0.5;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#ctor", this ); }

                this.$initialize();
                UnityEngine.EventSystems.PointerInputModule.ctor.call(this);
            }
        },
        methods: {
            /*UnityEngine.EventSystems.StandaloneInputModule.ShouldIgnoreEventsOnNoFocus start.*/
            ShouldIgnoreEventsOnNoFocus: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#ShouldIgnoreEventsOnNoFocus", this ); }

                // Unity set this property based on OS type.
                // Because we always want to ignore event on no focus - we just set it to true;
                return true;
            },
            /*UnityEngine.EventSystems.StandaloneInputModule.ShouldIgnoreEventsOnNoFocus end.*/

            /*UnityEngine.EventSystems.StandaloneInputModule.UpdateModule start.*/
            UpdateModule: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#UpdateModule", this ); }

                if (!this.eventSystem.isFocused && this.ShouldIgnoreEventsOnNoFocus()) {
                    if (this.inputPointerEvent != null && UnityEngine.GameObject.op_Inequality(this.inputPointerEvent.pointerDrag, null) && this.inputPointerEvent.dragging) {
                        this.ReleaseMouse(this.inputPointerEvent, this.inputPointerEvent.pointerCurrentRaycast.gameObject);
                    }

                    this.inputPointerEvent = null;

                    return;
                }

                this.lastMousePosition = this.mousePosition.$clone();
                this.mousePosition = this.input.mousePosition.$clone();
            },
            /*UnityEngine.EventSystems.StandaloneInputModule.UpdateModule end.*/

            /*UnityEngine.EventSystems.StandaloneInputModule.ReleaseMouse start.*/
            ReleaseMouse: function (pointerEvent, currentOverGo) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#ReleaseMouse", this ); }

                UnityEngine.EventSystems.ExecuteEvents.Execute(UnityEngine.EventSystems.IPointerUpHandler, pointerEvent.pointerPress, pointerEvent, UnityEngine.EventSystems.ExecuteEvents.pointerUpHandler);

                var pointerUpHandler = UnityEngine.EventSystems.ExecuteEvents.GetEventHandler(UnityEngine.EventSystems.IPointerClickHandler, currentOverGo);

                // PointerClick and Drop events
                if (UnityEngine.GameObject.op_Equality(pointerEvent.pointerPress, pointerUpHandler) && pointerEvent.eligibleForClick) {
                    UnityEngine.EventSystems.ExecuteEvents.Execute(UnityEngine.EventSystems.IPointerClickHandler, pointerEvent.pointerPress, pointerEvent, UnityEngine.EventSystems.ExecuteEvents.pointerClickHandler);
                } else if (UnityEngine.GameObject.op_Inequality(pointerEvent.pointerDrag, null) && pointerEvent.dragging) {
                    UnityEngine.EventSystems.ExecuteEvents.ExecuteHierarchy(UnityEngine.EventSystems.IDropHandler, currentOverGo, pointerEvent, UnityEngine.EventSystems.ExecuteEvents.dropHandler);
                }

                pointerEvent.eligibleForClick = false;
                pointerEvent.pointerPress = null;
                pointerEvent.rawPointerPress = null;

                if (UnityEngine.GameObject.op_Inequality(pointerEvent.pointerDrag, null) && pointerEvent.dragging) {
                    UnityEngine.EventSystems.ExecuteEvents.Execute(UnityEngine.EventSystems.IEndDragHandler, pointerEvent.pointerDrag, pointerEvent, UnityEngine.EventSystems.ExecuteEvents.endDragHandler);
                }

                pointerEvent.dragging = false;
                pointerEvent.pointerDrag = null;

                // redo pointer enter / exit to refresh state
                // so that if we moused over something that ignored it before
                // due to having pressed on something else
                // it now gets it.
                if (UnityEngine.GameObject.op_Inequality(currentOverGo, pointerEvent.pointerEnter)) {
                    this.HandlePointerExitAndEnter(pointerEvent, null);
                    this.HandlePointerExitAndEnter(pointerEvent, currentOverGo);
                }

                this.inputPointerEvent = pointerEvent;
            },
            /*UnityEngine.EventSystems.StandaloneInputModule.ReleaseMouse end.*/

            /*UnityEngine.EventSystems.StandaloneInputModule.IsModuleSupported start.*/
            IsModuleSupported: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#IsModuleSupported", this ); }

                return this._forceModuleActive || this.input.mousePresent || this.input.touchSupported;
            },
            /*UnityEngine.EventSystems.StandaloneInputModule.IsModuleSupported end.*/

            /*UnityEngine.EventSystems.StandaloneInputModule.ShouldActivateModule start.*/
            ShouldActivateModule: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#ShouldActivateModule", this ); }

                if (!UnityEngine.EventSystems.PointerInputModule.prototype.ShouldActivateModule.call(this)) {
                    return false;
                }

                var shouldActivate = this._forceModuleActive;
                shouldActivate = !!(shouldActivate | this.input.GetButtonDown(this._submitButton));
                shouldActivate = !!(shouldActivate | this.input.GetButtonDown(this._cancelButton));
                shouldActivate = !!(shouldActivate | !UnityEngine.Mathf.Approximately(this.input.GetAxisRaw(this._horizontalAxis), 0.0));
                shouldActivate = !!(shouldActivate | !UnityEngine.Mathf.Approximately(this.input.GetAxisRaw(this._verticalAxis), 0.0));
                shouldActivate = !!(shouldActivate | (this.mousePosition.$clone().sub( this.lastMousePosition )).lengthSq() > 0.0);
                shouldActivate = !!(shouldActivate | this.input.GetMouseButtonDown(0));

                if (this.input.touchCount > 0) {
                    shouldActivate = true;
                }

                return shouldActivate;
            },
            /*UnityEngine.EventSystems.StandaloneInputModule.ShouldActivateModule end.*/

            /*UnityEngine.EventSystems.StandaloneInputModule.ActivateModule start.*/
            /**
             * See BaseInputModule.
             *
             * @instance
             * @public
             * @override
             * @this UnityEngine.EventSystems.StandaloneInputModule
             * @memberof UnityEngine.EventSystems.StandaloneInputModule
             * @return  {void}
             */
            ActivateModule: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#ActivateModule", this ); }

                if (!this.eventSystem.isFocused && this.ShouldIgnoreEventsOnNoFocus()) {
                    return;
                }

                UnityEngine.EventSystems.PointerInputModule.prototype.ActivateModule.call(this);
                this.mousePosition = this.input.mousePosition.$clone();
                this.lastMousePosition = this.input.mousePosition.$clone();

                var toSelect = this.eventSystem.currentSelectedGameObject;
                if (UnityEngine.GameObject.op_Equality(toSelect, null)) {
                    toSelect = this.eventSystem.firstSelectedGameObject;
                }

                this.eventSystem.SetSelectedGameObject$1(toSelect, this.GetBaseEventData());
            },
            /*UnityEngine.EventSystems.StandaloneInputModule.ActivateModule end.*/

            /*UnityEngine.EventSystems.StandaloneInputModule.DeactivateModule start.*/
            /**
             * See BaseInputModule.
             *
             * @instance
             * @public
             * @override
             * @this UnityEngine.EventSystems.StandaloneInputModule
             * @memberof UnityEngine.EventSystems.StandaloneInputModule
             * @return  {void}
             */
            DeactivateModule: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#DeactivateModule", this ); }

                UnityEngine.EventSystems.PointerInputModule.prototype.DeactivateModule.call(this);
                this.ClearSelection();
            },
            /*UnityEngine.EventSystems.StandaloneInputModule.DeactivateModule end.*/

            /*UnityEngine.EventSystems.StandaloneInputModule.Process start.*/
            Process: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#Process", this ); }

                if (!this.eventSystem.isFocused && this.ShouldIgnoreEventsOnNoFocus()) {
                    return;
                }

                var usedEvent = this.SendUpdateEventToSelectedObject();

                // case 1004066 - touch / mouse events should be processed before navigation events in case
                // they change the current selected gameobject and the submit button is a touch / mouse button.

                // touch needs to take precedence because of the mouse emulation layer
                if (!this.ProcessTouchEvents() && this.input.mousePresent) {
                    this.ProcessMouseEvent();
                }

                if (this.eventSystem.sendNavigationEvents) {
                    if (!usedEvent) {
                        usedEvent = !!(usedEvent | this.SendMoveEventToSelectedObject());
                    }

                    if (!usedEvent) {
                        this.SendSubmitEventToSelectedObject();
                    }
                }
            },
            /*UnityEngine.EventSystems.StandaloneInputModule.Process end.*/

            /*UnityEngine.EventSystems.StandaloneInputModule.ProcessTouchEvents start.*/
            ProcessTouchEvents: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#ProcessTouchEvents", this ); }

                for (var i = 0; i < this.input.touchCount; ++i) {
                    var touch = this.input.GetTouch(i);

                    if (touch.type === UnityEngine.TouchType.Indirect) {
                        continue;
                    }

                    var released = { };
                    var pressed = { };
                    var pointer = this.GetTouchPointerEventData(touch.$clone(), pressed, released);

                    this.ProcessTouchPress(pointer, pressed.v, released.v);

                    if (!released.v) {
                        this.ProcessMove(pointer);
                        this.ProcessDrag(pointer);
                    } else {
                        this.RemovePointerData(pointer);
                    }
                }

                return this.input.touchCount > 0;
            },
            /*UnityEngine.EventSystems.StandaloneInputModule.ProcessTouchEvents end.*/

            /*UnityEngine.EventSystems.StandaloneInputModule.ProcessTouchPress start.*/
            /**
             * This method is called by Unity whenever a touch event is processed. Override this method with a custom implementation to process touch events yourself.
             *
             * @instance
             * @protected
             * @this UnityEngine.EventSystems.StandaloneInputModule
             * @memberof UnityEngine.EventSystems.StandaloneInputModule
             * @param   {UnityEngine.EventSystems.PointerEventData}    pointerEvent    Event data relating to the touch event, such as position and ID to be passed to the touch event destination object.
             * @param   {boolean}                                      pressed         This is true for the first frame of a touch event, and false thereafter. This can therefore be used to determine the instant a touch event occurred.
             * @param   {boolean}                                      released        This is true only for the last frame of a touch event.
             * @return  {void}
             */
            ProcessTouchPress: function (pointerEvent, pressed, released) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#ProcessTouchPress", this ); }

                var currentOverGo = pointerEvent.pointerCurrentRaycast.gameObject;

                // PointerDown notification
                if (pressed) {
                    pointerEvent.eligibleForClick = true;
                    pointerEvent.delta.copy( pc.Vec2.ZERO.clone() );
                    pointerEvent.dragging = false;
                    pointerEvent.useDragThreshold = true;
                    pointerEvent.pressPosition.copy( pointerEvent.position );
                    pointerEvent.pointerPressRaycast.SetFrom(pointerEvent.pointerCurrentRaycast.$clone());

                    this.DeselectIfSelectionChanged(currentOverGo, pointerEvent);

                    if (UnityEngine.GameObject.op_Inequality(pointerEvent.pointerEnter, currentOverGo)) {
                        // send a pointer enter to the touched element if it isn't the one to select...
                        this.HandlePointerExitAndEnter(pointerEvent, currentOverGo);
                        pointerEvent.pointerEnter = currentOverGo;
                    }

                    // search for the control that will receive the press
                    // if we can't find a press handler set the press
                    // handler to be what would receive a click.
                    var newPressed = UnityEngine.EventSystems.ExecuteEvents.ExecuteHierarchy(UnityEngine.EventSystems.IPointerDownHandler, currentOverGo, pointerEvent, UnityEngine.EventSystems.ExecuteEvents.pointerDownHandler);

                    // didnt find a press handler... search for a click handler
                    if (UnityEngine.GameObject.op_Equality(newPressed, null)) {
                        newPressed = UnityEngine.EventSystems.ExecuteEvents.GetEventHandler(UnityEngine.EventSystems.IPointerClickHandler, currentOverGo);
                    }

                    // Debug.Log("Pressed: " + newPressed);

                    var time = UnityEngine.Time.unscaledTime;

                    if (UnityEngine.GameObject.op_Equality(newPressed, pointerEvent.lastPress)) {
                        var diffTime = time - pointerEvent.clickTime;
                        if (diffTime < 0.3) {
                            ++pointerEvent.clickCount;
                        } else {
                            pointerEvent.clickCount = 1;
                        }

                        pointerEvent.clickTime = time;
                    } else {
                        pointerEvent.clickCount = 1;
                    }

                    pointerEvent.pointerPress = newPressed;
                    pointerEvent.rawPointerPress = currentOverGo;

                    pointerEvent.clickTime = time;

                    // Save the drag handler as well
                    pointerEvent.pointerDrag = UnityEngine.EventSystems.ExecuteEvents.GetEventHandler(UnityEngine.EventSystems.IDragHandler, currentOverGo);

                    if (UnityEngine.GameObject.op_Inequality(pointerEvent.pointerDrag, null)) {
                        UnityEngine.EventSystems.ExecuteEvents.Execute(UnityEngine.EventSystems.IInitializePotentialDragHandler, pointerEvent.pointerDrag, pointerEvent, UnityEngine.EventSystems.ExecuteEvents.initializePotentialDrag);
                    }

                    this.inputPointerEvent = pointerEvent;
                }

                // PointerUp notification
                if (released) {
                    // Debug.Log("Executing pressup on: " + pointer.pointerPress);
                    UnityEngine.EventSystems.ExecuteEvents.Execute(UnityEngine.EventSystems.IPointerUpHandler, pointerEvent.pointerPress, pointerEvent, UnityEngine.EventSystems.ExecuteEvents.pointerUpHandler);

                    // Debug.Log("KeyCode: " + pointer.eventData.keyCode);

                    // see if we mouse up on the same element that we clicked on...
                    var pointerUpHandler = UnityEngine.EventSystems.ExecuteEvents.GetEventHandler(UnityEngine.EventSystems.IPointerClickHandler, currentOverGo);

                    // PointerClick and Drop events
                    if (UnityEngine.GameObject.op_Equality(pointerEvent.pointerPress, pointerUpHandler) && pointerEvent.eligibleForClick) {
                        UnityEngine.EventSystems.ExecuteEvents.Execute(UnityEngine.EventSystems.IPointerClickHandler, pointerEvent.pointerPress, pointerEvent, UnityEngine.EventSystems.ExecuteEvents.pointerClickHandler);
                    } else if (UnityEngine.GameObject.op_Inequality(pointerEvent.pointerDrag, null) && pointerEvent.dragging) {
                        UnityEngine.EventSystems.ExecuteEvents.ExecuteHierarchy(UnityEngine.EventSystems.IDropHandler, currentOverGo, pointerEvent, UnityEngine.EventSystems.ExecuteEvents.dropHandler);
                    }

                    pointerEvent.eligibleForClick = false;
                    pointerEvent.pointerPress = null;
                    pointerEvent.rawPointerPress = null;

                    if (UnityEngine.GameObject.op_Inequality(pointerEvent.pointerDrag, null) && pointerEvent.dragging) {
                        UnityEngine.EventSystems.ExecuteEvents.Execute(UnityEngine.EventSystems.IEndDragHandler, pointerEvent.pointerDrag, pointerEvent, UnityEngine.EventSystems.ExecuteEvents.endDragHandler);
                    }

                    pointerEvent.dragging = false;
                    pointerEvent.pointerDrag = null;

                    // send exit events as we need to simulate this on touch up on touch device
                    UnityEngine.EventSystems.ExecuteEvents.ExecuteHierarchy(UnityEngine.EventSystems.IPointerExitHandler, pointerEvent.pointerEnter, pointerEvent, UnityEngine.EventSystems.ExecuteEvents.pointerExitHandler);
                    pointerEvent.pointerEnter = null;

                    this.inputPointerEvent = pointerEvent;
                }
            },
            /*UnityEngine.EventSystems.StandaloneInputModule.ProcessTouchPress end.*/

            /*UnityEngine.EventSystems.StandaloneInputModule.SendSubmitEventToSelectedObject start.*/
            /**
             * Calculate and send a submit event to the current selected object.
             *
             * @instance
             * @protected
             * @this UnityEngine.EventSystems.StandaloneInputModule
             * @memberof UnityEngine.EventSystems.StandaloneInputModule
             * @return  {boolean}        If the submit event was used by the selected object.
             */
            SendSubmitEventToSelectedObject: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#SendSubmitEventToSelectedObject", this ); }

                if (UnityEngine.GameObject.op_Equality(this.eventSystem.currentSelectedGameObject, null)) {
                    return false;
                }

                var data = this.GetBaseEventData();
                if (this.input.GetButtonDown(this._submitButton)) {
                    UnityEngine.EventSystems.ExecuteEvents.Execute(UnityEngine.EventSystems.ISubmitHandler, this.eventSystem.currentSelectedGameObject, data, UnityEngine.EventSystems.ExecuteEvents.submitHandler);
                }

                if (this.input.GetButtonDown(this._cancelButton)) {
                    UnityEngine.EventSystems.ExecuteEvents.Execute(UnityEngine.EventSystems.ICancelHandler, this.eventSystem.currentSelectedGameObject, data, UnityEngine.EventSystems.ExecuteEvents.cancelHandler);
                }

                return data.used;
            },
            /*UnityEngine.EventSystems.StandaloneInputModule.SendSubmitEventToSelectedObject end.*/

            /*UnityEngine.EventSystems.StandaloneInputModule.GetRawMoveVector start.*/
            GetRawMoveVector: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#GetRawMoveVector", this ); }

                var move = pc.Vec2.ZERO.clone();
                move.x = this.input.GetAxisRaw(this._horizontalAxis);
                move.y = this.input.GetAxisRaw(this._verticalAxis);

                if (this.input.GetButtonDown(this._horizontalAxis)) {
                    if (move.x < 0) {
                        move.x = -1.0;
                    }

                    if (move.x > 0) {
                        move.x = 1.0;
                    }
                }

                if (this.input.GetButtonDown(this._verticalAxis)) {
                    if (move.y < 0) {
                        move.y = -1.0;
                    }

                    if (move.y > 0) {
                        move.y = 1.0;
                    }
                }

                return move.$clone();
            },
            /*UnityEngine.EventSystems.StandaloneInputModule.GetRawMoveVector end.*/

            /*UnityEngine.EventSystems.StandaloneInputModule.SendMoveEventToSelectedObject start.*/
            /**
             * Calculate and send a move event to the current selected object.
             *
             * @instance
             * @protected
             * @this UnityEngine.EventSystems.StandaloneInputModule
             * @memberof UnityEngine.EventSystems.StandaloneInputModule
             * @return  {boolean}        If the move event was used by the selected object.
             */
            SendMoveEventToSelectedObject: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#SendMoveEventToSelectedObject", this ); }

                var time = UnityEngine.Time.unscaledTime;

                var movement = this.GetRawMoveVector();
                if (UnityEngine.Mathf.Approximately(movement.x, 0.0) && UnityEngine.Mathf.Approximately(movement.y, 0.0)) {
                    this.consecutiveMoveCount = 0;
                    return false;
                }

                var similarDir = movement.dot( UnityEngine.Vector2.FromVector3(this.lastMoveVector) ) > 0;

                // If direction didn't change at least 90 degrees, wait for delay before allowing consequtive event.
                if (similarDir && this.consecutiveMoveCount === 1) {
                    if (time <= this.prevActionTime + this._repeatDelay) {
                        return false;
                    }
                } else {
                    if (time <= this.prevActionTime + 1.0 / this._inputActionsPerSecond) {
                        return false;
                    }
                }

                var axisEventData = this.GetAxisEventData(movement.x, movement.y, 0.6);

                if (axisEventData.moveDir !== UnityEngine.EventSystems.MoveDirection.None) {
                    UnityEngine.EventSystems.ExecuteEvents.Execute(UnityEngine.EventSystems.IMoveHandler, this.eventSystem.currentSelectedGameObject, axisEventData, UnityEngine.EventSystems.ExecuteEvents.moveHandler);
                    if (!similarDir) {
                        this.consecutiveMoveCount = 0;
                    }

                    this.consecutiveMoveCount++;
                    this.prevActionTime = time;
                    this.lastMoveVector = UnityEngine.Vector3.FromVector2(movement.$clone());
                } else {
                    this.consecutiveMoveCount = 0;
                }

                return axisEventData.used;
            },
            /*UnityEngine.EventSystems.StandaloneInputModule.SendMoveEventToSelectedObject end.*/

            /*UnityEngine.EventSystems.StandaloneInputModule.ProcessMouseEvent start.*/
            ProcessMouseEvent: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#ProcessMouseEvent", this ); }

                this.ProcessMouseEvent$1(0);
            },
            /*UnityEngine.EventSystems.StandaloneInputModule.ProcessMouseEvent end.*/

            /*UnityEngine.EventSystems.StandaloneInputModule.ProcessMouseEvent$1 start.*/
            /**
             * Process all mouse events.
             *
             * @instance
             * @protected
             * @this UnityEngine.EventSystems.StandaloneInputModule
             * @memberof UnityEngine.EventSystems.StandaloneInputModule
             * @param   {number}    id
             * @return  {void}
             */
            ProcessMouseEvent$1: function (id) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#ProcessMouseEvent$1", this ); }

                var mouseData = this.GetMousePointerEventData$1(id);
                var leftButtonData = mouseData.GetButtonState(UnityEngine.EventSystems.PointerEventData.InputButton.Left).eventData;

                this.currentFocusedGameObject = leftButtonData.buttonData.pointerCurrentRaycast.gameObject;

                // Process the first mouse button fully
                this.ProcessMousePress(leftButtonData);
                this.ProcessMove(leftButtonData.buttonData);
                this.ProcessDrag(leftButtonData.buttonData);

                // Now process right / middle clicks
                this.ProcessMousePress(mouseData.GetButtonState(UnityEngine.EventSystems.PointerEventData.InputButton.Right).eventData);
                this.ProcessDrag(mouseData.GetButtonState(UnityEngine.EventSystems.PointerEventData.InputButton.Right).eventData.buttonData);
                this.ProcessMousePress(mouseData.GetButtonState(UnityEngine.EventSystems.PointerEventData.InputButton.Middle).eventData);
                this.ProcessDrag(mouseData.GetButtonState(UnityEngine.EventSystems.PointerEventData.InputButton.Middle).eventData.buttonData);

                if (!UnityEngine.Mathf.Approximately(leftButtonData.buttonData.scrollDelta.lengthSq(), 0.0)) {
                    var scrollHandler = UnityEngine.EventSystems.ExecuteEvents.GetEventHandler(UnityEngine.EventSystems.IScrollHandler, leftButtonData.buttonData.pointerCurrentRaycast.gameObject);
                    UnityEngine.EventSystems.ExecuteEvents.ExecuteHierarchy(UnityEngine.EventSystems.IScrollHandler, scrollHandler, leftButtonData.buttonData, UnityEngine.EventSystems.ExecuteEvents.scrollHandler);
                }
            },
            /*UnityEngine.EventSystems.StandaloneInputModule.ProcessMouseEvent$1 end.*/

            /*UnityEngine.EventSystems.StandaloneInputModule.ForceAutoSelect start.*/
            ForceAutoSelect: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#ForceAutoSelect", this ); }

                return false;
            },
            /*UnityEngine.EventSystems.StandaloneInputModule.ForceAutoSelect end.*/

            /*UnityEngine.EventSystems.StandaloneInputModule.SendUpdateEventToSelectedObject start.*/
            SendUpdateEventToSelectedObject: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#SendUpdateEventToSelectedObject", this ); }

                if (UnityEngine.GameObject.op_Equality(this.eventSystem.currentSelectedGameObject, null)) {
                    return false;
                }

                var data = this.GetBaseEventData();
                UnityEngine.EventSystems.ExecuteEvents.Execute(UnityEngine.EventSystems.IUpdateSelectedHandler, this.eventSystem.currentSelectedGameObject, data, UnityEngine.EventSystems.ExecuteEvents.updateSelectedHandler);
                return data.used;
            },
            /*UnityEngine.EventSystems.StandaloneInputModule.SendUpdateEventToSelectedObject end.*/

            /*UnityEngine.EventSystems.StandaloneInputModule.ProcessMousePress start.*/
            /**
             * Calculate and process any mouse button state changes.
             *
             * @instance
             * @protected
             * @this UnityEngine.EventSystems.StandaloneInputModule
             * @memberof UnityEngine.EventSystems.StandaloneInputModule
             * @param   {UnityEngine.EventSystems.PointerInputModule.MouseButtonEventData}    data
             * @return  {void}
             */
            ProcessMousePress: function (data) {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#ProcessMousePress", this ); }

                var pointerEvent = data.buttonData;
                var currentOverGo = pointerEvent.pointerCurrentRaycast.gameObject;

                // PointerDown notification
                if (data.PressedThisFrame()) {
                    pointerEvent.eligibleForClick = true;
                    pointerEvent.delta = pc.Vec2.ZERO.clone();
                    pointerEvent.dragging = false;
                    pointerEvent.useDragThreshold = true;
                    pointerEvent.pressPosition = pointerEvent.position.$clone();
                    pointerEvent.pointerPressRaycast = pointerEvent.pointerCurrentRaycast.$clone();

                    this.DeselectIfSelectionChanged(currentOverGo, pointerEvent);

                    // search for the control that will receive the press
                    // if we can't find a press handler set the press
                    // handler to be what would receive a click.
                    var newPressed = UnityEngine.EventSystems.ExecuteEvents.ExecuteHierarchy(UnityEngine.EventSystems.IPointerDownHandler, currentOverGo, pointerEvent, UnityEngine.EventSystems.ExecuteEvents.pointerDownHandler);

                    // didnt find a press handler... search for a click handler
                    if (UnityEngine.GameObject.op_Equality(newPressed, null)) {
                        newPressed = UnityEngine.EventSystems.ExecuteEvents.GetEventHandler(UnityEngine.EventSystems.IPointerClickHandler, currentOverGo);
                    }

                    // Debug.Log("Pressed: " + newPressed);

                    var time = UnityEngine.Time.unscaledTime;

                    if (UnityEngine.GameObject.op_Equality(newPressed, pointerEvent.lastPress)) {
                        var diffTime = time - pointerEvent.clickTime;
                        if (diffTime < 0.3) {
                            ++pointerEvent.clickCount;
                        } else {
                            pointerEvent.clickCount = 1;
                        }

                        pointerEvent.clickTime = time;
                    } else {
                        pointerEvent.clickCount = 1;
                    }

                    pointerEvent.pointerPress = newPressed;
                    pointerEvent.rawPointerPress = currentOverGo;

                    pointerEvent.clickTime = time;

                    // Save the drag handler as well
                    pointerEvent.pointerDrag = UnityEngine.EventSystems.ExecuteEvents.GetEventHandler(UnityEngine.EventSystems.IDragHandler, currentOverGo);

                    if (UnityEngine.GameObject.op_Inequality(pointerEvent.pointerDrag, null)) {
                        UnityEngine.EventSystems.ExecuteEvents.Execute(UnityEngine.EventSystems.IInitializePotentialDragHandler, pointerEvent.pointerDrag, pointerEvent, UnityEngine.EventSystems.ExecuteEvents.initializePotentialDrag);
                    }

                    this.inputPointerEvent = pointerEvent;
                }

                // PointerUp notification
                if (data.ReleasedThisFrame()) {
                    this.ReleaseMouse(pointerEvent, currentOverGo);
                }
            },
            /*UnityEngine.EventSystems.StandaloneInputModule.ProcessMousePress end.*/

            /*UnityEngine.EventSystems.StandaloneInputModule.GetCurrentFocusedGameObject start.*/
            GetCurrentFocusedGameObject: function () {
if ( TRACE ) { TRACE( "UnityEngine.EventSystems.StandaloneInputModule#GetCurrentFocusedGameObject", this ); }

                return this.currentFocusedGameObject;
            },
            /*UnityEngine.EventSystems.StandaloneInputModule.GetCurrentFocusedGameObject end.*/


        },
        overloads: {
            "ProcessMouseEvent(int)": "ProcessMouseEvent$1"
        }
    });
    /*UnityEngine.EventSystems.StandaloneInputModule end.*/

    /*UnityEngine.UI.Button start.*/
    Bridge.define("UnityEngine.UI.Button", {
        inherits: [UnityEngine.UI.Selectable,UnityEngine.EventSystems.IPointerClickHandler,UnityEngine.EventSystems.ISubmitHandler],
        fields: {
            /**
             * Button OnClick event
             *
             * @instance
             * @protected
             * @memberof UnityEngine.UI.Button
             * @type UnityEngine.UI.Button.ButtonClickedEvent
             */
            m_OnClick: null
        },
        props: {
            /**
             * Gets or sets the on click.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Button
             * @function onClick
             * @type UnityEngine.UI.Button.ButtonClickedEvent
             */
            onClick: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Button#onClick#get", this ); }

                    return this.m_OnClick;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Button#onClick#set", this ); }

                    this.m_OnClick = value;
                }
            }
        },
        alias: [
            "OnPointerClick", "UnityEngine$EventSystems$IPointerClickHandler$OnPointerClick",
            "OnSubmit", "UnityEngine$EventSystems$ISubmitHandler$OnSubmit"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Button#init", this ); }

                this.m_OnClick = new UnityEngine.UI.Button.ButtonClickedEvent();
            },
            /**
             * Initializes a new instance of the {@link } class.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Button
             * @memberof UnityEngine.UI.Button
             * @param   {pc.ElementComponent}    handle    Handle.
             * @return  {void}
             */
            $ctor1: function (handle) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Button#$ctor1", this ); }

                this.$initialize();
                UnityEngine.UI.Selectable.$ctor1.call(this, handle);
            },
            /**
             * Initializes a new instance of the {@link } class.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Button
             * @memberof UnityEngine.UI.Button
             * @return  {void}
             */
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Button#ctor", this ); }

                this.$initialize();
                UnityEngine.UI.Selectable.ctor.call(this);
            }
        },
        methods: {
            /*UnityEngine.UI.Button.OnPointerClick start.*/
            /**
             * On pointer click callback handle.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Button
             * @memberof UnityEngine.UI.Button
             * @param   {UnityEngine.EventSystems.PointerEventData}    eventData    Event data.
             * @return  {void}
             */
            OnPointerClick: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Button#OnPointerClick", this ); }

                if (eventData.button !== UnityEngine.EventSystems.PointerEventData.InputButton.Left) {
                    return;
                }

                this.Press();
            },
            /*UnityEngine.UI.Button.OnPointerClick end.*/

            /*UnityEngine.UI.Button.OnSubmit start.*/
            OnSubmit: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Button#OnSubmit", this ); }

                this.Press();

                // if we get set disabled during the press
                // don't run the coroutine.
                if (!this.IsActive() || !this.IsInteractable()) {
                    return;
                }

                this.DoStateTransition(UnityEngine.UI.Selectable.SelectionState.Pressed, false);
                this.StartCoroutine$1(this.OnFinishSubmit());
            },
            /*UnityEngine.UI.Button.OnSubmit end.*/

            /*UnityEngine.UI.Button.Press start.*/
            Press: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Button#Press", this ); }

                if (!this.IsActive() || !this.IsInteractable()) {
                    return;
                }

                this.m_OnClick.Invoke();
            },
            /*UnityEngine.UI.Button.Press end.*/

            /*UnityEngine.UI.Button.OnFinishSubmit start.*/
            OnFinishSubmit: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Button#OnFinishSubmit", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    fadeTime,
                    elapsedTime,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    fadeTime = this.colors.fadeDuration;
                                        elapsedTime = 0.0;
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( elapsedTime < fadeTime ) {
                                            $step = 2;
                                            continue;
                                        } 
                                        $step = 4;
                                        continue;
                                }
                                case 2: {
                                    elapsedTime += UnityEngine.Time.unscaledDeltaTime;
                                        $enumerator.current = null;
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    
                                        $step = 1;
                                        continue;
                                }
                                case 4: {
                                    this.DoStateTransition(this.currentSelectionState, false);

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*UnityEngine.UI.Button.OnFinishSubmit end.*/

            /*UnityEngine.UI.Button.ConfigureForEntity start.*/
            /**
             * Configures for entity.
             *
             * @instance
             * @public
             * @override
             * @this UnityEngine.UI.Button
             * @memberof UnityEngine.UI.Button
             * @param   {pc.Entity}    entity    Entity.
             * @return  {void}
             */
            ConfigureForEntity: function (entity) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Button#ConfigureForEntity", this ); }

                UnityEngine.UI.Selectable.prototype.ConfigureForEntity.call(this, entity);
                entity.element["UnityEngine.UI.Button"] = this;
            },
            /*UnityEngine.UI.Button.ConfigureForEntity end.*/


        }
    });
    /*UnityEngine.UI.Button end.*/

    /*UnityEngine.UI.Dropdown start.*/
    /**
     * A standard dropdown that presents a list of options when clicked, of which one can be chosen.
     *
     * @public
     * @class UnityEngine.UI.Dropdown
     * @augments UnityEngine.UI.Selectable
     * @implements  UnityEngine.EventSystems.IPointerClickHandler
     * @implements  UnityEngine.EventSystems.ISubmitHandler
     * @implements  UnityEngine.EventSystems.ICancelHandler
     */
    Bridge.define("UnityEngine.UI.Dropdown", {
        inherits: [UnityEngine.UI.Selectable,UnityEngine.EventSystems.IPointerClickHandler,UnityEngine.EventSystems.ISubmitHandler,UnityEngine.EventSystems.ICancelHandler],
        statics: {
            fields: {
                s_NoOptionData: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#init", this ); }

                    this.s_NoOptionData = new UnityEngine.UI.Dropdown.OptionData.ctor();
                }
            },
            methods: {
                /*UnityEngine.UI.Dropdown.GetOrAddComponent:static start.*/
                GetOrAddComponent: function (T, go) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#GetOrAddComponent", this ); }

                    var comp = Bridge.rValue(go.GetComponent(T));
                    if (!Bridge.rValue(comp)) {
                        comp = Bridge.rValue(go.AddComponent(T));
                    }

                    return Bridge.rValue(comp);
                },
                /*UnityEngine.UI.Dropdown.GetOrAddComponent:static end.*/


            }
        },
        fields: {
            m_Template: null,
            m_CaptionText: null,
            m_CaptionImage: null,
            m_ItemText: null,
            m_ItemImage: null,
            m_Value: 0,
            m_Options: null,
            m_OnValueChanged: null,
            m_AlphaFadeSpeed: 0,
            m_Dropdown: null,
            m_Blocker: null,
            m_Items: null,
            m_AlphaTweenRunner: null,
            validTemplate: false
        },
        props: {
            /**
             * The Rect Transform of the template for the dropdown list.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Dropdown
             * @function template
             * @type UnityEngine.RectTransform
             */
            template: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#template#get", this ); }

                    return this.m_Template;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#template#set", this ); }

                    this.m_Template = value;
                    this.RefreshShownValue();
                }
            },
            /**
             * The Text component to hold the text of the currently selected option.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Dropdown
             * @function captionText
             * @type UnityEngine.UI.Text
             */
            captionText: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#captionText#get", this ); }

                    return this.m_CaptionText;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#captionText#set", this ); }

                    this.m_CaptionText = value;
                    this.RefreshShownValue();
                }
            },
            /**
             * The Image component to hold the image of the currently selected option.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Dropdown
             * @function captionImage
             * @type UnityEngine.UI.Image
             */
            captionImage: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#captionImage#get", this ); }

                    return this.m_CaptionImage;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#captionImage#set", this ); }

                    this.m_CaptionImage = value;
                    this.RefreshShownValue();
                }
            },
            /**
             * The Text component to hold the text of the item.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Dropdown
             * @function itemText
             * @type UnityEngine.UI.Text
             */
            itemText: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#itemText#get", this ); }

                    return this.m_ItemText;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#itemText#set", this ); }

                    this.m_ItemText = value;
                    this.RefreshShownValue();
                }
            },
            /**
             * The Image component to hold the image of the item
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Dropdown
             * @function itemImage
             * @type UnityEngine.UI.Image
             */
            itemImage: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#itemImage#get", this ); }

                    return this.m_ItemImage;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#itemImage#set", this ); }

                    this.m_ItemImage = value;
                    this.RefreshShownValue();
                }
            },
            
            options: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#options#get", this ); }

                    return this.m_Options.options;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#options#set", this ); }

                    this.m_Options.options = value;
                    this.RefreshShownValue();
                }
            },
            
            onValueChanged: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#onValueChanged#get", this ); }

                    return this.m_OnValueChanged;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#onValueChanged#set", this ); }

                    this.m_OnValueChanged = value;
                }
            },
            /**
             * The time interval at which a drop down will appear and disappear
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Dropdown
             * @function alphaFadeSpeed
             * @type number
             */
            alphaFadeSpeed: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#alphaFadeSpeed#get", this ); }

                    return this.m_AlphaFadeSpeed;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#alphaFadeSpeed#set", this ); }

                    this.m_AlphaFadeSpeed = value;
                }
            },
            
            value: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#value#get", this ); }

                    return this.m_Value;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#value#set", this ); }

                    this.Set(value);
                }
            }
        },
        alias: [
            "OnPointerClick", "UnityEngine$EventSystems$IPointerClickHandler$OnPointerClick",
            "OnSubmit", "UnityEngine$EventSystems$ISubmitHandler$OnSubmit",
            "OnCancel", "UnityEngine$EventSystems$ICancelHandler$OnCancel"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#init", this ); }

                this.m_Options = new UnityEngine.UI.Dropdown.OptionDataList();
                this.m_OnValueChanged = new UnityEngine.UI.Dropdown.DropdownEvent();
                this.m_AlphaFadeSpeed = 0.15;
                this.m_Items = new (System.Collections.Generic.List$1(UnityEngine.UI.Dropdown.DropdownItem)).ctor();
                this.validTemplate = false;
            },
            $ctor1: function (handle) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#$ctor1", this ); }

                this.$initialize();
                UnityEngine.UI.Selectable.$ctor1.call(this, handle);
            },
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#ctor", this ); }

                this.$initialize();
                UnityEngine.UI.Selectable.$ctor1.call(this, null);
            }
        },
        methods: {
            /*UnityEngine.UI.Dropdown.SetValueWithoutNotify start.*/
            /**
             * Set index number of the current selection in the Dropdown without invoking onValueChanged callback.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Dropdown
             * @memberof UnityEngine.UI.Dropdown
             * @param   {number}    input    The new index for the current selection.
             * @return  {void}
             */
            SetValueWithoutNotify: function (input) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#SetValueWithoutNotify", this ); }

                this.Set(input, false);
            },
            /*UnityEngine.UI.Dropdown.SetValueWithoutNotify end.*/

            /*UnityEngine.UI.Dropdown.Set start.*/
            Set: function (value, sendCallback) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#Set", this ); }

                if (sendCallback === void 0) { sendCallback = true; }
                if (UnityEngine.Application.isPlaying && (value === this.m_Value || this.options.Count === 0)) {
                    return;
                }

                this.m_Value = Math.max(0, Math.min(value, this.options.Count - 1));
                this.RefreshShownValue();

                if (sendCallback) {
                    // Notify all listeners
                    this.m_OnValueChanged.Invoke(this.m_Value);
                }
            },
            /*UnityEngine.UI.Dropdown.Set end.*/

            /*UnityEngine.UI.Dropdown.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#Awake", this ); }


                this.m_AlphaTweenRunner = new (UnityEngine.UI.CoroutineTween.TweenRunner$1(UnityEngine.UI.CoroutineTween.FloatTween))();
                this.m_AlphaTweenRunner.Init(this);

                if (UnityEngine.Object.op_Implicit(this.m_CaptionImage)) {
                    this.m_CaptionImage.enabled = this.m_CaptionImage.sprite != null;
                }

                if (UnityEngine.Object.op_Implicit(this.m_Template)) {
                    this.m_Template.gameObject.SetActive(false);
                }
            },
            /*UnityEngine.UI.Dropdown.Awake end.*/

            /*UnityEngine.UI.Dropdown.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#Start", this ); }

                UnityEngine.UI.Selectable.prototype.Start.call(this);

                this.RefreshShownValue();
            },
            /*UnityEngine.UI.Dropdown.Start end.*/

            /*UnityEngine.UI.Dropdown.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#OnDisable", this ); }

                //Destroy dropdown and blocker in case user deactivates the dropdown when they click an option (case 935649)
                this.ImmediateDestroyDropdownList();

                if (UnityEngine.GameObject.op_Inequality(this.m_Blocker, null)) {
                    this.DestroyBlocker(this.m_Blocker);
                }

                this.m_Blocker = null;

                UnityEngine.UI.Selectable.prototype.OnDisable.call(this);
            },
            /*UnityEngine.UI.Dropdown.OnDisable end.*/

            /*UnityEngine.UI.Dropdown.RefreshShownValue start.*/
            /**
             * Refreshes the text and image (if available) of the currently selected option.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Dropdown
             * @memberof UnityEngine.UI.Dropdown
             * @return  {void}
             */
            RefreshShownValue: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#RefreshShownValue", this ); }

                var data = UnityEngine.UI.Dropdown.s_NoOptionData;

                if (this.options.Count > 0) {
                    data = this.options.getItem(Math.max(0, Math.min(this.m_Value, this.options.Count - 1)));
                }

                if (UnityEngine.Object.op_Implicit(this.m_CaptionText)) {
                    if (data != null && data.text != null) {
                        this.m_CaptionText.text = data.text;
                    } else {
                        this.m_CaptionText.text = "";
                    }
                }

                if (UnityEngine.Object.op_Implicit(this.m_CaptionImage)) {
                    if (data != null) {
                        this.m_CaptionImage.sprite = data.image;
                    } else {
                        this.m_CaptionImage.sprite = null;
                    }

                    this.m_CaptionImage.enabled = this.m_CaptionImage.sprite != null;
                }
            },
            /*UnityEngine.UI.Dropdown.RefreshShownValue end.*/

            /*UnityEngine.UI.Dropdown.AddOptions$2 start.*/
            
            AddOptions$2: function (options) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#AddOptions$2", this ); }

                this.options.AddRange(options);
                this.RefreshShownValue();
            },
            /*UnityEngine.UI.Dropdown.AddOptions$2 end.*/

            /*UnityEngine.UI.Dropdown.AddOptions start.*/
            
            AddOptions: function (options) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#AddOptions", this ); }

                for (var i = 0; i < options.Count; i++) {
                    this.options.add(new UnityEngine.UI.Dropdown.OptionData.$ctor1(options.getItem(i)));
                }

                this.RefreshShownValue();
            },
            /*UnityEngine.UI.Dropdown.AddOptions end.*/

            /*UnityEngine.UI.Dropdown.AddOptions$1 start.*/
            
            AddOptions$1: function (options) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#AddOptions$1", this ); }

                for (var i = 0; i < options.Count; i++) {
                    this.options.add(new UnityEngine.UI.Dropdown.OptionData.$ctor3(options.getItem(i)));
                }

                this.RefreshShownValue();
            },
            /*UnityEngine.UI.Dropdown.AddOptions$1 end.*/

            /*UnityEngine.UI.Dropdown.ClearOptions start.*/
            /**
             * Clear the list of options in the Dropdown.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Dropdown
             * @memberof UnityEngine.UI.Dropdown
             * @return  {void}
             */
            ClearOptions: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#ClearOptions", this ); }

                this.options.clear();
                this.m_Value = 0;
                this.RefreshShownValue();
            },
            /*UnityEngine.UI.Dropdown.ClearOptions end.*/

            /*UnityEngine.UI.Dropdown.SetupTemplate start.*/
            SetupTemplate: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#SetupTemplate", this ); }

                this.validTemplate = false;

                if (!UnityEngine.Object.op_Implicit(this.m_Template)) {
                    UnityEngine.Debug.LogError$2("The dropdown template is not assigned. The template needs to be assigned and must have a child GameObject with a Toggle component serving as the item.", this);
                    return;
                }

                var templateGo = this.m_Template.gameObject;
                templateGo.SetActive(true);
                var itemToggle = this.m_Template.GetComponentInChildren(UnityEngine.UI.Toggle);

                this.validTemplate = true;
                if (!UnityEngine.Object.op_Implicit(itemToggle) || UnityEngine.Component.op_Equality(itemToggle.transform, this.template)) {
                    this.validTemplate = false;
                    UnityEngine.Debug.LogError$2("The dropdown template is not valid. The template must have a child GameObject with a Toggle component serving as the item.", this.template);
                } else if (!(Bridge.is(itemToggle.transform.parent, UnityEngine.RectTransform))) {
                    this.validTemplate = false;
                    UnityEngine.Debug.LogError$2("The dropdown template is not valid. The child GameObject with a Toggle component (the item) must have a RectTransform on its parent.", this.template);
                } else if (UnityEngine.MonoBehaviour.op_Inequality(this.itemText, null) && !this.itemText.transform.IsChildOf(itemToggle.transform)) {
                    this.validTemplate = false;
                    UnityEngine.Debug.LogError$2("The dropdown template is not valid. The Item Text must be on the item GameObject or children of it.", this.template);
                } else if (UnityEngine.MonoBehaviour.op_Inequality(this.itemImage, null) && !this.itemImage.transform.IsChildOf(itemToggle.transform)) {
                    this.validTemplate = false;
                    UnityEngine.Debug.LogError$2("The dropdown template is not valid. The Item Image must be on the item GameObject or children of it.", this.template);
                }

                if (!this.validTemplate) {
                    templateGo.SetActive(false);
                    return;
                }

                var item = itemToggle.gameObject.AddComponent(UnityEngine.UI.Dropdown.DropdownItem);
                item.text = this.m_ItemText;
                item.image = this.m_ItemImage;
                item.toggle = itemToggle;
                item.rectTransform = Bridge.cast(itemToggle.transform, UnityEngine.RectTransform);

                // Find the Canvas that this dropdown is a part of
                var parentCanvas = null;
                var parentTransform = this.m_Template.parent;
                while (UnityEngine.Component.op_Inequality(parentTransform, null)) {
                    parentCanvas = parentTransform.GetComponent(UnityEngine.Canvas);
                    if (UnityEngine.Component.op_Inequality(parentCanvas, null)) {
                        break;
                    }

                    parentTransform = parentTransform.parent;
                }

                var popupCanvas = UnityEngine.UI.Dropdown.GetOrAddComponent(UnityEngine.Canvas, templateGo);
                popupCanvas.overrideSorting = true;
                popupCanvas.sortingOrder = 30000;

                // If we have a parent canvas, apply the same raycasters as the parent for consistency.
                if (UnityEngine.Component.op_Inequality(parentCanvas, null)) {
                    var components = parentCanvas.GetComponents(UnityEngine.EventSystems.BaseRaycaster);
                    for (var i = 0; i < components.length; i++) {
                        var raycasterType = Bridge.getType(components[i]);
                        if (UnityEngine.Component.op_Equality(templateGo.GetComponent$1(raycasterType), null)) {
                            templateGo.AddComponent$1(raycasterType);
                        }
                    }
                } else {
                    UnityEngine.UI.Dropdown.GetOrAddComponent(UnityEngine.UI.GraphicRaycaster, templateGo);
                }

                UnityEngine.UI.Dropdown.GetOrAddComponent(UnityEngine.CanvasGroup, templateGo);
                templateGo.SetActive(false);

                this.validTemplate = true;
            },
            /*UnityEngine.UI.Dropdown.SetupTemplate end.*/

            /*UnityEngine.UI.Dropdown.OnPointerClick start.*/
            /**
             * Handling for when the dropdown is initially 'clicked'. Typically shows the dropdown
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Dropdown
             * @memberof UnityEngine.UI.Dropdown
             * @param   {UnityEngine.EventSystems.PointerEventData}    eventData    The asocciated event data.
             * @return  {void}
             */
            OnPointerClick: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#OnPointerClick", this ); }

                this.Show();
            },
            /*UnityEngine.UI.Dropdown.OnPointerClick end.*/

            /*UnityEngine.UI.Dropdown.OnSubmit start.*/
            /**
             * Handling for when the dropdown is selected and a submit event is processed. Typically shows the dropdown
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Dropdown
             * @memberof UnityEngine.UI.Dropdown
             * @param   {UnityEngine.EventSystems.BaseEventData}    eventData    The asocciated event data.
             * @return  {void}
             */
            OnSubmit: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#OnSubmit", this ); }

                this.Show();
            },
            /*UnityEngine.UI.Dropdown.OnSubmit end.*/

            /*UnityEngine.UI.Dropdown.OnCancel start.*/
            /**
             * This will hide the dropdown list.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Dropdown
             * @memberof UnityEngine.UI.Dropdown
             * @param   {UnityEngine.EventSystems.BaseEventData}    eventData    The asocciated event data.
             * @return  {void}
             */
            OnCancel: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#OnCancel", this ); }

                this.Hide();
            },
            /*UnityEngine.UI.Dropdown.OnCancel end.*/

            /*UnityEngine.UI.Dropdown.Show start.*/
            /**
             * Show the dropdown.
             Plan for dropdown scrolling to ensure dropdown is contained within screen.
             We assume the Canvas is the screen that the dropdown must be kept inside.
             This is always valid for screen space canvas modes.
             For world space canvases we don't know how it's used, but it could be e.g. for an in-game monitor.
             We consider it a fair constraint that the canvas must be big enough to contain dropdowns.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Dropdown
             * @memberof UnityEngine.UI.Dropdown
             * @return  {void}
             */
            Show: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#Show", this ); }

                if (!this.IsActive() || !this.IsInteractable() || UnityEngine.GameObject.op_Inequality(this.m_Dropdown, null)) {
                    return;
                }

                // Get root Canvas.
                var list = UnityEngine.UI.ListPool$1(UnityEngine.Canvas).Get();
                this.gameObject.GetComponentsInParent$1(UnityEngine.Canvas, false, list);
                if (list.Count === 0) {
                    return;
                }

                // case 1064466 rootCanvas should be last element returned by GetComponentsInParent()
                var rootCanvas = list.getItem(list.Count - 1);
                for (var i = 0; i < list.Count; i++) {
                    if (list.getItem(i).isRootCanvas) {
                        rootCanvas = list.getItem(i);
                        break;
                    }
                }

                UnityEngine.UI.ListPool$1(UnityEngine.Canvas).Release(list);

                if (!this.validTemplate) {
                    this.SetupTemplate();
                    if (!this.validTemplate) {
                        return;
                    }
                }

                this.m_Template.gameObject.SetActive(true);

                // popupCanvas used to assume the root canvas had the default sorting Layer, next line fixes (case 958281 - [UI] Dropdown list does not copy the parent canvas layer when the panel is opened)
                this.m_Template.GetComponent(UnityEngine.Canvas).sortingLayerID = rootCanvas.sortingLayerID;

                // Instantiate the drop-down template
                this.m_Dropdown = this.CreateDropdownList(this.m_Template.gameObject);
                this.m_Dropdown.name = "Dropdown List";
                this.m_Dropdown.SetActive(true);

                // Make drop-down RectTransform have same values as original.
                var dropdownRectTransform = Bridge.as(this.m_Dropdown.transform, UnityEngine.RectTransform);
                dropdownRectTransform.SetParent(this.m_Template.transform.parent, false);

                // Instantiate the drop-down list items

                // Find the dropdown item and disable it.
                var itemTemplate = this.m_Dropdown.GetComponentInChildren(UnityEngine.UI.Dropdown.DropdownItem);

                var content = itemTemplate.rectTransform.parent.gameObject;
                var contentRectTransform = Bridge.as(content.transform, UnityEngine.RectTransform);
                itemTemplate.rectTransform.gameObject.SetActive(true);

                // Get the rects of the dropdown and item
                var dropdownContentRect = contentRectTransform.rect.$clone();
                var itemTemplateRect = itemTemplate.rectTransform.rect.$clone();

                // Calculate the visual offset between the item's edges and the background's edges
                var offsetMin = itemTemplateRect.min.$clone().sub( dropdownContentRect.min ).add( UnityEngine.Vector2.FromVector3(itemTemplate.rectTransform.localPosition) );
                var offsetMax = itemTemplateRect.max.$clone().sub( dropdownContentRect.max ).add( UnityEngine.Vector2.FromVector3(itemTemplate.rectTransform.localPosition) );
                var itemSize = itemTemplateRect.size.$clone();

                this.m_Items.clear();

                var prev = null;
                for (var i1 = 0; i1 < this.options.Count; ++i1) {
                    var data = this.options.getItem(i1);
                    var item = { v : this.AddItem(data, this.value === i1, itemTemplate, this.m_Items) };
                    if (UnityEngine.MonoBehaviour.op_Equality(item.v, null)) {
                        continue;
                    }

                    // Automatically set up a toggle state change listener
                    item.v.toggle.isOn = this.value === i1;
                    item.v.toggle.onValueChanged.AddListener((function ($me, item) {
                        return Bridge.fn.bind($me, function (x) {
                            this.OnSelectItem(item.v.toggle);
                        });
                    })(this, item));

                    // Select current option
                    if (item.v.toggle.isOn) {
                        item.v.toggle.Select();
                    }

                    // Automatically set up explicit navigation
                    if (UnityEngine.MonoBehaviour.op_Inequality(prev, null)) {
                        var prevNav = prev.navigation.$clone();
                        var toggleNav = item.v.toggle.navigation.$clone();
                        prevNav.mode = UnityEngine.UI.Navigation.Mode.Explicit;
                        toggleNav.mode = UnityEngine.UI.Navigation.Mode.Explicit;

                        prevNav.selectOnDown = item.v.toggle;
                        prevNav.selectOnRight = item.v.toggle;
                        toggleNav.selectOnLeft = prev;
                        toggleNav.selectOnUp = prev;

                        prev.navigation = prevNav.$clone();
                        item.v.toggle.navigation = toggleNav.$clone();
                    }

                    prev = item.v.toggle;
                }

                // Reposition all items now that all of them have been added
                var sizeDelta = contentRectTransform.sizeDelta.$clone();
                sizeDelta.y = itemSize.y * this.m_Items.Count + offsetMin.y - offsetMax.y;
                contentRectTransform.sizeDelta = sizeDelta.$clone();

                var extraSpace = dropdownRectTransform.rect.height - contentRectTransform.rect.height;
                if (extraSpace > 0) {
                    dropdownRectTransform.sizeDelta = new pc.Vec2( dropdownRectTransform.sizeDelta.x, dropdownRectTransform.sizeDelta.y - extraSpace );
                }

                // Invert anchoring and position if dropdown is partially or fully outside of canvas rect.
                // Typically this will have the effect of placing the dropdown above the button instead of below,
                // but it works as inversion regardless of initial setup.
                var corners = System.Array.init(4, function (){
                    return new UnityEngine.Vector3();
                }, UnityEngine.Vector3);
                dropdownRectTransform.GetWorldCorners(corners);

                var rootCanvasRectTransform = Bridge.as(rootCanvas.transform, UnityEngine.RectTransform);
                var rootCanvasRect = rootCanvasRectTransform.rect.$clone();
                for (var axis = 0; axis < 2; axis++) {
                    var outside = false;
                    for (var i2 = 0; i2 < 4; i2++) {
                        var corner = rootCanvasRectTransform.InverseTransformPoint(corners[i2]);
                        if (corner.getitem(axis) < rootCanvasRect.min.getitem(axis) && !UnityEngine.Mathf.Approximately(corner.getitem(axis), rootCanvasRect.min.getitem(axis)) || corner.getitem(axis) > rootCanvasRect.max.getitem(axis) && !UnityEngine.Mathf.Approximately(corner.getitem(axis), rootCanvasRect.max.getitem(axis))) {
                            outside = true;
                            break;
                        }
                    }

                    if (outside) {
                        UnityEngine.RectTransformUtility.FlipLayoutOnAxis(dropdownRectTransform, axis, false, false);
                    }
                }

                for (var i3 = 0; i3 < this.m_Items.Count; i3++) {
                    var itemRect = this.m_Items.getItem(i3).rectTransform;
                    itemRect.anchorMin = new pc.Vec2( itemRect.anchorMin.x, 0 );
                    itemRect.anchorMax = new pc.Vec2( itemRect.anchorMax.x, 0 );
                    itemRect.anchoredPosition = new pc.Vec2( itemRect.anchoredPosition.x, offsetMin.y + itemSize.y * (this.m_Items.Count - 1 - i3) + itemSize.y * itemRect.pivot.y );
                    itemRect.sizeDelta = new pc.Vec2( itemRect.sizeDelta.x, itemSize.y );
                }

                // Fade in the popup
                this.AlphaFadeList$1(this.m_AlphaFadeSpeed, 0.0, 1.0);

                // Make drop-down template and item template inactive
                this.m_Template.gameObject.SetActive(false);
                itemTemplate.gameObject.SetActive(false);

                this.m_Blocker = this.CreateBlocker(rootCanvas);
            },
            /*UnityEngine.UI.Dropdown.Show end.*/

            /*UnityEngine.UI.Dropdown.CreateBlocker start.*/
            /**
             * Create a blocker that blocks clicks to other controls while the dropdown list is open.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.Dropdown
             * @memberof UnityEngine.UI.Dropdown
             * @param   {UnityEngine.Canvas}        rootCanvas    The root canvas the dropdown is under.
             * @return  {UnityEngine.GameObject}                  The created blocker object
             */
            CreateBlocker: function (rootCanvas) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#CreateBlocker", this ); }

                // Create blocker GameObject.
                var blocker = new UnityEngine.GameObject.$ctor2("Blocker");

                // Setup blocker RectTransform to cover entire root canvas area.
                var blockerRect = blocker.AddComponent(UnityEngine.RectTransform);
                blockerRect.SetParent(rootCanvas.transform, false);
                blockerRect.anchorMin = UnityEngine.Vector2.FromVector3(pc.Vec3.ZERO.clone());
                blockerRect.anchorMax = UnityEngine.Vector2.FromVector3(new pc.Vec3( 1, 1, 1 ));
                blockerRect.sizeDelta = pc.Vec2.ZERO.clone();

                // Make blocker be in separate canvas in same layer as dropdown and in layer just below it.
                var blockerCanvas = blocker.AddComponent(UnityEngine.Canvas);
                blockerCanvas.overrideSorting = true;
                var dropdownCanvas = this.m_Dropdown.GetComponent(UnityEngine.Canvas);
                blockerCanvas.sortingLayerID = dropdownCanvas.sortingLayerID;
                blockerCanvas.sortingOrder = dropdownCanvas.sortingOrder - 1;

                // Find the Canvas that this dropdown is a part of
                var parentCanvas = null;
                var parentTransform = this.m_Template.parent;
                while (UnityEngine.Component.op_Inequality(parentTransform, null)) {
                    parentCanvas = parentTransform.GetComponent(UnityEngine.Canvas);
                    if (UnityEngine.Component.op_Inequality(parentCanvas, null)) {
                        break;
                    }

                    parentTransform = parentTransform.parent;
                }

                // If we have a parent canvas, apply the same raycasters as the parent for consistency.
                if (UnityEngine.Component.op_Inequality(parentCanvas, null)) {
                    var components = parentCanvas.GetComponents(UnityEngine.EventSystems.BaseRaycaster);
                    for (var i = 0; i < components.length; i++) {
                        var raycasterType = Bridge.getType(components[i]);
                        if (UnityEngine.Component.op_Equality(blocker.GetComponent$1(raycasterType), null)) {
                            blocker.AddComponent$1(raycasterType);
                        }
                    }
                } else {
                    // Add raycaster since it's needed to block.
                    UnityEngine.UI.Dropdown.GetOrAddComponent(UnityEngine.UI.GraphicRaycaster, blocker);
                }


                // Add image since it's needed to block, but make it clear.
                var blockerImage = blocker.AddComponent(UnityEngine.UI.Image);
                blockerImage.color = new pc.Color( 0, 0, 0, 0 );

                // Add button since it's needed to block, and to close the dropdown when blocking area is clicked.
                var blockerButton = blocker.AddComponent(UnityEngine.UI.Button);
                blockerButton.onClick.AddListener(Bridge.fn.cacheBind(this, this.Hide));

                return blocker;
            },
            /*UnityEngine.UI.Dropdown.CreateBlocker end.*/

            /*UnityEngine.UI.Dropdown.DestroyBlocker start.*/
            /**
             * Convenience method to explicitly destroy the previously generated blocker object
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.Dropdown
             * @memberof UnityEngine.UI.Dropdown
             * @param   {UnityEngine.GameObject}    blocker    The blocker object to destroy.
             * @return  {void}
             */
            DestroyBlocker: function (blocker) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#DestroyBlocker", this ); }

                UnityEngine.MonoBehaviour.Destroy(blocker);
            },
            /*UnityEngine.UI.Dropdown.DestroyBlocker end.*/

            /*UnityEngine.UI.Dropdown.CreateDropdownList start.*/
            /**
             * Create the dropdown list to be shown when the dropdown is clicked. The dropdown list should correspond to the provided template GameObject, equivalent to instantiating a copy of it.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.Dropdown
             * @memberof UnityEngine.UI.Dropdown
             * @param   {UnityEngine.GameObject}    template    The template to create the dropdown list from.
             * @return  {UnityEngine.GameObject}                The created drop down list gameobject.
             */
            CreateDropdownList: function (template) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#CreateDropdownList", this ); }

                return UnityEngine.Object.Instantiate(UnityEngine.GameObject, template);
            },
            /*UnityEngine.UI.Dropdown.CreateDropdownList end.*/

            /*UnityEngine.UI.Dropdown.DestroyDropdownList start.*/
            /**
             * Convenience method to explicitly destroy the previously generated dropdown list
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.Dropdown
             * @memberof UnityEngine.UI.Dropdown
             * @param   {UnityEngine.GameObject}    dropdownList    The dropdown list GameObject to destroy
             * @return  {void}
             */
            DestroyDropdownList: function (dropdownList) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#DestroyDropdownList", this ); }

                UnityEngine.MonoBehaviour.Destroy(dropdownList);
            },
            /*UnityEngine.UI.Dropdown.DestroyDropdownList end.*/

            /*UnityEngine.UI.Dropdown.CreateItem start.*/
            /**
             * Create a dropdown item based upon the item template.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.Dropdown
             * @memberof UnityEngine.UI.Dropdown
             * @param   {UnityEngine.UI.Dropdown.DropdownItem}    itemTemplate    e template to create the option item from.
             * @return  {UnityEngine.UI.Dropdown.DropdownItem}                    The created dropdown item component
             */
            CreateItem: function (itemTemplate) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#CreateItem", this ); }

                return UnityEngine.Object.Instantiate(UnityEngine.UI.Dropdown.DropdownItem, itemTemplate);
            },
            /*UnityEngine.UI.Dropdown.CreateItem end.*/

            /*UnityEngine.UI.Dropdown.DestroyItem start.*/
            /**
             * Convenience method to explicitly destroy the previously generated Items.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.Dropdown
             * @memberof UnityEngine.UI.Dropdown
             * @param   {UnityEngine.UI.Dropdown.DropdownItem}    item    The Item to destroy.
             * @return  {void}
             */
            DestroyItem: function (item) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#DestroyItem", this ); }
 },
            /*UnityEngine.UI.Dropdown.DestroyItem end.*/

            /*UnityEngine.UI.Dropdown.AddItem start.*/
            AddItem: function (data, selected, itemTemplate, items) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#AddItem", this ); }

                // Add a new item to the dropdown.
                var item = this.CreateItem(itemTemplate);
                item.rectTransform.SetParent(itemTemplate.rectTransform.parent, false);

                item.gameObject.SetActive(true);
                item.gameObject.name = "Item " + items.Count + ((data.text != null ? ": " + (data.text || "") : "") || "");

                if (UnityEngine.MonoBehaviour.op_Inequality(item.toggle, null)) {
                    item.toggle.isOn = false;
                }

                // Set the item's data
                if (UnityEngine.Object.op_Implicit(item.text)) {
                    item.text.text = data.text;
                }

                if (UnityEngine.Object.op_Implicit(item.image)) {
                    item.image.sprite = data.image;
                    item.image.enabled = item.image.sprite != null;
                }

                items.add(item);
                return item;
            },
            /*UnityEngine.UI.Dropdown.AddItem end.*/

            /*UnityEngine.UI.Dropdown.AlphaFadeList start.*/
            AlphaFadeList: function (duration, alpha) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#AlphaFadeList", this ); }

                var group = this.m_Dropdown.GetComponent(UnityEngine.CanvasGroup);
                this.AlphaFadeList$1(duration, group.alpha, alpha);
            },
            /*UnityEngine.UI.Dropdown.AlphaFadeList end.*/

            /*UnityEngine.UI.Dropdown.AlphaFadeList$1 start.*/
            AlphaFadeList$1: function (duration, start, end) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#AlphaFadeList$1", this ); }

                var $t;
                if (end === start) {
                    return;
                }

                var tween = ($t = new UnityEngine.UI.CoroutineTween.FloatTween(), $t.duration = duration, $t.startValue = start, $t.targetValue = end, $t);
                tween.AddOnChangedCallback(Bridge.fn.cacheBind(this, this.SetAlpha));
                tween.ignoreTimeScale = true;
                this.m_AlphaTweenRunner.StartTween(tween.$clone());
            },
            /*UnityEngine.UI.Dropdown.AlphaFadeList$1 end.*/

            /*UnityEngine.UI.Dropdown.SetAlpha start.*/
            SetAlpha: function (alpha) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#SetAlpha", this ); }

                if (!UnityEngine.Object.op_Implicit(this.m_Dropdown)) {
                    return;
                }

                var group = this.m_Dropdown.GetComponent(UnityEngine.CanvasGroup);
                group.alpha = alpha;
            },
            /*UnityEngine.UI.Dropdown.SetAlpha end.*/

            /*UnityEngine.UI.Dropdown.Hide start.*/
            /**
             * Hide the dropdown list. I.e. close it.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Dropdown
             * @memberof UnityEngine.UI.Dropdown
             * @return  {void}
             */
            Hide: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#Hide", this ); }

                if (UnityEngine.GameObject.op_Inequality(this.m_Dropdown, null)) {
                    this.AlphaFadeList(this.m_AlphaFadeSpeed, 0.0);

                    // User could have disabled the dropdown during the OnValueChanged call.
                    if (this.IsActive()) {
                        this.StartCoroutine$1(this.DelayedDestroyDropdownList(this.m_AlphaFadeSpeed));
                    }
                }

                if (UnityEngine.GameObject.op_Inequality(this.m_Blocker, null)) {
                    this.DestroyBlocker(this.m_Blocker);
                }

                this.m_Blocker = null;
                this.Select();
            },
            /*UnityEngine.UI.Dropdown.Hide end.*/

            /*UnityEngine.UI.Dropdown.DelayedDestroyDropdownList start.*/
            DelayedDestroyDropdownList: function (delay) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#DelayedDestroyDropdownList", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = new UnityEngine.WaitForSecondsRealtime(delay);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    this.ImmediateDestroyDropdownList();

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*UnityEngine.UI.Dropdown.DelayedDestroyDropdownList end.*/

            /*UnityEngine.UI.Dropdown.ImmediateDestroyDropdownList start.*/
            ImmediateDestroyDropdownList: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#ImmediateDestroyDropdownList", this ); }

                for (var i = 0; i < this.m_Items.Count; i++) {
                    if (UnityEngine.MonoBehaviour.op_Inequality(this.m_Items.getItem(i), null)) {
                        this.DestroyItem(this.m_Items.getItem(i));
                    }
                }

                this.m_Items.clear();
                if (UnityEngine.GameObject.op_Inequality(this.m_Dropdown, null)) {
                    this.DestroyDropdownList(this.m_Dropdown);
                }

                this.m_Dropdown = null;
            },
            /*UnityEngine.UI.Dropdown.ImmediateDestroyDropdownList end.*/

            /*UnityEngine.UI.Dropdown.OnSelectItem start.*/
            OnSelectItem: function (toggle) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Dropdown#OnSelectItem", this ); }

                if (!toggle.isOn) {
                    toggle.isOn = true;
                }

                var selectedIndex = -1;
                var tr = toggle.transform;
                var parent = tr.parent;
                for (var i = 0; i < parent.childCount; i++) {
                    if (UnityEngine.Component.op_Equality(parent.GetChild(i), tr)) {
                        // Subtract one to account for template child.
                        selectedIndex = i - 1;
                        break;
                    }
                }

                if (selectedIndex < 0) {
                    return;
                }

                this.value = selectedIndex;
                this.Hide();
            },
            /*UnityEngine.UI.Dropdown.OnSelectItem end.*/


        },
        overloads: {
            "AddOptions(List<OptionData>)": "AddOptions$2",
            "AddOptions(List<Sprite>)": "AddOptions$1",
            "AlphaFadeList(float, float, float)": "AlphaFadeList$1"
        }
    });
    /*UnityEngine.UI.Dropdown end.*/

    /*UnityEngine.UI.GridLayoutGroup start.*/
    Bridge.define("UnityEngine.UI.GridLayoutGroup", {
        inherits: [UnityEngine.UI.LayoutGroup],
        fields: {
            m_StartCorner: 0,
            m_StartAxis: 0,
            m_CellSize: null,
            m_Spacing: null,
            m_Constraint: 0,
            m_ConstraintCount: 0
        },
        props: {
            startCorner: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.GridLayoutGroup#startCorner#get", this ); }

                    return this.m_StartCorner;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.GridLayoutGroup#startCorner#set", this ); }

                    this.m_StartCorner = value;
                }
            },
            startAxis: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.GridLayoutGroup#startAxis#get", this ); }

                    return this.m_StartAxis;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.GridLayoutGroup#startAxis#set", this ); }

                    this.m_StartAxis = value;
                }
            },
            cellSize: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.GridLayoutGroup#cellSize#get", this ); }

                    return this.m_CellSize.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.GridLayoutGroup#cellSize#set", this ); }

                    this.m_CellSize = value.$clone();
                }
            },
            spacing: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.GridLayoutGroup#spacing#get", this ); }

                    return this.m_Spacing.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.GridLayoutGroup#spacing#set", this ); }

                    this.m_Spacing = value.$clone();
                }
            },
            constraint: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.GridLayoutGroup#constraint#get", this ); }

                    return this.m_Constraint;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.GridLayoutGroup#constraint#set", this ); }

                    this.m_Constraint = value;
                }
            },
            constraintCount: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.GridLayoutGroup#constraintCount#get", this ); }

                    return this.m_ConstraintCount;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.GridLayoutGroup#constraintCount#set", this ); }

                    this.m_ConstraintCount = UnityEngine.Mathf.Max(1, value);
                }
            }
        },
        alias: [
            "CalculateLayoutInputHorizontal", "UnityEngine$UI$ILayoutElement$CalculateLayoutInputHorizontal",
            "CalculateLayoutInputVertical", "UnityEngine$UI$ILayoutElement$CalculateLayoutInputVertical",
            "SetLayoutHorizontal", "UnityEngine$UI$ILayoutController$SetLayoutHorizontal",
            "SetLayoutVertical", "UnityEngine$UI$ILayoutController$SetLayoutVertical"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.GridLayoutGroup#init", this ); }

                this.m_CellSize = new UnityEngine.Vector2();
                this.m_Spacing = new UnityEngine.Vector2();
                this.m_StartCorner = UnityEngine.UI.GridLayoutGroup.Corner.UpperLeft;
                this.m_StartAxis = UnityEngine.UI.GridLayoutGroup.Axis.Horizontal;
                this.m_CellSize = new pc.Vec2( 100, 100 );
                this.m_Spacing = pc.Vec2.ZERO.clone();
                this.m_Constraint = UnityEngine.UI.GridLayoutGroup.Constraint.Flexible;
                this.m_ConstraintCount = 2;
            }
        },
        methods: {
            /*UnityEngine.UI.GridLayoutGroup.CalculateLayoutInputHorizontal start.*/
            CalculateLayoutInputHorizontal: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.GridLayoutGroup#CalculateLayoutInputHorizontal", this ); }

                UnityEngine.UI.LayoutGroup.prototype.CalculateLayoutInputHorizontal.call(this);

                var minColumns = 0;
                var preferredColumns = 0;

                if (this.m_Constraint === UnityEngine.UI.GridLayoutGroup.Constraint.FixedColumnCount) {
                    minColumns = (preferredColumns = this.m_ConstraintCount);
                } else if (this.m_Constraint === UnityEngine.UI.GridLayoutGroup.Constraint.FixedRowCount) {
                    minColumns = (preferredColumns = Math.ceil(this.m_RectChildren.length / this.m_ConstraintCount - 0.001));
                } else {
                    minColumns = 1;
                    preferredColumns = Math.ceil(Math.sqrt(this.m_RectChildren.length));
                }

                this.SetLayoutInputForAxis(this.padding.horizontal + (this.cellSize.x + this.spacing.x) * minColumns - this.spacing.x, this.padding.horizontal + (this.cellSize.x + this.spacing.x) * preferredColumns - this.spacing.x, -1, 0);
            },
            /*UnityEngine.UI.GridLayoutGroup.CalculateLayoutInputHorizontal end.*/

            /*UnityEngine.UI.GridLayoutGroup.CalculateLayoutInputVertical start.*/
            CalculateLayoutInputVertical: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.GridLayoutGroup#CalculateLayoutInputVertical", this ); }

                var minRows = 0;

                if (this.m_Constraint === UnityEngine.UI.GridLayoutGroup.Constraint.FixedColumnCount) {
                    minRows = Math.ceil(this.m_RectChildren.length / this.m_ConstraintCount - 0.001);
                } else if (this.m_Constraint === UnityEngine.UI.GridLayoutGroup.Constraint.FixedRowCount) {
                    minRows = this.m_ConstraintCount;
                } else {
                    var width = this.rectTransform.rect.size.x;
                    var cellCountX = UnityEngine.Mathf.Max(1, Math.floor((width - this.padding.horizontal + this.spacing.x + 0.001) / (this.cellSize.x + this.spacing.x)));
                    minRows = Math.ceil(this.m_RectChildren.length / cellCountX);
                }

                var minSpace = this.padding.vertical + (this.cellSize.y + this.spacing.y) * minRows - this.spacing.y;

                this.SetLayoutInputForAxis(minSpace, minSpace, -1, 1);
            },
            /*UnityEngine.UI.GridLayoutGroup.CalculateLayoutInputVertical end.*/

            /*UnityEngine.UI.GridLayoutGroup.SetLayoutHorizontal start.*/
            SetLayoutHorizontal: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.GridLayoutGroup#SetLayoutHorizontal", this ); }

                this.SetCellsAlongAxis(0);
            },
            /*UnityEngine.UI.GridLayoutGroup.SetLayoutHorizontal end.*/

            /*UnityEngine.UI.GridLayoutGroup.SetLayoutVertical start.*/
            SetLayoutVertical: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.GridLayoutGroup#SetLayoutVertical", this ); }

                this.SetCellsAlongAxis(1);
            },
            /*UnityEngine.UI.GridLayoutGroup.SetLayoutVertical end.*/

            /*UnityEngine.UI.GridLayoutGroup.SetCellsAlongAxis start.*/
            SetCellsAlongAxis: function (axis) {
if ( TRACE ) { TRACE( "UnityEngine.UI.GridLayoutGroup#SetCellsAlongAxis", this ); }

                if (axis === 0) {
                    // Only set the sizes when invoked for horizontal axis, not the positions.
                    for (var i = 0; i < this.m_RectChildren.length; i++) {
                        var rect = this.m_RectChildren[i];

                        if (rect.Destroyed) {
                            continue;
                        }

                        rect.anchorMin = pc.Vec2.UP.clone();
                        rect.anchorMax = pc.Vec2.UP.clone();
                        rect.sizeDelta = this.cellSize.$clone();
                    }

                    return;
                }

                var width = this.rectTransform.rect.size.x;
                var height = this.rectTransform.rect.size.y;

                var cellCountX = 1;
                var cellCountY = 1;

                if (this.m_Constraint === UnityEngine.UI.GridLayoutGroup.Constraint.FixedColumnCount) {
                    cellCountX = this.m_ConstraintCount;
                    cellCountY = Math.ceil(this.m_RectChildren.length / cellCountX - 0.001);
                } else if (this.m_Constraint === UnityEngine.UI.GridLayoutGroup.Constraint.FixedRowCount) {
                    cellCountY = this.m_ConstraintCount;
                    cellCountX = Math.ceil(this.m_RectChildren.length / cellCountY - 0.001);
                } else {
                    if (this.cellSize.x + this.spacing.x <= 0) {
                        cellCountX = 2147483647;
                    } else {
                        cellCountX = UnityEngine.Mathf.Max(1, Math.floor((width - this.padding.horizontal + this.spacing.x + 0.001) / (this.cellSize.x + this.spacing.x)));
                    }

                    if (this.cellSize.y + this.spacing.y <= 0) {
                        cellCountY = 2147483647;
                    } else {
                        cellCountY = UnityEngine.Mathf.Max(1, Math.floor((height - this.padding.vertical + this.spacing.y + 0.001) / (this.cellSize.y + this.spacing.y)));
                    }
                }

                var cornerX = this.startCorner % 2;
                //EN-701
                //part of project optimization is to leave bridge out of dealing with integer and fractional numbers
                //leaving c# code as is "startCorner / 2" will result in integer in c# and a float one after compilation
                //the obvious solution Mathf.CeilToInt() would be fine, but the line below is a bit more performant
                var cornerY = ( this.startCorner / 2 ) | 0;

                var cellsPerMainAxis = 0;
                var actualCellCountX = 0;
                var actualCellCountY = 0;

                if (this.startAxis === UnityEngine.UI.GridLayoutGroup.Axis.Horizontal) {
                    cellsPerMainAxis = cellCountX;
                    actualCellCountX = Math.max(1, Math.min(cellCountX, this.m_RectChildren.length));
                    actualCellCountY = Math.max(1, Math.min(cellCountY, Math.ceil(this.m_RectChildren.length / cellsPerMainAxis)));
                } else {
                    cellsPerMainAxis = cellCountY;
                    actualCellCountY = Math.max(1, Math.min(cellCountY, this.m_RectChildren.length));
                    actualCellCountX = Math.max(1, Math.min(cellCountX, Math.ceil(this.m_RectChildren.length / cellsPerMainAxis)));
                }

                var requiredSpace = new pc.Vec2( actualCellCountX * this.cellSize.x + (actualCellCountX - 1) * this.spacing.x, actualCellCountY * this.cellSize.y + (actualCellCountY - 1) * this.spacing.y );

                var startOffset = new pc.Vec2( this.GetStartOffset(0, requiredSpace.x), this.GetStartOffset(1, requiredSpace.y) );

                for (var i1 = 0; i1 < this.m_RectChildren.length; i1++) {
                    var positionX = 0;
                    var positionY = 0;

                    if (this.startAxis === UnityEngine.UI.GridLayoutGroup.Axis.Horizontal) {
                        positionX = i1 % cellsPerMainAxis;
                        //EN-701 or comment above
                        positionY = ( i1 / cellsPerMainAxis ) | 0;
                    } else {
                        //EN-701 or comment above
                        positionX = ( i1 / cellsPerMainAxis ) | 0;
                        positionY = i1 % cellsPerMainAxis;
                    }

                    if (cornerX === 1) {
                        positionX = actualCellCountX - 1 - positionX;
                    }

                    if (cornerY === 1) {
                        positionY = actualCellCountY - 1 - positionY;
                    }

                    this.SetChildAlongAxis$1(this.m_RectChildren[i1], 0, startOffset.x + (this.cellSize.getitem(0) + this.spacing.getitem(0)) * positionX, this.cellSize.getitem(0));
                    this.SetChildAlongAxis$1(this.m_RectChildren[i1], 1, startOffset.y + (this.cellSize.getitem(1) + this.spacing.getitem(1)) * positionY, this.cellSize.getitem(1));
                }
            },
            /*UnityEngine.UI.GridLayoutGroup.SetCellsAlongAxis end.*/


        }
    });
    /*UnityEngine.UI.GridLayoutGroup end.*/

    /*UnityEngine.UI.HorizontalOrVerticalLayoutGroup start.*/
    /**
     * Horizontal or vertical layout group.
     *
     * @abstract
     * @public
     * @class UnityEngine.UI.HorizontalOrVerticalLayoutGroup
     * @augments UnityEngine.UI.LayoutGroup
     */
    Bridge.define("UnityEngine.UI.HorizontalOrVerticalLayoutGroup", {
        inherits: [UnityEngine.UI.LayoutGroup],
        fields: {
            m_ChildControlHeight: false,
            m_ChildControlWidth: false,
            m_ChildForceExpandHeight: false,
            m_ChildForceExpandWidth: false,
            m_Spacing: 0
        },
        props: {
            spacing: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.HorizontalOrVerticalLayoutGroup#spacing#get", this ); }

                    return this.m_Spacing;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.HorizontalOrVerticalLayoutGroup#spacing#set", this ); }

                    this.SetProperty(System.Single, Bridge.ref(this, "m_Spacing"), value);
                }
            },
            childForceExpandWidth: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.HorizontalOrVerticalLayoutGroup#childForceExpandWidth#get", this ); }

                    return this.m_ChildForceExpandWidth;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.HorizontalOrVerticalLayoutGroup#childForceExpandWidth#set", this ); }

                    this.SetProperty(System.Boolean, Bridge.ref(this, "m_ChildForceExpandWidth"), value);
                }
            },
            childForceExpandHeight: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.HorizontalOrVerticalLayoutGroup#childForceExpandHeight#get", this ); }

                    return this.m_ChildForceExpandHeight;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.HorizontalOrVerticalLayoutGroup#childForceExpandHeight#set", this ); }

                    this.SetProperty(System.Boolean, Bridge.ref(this, "m_ChildForceExpandHeight"), value);
                }
            },
            childControlWidth: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.HorizontalOrVerticalLayoutGroup#childControlWidth#get", this ); }

                    return this.m_ChildControlWidth;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.HorizontalOrVerticalLayoutGroup#childControlWidth#set", this ); }

                    this.SetProperty(System.Boolean, Bridge.ref(this, "m_ChildControlWidth"), value);
                }
            },
            childControlHeight: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.HorizontalOrVerticalLayoutGroup#childControlHeight#get", this ); }

                    return this.m_ChildControlHeight;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.HorizontalOrVerticalLayoutGroup#childControlHeight#set", this ); }

                    this.SetProperty(System.Boolean, Bridge.ref(this, "m_ChildControlHeight"), value);
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.HorizontalOrVerticalLayoutGroup#init", this ); }

                this.m_ChildControlHeight = true;
                this.m_ChildControlWidth = true;
                this.m_ChildForceExpandHeight = true;
                this.m_ChildForceExpandWidth = true;
            }
        },
        methods: {
            /*UnityEngine.UI.HorizontalOrVerticalLayoutGroup.CalcAlongAxis start.*/
            /**
             * Calculates the along axis.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.HorizontalOrVerticalLayoutGroup
             * @memberof UnityEngine.UI.HorizontalOrVerticalLayoutGroup
             * @param   {number}     axis          Axis.
             * @param   {boolean}    isVertical    If set to <pre><code>true</code></pre> is vertical.
             * @return  {void}
             */
            CalcAlongAxis: function (axis, isVertical) {
if ( TRACE ) { TRACE( "UnityEngine.UI.HorizontalOrVerticalLayoutGroup#CalcAlongAxis", this ); }

                var combinedPadding = axis === 0 ? this.padding.horizontal : this.padding.vertical;
                var controlSize = axis === 0 ? this.m_ChildControlWidth : this.m_ChildControlHeight;
                var childForceExpandSize = axis === 0 ? this.childForceExpandWidth : this.childForceExpandHeight;

                var totalMin = combinedPadding;
                var totalPreferred = combinedPadding;
                var totalFlexible = 0.0;

                var alongOtherAxis = isVertical != (axis === 1);

                for (var i = 0; i < this.m_RectChildren.length; i++) {
                    var child = this.m_RectChildren[i];

                    var min = { v : 0.0 };
                    var preferred = { v : 0.0 };
                    var flexible = { v : 0.0 };

                    this.GetChildSizes(child, axis, controlSize, childForceExpandSize, min, preferred, flexible);

                    if (alongOtherAxis) {
                        totalMin = UnityEngine.Mathf.Max(min.v + combinedPadding, totalMin);
                        totalPreferred = UnityEngine.Mathf.Max(preferred.v + combinedPadding, totalPreferred);
                        totalFlexible = UnityEngine.Mathf.Max(flexible.v, totalFlexible);
                    } else {
                        totalMin += min.v + this.spacing;
                        totalPreferred += preferred.v + this.spacing;

                        // Increment flexible size with element's flexible size.
                        totalFlexible += flexible.v;
                    }
                }

                if (!alongOtherAxis && this.m_RectChildren.length > 0) {
                    totalMin -= this.spacing;
                    totalPreferred -= this.spacing;
                }

                totalPreferred = UnityEngine.Mathf.Max(totalMin, totalPreferred);
                this.SetLayoutInputForAxis(totalMin, totalPreferred, totalFlexible, axis);
            },
            /*UnityEngine.UI.HorizontalOrVerticalLayoutGroup.CalcAlongAxis end.*/

            /*UnityEngine.UI.HorizontalOrVerticalLayoutGroup.SetChildrenAlongAxis start.*/
            /**
             * Sets the children along axis.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.HorizontalOrVerticalLayoutGroup
             * @memberof UnityEngine.UI.HorizontalOrVerticalLayoutGroup
             * @param   {number}     axis          Axis.
             * @param   {boolean}    isVertical    If set to <pre><code>true</code></pre> is vertical.
             * @return  {void}
             */
            SetChildrenAlongAxis: function (axis, isVertical) {
if ( TRACE ) { TRACE( "UnityEngine.UI.HorizontalOrVerticalLayoutGroup#SetChildrenAlongAxis", this ); }

                var size = this.rectTransform.rect.size.getitem(axis);
                var controlSize = axis === 0 ? this.m_ChildControlWidth : this.m_ChildControlHeight;
                var childForceExpandSize = axis === 0 ? this.childForceExpandWidth : this.childForceExpandHeight;
                var alignmentOnAxis = this.GetAlignmentOnAxis(axis);

                var alongOtherAxis = isVertical != (axis === 1);

                if (alongOtherAxis) {
                    var innerSize = size - (axis === 0 ? this.padding.horizontal : this.padding.vertical);

                    for (var i = 0; i < this.m_RectChildren.length; i++) {
                        var child = this.m_RectChildren[i];

                        var min = { v : 0.0 };
                        var preferred = { v : 0.0 };
                        var flexible = { v : 0.0 };

                        this.GetChildSizes(child, axis, controlSize, childForceExpandSize, min, preferred, flexible);

                        var requiredSpace = Math.max(min.v, Math.min(innerSize, flexible.v > 0 ? size : preferred.v));
                        var startOffset = this.GetStartOffset(axis, requiredSpace);

                        if (controlSize) {
                            this.SetChildAlongAxis$1(child, axis, startOffset, requiredSpace);
                        } else {
                            var offsetInCell = (requiredSpace - child.sizeDelta.getitem(axis)) * alignmentOnAxis;
                            this.SetChildAlongAxis(child, axis, startOffset + offsetInCell);
                        }
                    }
                } else {
                    var pos = axis === 0 ? this.padding.left : this.padding.top;

                    if (this.GetTotalFlexibleSize(axis) === 0 && this.GetTotalPreferredSize(axis) < size) {
                        pos = this.GetStartOffset(axis, this.GetTotalPreferredSize(axis) - (axis === 0 ? this.padding.horizontal : this.padding.vertical));
                    }

                    var minMaxLerp = 0.0;
                    if (this.GetTotalMinSize(axis) !== this.GetTotalPreferredSize(axis)) {
                        minMaxLerp = Math.max(0, Math.min(1, (size - this.GetTotalMinSize(axis)) / (this.GetTotalPreferredSize(axis) - this.GetTotalMinSize(axis))));
                    }

                    var itemFlexibleMultiplier = 0.0;
                    if (size > this.GetTotalPreferredSize(axis)) {
                        if (this.GetTotalFlexibleSize(axis) > 0) {
                            itemFlexibleMultiplier = (size - this.GetTotalPreferredSize(axis)) / this.GetTotalFlexibleSize(axis);
                        }
                    }

                    for (var i1 = 0; i1 < this.m_RectChildren.length; i1++) {
                        var child1 = this.m_RectChildren[i1];

                        var min1 = { v : 0.0 };
                        var preferred1 = { v : 0.0 };
                        var flexible1 = { v : 0.0 };

                        this.GetChildSizes(child1, axis, controlSize, childForceExpandSize, min1, preferred1, flexible1);

                        var childSize = pc.math.lerp(min1.v, preferred1.v, minMaxLerp);
                        childSize += flexible1.v * itemFlexibleMultiplier;

                        if (controlSize) {
                            this.SetChildAlongAxis$1(child1, axis, pos, childSize);
                        } else {
                            var offsetInCell1 = (childSize - child1.sizeDelta.getitem(axis)) * alignmentOnAxis;
                            this.SetChildAlongAxis(child1, axis, pos + offsetInCell1);
                        }

                        pos += childSize + this.spacing;
                    }
                }
            },
            /*UnityEngine.UI.HorizontalOrVerticalLayoutGroup.SetChildrenAlongAxis end.*/

            /*UnityEngine.UI.HorizontalOrVerticalLayoutGroup.GetChildSizes start.*/
            /**
             * Gets the child sizes.
             *
             * @instance
             * @private
             * @this UnityEngine.UI.HorizontalOrVerticalLayoutGroup
             * @memberof UnityEngine.UI.HorizontalOrVerticalLayoutGroup
             * @param   {UnityEngine.RectTransform}    child               Child.
             * @param   {number}                       axis                Axis.
             * @param   {boolean}                      controlSize         If set to <pre><code>true</code></pre> control size.
             * @param   {boolean}                      childForceExpand    If set to <pre><code>true</code></pre> child force expand.
             * @param   {System.Single}                min                 Minimum.
             * @param   {System.Single}                preferred           Preferred.
             * @param   {System.Single}                flexible            Flexible.
             * @return  {void}
             */
            GetChildSizes: function (child, axis, controlSize, childForceExpand, min, preferred, flexible) {
if ( TRACE ) { TRACE( "UnityEngine.UI.HorizontalOrVerticalLayoutGroup#GetChildSizes", this ); }

                if (!controlSize) {
                    min.v = child.sizeDelta.getitem(axis);
                    preferred.v = min.v;
                    flexible.v = 0;
                } else {
                    min.v = UnityEngine.UI.LayoutUtility.GetMinSize(child, axis);
                    preferred.v = UnityEngine.UI.LayoutUtility.GetPreferredSize(child, axis);
                    flexible.v = UnityEngine.UI.LayoutUtility.GetFlexibleSize(child, axis);
                }

                if (childForceExpand) {
                    flexible.v = UnityEngine.Mathf.Max(flexible.v, 1);
                }
            },
            /*UnityEngine.UI.HorizontalOrVerticalLayoutGroup.GetChildSizes end.*/


        }
    });
    /*UnityEngine.UI.HorizontalOrVerticalLayoutGroup end.*/

    /*UnityEngine.UI.Image start.*/
    Bridge.define("UnityEngine.UI.Image", {
        inherits: [UnityEngine.UI.MaskableGraphic,UnityEngine.UI.ILayoutElement,UnityEngine.ICanvasRaycastFilter],
        fields: {
            /**
             * The m sprite.
             *
             * @instance
             * @protected
             * @memberof UnityEngine.UI.Image
             * @type UnityEngine.Sprite
             */
            m_Sprite: null,
            /**
             * Gets or sets the override sprite.
             *
             * @instance
             * @protected
             * @memberof UnityEngine.UI.Image
             * @type UnityEngine.Sprite
             */
            m_OverrideSprite: null,
            /**
             * The type of the m.
             *
             * @instance
             * @protected
             * @memberof UnityEngine.UI.Image
             * @type number
             */
            m_Type: 0,
            /**
             * The fill method used.
             *
             * @instance
             * @protected
             * @memberof UnityEngine.UI.Image
             * @default 0
             * @type number
             */
            m_FillMethod: 0,
            /**
             * Whether to keep center filled.
             *
             * @instance
             * @protected
             * @memberof UnityEngine.UI.Image
             * @default true
             * @type boolean
             */
            m_FillCenter: false,
            /**
             * The fill origin.
             *
             * @instance
             * @protected
             * @memberof UnityEngine.UI.Image
             * @default 0
             * @type number
             */
            m_FillOrigin: 0,
            /**
             * The fill clockwise.
             *
             * @instance
             * @protected
             * @memberof UnityEngine.UI.Image
             * @default true
             * @type boolean
             */
            m_FillClockwise: false,
            /**
             * The fill amount.
             *
             * @instance
             * @protected
             * @memberof UnityEngine.UI.Image
             * @default 1.0
             * @type number
             */
            m_FillAmount: 0,
            /**
             * The m preserve aspect.
             *
             * @instance
             * @protected
             * @memberof UnityEngine.UI.Image
             * @default false
             * @type boolean
             */
            m_PreserveAspect: false,
            m_CachedReferencePixelsPerUnit: 0,
            m_PixelsPerUnitMultiplier: 0,
            m_AlphaHitTestMinimumThreshold: 0
        },
        props: {
            /**
             * Gets or sets the sprite.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Image
             * @function sprite
             * @type UnityEngine.Sprite
             */
            sprite: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#sprite#get", this ); }

                    return this.m_Sprite;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#sprite#set", this ); }

                    if (Bridge.referenceEquals(this.m_Sprite, value)) {
                        return;
                    }

                    if (this.m_Sprite != null) {
                        if (!Bridge.referenceEquals(this.m_Sprite, value)) {
                            this.m_SkipLayoutUpdate = this.m_Sprite.rect.size.strictEquals( UnityEngine.Object.op_Implicit(value) ? value.rect.size.$clone() : pc.Vec2.ZERO.clone() );
                            this.m_SkipMaterialUpdate = Bridge.referenceEquals(this.m_Sprite.texture, (UnityEngine.Object.op_Implicit(value) ? value.texture : null));
                            this.m_Sprite = value;
                            this.SetAllDirty();
                            // TrackSprite();
                        }
                    } else if (value != null) {
                        this.m_SkipLayoutUpdate = pc.Vec2.equals( value.rect.size, pc.Vec2.ZERO.clone() );
                        this.m_SkipMaterialUpdate = value.texture == null;
                        this.m_Sprite = value;
                        this.SetAllDirty();
                        // TrackSprite();
                    }

                    this.m_Sprite = value;
                    this.handle.entity.element._image.sprite = (value != null ? value.handle : null) != null ? value.handle : null;
                    this.SetAllDirty();
                }
            },
            /**
             * Gets or sets the override sprite.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Image
             * @function overrideSprite
             * @type UnityEngine.Sprite
             */
            overrideSprite: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#overrideSprite#get", this ); }

                    return this.m_OverrideSprite;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#overrideSprite#set", this ); }

                    if (Bridge.referenceEquals(this.m_OverrideSprite, value)) {
                        return;
                    }

                    this.m_OverrideSprite = value;
                    var sprite = this.m_OverrideSprite || this.m_Sprite;
                    this.handle.entity.element._image.sprite = (sprite != null ? sprite.handle : null) != null ? sprite.handle : null;
                    this.SetAllDirty();
                    // TrackSprite();
                }
            },
            /**
             * Gets the active sprite.
             *
             * @instance
             * @private
             * @readonly
             * @memberof UnityEngine.UI.Image
             * @function activeSprite
             * @type UnityEngine.Sprite
             */
            activeSprite: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#activeSprite#get", this ); }

                    return !(!Bridge.referenceEquals(Bridge.cast(this.m_OverrideSprite, UnityEngine.Object), null)) ? this.sprite : this.m_OverrideSprite;
                }
            },
            /**
             * Gets or sets the type.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Image
             * @function type
             * @type number
             */
            type: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#type#get", this ); }

                    return this.m_Type;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#type#set", this ); }

                    this.m_Type = value;
                    this.handle.entity.element._image.spriteType = value;
                }
            },
            /**
             * Gets or sets the fill method used.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Image
             * @function fillMethod
             * @type number
             */
            fillMethod: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#fillMethod#get", this ); }

                    return this.m_FillMethod;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#fillMethod#set", this ); }

                    this.m_FillMethod = value;
                    this.handle.entity.element._image.fillMethod = value;
                }
            },
            /**
             * Gets or sets a flag indicating whether to fill the center.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Image
             * @function fillCenter
             * @type boolean
             */
            fillCenter: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#fillCenter#get", this ); }

                    return this.m_FillCenter;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#fillCenter#set", this ); }

                    this.m_FillCenter = value;
                    this.handle.entity.element._image.fillCenter = value;
                }
            },
            /**
             * Gets or sets the fill origin.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Image
             * @function fillOrigin
             * @type number
             */
            fillOrigin: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#fillOrigin#get", this ); }

                    return this.m_FillOrigin;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#fillOrigin#set", this ); }

                    this.m_FillOrigin = value;
                    this.handle.entity.element._image.fillOrigin = value;
                }
            },
            /**
             * Gets or sets the fill clockwise or not.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Image
             * @function fillClockwise
             * @type boolean
             */
            fillClockwise: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#fillClockwise#get", this ); }

                    return this.m_FillClockwise;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#fillClockwise#set", this ); }

                    this.m_FillClockwise = value;
                    this.handle.entity.element._image.fillClockwise = value;
                }
            },
            /**
             * Gets or sets the fill amount.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Image
             * @function fillAmount
             * @type number
             */
            fillAmount: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#fillAmount#get", this ); }

                    return this.m_FillAmount;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#fillAmount#set", this ); }

                    value = Math.max(0, Math.min(1, value));
                    this.m_FillAmount = value;
                    this.handle.entity.element._image.fillAmount = value;
                }
            },
            /**
             * Gets or sets a value indicating whether this {@link } preserve aspect.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Image
             * @function preserveAspect
             * @type boolean
             */
            preserveAspect: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#preserveAspect#get", this ); }

                    return this.m_PreserveAspect;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#preserveAspect#set", this ); }

                    this.m_PreserveAspect = value;
                    this.handle.entity.element._image.preserveAspect = value;
                }
            },
            /**
             * Gets or sets the material.
             *
             * @instance
             * @public
             * @override
             * @memberof UnityEngine.UI.Image
             * @function material
             * @type UnityEngine.Material
             */
            material: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#material#get", this ); }

                    if (this.m_Material != null) {
                        return this.m_Material;
                    }

                    // if (activeSprite && activeSprite.associatedAlphaSplitTexture != null)
                    //     return defaultETC1GraphicMaterial;
                    return this.defaultMaterial;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#material#set", this ); }

                    Bridge.ensureBaseProperty(this, "material").$UnityEngine$UI$Graphic$material = value;
                }
            },
            /**
             * Gets or sets a value indicating whether this {@link } is enabled.
             *
             * @instance
             * @public
             * @override
             * @memberof UnityEngine.UI.Image
             * @function enabled
             * @type boolean
             */
            enabled: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#enabled#get", this ); }

                    return this.handle.entity.element._image.enabled && this.handle.enabled;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#enabled#set", this ); }

                    this.handle.entity.element._image.enabled = value;
                    this.handle.enabled = value;
                }
            },
            /**
             * Pixel per unit modifier to change how sliced sprites are generated.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Image
             * @function pixelsPerUnitMultiplier
             * @type number
             */
            pixelsPerUnitMultiplier: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#pixelsPerUnitMultiplier#get", this ); }

                    return this.m_PixelsPerUnitMultiplier;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#pixelsPerUnitMultiplier#set", this ); }

                    this.m_PixelsPerUnitMultiplier = UnityEngine.Mathf.Max(0.01, value);
                    this.handle.entity.element._image.pixelsPerUnitMultiplier = value;
                }
            },
            /**
             * Gets the pixels per unit.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.Image
             * @function pixelsPerUnit
             * @type number
             */
            pixelsPerUnit: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#pixelsPerUnit#get", this ); }

                    var spritePixelsPerUnit = 100;
                    if (UnityEngine.Object.op_Implicit(this.activeSprite)) {
                        spritePixelsPerUnit = this.activeSprite.pixelsPerUnit;
                    }

                    if (UnityEngine.Object.op_Implicit(this.canvas)) {
                        this.m_CachedReferencePixelsPerUnit = this.canvas.referencePixelsPerUnit;
                    }

                    return spritePixelsPerUnit / this.m_CachedReferencePixelsPerUnit;
                }
            },
            multipliedPixelsPerUnit: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#multipliedPixelsPerUnit#get", this ); }

                    return this.pixelsPerUnit * this.m_PixelsPerUnitMultiplier;
                }
            },
            mainTexture: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#mainTexture#get", this ); }

                    if (this.activeSprite == null) {
                        if (this.material != null && this.material.mainTexture != null) {
                            return this.material.mainTexture;
                        }

                        return UnityEngine.UI.Graphic.s_WhiteTexture;
                    }

                    return this.activeSprite.texture;
                }
            },
            hasBorder: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#hasBorder#get", this ); }

                    if (this.activeSprite != null) {
                        var v = this.activeSprite.border.$clone();
                        return v.lengthSq() > 0.0;
                    }

                    return false;
                }
            },
            /**
             * <p>See ILayoutElement.minWidth.</p>
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.Image
             * @function minWidth
             * @type number
             */
            minWidth: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#minWidth#get", this ); }

                    return 0.0;
                }
            },
            /**
             * <p>See ILayoutElement.preferredWidth.</p>
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.Image
             * @function preferredWidth
             * @type number
             */
            preferredWidth: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#preferredWidth#get", this ); }

                    if (Bridge.referenceEquals(Bridge.cast(this.activeSprite, UnityEngine.Object), null)) {
                        return 0.0;
                    }

                    return this.type === UnityEngine.UI.Image.Type.Sliced || this.type === UnityEngine.UI.Image.Type.Tiled ? UnityEngine.Sprites.DataUtility.GetMinSize(this.activeSprite).x / this.multipliedPixelsPerUnit : this.activeSprite.rect.size.x / this.multipliedPixelsPerUnit;
                }
            },
            /**
             * <p>See ILayoutElement.flexibleWidth.</p>
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.Image
             * @function flexibleWidth
             * @type number
             */
            flexibleWidth: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#flexibleWidth#get", this ); }

                    return -1.0;
                }
            },
            
            minHeight: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#minHeight#get", this ); }

                    return 0.0;
                }
            },
            /**
             * <p>See ILayoutElement.preferredHeight.</p>
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.Image
             * @function preferredHeight
             * @type number
             */
            preferredHeight: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#preferredHeight#get", this ); }

                    if (Bridge.referenceEquals(Bridge.cast(this.activeSprite, UnityEngine.Object), null)) {
                        return 0.0;
                    }

                    return this.type === UnityEngine.UI.Image.Type.Sliced || this.type === UnityEngine.UI.Image.Type.Tiled ? UnityEngine.Sprites.DataUtility.GetMinSize(this.activeSprite).y / this.multipliedPixelsPerUnit : this.activeSprite.rect.size.y / this.multipliedPixelsPerUnit;
                }
            },
            /**
             * <p>See ILayoutElement.flexibleHeight.</p>
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.Image
             * @function flexibleHeight
             * @type number
             */
            flexibleHeight: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#flexibleHeight#get", this ); }

                    return -1.0;
                }
            },
            /**
             * <p>See ILayoutElement.layoutPriority.</p>
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.Image
             * @function layoutPriority
             * @type number
             */
            layoutPriority: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#layoutPriority#get", this ); }

                    return 0;
                }
            },
            alphaHitTestMinimumThreshold: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#alphaHitTestMinimumThreshold#get", this ); }

                    return this.m_AlphaHitTestMinimumThreshold;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#alphaHitTestMinimumThreshold#set", this ); }

                    this.m_AlphaHitTestMinimumThreshold = value;
                }
            }
        },
        alias: [
            "CalculateLayoutInputHorizontal", "UnityEngine$UI$ILayoutElement$CalculateLayoutInputHorizontal",
            "CalculateLayoutInputVertical", "UnityEngine$UI$ILayoutElement$CalculateLayoutInputVertical",
            "minWidth", "UnityEngine$UI$ILayoutElement$minWidth",
            "preferredWidth", "UnityEngine$UI$ILayoutElement$preferredWidth",
            "flexibleWidth", "UnityEngine$UI$ILayoutElement$flexibleWidth",
            "minHeight", "UnityEngine$UI$ILayoutElement$minHeight",
            "preferredHeight", "UnityEngine$UI$ILayoutElement$preferredHeight",
            "flexibleHeight", "UnityEngine$UI$ILayoutElement$flexibleHeight",
            "layoutPriority", "UnityEngine$UI$ILayoutElement$layoutPriority",
            "IsRaycastLocationValid", "UnityEngine$ICanvasRaycastFilter$IsRaycastLocationValid"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#init", this ); }

                this.m_Type = UnityEngine.UI.Image.Type.Sliced;
                this.m_FillMethod = 0;
                this.m_FillCenter = true;
                this.m_FillOrigin = 0;
                this.m_FillClockwise = true;
                this.m_FillAmount = 1.0;
                this.m_PreserveAspect = false;
                this.m_CachedReferencePixelsPerUnit = 100;
                this.m_PixelsPerUnitMultiplier = 1.0;
                this.m_AlphaHitTestMinimumThreshold = 0;
            },
            /**
             * Initializes a new instance of the {@link } class.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Image
             * @memberof UnityEngine.UI.Image
             * @param   {pc.ElementComponent}    handle    Handle.
             * @return  {void}
             */
            $ctor1: function (handle) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#$ctor1", this ); }

                if (handle === void 0) { handle = null; }

                this.$initialize();
                UnityEngine.UI.MaskableGraphic.$ctor1.call(this, handle);
            },
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#ctor", this ); }

                this.$initialize();
                UnityEngine.UI.MaskableGraphic.$ctor1.call(this, null);
            }
        },
        methods: {
            /*UnityEngine.UI.Image.DisableSpriteOptimizations start.*/
            /**
             * Disable all automatic sprite optimizations.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Image
             * @memberof UnityEngine.UI.Image
             * @return  {void}
             */
            DisableSpriteOptimizations: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#DisableSpriteOptimizations", this ); }

                this.m_SkipLayoutUpdate = false;
                this.m_SkipMaterialUpdate = false;
            },
            /*UnityEngine.UI.Image.DisableSpriteOptimizations end.*/

            /*UnityEngine.UI.Image.Awake start.*/
            /**
             * Awake this instance.
             *
             * @instance
             * @protected
             * @override
             * @this UnityEngine.UI.Image
             * @memberof UnityEngine.UI.Image
             * @return  {void}
             */
            Awake: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#Awake", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.Awake.call(this);

                this.handle.entity.element.setupParametersFromImage(this, this.m_Sprite != null ? this.m_Sprite.handle : null, this.m_Type, this.m_FillMethod, this.m_FillOrigin, this.m_FillAmount, this.m_FillCenter, this.m_PixelsPerUnitMultiplier, this.m_PreserveAspect, this._dontMask, this.handle.enabled, this.m_Material != null ? this.m_Material.handle : null);
            },
            /*UnityEngine.UI.Image.Awake end.*/

            /*UnityEngine.UI.Image.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#OnEnable", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.OnEnable.call(this);
                if (this.handle.entity.element != null) {
                    this.handle.entity.element._image.enabled = true;
                }
            },
            /*UnityEngine.UI.Image.OnEnable end.*/

            /*UnityEngine.UI.Image.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#OnDisable", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.OnDisable.call(this);
                if (this.handle.entity.element != null) {
                    this.handle.entity.element._image.enabled = false;
                }
            },
            /*UnityEngine.UI.Image.OnDisable end.*/

            /*UnityEngine.UI.Image.ConfigureForEntity start.*/
            /**
             * Configures for entity.
             *
             * @instance
             * @public
             * @override
             * @this UnityEngine.UI.Image
             * @memberof UnityEngine.UI.Image
             * @param   {pc.Entity}    entity    Entity.
             * @return  {void}
             */
            ConfigureForEntity: function (entity) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#ConfigureForEntity", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.ConfigureForEntity.call(this, entity);
                entity.element.type = "image";
            },
            /*UnityEngine.UI.Image.ConfigureForEntity end.*/

            /*UnityEngine.UI.Image.OnDidApplyAnimationProperties start.*/
            /**
             * Synchronizes animatable properties with lower-level counterpart.
             *
             * @instance
             * @protected
             * @override
             * @this UnityEngine.UI.Image
             * @memberof UnityEngine.UI.Image
             * @return  {void}
             */
            OnDidApplyAnimationProperties: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#OnDidApplyAnimationProperties", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.OnDidApplyAnimationProperties.call(this);
                this.handle.entity.element._image.synchornizeProperties( this, false );
            },
            /*UnityEngine.UI.Image.OnDidApplyAnimationProperties end.*/

            /*UnityEngine.UI.Image.CalculateLayoutInputHorizontal start.*/
            /**
             * <p>See ILayoutElement.CalculateLayoutInputHorizontal.</p>
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Image
             * @memberof UnityEngine.UI.Image
             * @return  {void}
             */
            CalculateLayoutInputHorizontal: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#CalculateLayoutInputHorizontal", this ); }
 },
            /*UnityEngine.UI.Image.CalculateLayoutInputHorizontal end.*/

            /*UnityEngine.UI.Image.CalculateLayoutInputVertical start.*/
            /**
             * <p>See ILayoutElement.CalculateLayoutInputVertical.</p>
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Image
             * @memberof UnityEngine.UI.Image
             * @return  {void}
             */
            CalculateLayoutInputVertical: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#CalculateLayoutInputVertical", this ); }
 },
            /*UnityEngine.UI.Image.CalculateLayoutInputVertical end.*/

            /*UnityEngine.UI.Image.SetNativeSize start.*/
            /**
             * Sets the size of the native.
             *
             * @instance
             * @public
             * @override
             * @this UnityEngine.UI.Image
             * @memberof UnityEngine.UI.Image
             * @return  {void}
             */
            SetNativeSize: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#SetNativeSize", this ); }

                if (this.sprite == null) {
                    UnityEngine.Debug.LogWarning$1("Missing sprite, can't set size to native.");
                    return;
                }

                if (Math.abs(this.rectTransform.anchorMin.x - this.rectTransform.anchorMax.x) > 1E-05 || Math.abs(this.rectTransform.anchorMin.y - this.rectTransform.anchorMax.y) > 1E-05) {
                    this.rectTransform.anchorMin = pc.Vec2.ZERO.clone();
                    this.rectTransform.anchorMax = pc.Vec2.ZERO.clone();
                }

                // If you're using different Pixel per units on your canvas scaler and texture adjustment required
                var ratio = this.canvas.referencePixelsPerUnit / this.sprite.pixelsPerUnit;
                this.rectTransform.sizeDelta = new pc.Vec2( this.sprite.handle.getTexture().width * ratio, this.sprite.handle.getTexture().height * ratio );
            },
            /*UnityEngine.UI.Image.SetNativeSize end.*/

            /*UnityEngine.UI.Image.IsRaycastLocationValid start.*/
            IsRaycastLocationValid: function (screenPoint, eventCamera) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#IsRaycastLocationValid", this ); }

                if (this.alphaHitTestMinimumThreshold <= 0) {
                    return true;
                }

                if (this.alphaHitTestMinimumThreshold > 1) {
                    return false;
                }

                if (this.activeSprite == null) {
                    return true;
                }

                var local = { v : new UnityEngine.Vector2() };
                if (!UnityEngine.RectTransformUtility.ScreenPointToLocalPointInRectangle(this.rectTransform, screenPoint, eventCamera, local)) {
                    return false;
                }

                var rect = this.GetPixelAdjustedRect();

                // Convert to have lower left corner as reference point.
                local.v.x += this.rectTransform.pivot.x * rect.width;
                local.v.y += this.rectTransform.pivot.y * rect.height;
                local.v = this.MapCoordinate(local.v.$clone(), rect.$clone());

                // Convert local coordinates to texture space.
                var spriteRect = this.activeSprite.textureRect.$clone();
                var x = (spriteRect.x + local.v.x) / this.activeSprite.texture.width;
                var y = (spriteRect.y + local.v.y) / this.activeSprite.texture.height;

                try {
                    return this.activeSprite.texture.GetPixelBilinear(x, y).a >= this.alphaHitTestMinimumThreshold;
                } catch ($e1) {
                    $e1 = System.Exception.create($e1);
                    var e;
                    if (Bridge.is($e1, UnityEngine.UnityException)) {
                        e = $e1;
                        UnityEngine.Debug.LogError$2("Using alphaHitTestMinimumThreshold greater than 0 on Image whose sprite texture cannot be read. " + (e.Message || "") + " Also make sure to disable sprite packing for this sprite.", this);
                        return true;
                    } else {
                        throw $e1;
                    }
                }
            },
            /*UnityEngine.UI.Image.IsRaycastLocationValid end.*/

            /*UnityEngine.UI.Image.MapCoordinate start.*/
            MapCoordinate: function (local, rect) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#MapCoordinate", this ); }

                var $t, $t1;
                var spriteRect = this.activeSprite.rect.$clone();
                if (this.type === UnityEngine.UI.Image.Type.Simple || this.type === UnityEngine.UI.Image.Type.Filled) {
                    return new pc.Vec2( local.x * spriteRect.width / rect.width, local.y * spriteRect.height / rect.height );
                }

                var border = this.activeSprite.border.$clone();
                var adjustedBorder = this.GetAdjustedBorders(border.$clone().scale( 1.0 / ( this.multipliedPixelsPerUnit ) ), rect.$clone());

                for (var i = 0; i < 2; i++) {
                    if (local.getitem(i) <= adjustedBorder.getitem(i)) {
                        continue;
                    }

                    if (rect.size.getitem(i) - local.getitem(i) <= adjustedBorder.getitem(i + 2)) {
                        local.setitem(i, local.getitem(i) -(rect.size.getitem(i) - spriteRect.size.getitem(i)));
                        continue;
                    }

                    if (this.type === UnityEngine.UI.Image.Type.Sliced) {
                        var lerp = pc.math.inverseLerp(adjustedBorder.getitem(i), rect.size.getitem(i) - adjustedBorder.getitem(i + 2), local.getitem(i));
                        local.setitem(i, pc.math.lerp(border.getitem(i), spriteRect.size.getitem(i) - border.getitem(i + 2), lerp));
                        continue;
                    } else {
                        local.setitem(i, local.getitem(i) -adjustedBorder.getitem(i));
                        local.setitem(i, ($t = local.getitem(i), $t1 = spriteRect.size.getitem(i) - border.getitem(i) - border.getitem(i + 2), $t - Math.floor($t / $t1) * $t1));
                        local.setitem(i, local.getitem(i) +border.getitem(i));
                        continue;
                    }
                }

                return local.$clone();
            },
            /*UnityEngine.UI.Image.MapCoordinate end.*/

            /*UnityEngine.UI.Image.GetAdjustedBorders start.*/
            GetAdjustedBorders: function (border, adjustedRect) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Image#GetAdjustedBorders", this ); }

                var originalRect = this.rectTransform.rect.$clone();

                for (var axis = 0; axis <= 1; axis++) {
                    var borderScaleRatio;

                    // The adjusted rect (adjusted for pixel correctness)
                    // may be slightly larger than the original rect.
                    // Adjust the border to match the adjustedRect to avoid
                    // small gaps between borders (case 833201).
                    if (originalRect.size.getitem(axis) !== 0) {
                        borderScaleRatio = adjustedRect.size.getitem(axis) / originalRect.size.getitem(axis);
                        border.setitem(axis, border.getitem(axis) *borderScaleRatio);
                        border.setitem(axis + 2, border.getitem(axis + 2) *borderScaleRatio);
                    }

                    // If the rect is smaller than the combined borders, then there's not room for the borders at their normal size.
                    // In order to avoid artefacts with overlapping borders, we scale the borders down to fit.
                    var combinedBorders = border.getitem(axis) + border.getitem(axis + 2);
                    if (adjustedRect.size.getitem(axis) < combinedBorders && combinedBorders !== 0) {
                        borderScaleRatio = adjustedRect.size.getitem(axis) / combinedBorders;
                        border.setitem(axis, border.getitem(axis) *borderScaleRatio);
                        border.setitem(axis + 2, border.getitem(axis + 2) *borderScaleRatio);
                    }
                }

                return border.$clone();
            },
            /*UnityEngine.UI.Image.GetAdjustedBorders end.*/


        }
    });
    /*UnityEngine.UI.Image end.*/
    /**
     * @memberof UnityEngine.UI
     * @callback UnityEngine.UI.InputField.OnValidateInput
     * @param   {string}    text         
     * @param   {number}    charIndex    
     * @param   {number}    addedChar
     * @return  {number}
     */


    /*UnityEngine.UI.InputField start.*/
    /**
     * Turn a simple label into a interactable input field.
     *
     * @public
     * @class UnityEngine.UI.InputField
     * @augments UnityEngine.UI.Selectable
     * @implements  UnityEngine.EventSystems.IUpdateSelectedHandler
     * @implements  UnityEngine.EventSystems.IBeginDragHandler
     * @implements  UnityEngine.EventSystems.IDragHandler
     * @implements  UnityEngine.EventSystems.IEndDragHandler
     * @implements  UnityEngine.EventSystems.IPointerClickHandler
     * @implements  UnityEngine.EventSystems.ISubmitHandler
     * @implements  UnityEngine.UI.ICanvasElement
     * @implements  UnityEngine.UI.ILayoutElement
     */
    Bridge.define("UnityEngine.UI.InputField", {
        inherits: [UnityEngine.UI.Selectable,UnityEngine.EventSystems.IUpdateSelectedHandler,UnityEngine.EventSystems.IBeginDragHandler,UnityEngine.EventSystems.IDragHandler,UnityEngine.EventSystems.IEndDragHandler,UnityEngine.EventSystems.IPointerClickHandler,UnityEngine.EventSystems.ISubmitHandler,UnityEngine.UI.ICanvasElement,UnityEngine.UI.ILayoutElement],
        statics: {
            fields: {
                StyleDisplayBlock: null,
                StyleDisplayNone: null,
                kHScrollSpeed: 0,
                kVScrollSpeed: 0,
                kEmailSpecialCharacters: null,
                k_MaxTextLength: 0,
                kSeparators: null,
                isStyleInitialized: false
            },
            props: {
                clipboard: {
                    get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#clipboard#get", this ); }

                        return pc.generateStubProxy( 'UnityEngine.GUIUtility', true ).reportProperty( 'UnityEngine.GUIUtility.systemCopyBuffer', '' );
                    },
                    set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#clipboard#set", this ); }

                        pc.generateStubProxy( 'UnityEngine.GUIUtility', true ).systemCopyBuffer = value;
                    }
                }
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#init", this ); }

                    this.StyleDisplayBlock = "block";
                    this.StyleDisplayNone = "none";
                    this.kHScrollSpeed = 0.05;
                    this.kVScrollSpeed = 0.1;
                    this.kEmailSpecialCharacters = "!#$%&'*+-/=?^_`{|}~";
                    this.k_MaxTextLength = 16382;
                    this.kSeparators = System.Array.init([
                        32, 
                        46, 
                        44, 
                        9, 
                        13, 
                        10
                    ], System.Char);
                }
            },
            methods: {
                /*UnityEngine.UI.InputField.GetLineStartPosition:static start.*/
                GetLineStartPosition: function (gen, line) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#GetLineStartPosition", this ); }

                    line = Math.max(0, Math.min(line, gen.lines.Count - 1));
                    return gen.lines.getItem(line).startCharIdx;
                },
                /*UnityEngine.UI.InputField.GetLineStartPosition:static end.*/

                /*UnityEngine.UI.InputField.GetLineEndPosition:static start.*/
                GetLineEndPosition: function (gen, line) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#GetLineEndPosition", this ); }

                    line = UnityEngine.Mathf.Max(line, 0);
                    if (line + 1 < gen.lines.Count) {
                        return gen.lines.getItem(line + 1).startCharIdx - 1;
                    }

                    return gen.characterCountVisible;
                },
                /*UnityEngine.UI.InputField.GetLineEndPosition:static end.*/


            }
        },
        fields: {
            m_Keyboard: null,
            shouldBeShown: false,
            /**
             * Text Text used to display the input's value.
             *
             * @instance
             * @protected
             * @memberof UnityEngine.UI.InputField
             * @type UnityEngine.UI.Text
             */
            m_TextComponent: null,
            m_Placeholder: null,
            m_ContentType: 0,
            m_InputType: 0,
            m_AsteriskChar: 0,
            m_KeyboardType: 0,
            m_LineType: 0,
            m_HideMobileInput: false,
            m_CharacterValidation: 0,
            m_CharacterLimit: 0,
            m_OnEndEdit: null,
            m_OnValueChanged: null,
            m_OnValidateInput: null,
            m_CaretColor: null,
            m_CustomCaretColor: false,
            m_SelectionColor: null,
            m_Text: null,
            m_CaretBlinkRate: 0,
            m_CaretWidth: 0,
            m_ReadOnly: false,
            m_CaretPosition: 0,
            m_CaretSelectPosition: 0,
            caretRectTrans: null,
            m_CursorVerts: null,
            m_InputTextCache: null,
            m_CachedInputRenderer: null,
            m_PreventFontCallback: false,
            m_Mesh: null,
            m_AllowInput: false,
            m_ShouldActivateNextUpdate: false,
            m_UpdateDrag: false,
            m_DragPositionOutOfBounds: false,
            m_CaretVisible: false,
            m_BlinkCoroutine: null,
            m_BlinkStartTime: 0,
            m_DrawStart: 0,
            m_DrawEnd: 0,
            m_DragCoroutine: null,
            m_OriginalText: null,
            m_WasCanceled: false,
            m_HasDoneFocusTransition: false,
            m_WaitForSecondsRealtime: null,
            /**
             * Handle the specified event.
             *
             * @instance
             * @private
             * @memberof UnityEngine.UI.InputField
             * @type ( pc.stubProxy.generateConstructorFor( 'UnityEngine.Event' ) )
             */
            m_ProcessingEvent: null,
            rt: null,
            corners: null,
            cornersScreen: null,
            webInput: null,
            canvases: null
        },
        props: {
            input: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#input#get", this ); }

                    if (UnityEngine.Object.op_Implicit(UnityEngine.EventSystems.EventSystem.current) && UnityEngine.Object.op_Implicit(UnityEngine.EventSystems.EventSystem.current.currentInputModule)) {
                        return UnityEngine.EventSystems.EventSystem.current.currentInputModule.input;
                    }

                    return null;
                }
            },
            compositionString: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#compositionString#get", this ); }

                    return UnityEngine.MonoBehaviour.op_Inequality(this.input, null) ? this.input.compositionString : UnityEngine.Input.compositionString;
                }
            },
            mesh: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#mesh#get", this ); }

                    if (this.m_Mesh == null) {
                        this.m_Mesh = new UnityEngine.Mesh.ctor();
                    }

                    return this.m_Mesh;
                }
            },
            cachedInputTextGenerator: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#cachedInputTextGenerator#get", this ); }

                    if (this.m_InputTextCache == null) {
                        this.m_InputTextCache = new UnityEngine.TextGenerator.ctor();
                    }

                    return this.m_InputTextCache;
                }
            },
            /**
             * Should the mobile keyboard input be hidden. This allows for input to happen with a caret in the InputField instead of a OS input box above the keyboard.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.InputField
             * @function shouldHideMobileInput
             * @type boolean
             */
            shouldHideMobileInput: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#shouldHideMobileInput#get", this ); }

                    return true;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#shouldHideMobileInput#set", this ); }

                    UnityEngine.UI.SetPropertyUtility.SetStruct(System.Boolean, Bridge.ref(this, "m_HideMobileInput"), value);
                }
            },
            shouldActivateOnSelect: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#shouldActivateOnSelect#get", this ); }

                    return UnityEngine.Application.platform !== UnityEngine.RuntimePlatform.tvOS;
                }
            },
            /**
             * Input field's current text value. This is not nessisarially the same as what is visible on screen.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.InputField
             * @function text
             * @type string
             */
            text: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#text#get", this ); }

                    return this.m_Text;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#text#set", this ); }

                    if (Bridge.referenceEquals(this.text, value)) {
                        return;
                    }

                    if (value == null) {
                        value = "";
                    }

                    value = System.String.replaceAll(value, "\u0000", ""); // remove embedded nulls
                    if (this.m_LineType === UnityEngine.UI.InputField.LineType.SingleLine) {
                        value = System.String.replaceAll(System.String.replaceAll(value, "\n", ""), "\t", "");
                    }

                    // If we have an input validator, validate the input and apply the character limit at the same time.
                    if (!Bridge.staticEquals(this.onValidateInput, null) || this.characterValidation !== UnityEngine.UI.InputField.CharacterValidation.None) {
                        this.m_Text = "";
                        var validatorMethod = this.onValidateInput || Bridge.fn.cacheBind(this, this.Validate);
                        this.m_CaretPosition = (this.m_CaretSelectPosition = value.length);
                        var charactersToCheck = this.characterLimit > 0 ? Math.min(this.characterLimit, value.length) : value.length;
                        for (var i = 0; i < charactersToCheck; ++i) {
                            var c = validatorMethod(this.m_Text, this.m_Text.length, value.charCodeAt(i));
                            if (c !== 0) {
                                this.m_Text = (this.m_Text || "") + String.fromCharCode(c);
                            }
                        }
                    } else {
                        this.m_Text = this.characterLimit > 0 && value.length > this.characterLimit ? value.substr(0, this.characterLimit) : value;
                    }

                    if (this.m_Keyboard != null) {
                        this.m_Keyboard.text = this.m_Text;
                    }

                    if (this.m_CaretPosition > this.m_Text.length) {
                        this.m_CaretPosition = (this.m_CaretSelectPosition = this.m_Text.length);
                    } else if (this.m_CaretSelectPosition > this.m_Text.length) {
                        this.m_CaretSelectPosition = this.m_Text.length;
                    }

                    this.SendOnValueChangedAndUpdateLabel();
                }
            },
            /**
             * Does the InputField currently have focus and is able to process events.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.InputField
             * @function isFocused
             * @type boolean
             */
            isFocused: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#isFocused#get", this ); }

                    return this.m_AllowInput;
                }
            },
            /**
             * The blinking rate of the input caret, defined as the number of times the blink cycle occurs per second.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.InputField
             * @function caretBlinkRate
             * @type number
             */
            caretBlinkRate: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#caretBlinkRate#get", this ); }

                    return this.m_CaretBlinkRate;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#caretBlinkRate#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetStruct(System.Single, Bridge.ref(this, "m_CaretBlinkRate"), value)) {
                        if (this.m_AllowInput) {
                            this.SetCaretActive();
                        }
                    }
                }
            },
            /**
             * The width of the caret in pixels.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.InputField
             * @function caretWidth
             * @type number
             */
            caretWidth: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#caretWidth#get", this ); }

                    return this.m_CaretWidth;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#caretWidth#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetStruct(System.Int32, Bridge.ref(this, "m_CaretWidth"), value)) {
                        this.MarkGeometryAsDirty();
                    }
                }
            },
            /**
             * The Text component that is going to be used to render the text to screen.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.InputField
             * @function textComponent
             * @type UnityEngine.UI.Text
             */
            textComponent: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#textComponent#get", this ); }

                    return this.m_TextComponent;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#textComponent#set", this ); }

                    if (UnityEngine.MonoBehaviour.op_Inequality(this.m_TextComponent, null)) {
                        this.m_TextComponent.UnregisterDirtyVerticesCallback(Bridge.fn.cacheBind(this, this.MarkGeometryAsDirty));
                        this.m_TextComponent.UnregisterDirtyVerticesCallback(Bridge.fn.cacheBind(this, this.UpdateLabel));
                        this.m_TextComponent.UnregisterDirtyMaterialCallback(Bridge.fn.cacheBind(this, this.UpdateCaretMaterial));
                    }

                    if (UnityEngine.UI.SetPropertyUtility.SetClass(UnityEngine.UI.Text, Bridge.ref(this, "m_TextComponent"), value)) {
                        this.EnforceTextHOverflow();
                        if (UnityEngine.MonoBehaviour.op_Inequality(this.m_TextComponent, null)) {
                            this.m_TextComponent.RegisterDirtyVerticesCallback(Bridge.fn.cacheBind(this, this.MarkGeometryAsDirty));
                            this.m_TextComponent.RegisterDirtyVerticesCallback(Bridge.fn.cacheBind(this, this.UpdateLabel));
                            this.m_TextComponent.RegisterDirtyMaterialCallback(Bridge.fn.cacheBind(this, this.UpdateCaretMaterial));
                        }
                    }
                }
            },
            /**
             * This is an optional ‘empty’ graphic to show that the InputField text field is empty. Note that this ‘empty' graphic still displays even when the InputField is selected (that is; when there is focus on it).
             A placeholder graphic can be used to show subtle hints or make it more obvious that the control is an InputField.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.InputField
             * @function placeholder
             * @type UnityEngine.UI.Graphic
             */
            placeholder: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#placeholder#get", this ); }

                    return this.m_Placeholder;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#placeholder#set", this ); }

                    UnityEngine.UI.SetPropertyUtility.SetClass(UnityEngine.UI.Graphic, Bridge.ref(this, "m_Placeholder"), value);
                }
            },
            /**
             * The custom caret color used if customCaretColor is set.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.InputField
             * @function caretColor
             * @type UnityEngine.Color
             */
            caretColor: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#caretColor#get", this ); }

                    return this.customCaretColor ? this.m_CaretColor.$clone() : this.textComponent.color.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#caretColor#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetColor(Bridge.ref(this, "m_CaretColor"), value.$clone())) {
                        this.MarkGeometryAsDirty();
                    }
                }
            },
            /**
             * Should a custom caret color be used or should the textComponent.color be used.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.InputField
             * @function customCaretColor
             * @type boolean
             */
            customCaretColor: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#customCaretColor#get", this ); }

                    return this.m_CustomCaretColor;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#customCaretColor#set", this ); }

                    if (this.m_CustomCaretColor !== value) {
                        this.m_CustomCaretColor = value;
                        this.MarkGeometryAsDirty();
                    }
                }
            },
            /**
             * The color of the highlight to show which characters are selected.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.InputField
             * @function selectionColor
             * @type UnityEngine.Color
             */
            selectionColor: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#selectionColor#get", this ); }

                    return this.m_SelectionColor.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#selectionColor#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetColor(Bridge.ref(this, "m_SelectionColor"), value.$clone())) {
                        this.MarkGeometryAsDirty();
                    }
                }
            },
            /**
             * The Unity Event to call when editing has ended
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.InputField
             * @function onEndEdit
             * @type UnityEngine.UI.InputField.SubmitEvent
             */
            onEndEdit: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#onEndEdit#get", this ); }

                    return this.m_OnEndEdit;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#onEndEdit#set", this ); }

                    UnityEngine.UI.SetPropertyUtility.SetClass(UnityEngine.UI.InputField.SubmitEvent, Bridge.ref(this, "m_OnEndEdit"), value);
                }
            },
            onValueChange: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#onValueChange#get", this ); }

                    return this.onValueChanged;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#onValueChange#set", this ); }

                    this.onValueChanged = value;
                }
            },
            /**
             * Accessor to the OnChangeEvent.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.InputField
             * @function onValueChanged
             * @type UnityEngine.UI.InputField.OnChangeEvent
             */
            onValueChanged: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#onValueChanged#get", this ); }

                    return this.m_OnValueChanged;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#onValueChanged#set", this ); }

                    UnityEngine.UI.SetPropertyUtility.SetClass(UnityEngine.UI.InputField.OnChangeEvent, Bridge.ref(this, "m_OnValueChanged"), value);
                }
            },
            /**
             * The function to call to validate the input characters.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.InputField
             * @function onValidateInput
             * @type UnityEngine.UI.InputField.OnValidateInput
             */
            onValidateInput: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#onValidateInput#get", this ); }

                    return this.m_OnValidateInput;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#onValidateInput#set", this ); }

                    UnityEngine.UI.SetPropertyUtility.SetClass(Function, Bridge.ref(this, "m_OnValidateInput"), value);
                }
            },
            /**
             * How many characters the input field is limited to. 0 = infinite.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.InputField
             * @function characterLimit
             * @type number
             */
            characterLimit: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#characterLimit#get", this ); }

                    return this.m_CharacterLimit;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#characterLimit#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetStruct(System.Int32, Bridge.ref(this, "m_CharacterLimit"), Math.max(0, value))) {
                        this.UpdateLabel();
                        if (this.m_Keyboard != null) {
                            this.m_Keyboard.characterLimit = value;
                        }
                    }
                }
            },
            /**
             * Specifies the type of the input text content.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.InputField
             * @function contentType
             * @type number
             */
            contentType: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#contentType#get", this ); }

                    return this.m_ContentType;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#contentType#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetStruct(UnityEngine.UI.InputField.ContentType, Bridge.ref(this, "m_ContentType"), value)) {
                        this.EnforceContentType();
                    }
                }
            },
            /**
             * The LineType used by the InputField.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.InputField
             * @function lineType
             * @type number
             */
            lineType: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#lineType#get", this ); }

                    return this.m_LineType;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#lineType#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetStruct(UnityEngine.UI.InputField.LineType, Bridge.ref(this, "m_LineType"), value)) {
                        this.SetToCustomIfContentTypeIsNot([UnityEngine.UI.InputField.ContentType.Standard, UnityEngine.UI.InputField.ContentType.Autocorrected]);
                        this.EnforceTextHOverflow();
                    }
                }
            },
            /**
             * The type of input expected. See InputField.InputType.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.InputField
             * @function inputType
             * @type number
             */
            inputType: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#inputType#get", this ); }

                    return this.m_InputType;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#inputType#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetStruct(UnityEngine.UI.InputField.InputType, Bridge.ref(this, "m_InputType"), value)) {
                        this.SetToCustom();
                    }
                }
            },
            /**
             * The TouchScreenKeyboard being used to edit the Input Field.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.InputField
             * @function touchScreenKeyboard
             * @type UnityEngine.TouchScreenKeyboard
             */
            touchScreenKeyboard: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#touchScreenKeyboard#get", this ); }

                    return this.m_Keyboard;
                }
            },
            /**
             * They type of mobile keyboard that will be used.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.InputField
             * @function keyboardType
             * @type UnityEngine.TouchScreenKeyboardType
             */
            keyboardType: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#keyboardType#get", this ); }

                    return this.m_KeyboardType;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#keyboardType#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetStruct(UnityEngine.TouchScreenKeyboardType, Bridge.ref(this, "m_KeyboardType"), value)) {
                        this.SetToCustom();
                    }
                }
            },
            /**
             * The type of validation to perform on a character
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.InputField
             * @function characterValidation
             * @type number
             */
            characterValidation: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#characterValidation#get", this ); }

                    return this.m_CharacterValidation;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#characterValidation#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetStruct(UnityEngine.UI.InputField.CharacterValidation, Bridge.ref(this, "m_CharacterValidation"), value)) {
                        this.SetToCustom();
                    }
                }
            },
            /**
             * Set the InputField to be read only.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.InputField
             * @function readOnly
             * @type boolean
             */
            readOnly: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#readOnly#get", this ); }

                    return this.m_ReadOnly;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#readOnly#set", this ); }

                    this.m_ReadOnly = value;
                }
            },
            /**
             * If the input field supports multiple lines.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.InputField
             * @function multiLine
             * @type boolean
             */
            multiLine: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#multiLine#get", this ); }

                    return this.m_LineType === UnityEngine.UI.InputField.LineType.MultiLineNewline || this.lineType === UnityEngine.UI.InputField.LineType.MultiLineSubmit;
                }
            },
            /**
             * The character used to hide text in password field.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.InputField
             * @function asteriskChar
             * @type number
             */
            asteriskChar: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#asteriskChar#get", this ); }

                    return this.m_AsteriskChar;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#asteriskChar#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetStruct(System.Char, Bridge.ref(this, "m_AsteriskChar"), value)) {
                        this.UpdateLabel();
                    }
                }
            },
            /**
             * If the InputField was canceled and will revert back to the original text upon DeactivateInputField.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.InputField
             * @function wasCanceled
             * @type boolean
             */
            wasCanceled: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#wasCanceled#get", this ); }

                    return this.m_WasCanceled;
                }
            },
            /**
             * Current position of the cursor.
             Getters are public Setters are protected
             *
             * @instance
             * @protected
             * @memberof UnityEngine.UI.InputField
             * @function caretPositionInternal
             * @type number
             */
            caretPositionInternal: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#caretPositionInternal#get", this ); }

                    return this.m_CaretPosition + this.compositionString.length;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#caretPositionInternal#set", this ); }

                    this.m_CaretPosition = value;
                    this.ClampPos(Bridge.ref(this, "m_CaretPosition"));
                }
            },
            caretSelectPositionInternal: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#caretSelectPositionInternal#get", this ); }

                    return this.m_CaretSelectPosition + this.compositionString.length;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#caretSelectPositionInternal#set", this ); }

                    this.m_CaretSelectPosition = value;
                    this.ClampPos(Bridge.ref(this, "m_CaretSelectPosition"));
                }
            },
            hasSelection$1: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#hasSelection$1#get", this ); }

                    return this.caretPositionInternal !== this.caretSelectPositionInternal;
                }
            },
            /**
             * Get: Returns the focus position as thats the position that moves around even during selection.
             Set: Set both the anchor and focus position such that a selection doesn't happen
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.InputField
             * @function caretPosition
             * @type number
             */
            caretPosition: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#caretPosition#get", this ); }

                    return this.m_CaretSelectPosition + this.compositionString.length;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#caretPosition#set", this ); }

                    this.selectionAnchorPosition = value;
                    this.selectionFocusPosition = value;
                }
            },
            /**
             * The beginning point of the selection.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.InputField
             * @function selectionAnchorPosition
             * @type number
             */
            selectionAnchorPosition: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#selectionAnchorPosition#get", this ); }

                    return this.m_CaretPosition + this.compositionString.length;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#selectionAnchorPosition#set", this ); }

                    if (this.compositionString.length !== 0) {
                        return;
                    }

                    this.m_CaretPosition = value;
                    this.ClampPos(Bridge.ref(this, "m_CaretPosition"));
                }
            },
            /**
             * The end point of the selection.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.InputField
             * @function selectionFocusPosition
             * @type number
             */
            selectionFocusPosition: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#selectionFocusPosition#get", this ); }

                    return this.m_CaretSelectPosition + this.compositionString.length;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#selectionFocusPosition#set", this ); }

                    if (this.compositionString.length !== 0) {
                        return;
                    }

                    this.m_CaretSelectPosition = value;
                    this.ClampPos(Bridge.ref(this, "m_CaretSelectPosition"));
                }
            },
            /**
             * See ILayoutElement.minWidth.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.InputField
             * @function minWidth
             * @type number
             */
            minWidth: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#minWidth#get", this ); }

                    return 0;
                }
            },
            /**
             * Get the displayed with of all input characters.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.InputField
             * @function preferredWidth
             * @type number
             */
            preferredWidth: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#preferredWidth#get", this ); }

                    return Bridge.getDefaultValue(System.Single);
                }
            },
            /**
             * See ILayoutElement.flexibleWidth.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.InputField
             * @function flexibleWidth
             * @type number
             */
            flexibleWidth: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#flexibleWidth#get", this ); }

                    return -1;
                }
            },
            /**
             * See ILayoutElement.minHeight.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.InputField
             * @function minHeight
             * @type number
             */
            minHeight: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#minHeight#get", this ); }

                    return 0;
                }
            },
            /**
             * Get the height of all the text if constrained to the height of the RectTransform.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.InputField
             * @function preferredHeight
             * @type number
             */
            preferredHeight: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#preferredHeight#get", this ); }

                    return Bridge.getDefaultValue(System.Single);
                }
            },
            /**
             * See ILayoutElement.flexibleHeight.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.InputField
             * @function flexibleHeight
             * @type number
             */
            flexibleHeight: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#flexibleHeight#get", this ); }

                    return -1;
                }
            },
            /**
             * See ILayoutElement.layoutPriority.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.InputField
             * @function layoutPriority
             * @type number
             */
            layoutPriority: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#layoutPriority#get", this ); }

                    return 1;
                }
            }
        },
        alias: [
            "OnBeginDrag", "UnityEngine$EventSystems$IBeginDragHandler$OnBeginDrag",
            "OnDrag", "UnityEngine$EventSystems$IDragHandler$OnDrag",
            "OnEndDrag", "UnityEngine$EventSystems$IEndDragHandler$OnEndDrag",
            "OnPointerDown", "UnityEngine$EventSystems$IPointerDownHandler$OnPointerDown",
            "OnUpdateSelected", "UnityEngine$EventSystems$IUpdateSelectedHandler$OnUpdateSelected",
            "Rebuild", "UnityEngine$UI$ICanvasElement$Rebuild",
            "LayoutComplete", "UnityEngine$UI$ICanvasElement$LayoutComplete",
            "GraphicUpdateComplete", "UnityEngine$UI$ICanvasElement$GraphicUpdateComplete",
            "OnSelect", "UnityEngine$EventSystems$ISelectHandler$OnSelect",
            "OnPointerClick", "UnityEngine$EventSystems$IPointerClickHandler$OnPointerClick",
            "OnDeselect", "UnityEngine$EventSystems$IDeselectHandler$OnDeselect",
            "OnSubmit", "UnityEngine$EventSystems$ISubmitHandler$OnSubmit",
            "CalculateLayoutInputHorizontal", "UnityEngine$UI$ILayoutElement$CalculateLayoutInputHorizontal",
            "CalculateLayoutInputVertical", "UnityEngine$UI$ILayoutElement$CalculateLayoutInputVertical",
            "minWidth", "UnityEngine$UI$ILayoutElement$minWidth",
            "preferredWidth", "UnityEngine$UI$ILayoutElement$preferredWidth",
            "flexibleWidth", "UnityEngine$UI$ILayoutElement$flexibleWidth",
            "minHeight", "UnityEngine$UI$ILayoutElement$minHeight",
            "preferredHeight", "UnityEngine$UI$ILayoutElement$preferredHeight",
            "flexibleHeight", "UnityEngine$UI$ILayoutElement$flexibleHeight",
            "layoutPriority", "UnityEngine$UI$ILayoutElement$layoutPriority",
            "IsDestroyed", "UnityEngine$UI$ICanvasElement$IsDestroyed",
            "transform", "UnityEngine$UI$ICanvasElement$transform"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#init", this ); }

                this.m_CaretColor = new UnityEngine.Color();
                this.m_SelectionColor = new UnityEngine.Color();
                this.m_ContentType = UnityEngine.UI.InputField.ContentType.Standard;
                this.m_InputType = UnityEngine.UI.InputField.InputType.Standard;
                this.m_AsteriskChar = 42;
                this.m_KeyboardType = UnityEngine.TouchScreenKeyboardType.Default;
                this.m_LineType = UnityEngine.UI.InputField.LineType.SingleLine;
                this.m_HideMobileInput = false;
                this.m_CharacterValidation = UnityEngine.UI.InputField.CharacterValidation.None;
                this.m_CharacterLimit = 0;
                this.m_OnEndEdit = new UnityEngine.UI.InputField.SubmitEvent();
                this.m_OnValueChanged = new UnityEngine.UI.InputField.OnChangeEvent();
                this.m_CaretColor = new pc.Color( 0.196078435, 0.196078435, 0.196078435, 1.0 );
                this.m_CustomCaretColor = false;
                this.m_SelectionColor = new pc.Color( 0.65882355, 0.807843149, 1.0, 0.7529412 );
                this.m_Text = "";
                this.m_CaretBlinkRate = 0.85;
                this.m_CaretWidth = 1;
                this.m_ReadOnly = false;
                this.m_CaretPosition = 0;
                this.m_CaretSelectPosition = 0;
                this.m_PreventFontCallback = false;
                this.m_AllowInput = false;
                this.m_ShouldActivateNextUpdate = false;
                this.m_UpdateDrag = false;
                this.m_DragPositionOutOfBounds = false;
                this.m_BlinkStartTime = 0.0;
                this.m_DrawStart = 0;
                this.m_DrawEnd = 0;
                this.m_OriginalText = "";
                this.m_WasCanceled = false;
                this.m_HasDoneFocusTransition = false;
                this.m_ProcessingEvent = ( pc.generateStubProxy( 'UnityEngine.Event' ) );
                this.corners = System.Array.init(4, function (){
                    return new UnityEngine.Vector3();
                }, UnityEngine.Vector3);
                this.cornersScreen = System.Array.init(4, function (){
                    return new UnityEngine.Vector3();
                }, UnityEngine.Vector3);
            },
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#ctor", this ); }

                this.$initialize();
                UnityEngine.UI.Selectable.ctor.call(this);
                this.EnforceTextHOverflow();
            }
        },
        methods: {
            /*UnityEngine.UI.InputField.ClampPos start.*/
            /**
             * Clamp a value (by reference) between 0 and the current text length.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.InputField
             * @memberof UnityEngine.UI.InputField
             * @param   {System.Int32}    pos    The input position to be clampped
             * @return  {void}
             */
            ClampPos: function (pos) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#ClampPos", this ); }

                if (pos.v < 0) {
                    pos.v = 0;
                } else if (pos.v > this.text.length) {
                    pos.v = this.text.length;
                }
            },
            /*UnityEngine.UI.InputField.ClampPos end.*/

            /*UnityEngine.UI.InputField.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#OnEnable", this ); }

                UnityEngine.UI.Selectable.prototype.OnEnable.call(this);
                if (this.m_Text == null) {
                    this.m_Text = "";
                }

                this.m_DrawStart = 0;
                this.m_DrawEnd = this.m_Text.length;

                // If we have a cached renderer then we had OnDisable called so just restore the material.
                if (UnityEngine.Component.op_Inequality(this.m_CachedInputRenderer, null)) {
                    this.m_CachedInputRenderer.SetMaterial$1(this.m_TextComponent.GetModifiedMaterial(UnityEngine.UI.Graphic.defaultGraphicMaterial), UnityEngine.Texture2D.whiteTexture);
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.m_TextComponent, null)) {
                    this.m_TextComponent.RegisterDirtyVerticesCallback(Bridge.fn.cacheBind(this, this.MarkGeometryAsDirty));
                    this.m_TextComponent.RegisterDirtyVerticesCallback(Bridge.fn.cacheBind(this, this.UpdateLabel));
                    this.m_TextComponent.RegisterDirtyMaterialCallback(Bridge.fn.cacheBind(this, this.UpdateCaretMaterial));
                    this.UpdateLabel();
                }

                this.OnEnableWebInput();
            },
            /*UnityEngine.UI.InputField.OnEnable end.*/

            /*UnityEngine.UI.InputField.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#OnDisable", this ); }

                // the coroutine will be terminated, so this will ensure it restarts when we are next activated
                this.m_BlinkCoroutine = null;

                this.DeactivateInputField();
                if (UnityEngine.MonoBehaviour.op_Inequality(this.m_TextComponent, null)) {
                    this.m_TextComponent.UnregisterDirtyVerticesCallback(Bridge.fn.cacheBind(this, this.MarkGeometryAsDirty));
                    this.m_TextComponent.UnregisterDirtyVerticesCallback(Bridge.fn.cacheBind(this, this.UpdateLabel));
                    this.m_TextComponent.UnregisterDirtyMaterialCallback(Bridge.fn.cacheBind(this, this.UpdateCaretMaterial));
                }

                UnityEngine.UI.CanvasUpdateRegistry.UnRegisterCanvasElementForRebuild(this);

                // Clear needs to be called otherwise sync never happens as the object is disabled.
                if (UnityEngine.Component.op_Inequality(this.m_CachedInputRenderer, null)) {
                    this.m_CachedInputRenderer.Clear();
                }

                if (this.m_Mesh != null) {
                    UnityEngine.Object.DestroyImmediate(this.m_Mesh);
                }

                this.m_Mesh = null;

                UnityEngine.UI.Selectable.prototype.OnDisable.call(this);
                this.OnDisableWebInput();
            },
            /*UnityEngine.UI.InputField.OnDisable end.*/

            /*UnityEngine.UI.InputField.CaretBlink start.*/
            CaretBlink: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#CaretBlink", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    blinkPeriod,
                    blinkState,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    // Always ensure caret is initially visible since it can otherwise be confusing for a moment.
                                        this.m_CaretVisible = true;
                                        $enumerator.current = null;
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    if ( this.isFocused && this.m_CaretBlinkRate > 0 ) {
                                            $step = 2;
                                            continue;
                                        } 
                                        $step = 4;
                                        continue;
                                }
                                case 2: {
                                    // the blink rate is expressed as a frequency
                                        blinkPeriod = 1.0 / this.m_CaretBlinkRate;

                                        // the caret should be ON if we are in the first half of the blink period
                                        blinkState = (UnityEngine.Time.unscaledTime - this.m_BlinkStartTime) % blinkPeriod < blinkPeriod / 2;
                                        if (this.m_CaretVisible !== blinkState) {
                                            this.m_CaretVisible = blinkState;
                                            if (!this.hasSelection$1) {
                                                this.MarkGeometryAsDirty();
                                            }
                                        }

                                        // Then wait again.
                                        $enumerator.current = null;
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    
                                        $step = 1;
                                        continue;
                                }
                                case 4: {
                                    this.m_BlinkCoroutine = null;

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*UnityEngine.UI.InputField.CaretBlink end.*/

            /*UnityEngine.UI.InputField.SetCaretVisible start.*/
            SetCaretVisible: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#SetCaretVisible", this ); }

                if (!this.m_AllowInput) {
                    return;
                }

                this.m_CaretVisible = true;
                this.m_BlinkStartTime = UnityEngine.Time.unscaledTime;
                this.SetCaretActive();
            },
            /*UnityEngine.UI.InputField.SetCaretVisible end.*/

            /*UnityEngine.UI.InputField.SetCaretActive start.*/
            SetCaretActive: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#SetCaretActive", this ); }

                if (!this.m_AllowInput) {
                    return;
                }

                if (this.m_CaretBlinkRate > 0.0) {
                    if (this.m_BlinkCoroutine == null) {
                        this.m_BlinkCoroutine = this.StartCoroutine$1(this.CaretBlink());
                    }
                } else {
                    this.m_CaretVisible = true;
                }
            },
            /*UnityEngine.UI.InputField.SetCaretActive end.*/

            /*UnityEngine.UI.InputField.UpdateCaretMaterial start.*/
            UpdateCaretMaterial: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#UpdateCaretMaterial", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.m_TextComponent, null) && UnityEngine.Component.op_Inequality(this.m_CachedInputRenderer, null)) {
                    this.m_CachedInputRenderer.SetMaterial$1(this.m_TextComponent.GetModifiedMaterial(UnityEngine.UI.Graphic.defaultGraphicMaterial), UnityEngine.Texture2D.whiteTexture);
                }
            },
            /*UnityEngine.UI.InputField.UpdateCaretMaterial end.*/

            /*UnityEngine.UI.InputField.OnFocus start.*/
            /**
             * Focus the input field initializing properties.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.InputField
             * @memberof UnityEngine.UI.InputField
             * @return  {void}
             */
            OnFocus: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#OnFocus", this ); }

                this.SelectAll();
            },
            /*UnityEngine.UI.InputField.OnFocus end.*/

            /*UnityEngine.UI.InputField.SelectAll start.*/
            /**
             * Highlight the whole InputField.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.InputField
             * @memberof UnityEngine.UI.InputField
             * @return  {void}
             */
            SelectAll: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#SelectAll", this ); }

                this.caretPositionInternal = this.text.length;
                this.caretSelectPositionInternal = 0;
            },
            /*UnityEngine.UI.InputField.SelectAll end.*/

            /*UnityEngine.UI.InputField.MoveTextEnd start.*/
            /**
             * Move the caret index to end of text.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.InputField
             * @memberof UnityEngine.UI.InputField
             * @param   {boolean}    shift    Only move the selection position to facilate selection
             * @return  {void}
             */
            MoveTextEnd: function (shift) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#MoveTextEnd", this ); }

                var position = this.text.length;

                if (shift) {
                    this.caretSelectPositionInternal = position;
                } else {
                    this.caretPositionInternal = position;
                    this.caretSelectPositionInternal = this.caretPositionInternal;
                }

                this.UpdateLabel();
            },
            /*UnityEngine.UI.InputField.MoveTextEnd end.*/

            /*UnityEngine.UI.InputField.MoveTextStart start.*/
            /**
             * Move the caret index to start of text.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.InputField
             * @memberof UnityEngine.UI.InputField
             * @param   {boolean}    shift    Only move the selection position to facilate selection
             * @return  {void}
             */
            MoveTextStart: function (shift) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#MoveTextStart", this ); }

                var position = 0;

                if (shift) {
                    this.caretSelectPositionInternal = position;
                } else {
                    this.caretPositionInternal = position;
                    this.caretSelectPositionInternal = this.caretPositionInternal;
                }

                this.UpdateLabel();
            },
            /*UnityEngine.UI.InputField.MoveTextStart end.*/

            /*UnityEngine.UI.InputField.InPlaceEditing start.*/
            InPlaceEditing: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#InPlaceEditing", this ); }

                return !UnityEngine.TouchScreenKeyboard.isSupported;
            },
            /*UnityEngine.UI.InputField.InPlaceEditing end.*/

            /*UnityEngine.UI.InputField.UpdateCaretFromKeyboard start.*/
            UpdateCaretFromKeyboard: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#UpdateCaretFromKeyboard", this ); }

                var selectionRange = this.m_Keyboard.selection.$clone();

                var selectionStart = selectionRange.start;
                var selectionEnd = selectionRange.end;

                var caretChanged = false;

                if (this.caretPositionInternal !== selectionStart) {
                    caretChanged = true;
                    this.caretPositionInternal = selectionStart;
                }

                if (this.caretSelectPositionInternal !== selectionEnd) {
                    this.caretSelectPositionInternal = selectionEnd;
                    caretChanged = true;
                }

                if (caretChanged) {
                    this.m_BlinkStartTime = UnityEngine.Time.unscaledTime;

                    this.UpdateLabel();
                }
            },
            /*UnityEngine.UI.InputField.UpdateCaretFromKeyboard end.*/

            /*UnityEngine.UI.InputField.LateUpdate start.*/
            /**
             * Update the text based on input.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.InputField
             * @memberof UnityEngine.UI.InputField
             * @return  {void}
             */
            LateUpdate: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#LateUpdate", this ); }

                var $t;
                // Only activate if we are not already activated.
                if (this.m_ShouldActivateNextUpdate) {
                    if (!this.isFocused) {
                        this.ActivateInputFieldInternal();
                        this.m_ShouldActivateNextUpdate = false;
                        return;
                    }

                    // Reset as we are already activated.
                    this.m_ShouldActivateNextUpdate = false;
                }

                if (this.InPlaceEditing() || !this.isFocused) {
                    return;
                }

                this.AssignPositioningIfNeeded();

                if (this.m_Keyboard == null || this.m_Keyboard.status !== UnityEngine.TouchScreenKeyboard.Status.Visible) {
                    if (this.m_Keyboard != null) {
                        if (!this.m_ReadOnly) {
                            this.text = this.m_Keyboard.text;
                        }

                        if (this.m_Keyboard.status === UnityEngine.TouchScreenKeyboard.Status.Canceled) {
                            this.m_WasCanceled = true;
                        }
                    }

                    this.OnDeselect(null);
                    return;
                }

                this.m_Keyboard.Update(); //[EN-1289] InputField check api. Additional logic: MAKE SURE ARROWS ARE HANDLED ON PC

                var val = this.m_Keyboard.text;

                if (!Bridge.referenceEquals(this.m_Text, val)) {
                    if (this.m_ReadOnly) {
                        this.m_Keyboard.text = this.m_Text;
                    } else {
                        this.m_Text = "";

                        for (var i = 0; i < val.length; ++i) {
                            var c = val.charCodeAt(i);

                            if (c === 13 || c === 3) {
                                c = 10;
                            }

                            if (!Bridge.staticEquals(this.onValidateInput, null)) {
                                c = this.onValidateInput(this.m_Text, this.m_Text.length, c);
                            } else if (this.characterValidation !== UnityEngine.UI.InputField.CharacterValidation.None) {
                                c = this.Validate(this.m_Text, this.m_Text.length, c);
                            }

                            if (this.lineType === UnityEngine.UI.InputField.LineType.MultiLineSubmit && c === 10) {
                                this.m_Keyboard.text = this.m_Text;

                                this.OnDeselect(null);
                                return;
                            }

                            if (c !== 0) {
                                this.m_Text = (this.m_Text || "") + String.fromCharCode(c);
                            }
                        }

                        if (this.characterLimit > 0 && this.m_Text.length > this.characterLimit) {
                            this.m_Text = this.m_Text.substr(0, this.characterLimit);
                        }

                        if (this.m_Keyboard.canGetSelection) {
                            this.UpdateCaretFromKeyboard();
                        } else {
                            this.caretPositionInternal = ($t = this.m_Text.length, this.caretSelectPositionInternal = $t, $t);
                        }

                        // Set keyboard text before updating label, as we might have changed it with validation
                        // and update label will take the old value from keyboard if we don't change it here
                        if (!Bridge.referenceEquals(this.m_Text, val)) {
                            this.m_Keyboard.text = this.m_Text;
                        }

                        this.SendOnValueChangedAndUpdateLabel();
                    }
                } else if (this.m_HideMobileInput && this.m_Keyboard.canSetSelection) {
                    this.m_Keyboard.selection = new UnityEngine.RangeInt.$ctor1(this.caretPositionInternal, this.caretSelectPositionInternal - this.caretPositionInternal);
                } else if (this.m_Keyboard.canGetSelection) {
                    // } else if ( m_Keyboard.canGetSelection && !m_HideMobileInput ) { //[EN-1289] InputField check api. this is used to select readonly +375 field
                    this.UpdateCaretFromKeyboard();
                }

                if (this.m_Keyboard.status !== UnityEngine.TouchScreenKeyboard.Status.Visible) {
                    if (this.m_Keyboard.status === UnityEngine.TouchScreenKeyboard.Status.Canceled) {
                        this.m_WasCanceled = true;
                    }

                    this.OnDeselect(null);
                }
            },
            /*UnityEngine.UI.InputField.LateUpdate end.*/

            /*UnityEngine.UI.InputField.GetUnclampedCharacterLineFromPosition start.*/
            GetUnclampedCharacterLineFromPosition: function (pos, generator) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#GetUnclampedCharacterLineFromPosition", this ); }

                if (!this.multiLine) {
                    return 0;
                }

                // transform y to local scale
                var y = pos.y * this.m_TextComponent.pixelsPerUnit;
                var lastBottomY = 0.0;

                for (var i = 0; i < generator.lineCount; ++i) {
                    var topY = generator.lines.getItem(i).topY;
                    var bottomY = topY - generator.lines.getItem(i).height;

                    // pos is somewhere in the leading above this line
                    if (y > topY) {
                        // determine which line we're closer to
                        var leading = topY - lastBottomY;
                        if (y > topY - 0.5 * leading) {
                            return i - 1;
                        } else {
                            return i;
                        }
                    }

                    if (y > bottomY) {
                        return i;
                    }

                    lastBottomY = bottomY;
                }

                // Position is after last line.
                return generator.lineCount;
            },
            /*UnityEngine.UI.InputField.GetUnclampedCharacterLineFromPosition end.*/

            /*UnityEngine.UI.InputField.GetCharacterIndexFromPosition start.*/
            /**
             * Given an input position in local space on the Text return the index for the selection cursor at this position.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.InputField
             * @memberof UnityEngine.UI.InputField
             * @param   {UnityEngine.Vector2}    pos    Mouse position.
             * @return  {number}                        Character index with in value.
             */
            GetCharacterIndexFromPosition: function (pos) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#GetCharacterIndexFromPosition", this ); }

                var gen = this.m_TextComponent.cachedTextGenerator;

                if (gen.lineCount === 0) {
                    return 0;
                }

                var line = this.GetUnclampedCharacterLineFromPosition(pos.$clone(), gen);
                if (line < 0) {
                    return 0;
                }

                if (line >= gen.lineCount) {
                    return gen.characterCountVisible;
                }

                var startCharIndex = gen.lines.getItem(line).startCharIdx;
                var endCharIndex = UnityEngine.UI.InputField.GetLineEndPosition(gen, line);

                for (var i = startCharIndex; i < endCharIndex; i++) {
                    if (i >= gen.characterCountVisible) {
                        break;
                    }

                    var charInfo = gen.characters.getItem(i);
                    var charPos = charInfo.cursorPos.$clone().scale( 1.0 / ( this.m_TextComponent.pixelsPerUnit ) );

                    var distToCharStart = pos.x - charPos.x;
                    var distToCharEnd = charPos.x + charInfo.charWidth / this.m_TextComponent.pixelsPerUnit - pos.x;
                    if (distToCharStart < distToCharEnd) {
                        return i;
                    }
                }

                return endCharIndex;
            },
            /*UnityEngine.UI.InputField.GetCharacterIndexFromPosition end.*/

            /*UnityEngine.UI.InputField.MayDrag start.*/
            MayDrag: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#MayDrag", this ); }

                return this.IsActive() && this.IsInteractable() && eventData.button === UnityEngine.EventSystems.PointerEventData.InputButton.Left && UnityEngine.MonoBehaviour.op_Inequality(this.m_TextComponent, null) && (this.m_Keyboard == null || this.m_HideMobileInput);
            },
            /*UnityEngine.UI.InputField.MayDrag end.*/

            /*UnityEngine.UI.InputField.OnBeginDrag start.*/
            /**
             * Capture the OnBeginDrag callback from the EventSystem and ensure we should listen to the drag events to follow.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.InputField
             * @memberof UnityEngine.UI.InputField
             * @param   {UnityEngine.EventSystems.PointerEventData}    eventData    The data passed by the EventSystem
             * @return  {void}
             */
            OnBeginDrag: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#OnBeginDrag", this ); }

                if (!this.MayDrag(eventData)) {
                    return;
                }

                this.m_UpdateDrag = true;
            },
            /*UnityEngine.UI.InputField.OnBeginDrag end.*/

            /*UnityEngine.UI.InputField.OnDrag start.*/
            /**
             * If we are able to drag, try and select the character range underneath the bounding rect.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.InputField
             * @memberof UnityEngine.UI.InputField
             * @param   {UnityEngine.EventSystems.PointerEventData}    eventData
             * @return  {void}
             */
            OnDrag: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#OnDrag", this ); }

                if (!this.MayDrag(eventData)) {
                    return;
                }

                var localMousePos = { v : new UnityEngine.Vector2() };
                UnityEngine.RectTransformUtility.ScreenPointToLocalPointInRectangle(this.textComponent.rectTransform, eventData.position, eventData.pressEventCamera, localMousePos);
                this.caretSelectPositionInternal = this.GetCharacterIndexFromPosition(localMousePos.v.$clone()) + this.m_DrawStart;

                this.MarkGeometryAsDirty();

                this.m_DragPositionOutOfBounds = !UnityEngine.RectTransformUtility.RectangleContainsScreenPoint$1(this.textComponent.rectTransform, eventData.position, eventData.pressEventCamera);
                if (this.m_DragPositionOutOfBounds && this.m_DragCoroutine == null) {
                    this.m_DragCoroutine = this.StartCoroutine$1(this.MouseDragOutsideRect(eventData));
                }

                eventData.Use();
            },
            /*UnityEngine.UI.InputField.OnDrag end.*/

            /*UnityEngine.UI.InputField.MouseDragOutsideRect start.*/
            MouseDragOutsideRect: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#MouseDragOutsideRect", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    localMousePos,
                    rect,
                    delay,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if ( this.m_UpdateDrag && this.m_DragPositionOutOfBounds ) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 3;
                                        continue;
                                }
                                case 1: {
                                    localMousePos = { v : new UnityEngine.Vector2() };
                                        UnityEngine.RectTransformUtility.ScreenPointToLocalPointInRectangle(this.textComponent.rectTransform, eventData.position, eventData.pressEventCamera, localMousePos);

                                        rect = this.textComponent.rectTransform.rect.$clone();

                                        if (this.multiLine) {
                                            if (localMousePos.v.y > rect.yMax) {
                                                this.MoveUp$1(true, true);
                                            } else if (localMousePos.v.y < rect.yMin) {
                                                this.MoveDown$1(true, true);
                                            }
                                        } else {
                                            if (localMousePos.v.x < rect.xMin) {
                                                this.MoveLeft(true, false);
                                            } else if (localMousePos.v.x > rect.xMax) {
                                                this.MoveRight(true, false);
                                            }
                                        }

                                        this.UpdateLabel();
                                        delay = this.multiLine ? UnityEngine.UI.InputField.kVScrollSpeed : UnityEngine.UI.InputField.kHScrollSpeed;
                                        if (this.m_WaitForSecondsRealtime == null) {
                                            this.m_WaitForSecondsRealtime = new UnityEngine.WaitForSecondsRealtime(delay);
                                        } else {
                                            this.m_WaitForSecondsRealtime.waitTime = delay;
                                        }

                                        $enumerator.current = this.m_WaitForSecondsRealtime;
                                        $step = 2;
                                        return true;
                                }
                                case 2: {
                                    
                                        $step = 0;
                                        continue;
                                }
                                case 3: {
                                    this.m_DragCoroutine = null;

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*UnityEngine.UI.InputField.MouseDragOutsideRect end.*/

            /*UnityEngine.UI.InputField.OnEndDrag start.*/
            /**
             * Capture the OnEndDrag callback from the EventSystem and cancel the listening of drag events.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.InputField
             * @memberof UnityEngine.UI.InputField
             * @param   {UnityEngine.EventSystems.PointerEventData}    eventData    The eventData sent by the EventSystem.
             * @return  {void}
             */
            OnEndDrag: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#OnEndDrag", this ); }

                if (!this.MayDrag(eventData)) {
                    return;
                }

                this.m_UpdateDrag = false;
            },
            /*UnityEngine.UI.InputField.OnEndDrag end.*/

            /*UnityEngine.UI.InputField.OnPointerDown start.*/
            OnPointerDown: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#OnPointerDown", this ); }

                var $t;
                if (!this.MayDrag(eventData)) {
                    return;
                }

                UnityEngine.EventSystems.EventSystem.current.SetSelectedGameObject$1(this.gameObject, eventData);

                var hadFocusBefore = this.m_AllowInput;
                UnityEngine.UI.Selectable.prototype.OnPointerDown.call(this, eventData);

                if (!this.InPlaceEditing()) {
                    if (this.m_Keyboard == null || !this.m_Keyboard.active) {
                        this.OnSelect(eventData);
                        return;
                    }
                }

                // Only set caret position if we didn't just get focus now.
                // Otherwise it will overwrite the select all on focus.
                if (hadFocusBefore) {
                    var localMousePos = { v : new UnityEngine.Vector2() };
                    UnityEngine.RectTransformUtility.ScreenPointToLocalPointInRectangle(this.textComponent.rectTransform, eventData.position, eventData.pressEventCamera, localMousePos);
                    this.caretSelectPositionInternal = ($t = this.GetCharacterIndexFromPosition(localMousePos.v.$clone()) + this.m_DrawStart, this.caretPositionInternal = $t, $t);
                }

                this.UpdateLabel();
                eventData.Use();
            },
            /*UnityEngine.UI.InputField.OnPointerDown end.*/

            /*UnityEngine.UI.InputField.KeyPressed start.*/
            /**
             * Process the Event and perform the appropriate action for that key.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.InputField
             * @memberof UnityEngine.UI.InputField
             * @param   {( pc.stubProxy.generateConstructorFor( 'UnityEngine.Event' ) )}    evt    The Event that is currently being processed.
             * @return  {number}                                                                   If we should continue processing events or we have hit an end condition.
             */
            KeyPressed: function (evt) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#KeyPressed", this ); }

                var currentEventModifiers = evt.reportProperty( 'UnityEngine.Event.modifiers', 0 );
                UnityEngine.Debug.LogWarning$1("Not Implemented In Luna");
                var ctrl = false; //SystemInfo.operatingSystemFamily == OperatingSystemFamily.MacOSX ? (currentEventModifiers & EventModifiers.Command) != 0 : (currentEventModifiers & EventModifiers.Control) != 0;
                var shift = (currentEventModifiers & UnityEngine.EventModifiers.Shift) !== 0;
                var alt = (currentEventModifiers & UnityEngine.EventModifiers.Alt) !== 0;
                var ctrlOnly = ctrl && !alt && !shift;

                switch (evt.reportProperty( 'UnityEngine.Event.keyCode', 0 )) {
                    case UnityEngine.KeyCode.Backspace: 
                        {
                            this.Backspace();
                            return UnityEngine.UI.InputField.EditState.Continue;
                        }
                    case UnityEngine.KeyCode.Delete: 
                        {
                            this.ForwardSpace();
                            return UnityEngine.UI.InputField.EditState.Continue;
                        }
                    case UnityEngine.KeyCode.Home: 
                        {
                            this.MoveTextStart(shift);
                            return UnityEngine.UI.InputField.EditState.Continue;
                        }
                    case UnityEngine.KeyCode.End: 
                        {
                            this.MoveTextEnd(shift);
                            return UnityEngine.UI.InputField.EditState.Continue;
                        }
                    case UnityEngine.KeyCode.A: 
                        {
                            if (ctrlOnly) {
                                this.SelectAll();
                                return UnityEngine.UI.InputField.EditState.Continue;
                            }

                            break;
                        }
                    case UnityEngine.KeyCode.C: 
                        {
                            if (ctrlOnly) {
                                if (this.inputType !== UnityEngine.UI.InputField.InputType.Password) {
                                    UnityEngine.UI.InputField.clipboard = this.GetSelectedString();
                                } else {
                                    UnityEngine.UI.InputField.clipboard = "";
                                }

                                return UnityEngine.UI.InputField.EditState.Continue;
                            }

                            break;
                        }
                    case UnityEngine.KeyCode.V: 
                        {
                            if (ctrlOnly) {
                                this.Append$1(UnityEngine.UI.InputField.clipboard);
                                return UnityEngine.UI.InputField.EditState.Continue;
                            }

                            break;
                        }
                    case UnityEngine.KeyCode.X: 
                        {
                            if (ctrlOnly) {
                                if (this.inputType !== UnityEngine.UI.InputField.InputType.Password) {
                                    UnityEngine.UI.InputField.clipboard = this.GetSelectedString();
                                } else {
                                    UnityEngine.UI.InputField.clipboard = "";
                                }

                                this.Delete();
                                this.SendOnValueChangedAndUpdateLabel();
                                return UnityEngine.UI.InputField.EditState.Continue;
                            }

                            break;
                        }
                    case UnityEngine.KeyCode.LeftArrow: 
                        {
                            this.MoveLeft(shift, ctrl);
                            return UnityEngine.UI.InputField.EditState.Continue;
                        }
                    case UnityEngine.KeyCode.RightArrow: 
                        {
                            this.MoveRight(shift, ctrl);
                            return UnityEngine.UI.InputField.EditState.Continue;
                        }
                    case UnityEngine.KeyCode.UpArrow: 
                        {
                            this.MoveUp(shift);
                            return UnityEngine.UI.InputField.EditState.Continue;
                        }
                    case UnityEngine.KeyCode.DownArrow: 
                        {
                            this.MoveDown(shift);
                            return UnityEngine.UI.InputField.EditState.Continue;
                        }
                    case UnityEngine.KeyCode.Return: 
                    case UnityEngine.KeyCode.KeypadEnter: 
                        {
                            if (this.lineType !== UnityEngine.UI.InputField.LineType.MultiLineNewline) {
                                return UnityEngine.UI.InputField.EditState.Finish;
                            }

                            break;
                        }
                    case UnityEngine.KeyCode.Escape: 
                        {
                            this.m_WasCanceled = true;
                            return UnityEngine.UI.InputField.EditState.Finish;
                        }
                }

                var c = evt.reportProperty( 'UnityEngine.Event.character', null );
                // Don't allow return chars or tabulator key to be entered into single line fields.
                if (!this.multiLine && (c === 9 || c === 13 || c === 10)) {
                    return UnityEngine.UI.InputField.EditState.Continue;
                }

                // Convert carriage return and end-of-text characters to newline.
                if (c === 13 || c === 3) {
                    c = 10;
                }

                if (this.IsValidChar(c)) {
                    this.Append(c);
                }

                if (c === 0) {
                    if (this.compositionString.length > 0) {
                        this.UpdateLabel();
                    }
                }

                return UnityEngine.UI.InputField.EditState.Continue;
            },
            /*UnityEngine.UI.InputField.KeyPressed end.*/

            /*UnityEngine.UI.InputField.IsValidChar start.*/
            IsValidChar: function (c) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#IsValidChar", this ); }

                // Delete key on mac
                if (c === 127) {
                    return false;
                }

                // Accept newline and tab
                if (c === 9 || c === 10) {
                    return true;
                }

                /* return m_TextComponent.font.HasCharacter(c);*/
                return true;
            },
            /*UnityEngine.UI.InputField.IsValidChar end.*/

            /*UnityEngine.UI.InputField.ProcessEvent start.*/
            /**
             * Helper function to allow separate events to be processed by the InputField.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.InputField
             * @memberof UnityEngine.UI.InputField
             * @param   {( pc.stubProxy.generateConstructorFor( 'UnityEngine.Event' ) )}    e    The Event to process
             * @return  {void}
             */
            ProcessEvent: function (e) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#ProcessEvent", this ); }

                this.KeyPressed(e);
            },
            /*UnityEngine.UI.InputField.ProcessEvent end.*/

            /*UnityEngine.UI.InputField.OnUpdateSelected start.*/
            /**
             * What to do when the event system sends a Update selected Event.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.InputField
             * @memberof UnityEngine.UI.InputField
             * @param   {UnityEngine.EventSystems.BaseEventData}    eventData    The data on which to process.
             * @return  {void}
             */
            OnUpdateSelected: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#OnUpdateSelected", this ); }

                if (!this.isFocused) {
                    return;
                }

                var consumedEvent = false;
                while (pc.stubProxy.reportMethod( 'UnityEngine.Event.PopEvent', false )) {
                    if (this.m_ProcessingEvent.reportProperty( 'UnityEngine.Event.rawType', 0 ) === UnityEngine.EventType.KeyDown) {
                        consumedEvent = true;
                        var shouldContinue = this.KeyPressed(this.m_ProcessingEvent);
                        if (shouldContinue === UnityEngine.UI.InputField.EditState.Finish) {
                            this.DeactivateInputField();
                            break;
                        }
                    }

                    switch (this.m_ProcessingEvent.reportProperty( 'UnityEngine.Event.type', 0 )) {
                        case UnityEngine.EventType.ValidateCommand: 
                        case UnityEngine.EventType.ExecuteCommand: 
                            switch (this.m_ProcessingEvent.reportProperty( 'UnityEngine.Event.commandName', '' )) {
                                case "SelectAll": 
                                    this.SelectAll();
                                    consumedEvent = true;
                                    break;
                            }
                            break;
                    }
                }

                if (consumedEvent) {
                    this.UpdateLabel();
                }

                eventData.Use();
            },
            /*UnityEngine.UI.InputField.OnUpdateSelected end.*/

            /*UnityEngine.UI.InputField.GetSelectedString start.*/
            GetSelectedString: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#GetSelectedString", this ); }

                if (!this.hasSelection$1) {
                    return "";
                }

                var startPos = this.caretPositionInternal;
                var endPos = this.caretSelectPositionInternal;

                // Ensure startPos is always less then endPos to make the code simpler
                if (startPos > endPos) {
                    var temp = startPos;
                    startPos = endPos;
                    endPos = temp;
                }

                return this.text.substr(startPos, endPos - startPos);
            },
            /*UnityEngine.UI.InputField.GetSelectedString end.*/

            /*UnityEngine.UI.InputField.FindtNextWordBegin start.*/
            FindtNextWordBegin: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#FindtNextWordBegin", this ); }

                if (this.caretSelectPositionInternal + 1 >= this.text.length) {
                    return this.text.length;
                }

                var spaceLoc = System.String.indexOfAny(this.text, UnityEngine.UI.InputField.kSeparators, this.caretSelectPositionInternal + 1);

                if (spaceLoc === -1) {
                    spaceLoc = this.text.length;
                } else {
                    spaceLoc++;
                }

                return spaceLoc;
            },
            /*UnityEngine.UI.InputField.FindtNextWordBegin end.*/

            /*UnityEngine.UI.InputField.MoveRight start.*/
            MoveRight: function (shift, ctrl) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#MoveRight", this ); }

                var $t;
                if (this.hasSelection$1 && !shift) {
                    // By convention, if we have a selection and move right without holding shift,
                    // we just place the cursor at the end.
                    this.caretPositionInternal = ($t = UnityEngine.Mathf.Max(this.caretPositionInternal, this.caretSelectPositionInternal), this.caretSelectPositionInternal = $t, $t);
                    return;
                }

                var position;
                if (ctrl) {
                    position = this.FindtNextWordBegin();
                } else {
                    position = this.caretSelectPositionInternal + 1;
                }

                if (shift) {
                    this.caretSelectPositionInternal = position;
                } else {
                    this.caretSelectPositionInternal = (this.caretPositionInternal = position, position);
                }
            },
            /*UnityEngine.UI.InputField.MoveRight end.*/

            /*UnityEngine.UI.InputField.FindtPrevWordBegin start.*/
            FindtPrevWordBegin: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#FindtPrevWordBegin", this ); }

                if (this.caretSelectPositionInternal - 2 < 0) {
                    return 0;
                }

                var spaceLoc = System.String.lastIndexOfAny(this.text, UnityEngine.UI.InputField.kSeparators, this.caretSelectPositionInternal - 2);

                if (spaceLoc === -1) {
                    spaceLoc = 0;
                } else {
                    spaceLoc++;
                }

                return spaceLoc;
            },
            /*UnityEngine.UI.InputField.FindtPrevWordBegin end.*/

            /*UnityEngine.UI.InputField.MoveLeft start.*/
            MoveLeft: function (shift, ctrl) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#MoveLeft", this ); }

                var $t;
                if (this.hasSelection$1 && !shift) {
                    // By convention, if we have a selection and move left without holding shift,
                    // we just place the cursor at the start.
                    this.caretPositionInternal = ($t = UnityEngine.Mathf.Min(this.caretPositionInternal, this.caretSelectPositionInternal), this.caretSelectPositionInternal = $t, $t);
                    return;
                }

                var position;
                if (ctrl) {
                    position = this.FindtPrevWordBegin();
                } else {
                    position = this.caretSelectPositionInternal - 1;
                }

                if (shift) {
                    this.caretSelectPositionInternal = position;
                } else {
                    this.caretSelectPositionInternal = (this.caretPositionInternal = position, position);
                }
            },
            /*UnityEngine.UI.InputField.MoveLeft end.*/

            /*UnityEngine.UI.InputField.DetermineCharacterLine start.*/
            DetermineCharacterLine: function (charPos, generator) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#DetermineCharacterLine", this ); }

                for (var i = 0; i < generator.lineCount - 1; ++i) {
                    if (generator.lines.getItem(i + 1).startCharIdx > charPos) {
                        return i;
                    }
                }

                return generator.lineCount - 1;
            },
            /*UnityEngine.UI.InputField.DetermineCharacterLine end.*/

            /*UnityEngine.UI.InputField.LineUpCharacterPosition start.*/
            /**
             * Use cachedInputTextGenerator as the y component for the UICharInfo is not required
             *
             * @instance
             * @private
             * @this UnityEngine.UI.InputField
             * @memberof UnityEngine.UI.InputField
             * @param   {number}     originalPos      
             * @param   {boolean}    goToFirstChar
             * @return  {number}
             */
            LineUpCharacterPosition: function (originalPos, goToFirstChar) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#LineUpCharacterPosition", this ); }

                if (originalPos >= this.cachedInputTextGenerator.characters.Count) {
                    return 0;
                }

                var originChar = this.cachedInputTextGenerator.characters.getItem(originalPos);
                var originLine = this.DetermineCharacterLine(originalPos, this.cachedInputTextGenerator);

                // We are on the first line return first character
                if (originLine <= 0) {
                    return goToFirstChar ? 0 : originalPos;
                }

                var endCharIdx = this.cachedInputTextGenerator.lines.getItem(originLine).startCharIdx - 1;

                for (var i = this.cachedInputTextGenerator.lines.getItem(originLine - 1).startCharIdx; i < endCharIdx; ++i) {
                    if (this.cachedInputTextGenerator.characters.getItem(i).cursorPos.x >= originChar.cursorPos.x) {
                        return i;
                    }
                }

                return endCharIdx;
            },
            /*UnityEngine.UI.InputField.LineUpCharacterPosition end.*/

            /*UnityEngine.UI.InputField.LineDownCharacterPosition start.*/
            /**
             * Use cachedInputTextGenerator as the y component for the UICharInfo is not required
             *
             * @instance
             * @private
             * @this UnityEngine.UI.InputField
             * @memberof UnityEngine.UI.InputField
             * @param   {number}     originalPos     
             * @param   {boolean}    goToLastChar
             * @return  {number}
             */
            LineDownCharacterPosition: function (originalPos, goToLastChar) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#LineDownCharacterPosition", this ); }

                if (originalPos >= this.cachedInputTextGenerator.characterCountVisible) {
                    return this.text.length;
                }

                var originChar = this.cachedInputTextGenerator.characters.getItem(originalPos);
                var originLine = this.DetermineCharacterLine(originalPos, this.cachedInputTextGenerator);

                // We are on the last line return last character
                if (originLine + 1 >= this.cachedInputTextGenerator.lineCount) {
                    return goToLastChar ? this.text.length : originalPos;
                }

                // Need to determine end line for next line.
                var endCharIdx = UnityEngine.UI.InputField.GetLineEndPosition(this.cachedInputTextGenerator, originLine + 1);

                for (var i = this.cachedInputTextGenerator.lines.getItem(originLine + 1).startCharIdx; i < endCharIdx; ++i) {
                    if (this.cachedInputTextGenerator.characters.getItem(i).cursorPos.x >= originChar.cursorPos.x) {
                        return i;
                    }
                }

                return endCharIdx;
            },
            /*UnityEngine.UI.InputField.LineDownCharacterPosition end.*/

            /*UnityEngine.UI.InputField.MoveDown start.*/
            MoveDown: function (shift) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#MoveDown", this ); }

                this.MoveDown$1(shift, true);
            },
            /*UnityEngine.UI.InputField.MoveDown end.*/

            /*UnityEngine.UI.InputField.MoveDown$1 start.*/
            MoveDown$1: function (shift, goToLastChar) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#MoveDown$1", this ); }

                var $t;
                if (this.hasSelection$1 && !shift) {
                    // If we have a selection and press down without shift,
                    // set caret position to end of selection before we move it down.
                    this.caretPositionInternal = ($t = UnityEngine.Mathf.Max(this.caretPositionInternal, this.caretSelectPositionInternal), this.caretSelectPositionInternal = $t, $t);
                }

                var position = this.multiLine ? this.LineDownCharacterPosition(this.caretSelectPositionInternal, goToLastChar) : this.text.length;

                if (shift) {
                    this.caretSelectPositionInternal = position;
                } else {
                    this.caretPositionInternal = (this.caretSelectPositionInternal = position, position);
                }
            },
            /*UnityEngine.UI.InputField.MoveDown$1 end.*/

            /*UnityEngine.UI.InputField.MoveUp start.*/
            MoveUp: function (shift) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#MoveUp", this ); }

                this.MoveUp$1(shift, true);
            },
            /*UnityEngine.UI.InputField.MoveUp end.*/

            /*UnityEngine.UI.InputField.MoveUp$1 start.*/
            MoveUp$1: function (shift, goToFirstChar) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#MoveUp$1", this ); }

                var $t;
                if (this.hasSelection$1 && !shift) {
                    // If we have a selection and press up without shift,
                    // set caret position to start of selection before we move it up.
                    this.caretPositionInternal = ($t = UnityEngine.Mathf.Min(this.caretPositionInternal, this.caretSelectPositionInternal), this.caretSelectPositionInternal = $t, $t);
                }

                var position = this.multiLine ? this.LineUpCharacterPosition(this.caretSelectPositionInternal, goToFirstChar) : 0;

                if (shift) {
                    this.caretSelectPositionInternal = position;
                } else {
                    this.caretSelectPositionInternal = (this.caretPositionInternal = position, position);
                }
            },
            /*UnityEngine.UI.InputField.MoveUp$1 end.*/

            /*UnityEngine.UI.InputField.Delete start.*/
            Delete: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#Delete", this ); }

                if (this.m_ReadOnly) {
                    return;
                }

                if (this.caretPositionInternal === this.caretSelectPositionInternal) {
                    return;
                }

                if (this.caretPositionInternal < this.caretSelectPositionInternal) {
                    this.m_Text = (this.text.substr(0, this.caretPositionInternal) || "") + (this.text.substr(this.caretSelectPositionInternal, this.text.length - this.caretSelectPositionInternal) || "");
                    this.caretSelectPositionInternal = this.caretPositionInternal;
                } else {
                    this.m_Text = (this.text.substr(0, this.caretSelectPositionInternal) || "") + (this.text.substr(this.caretPositionInternal, this.text.length - this.caretPositionInternal) || "");
                    this.caretPositionInternal = this.caretSelectPositionInternal;
                }
            },
            /*UnityEngine.UI.InputField.Delete end.*/

            /*UnityEngine.UI.InputField.ForwardSpace start.*/
            ForwardSpace: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#ForwardSpace", this ); }

                if (this.m_ReadOnly) {
                    return;
                }

                if (this.hasSelection$1) {
                    this.Delete();
                    this.SendOnValueChangedAndUpdateLabel();
                } else {
                    if (this.caretPositionInternal < this.text.length) {
                        this.m_Text = System.String.remove(this.text, this.caretPositionInternal, 1);
                        this.SendOnValueChangedAndUpdateLabel();
                    }
                }
            },
            /*UnityEngine.UI.InputField.ForwardSpace end.*/

            /*UnityEngine.UI.InputField.Backspace start.*/
            Backspace: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#Backspace", this ); }

                var $t;
                if (this.m_ReadOnly) {
                    return;
                }

                if (this.hasSelection$1) {
                    this.Delete();
                    this.SendOnValueChangedAndUpdateLabel();
                } else {
                    if (this.caretPositionInternal > 0) {
                        this.m_Text = System.String.remove(this.text, this.caretPositionInternal - 1, 1);
                        this.caretSelectPositionInternal = ($t = this.caretPositionInternal - 1, this.caretPositionInternal = $t, $t);
                        this.SendOnValueChangedAndUpdateLabel();
                    }
                }
            },
            /*UnityEngine.UI.InputField.Backspace end.*/

            /*UnityEngine.UI.InputField.Insert start.*/
            Insert: function (c) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#Insert", this ); }

                var $t;
                if (this.m_ReadOnly) {
                    return;
                }

                var replaceString = String.fromCharCode(c);
                this.Delete();

                // Can't go past the character limit
                if (this.characterLimit > 0 && this.text.length >= this.characterLimit) {
                    return;
                }

                this.m_Text = System.String.insert(this.m_CaretPosition, this.text, replaceString);
                this.caretSelectPositionInternal = ($t = this.caretPositionInternal + replaceString.length, this.caretPositionInternal = $t, $t);

                this.SendOnValueChanged();
            },
            /*UnityEngine.UI.InputField.Insert end.*/

            /*UnityEngine.UI.InputField.SendOnValueChangedAndUpdateLabel start.*/
            SendOnValueChangedAndUpdateLabel: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#SendOnValueChangedAndUpdateLabel", this ); }

                this.SendOnValueChanged();
                this.UpdateLabel();
            },
            /*UnityEngine.UI.InputField.SendOnValueChangedAndUpdateLabel end.*/

            /*UnityEngine.UI.InputField.SendOnValueChanged start.*/
            SendOnValueChanged: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#SendOnValueChanged", this ); }

                // UISystemProfilerApi.AddMarker("InputField.value", this);
                if (this.onValueChanged != null) {
                    this.onValueChanged.Invoke(this.text);
                }
            },
            /*UnityEngine.UI.InputField.SendOnValueChanged end.*/

            /*UnityEngine.UI.InputField.SendOnSubmit start.*/
            /**
             * Convenience function to make functionality to send the ::ref::SubmitEvent easier.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.InputField
             * @memberof UnityEngine.UI.InputField
             * @return  {void}
             */
            SendOnSubmit: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#SendOnSubmit", this ); }

                // UISystemProfilerApi.AddMarker("InputField.onSubmit", this);
                if (this.onEndEdit != null) {
                    this.onEndEdit.Invoke(this.m_Text);
                }
            },
            /*UnityEngine.UI.InputField.SendOnSubmit end.*/

            /*UnityEngine.UI.InputField.Append$1 start.*/
            /**
             * Append the specified text to the end of the current text string. Appends character by character testing validation criteria.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.InputField
             * @memberof UnityEngine.UI.InputField
             * @param   {string}    input    The String to append.
             * @return  {void}
             */
            Append$1: function (input) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#Append$1", this ); }

                if (this.m_ReadOnly) {
                    return;
                }

                if (!this.InPlaceEditing()) {
                    return;
                }

                for (var i = 0, imax = input.length; i < imax; ++i) {
                    var c = input.charCodeAt(i);

                    if (c >= 32 || c === 9 || c === 13 || c === 10 || c === 10) {
                        this.Append(c);
                    }
                }
            },
            /*UnityEngine.UI.InputField.Append$1 end.*/

            /*UnityEngine.UI.InputField.Append start.*/
            /**
             * Append a character to the input field, taking into account the validation of each character.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.InputField
             * @memberof UnityEngine.UI.InputField
             * @param   {number}    input    Character to append.
             * @return  {void}
             */
            Append: function (input) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#Append", this ); }

                // We do not currently support surrogate pairs
                if (System.Char.isSurrogate(input)) {
                    return;
                }

                if (this.m_ReadOnly || this.text.length >= UnityEngine.UI.InputField.k_MaxTextLength) {
                    return;
                }

                if (!this.InPlaceEditing()) {
                    return;
                }

                // If we have an input validator, validate the input first
                var insertionPoint = Math.min(this.selectionFocusPosition, this.selectionAnchorPosition);
                if (!Bridge.staticEquals(this.onValidateInput, null)) {
                    input = this.onValidateInput(this.text, insertionPoint, input);
                } else if (this.characterValidation !== UnityEngine.UI.InputField.CharacterValidation.None) {
                    input = this.Validate(this.text, insertionPoint, input);
                }

                // If the input is invalid, skip it
                if (input === 0) {
                    return;
                }

                // Append the character and update the label
                this.Insert(input);
            },
            /*UnityEngine.UI.InputField.Append end.*/

            /*UnityEngine.UI.InputField.UpdateLabel start.*/
            /**
             * Update the Text associated with this input field.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.InputField
             * @memberof UnityEngine.UI.InputField
             * @return  {void}
             */
            UpdateLabel: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#UpdateLabel", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.m_TextComponent, null) && this.m_TextComponent.font != null && !this.m_PreventFontCallback) {
                    // TextGenerator.Populate invokes a callback that's called for anything
                    // that needs to be updated when the data for that font has changed.
                    // This makes all Text components that use that font update their vertices.
                    // In turn, this makes the InputField that's associated with that Text component
                    // update its label by calling this UpdateLabel method.
                    // This is a recursive call we want to prevent, since it makes the InputField
                    // update based on font data that didn't yet finish executing, or alternatively
                    // hang on infinite recursion, depending on whether the cached value is cached
                    // before or after the calculation.
                    //
                    // This callback also occurs when assigning text to our Text component, i.e.,
                    // m_TextComponent.text = processed;

                    this.m_PreventFontCallback = true;

                    var fullText;
                    if (this.compositionString.length > 0) {
                        fullText = (this.text.substr(0, this.m_CaretPosition) || "") + (this.compositionString || "") + (this.text.substr(this.m_CaretPosition) || "");
                    } else {
                        fullText = this.text;
                    }

                    var processed;
                    if (this.inputType === UnityEngine.UI.InputField.InputType.Password) {
                        processed = System.String.fromCharCount(this.asteriskChar, fullText.length);
                    } else {
                        processed = fullText;
                    }

                    var isEmpty = System.String.isNullOrEmpty(fullText);

                    if (UnityEngine.MonoBehaviour.op_Inequality(this.m_Placeholder, null)) {
                        this.m_Placeholder.enabled = isEmpty;
                    }

                    // If not currently editing the text, set the visible range to the whole text.
                    // The UpdateLabel method will then truncate it to the part that fits inside the Text area.
                    // We can't do this when text is being edited since it would discard the current scroll,
                    // which is defined by means of the m_DrawStart and m_DrawEnd indices.
                    if (!this.m_AllowInput) {
                        this.m_DrawStart = 0;
                        this.m_DrawEnd = this.m_Text.length;
                    }

                    if (!isEmpty) {
                        // Determine what will actually fit into the given line
                        var extents = this.m_TextComponent.rectTransform.rect.size.$clone();

                        var settings = this.m_TextComponent.GetGenerationSettings(extents.$clone());
                        settings.generateOutOfBounds = true;

                        this.cachedInputTextGenerator.PopulateWithErrors(processed, settings.$clone(), this.gameObject); //[EN-1289] InputField check api.
                        this.SetDrawRangeToContainCaretPosition(this.caretSelectPositionInternal);

                        processed = processed.substr(this.m_DrawStart, UnityEngine.Mathf.Min(this.m_DrawEnd, processed.length) - this.m_DrawStart);

                        this.SetCaretVisible();
                    }

                    this.m_TextComponent.text = processed;
                    this.MarkGeometryAsDirty();
                    this.m_PreventFontCallback = false;
                }
            },
            /*UnityEngine.UI.InputField.UpdateLabel end.*/

            /*UnityEngine.UI.InputField.IsSelectionVisible start.*/
            IsSelectionVisible: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#IsSelectionVisible", this ); }

                if (this.m_DrawStart > this.caretPositionInternal || this.m_DrawStart > this.caretSelectPositionInternal) {
                    return false;
                }

                if (this.m_DrawEnd < this.caretPositionInternal || this.m_DrawEnd < this.caretSelectPositionInternal) {
                    return false;
                }

                return true;
            },
            /*UnityEngine.UI.InputField.IsSelectionVisible end.*/

            /*UnityEngine.UI.InputField.SetDrawRangeToContainCaretPosition start.*/
            SetDrawRangeToContainCaretPosition: function (caretPos) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#SetDrawRangeToContainCaretPosition", this ); }

                // We don't have any generated lines generation is not valid.
                if (this.cachedInputTextGenerator.lineCount <= 0) {
                    return;
                }

                // the extents gets modified by the pixel density, so we need to use the generated extents since that will be in the same 'space' as
                // the values returned by the TextGenerator.lines[x].height for instance.
                var extents = this.cachedInputTextGenerator.rectExtents.size.$clone();

                if (this.multiLine) {
                    var lines = this.cachedInputTextGenerator.lines;
                    var caretLine = this.DetermineCharacterLine(caretPos, this.cachedInputTextGenerator);

                    if (caretPos > this.m_DrawEnd) {
                        // Caret comes after drawEnd, so we need to move drawEnd to the end of the line with the caret
                        this.m_DrawEnd = UnityEngine.UI.InputField.GetLineEndPosition(this.cachedInputTextGenerator, caretLine);
                        var bottomY = lines.getItem(caretLine).topY - lines.getItem(caretLine).height;
                        if (caretLine === lines.Count - 1) {
                            // Remove interline spacing on last line.
                            bottomY += lines.getItem(caretLine).leading;
                        }

                        var startLine = caretLine;
                        while (startLine > 0) {
                            var topY = lines.getItem(startLine - 1).topY;
                            if (topY - bottomY > extents.y) {
                                break;
                            }

                            startLine--;
                        }

                        this.m_DrawStart = UnityEngine.UI.InputField.GetLineStartPosition(this.cachedInputTextGenerator, startLine);
                    } else {
                        if (caretPos < this.m_DrawStart) {
                            // Caret comes before drawStart, so we need to move drawStart to an earlier line start that comes before caret.
                            this.m_DrawStart = UnityEngine.UI.InputField.GetLineStartPosition(this.cachedInputTextGenerator, caretLine);
                        }

                        var startLine1 = this.DetermineCharacterLine(this.m_DrawStart, this.cachedInputTextGenerator);
                        var endLine = startLine1;

                        var topY1 = lines.getItem(startLine1).topY;
                        var bottomY1 = lines.getItem(endLine).topY - lines.getItem(endLine).height;

                        if (endLine === lines.Count - 1) {
                            // Remove interline spacing on last line.
                            bottomY1 += lines.getItem(endLine).leading;
                        }

                        while (endLine < lines.Count - 1) {
                            bottomY1 = lines.getItem(endLine + 1).topY - lines.getItem(endLine + 1).height;

                            if (endLine + 1 === lines.Count - 1) {
                                // Remove interline spacing on last line.
                                bottomY1 += lines.getItem(endLine + 1).leading;
                            }

                            if (topY1 - bottomY1 > extents.y) {
                                break;
                            }

                            ++endLine;
                        }

                        this.m_DrawEnd = UnityEngine.UI.InputField.GetLineEndPosition(this.cachedInputTextGenerator, endLine);

                        while (startLine1 > 0) {
                            topY1 = lines.getItem(startLine1 - 1).topY;
                            if (topY1 - bottomY1 > extents.y) {
                                break;
                            }

                            startLine1--;
                        }

                        this.m_DrawStart = UnityEngine.UI.InputField.GetLineStartPosition(this.cachedInputTextGenerator, startLine1);
                    }
                } else {
                    var characters = this.cachedInputTextGenerator.characters;
                    if (this.m_DrawEnd > this.cachedInputTextGenerator.characterCountVisible) {
                        this.m_DrawEnd = this.cachedInputTextGenerator.characterCountVisible;
                    }

                    var width = 0.0;
                    if (caretPos > this.m_DrawEnd || caretPos === this.m_DrawEnd && this.m_DrawStart > 0) {
                        // fit characters from the caretPos leftward
                        this.m_DrawEnd = caretPos;
                        for (this.m_DrawStart = this.m_DrawEnd - 1; this.m_DrawStart >= 0; --this.m_DrawStart) {
                            if (width + characters.getItem(this.m_DrawStart).charWidth > extents.x) {
                                break;
                            }

                            width += characters.getItem(this.m_DrawStart).charWidth;
                        }

                        ++this.m_DrawStart; // move right one to the last character we could fit on the left
                    } else {
                        if (caretPos < this.m_DrawStart) {
                            this.m_DrawStart = caretPos;
                        }

                        this.m_DrawEnd = this.m_DrawStart;
                    }

                    // fit characters rightward
                    for (; this.m_DrawEnd < this.cachedInputTextGenerator.characterCountVisible; ++this.m_DrawEnd) {
                        width += characters.getItem(this.m_DrawEnd).charWidth;
                        if (width > extents.x) {
                            break;
                        }
                    }
                }
            },
            /*UnityEngine.UI.InputField.SetDrawRangeToContainCaretPosition end.*/

            /*UnityEngine.UI.InputField.ForceLabelUpdate start.*/
            /**
             * Force the label to update immediatly. This will recalculate the positioning of the caret and the visible text.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.InputField
             * @memberof UnityEngine.UI.InputField
             * @return  {void}
             */
            ForceLabelUpdate: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#ForceLabelUpdate", this ); }

                this.UpdateLabel();
            },
            /*UnityEngine.UI.InputField.ForceLabelUpdate end.*/

            /*UnityEngine.UI.InputField.MarkGeometryAsDirty start.*/
            MarkGeometryAsDirty: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#MarkGeometryAsDirty", this ); }


                UnityEngine.UI.CanvasUpdateRegistry.RegisterCanvasElementForGraphicRebuild(this);
            },
            /*UnityEngine.UI.InputField.MarkGeometryAsDirty end.*/

            /*UnityEngine.UI.InputField.Rebuild start.*/
            /**
             * Rebuild the input fields geometry. (caret and highlight).
             *
             * @instance
             * @public
             * @this UnityEngine.UI.InputField
             * @memberof UnityEngine.UI.InputField
             * @param   {UnityEngine.UI.CanvasUpdate}    update    Which update loop we are in.
             * @return  {void}
             */
            Rebuild: function (update) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#Rebuild", this ); }

                switch (update) {
                    case UnityEngine.UI.CanvasUpdate.LatePreRender: 
                        this.UpdateGeometry();
                        break;
                }
            },
            /*UnityEngine.UI.InputField.Rebuild end.*/

            /*UnityEngine.UI.InputField.LayoutComplete start.*/
            /**
             * See ICanvasElement.LayoutComplete. Does nothing by default.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.InputField
             * @memberof UnityEngine.UI.InputField
             * @return  {void}
             */
            LayoutComplete: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#LayoutComplete", this ); }
 },
            /*UnityEngine.UI.InputField.LayoutComplete end.*/

            /*UnityEngine.UI.InputField.GraphicUpdateComplete start.*/
            /**
             * See ICanvasElement.GraphicUpdateComplete. Does nothing by default.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.InputField
             * @memberof UnityEngine.UI.InputField
             * @return  {void}
             */
            GraphicUpdateComplete: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#GraphicUpdateComplete", this ); }
 },
            /*UnityEngine.UI.InputField.GraphicUpdateComplete end.*/

            /*UnityEngine.UI.InputField.UpdateGeometry start.*/
            UpdateGeometry: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#UpdateGeometry", this ); }

                // No need to draw a cursor on mobile as its handled by the devices keyboard.
                if (!this.shouldHideMobileInput) {
                    return;
                }

                if (UnityEngine.Component.op_Equality(this.m_CachedInputRenderer, null) && UnityEngine.MonoBehaviour.op_Inequality(this.m_TextComponent, null)) {
                    var go = new UnityEngine.GameObject.$ctor4((this.transform.name || "") + " Input Caret", [UnityEngine.RectTransform, UnityEngine.CanvasRenderer]);
                    go.hideFlags = UnityEngine.HideFlags.DontSave;
                    go.transform.SetParent(this.m_TextComponent.transform.parent);
                    go.transform.SetAsFirstSibling();
                    go.layer = this.gameObject.layer;

                    this.caretRectTrans = go.GetComponent(UnityEngine.RectTransform);
                    this.m_CachedInputRenderer = go.GetComponent(UnityEngine.CanvasRenderer);
                    this.m_CachedInputRenderer.SetMaterial$1(this.m_TextComponent.GetModifiedMaterial(UnityEngine.UI.Graphic.defaultGraphicMaterial), UnityEngine.Texture2D.whiteTexture);

                    // Needed as if any layout is present we want the caret to always be the same as the text area.
                    go.AddComponent(UnityEngine.UI.LayoutElement).ignoreLayout = true;

                    this.AssignPositioningIfNeeded();
                }

                if (UnityEngine.Component.op_Equality(this.m_CachedInputRenderer, null)) {
                    return;
                }

                this.OnFillVBO(this.mesh);
                this.m_CachedInputRenderer.SetMesh(this.mesh);
            },
            /*UnityEngine.UI.InputField.UpdateGeometry end.*/

            /*UnityEngine.UI.InputField.AssignPositioningIfNeeded start.*/
            AssignPositioningIfNeeded: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#AssignPositioningIfNeeded", this ); }

                var $t, $t1;
                if (UnityEngine.MonoBehaviour.op_Inequality(this.m_TextComponent, null) && UnityEngine.Component.op_Inequality(this.caretRectTrans, null) && (!pc.Vec3.equals( this.caretRectTrans.localPosition, this.m_TextComponent.rectTransform.localPosition ) || ($t = this.caretRectTrans.localRotation, $t1 = this.m_TextComponent.rectTransform.localRotation, ( $t == null && $t1 != null ) || ( $t != null && $t1 == null ) || ( $t != null && !$t.equals( $t1 ) )) || !pc.Vec3.equals( this.caretRectTrans.localScale, this.m_TextComponent.rectTransform.localScale ) || !pc.Vec2.equals( this.caretRectTrans.anchorMin, this.m_TextComponent.rectTransform.anchorMin ) || !pc.Vec2.equals( this.caretRectTrans.anchorMax, this.m_TextComponent.rectTransform.anchorMax ) || !pc.Vec2.equals( this.caretRectTrans.anchoredPosition, this.m_TextComponent.rectTransform.anchoredPosition ) || !pc.Vec2.equals( this.caretRectTrans.sizeDelta, this.m_TextComponent.rectTransform.sizeDelta ) || !pc.Vec2.equals( this.caretRectTrans.pivot, this.m_TextComponent.rectTransform.pivot ))) {
                    this.caretRectTrans.localPosition = this.m_TextComponent.rectTransform.localPosition.$clone();
                    this.caretRectTrans.localRotation = this.m_TextComponent.rectTransform.localRotation.$clone();
                    this.caretRectTrans.localScale = this.m_TextComponent.rectTransform.localScale.$clone();
                    this.caretRectTrans.anchorMin = this.m_TextComponent.rectTransform.anchorMin.$clone();
                    this.caretRectTrans.anchorMax = this.m_TextComponent.rectTransform.anchorMax.$clone();
                    this.caretRectTrans.anchoredPosition = this.m_TextComponent.rectTransform.anchoredPosition.$clone();
                    this.caretRectTrans.sizeDelta = this.m_TextComponent.rectTransform.sizeDelta.$clone();
                    this.caretRectTrans.pivot = this.m_TextComponent.rectTransform.pivot.$clone();
                }
            },
            /*UnityEngine.UI.InputField.AssignPositioningIfNeeded end.*/

            /*UnityEngine.UI.InputField.OnFillVBO start.*/
            OnFillVBO: function (vbo) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#OnFillVBO", this ); }

                var helper = new UnityEngine.UI.VertexHelper.ctor();
                try {
                    if (!this.isFocused) {
                        helper.FillMesh(vbo);
                        return;
                    }

                    var roundingOffset = this.m_TextComponent.PixelAdjustPoint(pc.Vec2.ZERO.clone());
                    if (!this.hasSelection$1) {
                        this.GenerateCaret(helper, roundingOffset.$clone());
                    } else {
                        this.GenerateHightlight(helper, roundingOffset.$clone());
                    }

                    helper.FillMesh(vbo);
                }
                finally {
                    if (Bridge.hasValue(helper)) {
                        helper.System$IDisposable$Dispose();
                    }
                }
            },
            /*UnityEngine.UI.InputField.OnFillVBO end.*/

            /*UnityEngine.UI.InputField.GenerateCaret start.*/
            GenerateCaret: function (vbo, roundingOffset) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#GenerateCaret", this ); }

                if (!this.m_CaretVisible) {
                    return;
                }

                if (this.m_CursorVerts == null) {
                    this.CreateCursorVerts();
                }

                var width = this.m_CaretWidth;
                var adjustedPos = UnityEngine.Mathf.Max(0, this.caretPositionInternal - this.m_DrawStart);
                var gen = this.m_TextComponent.cachedTextGenerator;

                if (gen == null) {
                    return;
                }

                if (gen.lineCount === 0) {
                    return;
                }

                var startPosition = pc.Vec2.ZERO.clone();

                // Calculate startPosition
                var textRt = this.textComponent.rectTransform;
                //[EN-1289] InputField check api.
                var pp = textRt.handle.element._pivotPoint.$clone();
                var zeroOffset = new pc.Vec3( -pp.x, -pp.y, 0 ).add( gen.handle.offset );

                if (adjustedPos < gen.characters.Count) {
                    var cursorChar = gen.characters.getItem(adjustedPos);
                    startPosition.x = cursorChar.cursorPos.x;
                } else if (gen.characters.Count !== 0) {
                    //[EN-1289] InputField check api.  - additional logic
                    var cursorChar1 = gen.characters.getItem(gen.characters.Count - 1);
                    startPosition.x = cursorChar1.cursorPos.x + cursorChar1.charWidth;
                } else {
                    startPosition.x = zeroOffset.x;
                }

                startPosition.x /= this.m_TextComponent.pixelsPerUnit;

                // TODO: Only clamp when Text uses horizontal word wrap.
                if (startPosition.x > this.m_TextComponent.rectTransform.rect.xMax) {
                    startPosition.x = this.m_TextComponent.rectTransform.rect.xMax;
                }

                var characterLine = this.DetermineCharacterLine(adjustedPos, gen);
                startPosition.y = (gen.characters.Count !== 0 ? gen.lines.getItem(characterLine).topY : zeroOffset.y + gen.lines.getItem(characterLine).height) / this.m_TextComponent.pixelsPerUnit;
                var height = gen.lines.getItem(characterLine).height / this.m_TextComponent.pixelsPerUnit;

                for (var i = 0; i < this.m_CursorVerts.length; i++) {
                    this.m_CursorVerts[i].color = UnityEngine.Color32.op_Implicit$1(this.caretColor.$clone());
                }

                this.m_CursorVerts[0].position = new pc.Vec3( startPosition.x, startPosition.y - height, 0.0 );
                this.m_CursorVerts[1].position = new pc.Vec3( startPosition.x + width, startPosition.y - height, 0.0 );
                this.m_CursorVerts[2].position = new pc.Vec3( startPosition.x + width, startPosition.y, 0.0 );
                this.m_CursorVerts[3].position = new pc.Vec3( startPosition.x, startPosition.y, 0.0 );

                if (!pc.Vec2.equals( roundingOffset, pc.Vec2.ZERO.clone() )) {
                    for (var i1 = 0; i1 < this.m_CursorVerts.length; i1++) {
                        var uiv = this.m_CursorVerts[i1].$clone();
                        uiv.position.x += roundingOffset.x;
                        uiv.position.y += roundingOffset.y;
                    }
                }

                vbo.AddUIVertexQuad(this.m_CursorVerts);

                var screenHeight = UnityEngine.Screen.height;
                // Multiple display support only when not the main display. For display 0 the reported
                // resolution is always the desktops resolution since its part of the display API,
                // so we use the standard none multiple display method. (case 741751)
                var displayIndex = this.m_TextComponent.canvas.targetDisplay;
                if (displayIndex > 0 && displayIndex < UnityEngine.Display.displays.length) {
                    screenHeight = UnityEngine.Display.displays[displayIndex].renderingHeight;
                }

                startPosition.y = screenHeight - startPosition.y;
                // input.compositionCursorPos = startPosition; //[EN-1289] InputField check api.
            },
            /*UnityEngine.UI.InputField.GenerateCaret end.*/

            /*UnityEngine.UI.InputField.CreateCursorVerts start.*/
            CreateCursorVerts: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#CreateCursorVerts", this ); }

                this.m_CursorVerts = System.Array.init(4, function (){
                    return new UnityEngine.UIVertex();
                }, UnityEngine.UIVertex);

                for (var i = 0; i < this.m_CursorVerts.length; i++) {
                    this.m_CursorVerts[i] = UnityEngine.UIVertex.simpleVert.$clone();
                    this.m_CursorVerts[i].uv0 = pc.Vec2.ZERO.clone();
                }
            },
            /*UnityEngine.UI.InputField.CreateCursorVerts end.*/

            /*UnityEngine.UI.InputField.GenerateHightlight start.*/
            GenerateHightlight: function (vbo, roundingOffset) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#GenerateHightlight", this ); }

                var startChar = UnityEngine.Mathf.Max(0, this.caretPositionInternal - this.m_DrawStart);
                var endChar = UnityEngine.Mathf.Max(0, this.caretSelectPositionInternal - this.m_DrawStart);

                // Ensure pos is always less then selPos to make the code simpler
                if (startChar > endChar) {
                    var temp = startChar;
                    startChar = endChar;
                    endChar = temp;
                }

                endChar -= 1;
                var gen = this.m_TextComponent.cachedTextGenerator;

                if (gen.lineCount <= 0) {
                    return;
                }

                var currentLineIndex = this.DetermineCharacterLine(startChar, gen);

                var lastCharInLineIndex = UnityEngine.UI.InputField.GetLineEndPosition(gen, currentLineIndex);

                var vert = UnityEngine.UIVertex.simpleVert.$clone();
                vert.uv0 = pc.Vec2.ZERO.clone();
                vert.color = UnityEngine.Color32.op_Implicit$1(this.selectionColor.$clone());

                var currentChar = startChar;
                while (currentChar <= endChar && currentChar < gen.characterCount) {
                    if (currentChar === lastCharInLineIndex || currentChar === endChar) {
                        var startCharInfo = gen.characters.getItem(startChar);
                        var endCharInfo = gen.characters.getItem(currentChar);
                        var startPosition = new pc.Vec2( startCharInfo.cursorPos.x / this.m_TextComponent.pixelsPerUnit, gen.lines.getItem(currentLineIndex).topY / this.m_TextComponent.pixelsPerUnit );
                        var endPosition = new pc.Vec2( (endCharInfo.cursorPos.x + endCharInfo.charWidth) / this.m_TextComponent.pixelsPerUnit, startPosition.y - gen.lines.getItem(currentLineIndex).height / this.m_TextComponent.pixelsPerUnit );

                        // Checking xMin as well due to text generator not setting position if char is not rendered.
                        if (endPosition.x > this.m_TextComponent.rectTransform.rect.xMax || endPosition.x < this.m_TextComponent.rectTransform.rect.xMin) {
                            endPosition.x = this.m_TextComponent.rectTransform.rect.xMax;
                        }

                        var startIndex = vbo.currentVertCount;
                        vert.position = new pc.Vec3( startPosition.x, endPosition.y, 0.0 ).add( UnityEngine.Vector3.FromVector2(roundingOffset) );
                        vbo.AddVert(vert.$clone());

                        vert.position = new pc.Vec3( endPosition.x, endPosition.y, 0.0 ).add( UnityEngine.Vector3.FromVector2(roundingOffset) );
                        vbo.AddVert(vert.$clone());

                        vert.position = new pc.Vec3( endPosition.x, startPosition.y, 0.0 ).add( UnityEngine.Vector3.FromVector2(roundingOffset) );
                        vbo.AddVert(vert.$clone());

                        vert.position = new pc.Vec3( startPosition.x, startPosition.y, 0.0 ).add( UnityEngine.Vector3.FromVector2(roundingOffset) );
                        vbo.AddVert(vert.$clone());

                        vbo.AddTriangle(startIndex, startIndex + 1, startIndex + 2);
                        vbo.AddTriangle(startIndex + 2, startIndex + 3, startIndex + 0);

                        startChar = currentChar + 1;
                        currentLineIndex++;

                        lastCharInLineIndex = UnityEngine.UI.InputField.GetLineEndPosition(gen, currentLineIndex);
                    }

                    currentChar++;
                }
            },
            /*UnityEngine.UI.InputField.GenerateHightlight end.*/

            /*UnityEngine.UI.InputField.Validate start.*/
            /**
             * Predefined validation functionality for different characterValidation types.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.InputField
             * @memberof UnityEngine.UI.InputField
             * @param   {string}    text    The whole text string to validate.
             * @param   {number}    pos     The position at which the current character is being inserted.
             * @param   {number}    ch      The character that is being inserted
             * @return  {number}            The character that should be inserted.
             */
            Validate: function (text, pos, ch) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#Validate", this ); }

                // Validation is disabled
                if (this.characterValidation === UnityEngine.UI.InputField.CharacterValidation.None || !this.enabled) {
                    return ch;
                }

                if (this.characterValidation === UnityEngine.UI.InputField.CharacterValidation.Integer || this.characterValidation === UnityEngine.UI.InputField.CharacterValidation.Decimal) {
                    // Integer and decimal
                    var cursorBeforeDash = pos === 0 && text.length > 0 && text.charCodeAt(0) === 45;
                    var dashInSelection = text.length > 0 && text.charCodeAt(0) === 45 && (this.caretPositionInternal === 0 && this.caretSelectPositionInternal > 0 || this.caretSelectPositionInternal === 0 && this.caretPositionInternal > 0);
                    var selectionAtStart = this.caretPositionInternal === 0 || this.caretSelectPositionInternal === 0;
                    if (!cursorBeforeDash || dashInSelection) {
                        if (ch >= 48 && ch <= 57) {
                            return ch;
                        }

                        if (ch === 45 && (pos === 0 || selectionAtStart)) {
                            return ch;
                        }

                        if (ch === 46 && this.characterValidation === UnityEngine.UI.InputField.CharacterValidation.Decimal && !System.String.contains(text,".")) {
                            return ch;
                        }
                    }
                } else if (this.characterValidation === UnityEngine.UI.InputField.CharacterValidation.Alphanumeric) {
                    // All alphanumeric characters
                    if (ch >= 65 && ch <= 90) {
                        return ch;
                    }

                    if (ch >= 97 && ch <= 122) {
                        return ch;
                    }

                    if (ch >= 48 && ch <= 57) {
                        return ch;
                    }
                } else if (this.characterValidation === UnityEngine.UI.InputField.CharacterValidation.Name) {
                    // FIXME: some actions still lead to invalid input:
                    //        - Hitting delete in front of an uppercase letter
                    //        - Selecting an uppercase letter and deleting it
                    //        - Typing some text, hitting Home and typing more text (we then have an uppercase letter in the middle of a word)
                    //        - Typing some text, hitting Home and typing a space (we then have a leading space)
                    //        - Erasing a space between two words (we then have an uppercase letter in the middle of a word)
                    //        - We accept a trailing space
                    //        - We accept the insertion of a space between two lowercase letters.
                    //        - Typing text in front of an existing uppercase letter
                    //        - ... and certainly more
                    //
                    // The rule we try to implement are too complex for this kind of verification.

                    if (System.Char.isLetter(ch)) {
                        // Character following a space should be in uppercase.
                        if (Bridge.isLower(ch) && (pos === 0 || text.charCodeAt(pos - 1) === 32)) {
                            return String.fromCharCode(ch).toUpperCase().charCodeAt(0);
                        }

                        // Character not following a space or an apostrophe should be in lowercase.
                        if (Bridge.isUpper(ch) && pos > 0 && text.charCodeAt(pos - 1) !== 32 && text.charCodeAt(pos - 1) !== 39) {
                            return String.fromCharCode(ch).toLowerCase().charCodeAt(0);
                        }

                        return ch;
                    }

                    if (ch === 39) {
                        // Don't allow more than one apostrophe
                        if (!System.String.contains(text,"'")) {
                            if (!(pos > 0 && (text.charCodeAt(pos - 1) === 32 || text.charCodeAt(pos - 1) === 39) || pos < text.length && (text.charCodeAt(pos) === 32 || text.charCodeAt(pos) === 39))) {
                                return ch;
                            }
                        }
                    }

                    if (ch === 32) {
                        // Don't allow consecutive spaces and apostrophes.
                        if (!(pos > 0 && (text.charCodeAt(pos - 1) === 32 || text.charCodeAt(pos - 1) === 39) || pos < text.length && (text.charCodeAt(pos) === 32 || text.charCodeAt(pos) === 39))) {
                            return ch;
                        }
                    }
                } else if (this.characterValidation === UnityEngine.UI.InputField.CharacterValidation.EmailAddress) {
                    // From StackOverflow about allowed characters in email addresses:
                    // Uppercase and lowercase English letters (a-z, A-Z)
                    // Digits 0 to 9
                    // Characters ! # $ % & ' * + - / = ? ^ _ ` { | } ~
                    // Character . (dot, period, full stop) provided that it is not the first or last character,
                    // and provided also that it does not appear two or more times consecutively.

                    if (ch >= 65 && ch <= 90) {
                        return ch;
                    }

                    if (ch >= 97 && ch <= 122) {
                        return ch;
                    }

                    if (ch >= 48 && ch <= 57) {
                        return ch;
                    }

                    if (ch === 64 && System.String.indexOf(text, String.fromCharCode(64)) === -1) {
                        return ch;
                    }

                    if (System.String.indexOf(UnityEngine.UI.InputField.kEmailSpecialCharacters, String.fromCharCode(ch)) !== -1) {
                        return ch;
                    }

                    if (ch === 46) {
                        var lastChar = text.length > 0 ? text.charCodeAt(Math.max(0, Math.min(pos, text.length - 1))) : 32;
                        var nextChar = text.length > 0 ? text.charCodeAt(Math.max(0, Math.min(pos + 1, text.length - 1))) : 10;
                        if (lastChar !== 46 && nextChar !== 46) {
                            return ch;
                        }
                    }
                }

                return 0;
            },
            /*UnityEngine.UI.InputField.Validate end.*/

            /*UnityEngine.UI.InputField.ActivateInputField start.*/
            /**
             * Function to activate the InputField to begin processing Events.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.InputField
             * @memberof UnityEngine.UI.InputField
             * @example
             *
             * using UnityEngine;
             * using System.Collections;
             * using UnityEngine.UI;
             * public class Example : MonoBehaviour
             * {
             *     public InputField mainInputField;
             *     // Activate the main input field when the scene starts.
             *     void Start()
             *     {
             *         mainInputField.ActivateInputField();
             *     }
             * }
             * 
             *
             *
             * @return  {void}
             */
            ActivateInputField: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#ActivateInputField", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.m_TextComponent, null) || this.m_TextComponent.font == null || !this.IsActive() || !this.IsInteractable()) {
                    return;
                }

                if (this.isFocused) {
                    if (this.m_Keyboard != null && !this.m_Keyboard.active) {
                        this.m_Keyboard.active = true;
                        this.m_Keyboard.text = this.m_Text;
                    }
                }

                this.m_ShouldActivateNextUpdate = true;
            },
            /*UnityEngine.UI.InputField.ActivateInputField end.*/

            /*UnityEngine.UI.InputField.ActivateInputFieldInternal start.*/
            ActivateInputFieldInternal: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#ActivateInputFieldInternal", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(UnityEngine.EventSystems.EventSystem.current, null)) {
                    return;
                }

                if (UnityEngine.GameObject.op_Inequality(UnityEngine.EventSystems.EventSystem.current.currentSelectedGameObject, this.gameObject)) {
                    UnityEngine.EventSystems.EventSystem.current.SetSelectedGameObject(this.gameObject);
                }

                if (UnityEngine.TouchScreenKeyboard.isSupported) {
                    if (this.input.touchSupported) {
                        UnityEngine.TouchScreenKeyboard.hideInput = this.shouldHideMobileInput;
                    }

                    this.m_Keyboard = this.inputType === UnityEngine.UI.InputField.InputType.Password ? UnityEngine.TouchScreenKeyboard.Open$7(this.m_Text, this.keyboardType, false, this.multiLine, true, false, "", this.characterLimit) : UnityEngine.TouchScreenKeyboard.Open$7(this.m_Text, this.keyboardType, this.inputType === UnityEngine.UI.InputField.InputType.AutoCorrect, this.multiLine, false, false, "", this.characterLimit);

                    this.m_Keyboard.AttachWebInput(this.webInput);

                    // Cache the value of isInPlaceEditingAllowed, because on UWP this involves calling into native code
                    // The value only needs to be updated once when the TouchKeyboard is opened.
                    // m_TouchKeyboardAllowsInPlaceEditing = TouchScreenKeyboard.isInPlaceEditingAllowed;

                    // Mimics OnFocus but as mobile doesn't properly support select all
                    // just set it to the end of the text (where it would move when typing starts)
                    this.MoveTextEnd(false);
                } else {
                    this.input.imeCompositionMode = UnityEngine.IMECompositionMode.On;
                    this.OnFocus();
                }

                this.m_AllowInput = true;
                this.m_OriginalText = this.text;
                this.m_WasCanceled = false;
                this.SetCaretVisible();
                this.UpdateLabel();
            },
            /*UnityEngine.UI.InputField.ActivateInputFieldInternal end.*/

            /*UnityEngine.UI.InputField.OnSelect start.*/
            /**
             * What to do when the event system sends a submit Event.
             *
             * @instance
             * @public
             * @override
             * @this UnityEngine.UI.InputField
             * @memberof UnityEngine.UI.InputField
             * @param   {UnityEngine.EventSystems.BaseEventData}    eventData    The data on which to process
             * @return  {void}
             */
            OnSelect: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#OnSelect", this ); }

                UnityEngine.UI.Selectable.prototype.OnSelect.call(this, eventData);

                if (this.shouldActivateOnSelect) {
                    this.ActivateInputField();
                }
            },
            /*UnityEngine.UI.InputField.OnSelect end.*/

            /*UnityEngine.UI.InputField.OnPointerClick start.*/
            /**
             * What to do when the event system sends a pointer click Event
             *
             * @instance
             * @public
             * @this UnityEngine.UI.InputField
             * @memberof UnityEngine.UI.InputField
             * @param   {UnityEngine.EventSystems.PointerEventData}    eventData    The data on which to process
             * @return  {void}
             */
            OnPointerClick: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#OnPointerClick", this ); }

                if (eventData.button !== UnityEngine.EventSystems.PointerEventData.InputButton.Left) {
                    return;
                }

                this.ActivateInputField();
            },
            /*UnityEngine.UI.InputField.OnPointerClick end.*/

            /*UnityEngine.UI.InputField.DeactivateInputField start.*/
            /**
             * Function to deactivate the InputField to stop the processing of Events and send OnSubmit if not canceled.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.InputField
             * @memberof UnityEngine.UI.InputField
             * @example
             *
             * using UnityEngine;
             * using System.Collections;
             * using UnityEngine.UI; // Required when Using UI elements.
             * public class Example : MonoBehaviour
             * {
             *     public InputField mainInputField;
             *     // Deactivates the main input field when the scene starts.
             *     void Start()
             *     {
             *         mainInputField.DeactivateInputField();
             *     }
             * }
             * 
             *
             *
             * @return  {void}
             */
            DeactivateInputField: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#DeactivateInputField", this ); }

                // Not activated do nothing.
                if (!this.m_AllowInput) {
                    return;
                }

                this.m_HasDoneFocusTransition = false;
                this.m_AllowInput = false;

                if (UnityEngine.MonoBehaviour.op_Inequality(this.m_Placeholder, null)) {
                    this.m_Placeholder.enabled = System.String.isNullOrEmpty(this.m_Text);
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.m_TextComponent, null) && this.IsInteractable()) {
                    if (this.m_WasCanceled) {
                        this.text = this.m_OriginalText;
                    }

                    this.SendOnSubmit();

                    if (this.m_Keyboard != null) {
                        this.m_Keyboard.active = false;
                        this.m_Keyboard.DetachWebInput(this.webInput);
                        this.m_Keyboard = null;
                    }

                    this.m_CaretPosition = (this.m_CaretSelectPosition = 0);

                    // input.imeCompositionMode = IMECompositionMode.Auto; //[EN-1289] InputField check api.
                }

                this.MarkGeometryAsDirty();
            },
            /*UnityEngine.UI.InputField.DeactivateInputField end.*/

            /*UnityEngine.UI.InputField.OnDeselect start.*/
            /**
             * What to do when the event system sends a Deselect Event. Defaults to deactivating the inputfield.
             *
             * @instance
             * @public
             * @override
             * @this UnityEngine.UI.InputField
             * @memberof UnityEngine.UI.InputField
             * @param   {UnityEngine.EventSystems.BaseEventData}    eventData    The data sent by the EventSystem
             * @return  {void}
             */
            OnDeselect: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#OnDeselect", this ); }

                // DeactivateInputField();
                // base.OnDeselect(eventData);
            },
            /*UnityEngine.UI.InputField.OnDeselect end.*/

            /*UnityEngine.UI.InputField.OnSubmit start.*/
            OnSubmit: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#OnSubmit", this ); }

                if (!this.IsActive() || !this.IsInteractable()) {
                    return;
                }

                if (!this.isFocused) {
                    this.m_ShouldActivateNextUpdate = true;
                }
            },
            /*UnityEngine.UI.InputField.OnSubmit end.*/

            /*UnityEngine.UI.InputField.EnforceContentType start.*/
            EnforceContentType: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#EnforceContentType", this ); }

                switch (this.contentType) {
                    case UnityEngine.UI.InputField.ContentType.Standard: 
                        {
                            // Don't enforce line type for this content type.
                            this.m_InputType = UnityEngine.UI.InputField.InputType.Standard;
                            this.m_KeyboardType = UnityEngine.TouchScreenKeyboardType.Default;
                            this.m_CharacterValidation = UnityEngine.UI.InputField.CharacterValidation.None;
                            break;
                        }
                    case UnityEngine.UI.InputField.ContentType.Autocorrected: 
                        {
                            // Don't enforce line type for this content type.
                            this.m_InputType = UnityEngine.UI.InputField.InputType.AutoCorrect;
                            this.m_KeyboardType = UnityEngine.TouchScreenKeyboardType.Default;
                            this.m_CharacterValidation = UnityEngine.UI.InputField.CharacterValidation.None;
                            break;
                        }
                    case UnityEngine.UI.InputField.ContentType.IntegerNumber: 
                        {
                            this.m_LineType = UnityEngine.UI.InputField.LineType.SingleLine;
                            this.m_InputType = UnityEngine.UI.InputField.InputType.Standard;
                            this.m_KeyboardType = UnityEngine.TouchScreenKeyboardType.NumberPad;
                            this.m_CharacterValidation = UnityEngine.UI.InputField.CharacterValidation.Integer;
                            break;
                        }
                    case UnityEngine.UI.InputField.ContentType.DecimalNumber: 
                        {
                            this.m_LineType = UnityEngine.UI.InputField.LineType.SingleLine;
                            this.m_InputType = UnityEngine.UI.InputField.InputType.Standard;
                            this.m_KeyboardType = UnityEngine.TouchScreenKeyboardType.NumbersAndPunctuation;
                            this.m_CharacterValidation = UnityEngine.UI.InputField.CharacterValidation.Decimal;
                            break;
                        }
                    case UnityEngine.UI.InputField.ContentType.Alphanumeric: 
                        {
                            this.m_LineType = UnityEngine.UI.InputField.LineType.SingleLine;
                            this.m_InputType = UnityEngine.UI.InputField.InputType.Standard;
                            this.m_KeyboardType = UnityEngine.TouchScreenKeyboardType.ASCIICapable;
                            this.m_CharacterValidation = UnityEngine.UI.InputField.CharacterValidation.Alphanumeric;
                            break;
                        }
                    case UnityEngine.UI.InputField.ContentType.Name: 
                        {
                            this.m_LineType = UnityEngine.UI.InputField.LineType.SingleLine;
                            this.m_InputType = UnityEngine.UI.InputField.InputType.Standard;
                            this.m_KeyboardType = UnityEngine.TouchScreenKeyboardType.NamePhonePad;
                            this.m_CharacterValidation = UnityEngine.UI.InputField.CharacterValidation.Name;
                            break;
                        }
                    case UnityEngine.UI.InputField.ContentType.EmailAddress: 
                        {
                            this.m_LineType = UnityEngine.UI.InputField.LineType.SingleLine;
                            this.m_InputType = UnityEngine.UI.InputField.InputType.Standard;
                            this.m_KeyboardType = UnityEngine.TouchScreenKeyboardType.EmailAddress;
                            this.m_CharacterValidation = UnityEngine.UI.InputField.CharacterValidation.EmailAddress;
                            break;
                        }
                    case UnityEngine.UI.InputField.ContentType.Password: 
                        {
                            this.m_LineType = UnityEngine.UI.InputField.LineType.SingleLine;
                            this.m_InputType = UnityEngine.UI.InputField.InputType.Password;
                            this.m_KeyboardType = UnityEngine.TouchScreenKeyboardType.Default;
                            this.m_CharacterValidation = UnityEngine.UI.InputField.CharacterValidation.None;
                            break;
                        }
                    case UnityEngine.UI.InputField.ContentType.Pin: 
                        {
                            this.m_LineType = UnityEngine.UI.InputField.LineType.SingleLine;
                            this.m_InputType = UnityEngine.UI.InputField.InputType.Password;
                            this.m_KeyboardType = UnityEngine.TouchScreenKeyboardType.NumberPad;
                            this.m_CharacterValidation = UnityEngine.UI.InputField.CharacterValidation.Integer;
                            break;
                        }
                    default: 
                        {
                            // Includes Custom type. Nothing should be enforced.
                            break;
                        }
                }

                this.EnforceTextHOverflow();
            },
            /*UnityEngine.UI.InputField.EnforceContentType end.*/

            /*UnityEngine.UI.InputField.EnforceTextHOverflow start.*/
            EnforceTextHOverflow: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#EnforceTextHOverflow", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.m_TextComponent, null)) {
                    if (this.multiLine) {
                        this.m_TextComponent.horizontalOverflow = UnityEngine.HorizontalWrapMode.Wrap;
                    } else {
                        this.m_TextComponent.horizontalOverflow = UnityEngine.HorizontalWrapMode.Overflow;
                    }
                }
            },
            /*UnityEngine.UI.InputField.EnforceTextHOverflow end.*/

            /*UnityEngine.UI.InputField.SetToCustomIfContentTypeIsNot start.*/
            SetToCustomIfContentTypeIsNot: function (allowedContentTypes) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#SetToCustomIfContentTypeIsNot", this ); }

                if (allowedContentTypes === void 0) { allowedContentTypes = []; }
                if (this.contentType === UnityEngine.UI.InputField.ContentType.Custom) {
                    return;
                }

                for (var i = 0; i < allowedContentTypes.length; i++) {
                    if (this.contentType === allowedContentTypes[i]) {
                        return;
                    }
                }

                this.contentType = UnityEngine.UI.InputField.ContentType.Custom;
            },
            /*UnityEngine.UI.InputField.SetToCustomIfContentTypeIsNot end.*/

            /*UnityEngine.UI.InputField.SetToCustom start.*/
            SetToCustom: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#SetToCustom", this ); }

                if (this.contentType === UnityEngine.UI.InputField.ContentType.Custom) {
                    return;
                }

                this.contentType = UnityEngine.UI.InputField.ContentType.Custom;
            },
            /*UnityEngine.UI.InputField.SetToCustom end.*/

            /*UnityEngine.UI.InputField.DoStateTransition start.*/
            DoStateTransition: function (state, instant) {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#DoStateTransition", this ); }

                if (this.m_HasDoneFocusTransition) {
                    state = UnityEngine.UI.Selectable.SelectionState.Highlighted;
                } else if (state === UnityEngine.UI.Selectable.SelectionState.Pressed) {
                    this.m_HasDoneFocusTransition = true;
                }

                UnityEngine.UI.Selectable.prototype.DoStateTransition.call(this, state, instant);
            },
            /*UnityEngine.UI.InputField.DoStateTransition end.*/

            /*UnityEngine.UI.InputField.CalculateLayoutInputHorizontal start.*/
            /**
             * See ILayoutElement.CalculateLayoutInputHorizontal.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.InputField
             * @memberof UnityEngine.UI.InputField
             * @return  {void}
             */
            CalculateLayoutInputHorizontal: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#CalculateLayoutInputHorizontal", this ); }
 },
            /*UnityEngine.UI.InputField.CalculateLayoutInputHorizontal end.*/

            /*UnityEngine.UI.InputField.CalculateLayoutInputVertical start.*/
            /**
             * See ILayoutElement.CalculateLayoutInputVertical.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.InputField
             * @memberof UnityEngine.UI.InputField
             * @return  {void}
             */
            CalculateLayoutInputVertical: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#CalculateLayoutInputVertical", this ); }
 },
            /*UnityEngine.UI.InputField.CalculateLayoutInputVertical end.*/

            /*UnityEngine.UI.InputField.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#Awake", this ); }

                UnityEngine.UI.Selectable.prototype.Awake.call(this);
                this.rt = Bridge.as(this.m_TextComponent.transform, UnityEngine.RectTransform); // we want our

                this.webInput = document.createElement("input"); // single line
                this.webInput.style.position = "absolute";
                this.webInput.style.background = "transparent";
                this.webInput.style.backgroundColor = "#00000000";
                this.webInput.style.color = "#00000000"; // text's color
                this.webInput.style.resize = "none";
                this.webInput.style.overflow = "hidden";
                this.webInput.style.border = "0 none";
                this.webInput.style.outline = "none";
                this.webInput.style.padding = "0";
                this.webInput.style.margin = "0";
                this.webInput.style.left = "0px";
                this.webInput.style.top = "0px";
                this.webInput.style.fontSize = System.String.format("{0}px", [this.textComponent.fontSize]);
                this.webInput.spellcheck = false;
                this.webInput.style[ '-webkit-tap-highlight-color' ] = 'initial';
                this.webInput.style[ '-webkit-touch-callout' ] = 'initial';
                this.webInput.style[ '-webkit-user-select' ] = 'initial';
                this.webInput.style[ 'user-select' ] = 'initial';
                this.webInput.style.zIndex = Bridge.toString(2147483647);
                this.webInput.autocomplete = "one-time-code";
                this.webInput.maxLength = this.characterLimit === 0 ? 524288 : this.characterLimit; // according to docs, 0 => infinity, 524288 is max value for maxLength
                this.webInput.readOnly = this.readOnly; // readonly

                this.EnforceContentType();
                switch (this.keyboardType) {
                    case UnityEngine.TouchScreenKeyboardType.NumbersAndPunctuation: 
                    case UnityEngine.TouchScreenKeyboardType.NumberPad: 
                        this.webInput.type = "text"; // NUMBER don't support caret!
                        this.webInput.inputMode = 'numeric';
                        break;
                    case UnityEngine.TouchScreenKeyboardType.URL: 
                        this.webInput.type = "url";
                        break;
                    case UnityEngine.TouchScreenKeyboardType.PhonePad: 
                        this.webInput.type = "tel";
                        break;
                    case UnityEngine.TouchScreenKeyboardType.EmailAddress: 
                        this.webInput.type = "email";
                        break;
                    case UnityEngine.TouchScreenKeyboardType.Search: 
                        this.webInput.type = "search";
                        break;
                    case UnityEngine.TouchScreenKeyboardType.Default: 
                    case UnityEngine.TouchScreenKeyboardType.ASCIICapable: 
                    case UnityEngine.TouchScreenKeyboardType.NamePhonePad: 
                    case UnityEngine.TouchScreenKeyboardType.NintendoNetworkAccount: 
                    case UnityEngine.TouchScreenKeyboardType.Social: 
                    default: 
                        this.webInput.type = "text";
                        break;
                }

                if (Bridge.Browser.isiPad || Bridge.Browser.isiPhone) {
                    // there are no possible way to disable native highlight
                    this.selectionColor = new pc.Color( 0, 0, 0, 0 );
                }

                this.webInput.addEventListener("focus", Bridge.fn.bind(this, function (eventData) {
                    this.OnFocus();
                    this.ActivateInputField();
                    if (this.m_Keyboard != null) {
                        UnityEngine.TouchScreenKeyboard.visible = true;
                        this.m_Keyboard.active = true;
                        this.m_Keyboard.status = UnityEngine.TouchScreenKeyboard.Status.Visible;
                    }
                }));

                this.webInput.addEventListener("focusout", Bridge.fn.bind(this, function (eventData) {
                    this.DeactivateInputField();
                    UnityEngine.UI.Selectable.prototype.OnDeselect.call(this, null);
                    if (this.m_Keyboard != null) {
                        UnityEngine.TouchScreenKeyboard.visible = false;
                        this.m_Keyboard.active = false;
                        this.m_Keyboard.status = UnityEngine.TouchScreenKeyboard.Status.LostFocus;
                    }
                }));

                if (!UnityEngine.UI.InputField.isStyleInitialized) {
                    UnityEngine.UI.InputField.isStyleInitialized = true;
                    // Native selection color. Works on Mac and Android?, don't work on iOS

                var divNode = document.createElement('style');
                divNode.type = 'text/css';
                divNode.textContent = '                    "\r\n                input::-moz-selection {\r\n                    background:rgba(0, 0, 0, 0);\r\n                    color:#00000000;\r\n                }\r\n                input::-webkit-selection {\r\n                    background:rgba(0, 0, 0, 0);\r\n                    color:#00000000;\r\n                }\r\n                input::selection {\r\n                    background:rgba(0, 0, 0, 0);\r\n                    color:#00000000;\r\n                }\r\n                input::-webkit-outer-spin-button,\r\n                input::-webkit-inner-spin-button {\r\n                  -webkit-appearance: none;\r\n                  margin: 0;\r\n                }\r\n                /* Firefox */\r\n                input[type=number] {\r\n                  -moz-appearance: textfield;\r\n                }\r\n                * {\r\n                    -webkit-tap-highlight-color: rgba(0,0,0,0);\r\n                    caret-color: rgba(0,0,0,0);\r\n                }\r\n                html { -webkit-tap-highlight-color: rgba(0,0,0,0); }\r\n            "';
                document.head.appendChild(divNode);
            
                }

                this.webInput.style.display = UnityEngine.UI.InputField.StyleDisplayNone;

                //DEBUG RED
                // webInput.Style.BackgroundColor = "#FF00002F";
                // webInput.Style.Color = "#FF00007F"; // text's color

                // throughput click for popups
                this.webInput.addEventListener("mousedown", function (eventData) {
                    pc.Application.getApplication()._onMouseDown( eventData );
                });

                this.webInput.addEventListener("mouseup", function (eventData) {
                    pc.Application.getApplication()._onMouseUp( eventData );
                });

                
                this.webInput.addEventListener('touchstart', function (touches) {
                    var canvas = document.getElementById('application-canvas');
                    pc.Application.getApplication()._onTouchStart( new pc.TouchEvent( touches, canvas ) );
                });
                this.webInput.addEventListener('touchend', function (touches) {
                    var canvas = document.getElementById('application-canvas');
                    pc.Application.getApplication()._onTouchEnd( new pc.TouchEvent( touches, canvas ) );
                });

                document.body.appendChild(this.webInput);

                // var tc = this.textComponent;
                // var fontScale = tc.fontSize / tc.font.fontSize;
                // var fontPixelSize = tc.fontSize * fontScale * tc.font.lineHeight;
                // webInput.Style.FontSize = $"{fontPixelSize}px";
            },
            /*UnityEngine.UI.InputField.Awake end.*/

            /*UnityEngine.UI.InputField.OnCanvasHierarchyChanged start.*/
            OnCanvasHierarchyChanged: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#OnCanvasHierarchyChanged", this ); }

                UnityEngine.UI.Selectable.prototype.OnCanvasHierarchyChanged.call(this);
                var allEnable = this.AllCanvasedEnabled();
                this.webInput.style.display = allEnable ? UnityEngine.UI.InputField.StyleDisplayBlock : UnityEngine.UI.InputField.StyleDisplayNone;
            },
            /*UnityEngine.UI.InputField.OnCanvasHierarchyChanged end.*/

            /*UnityEngine.UI.InputField.OnEnableWebInput start.*/
            OnEnableWebInput: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#OnEnableWebInput", this ); }

                this.canvases = this.GetComponentsInParent$1(UnityEngine.Canvas, true);
                var allEnable = this.AllCanvasedEnabled();
                this.shouldBeShown = allEnable;
                this.webInput.style.display = allEnable ? UnityEngine.UI.InputField.StyleDisplayBlock : UnityEngine.UI.InputField.StyleDisplayNone;

                this.ResizeWebInput();
            },
            /*UnityEngine.UI.InputField.OnEnableWebInput end.*/

            /*UnityEngine.UI.InputField.OnRectTransformDimensionsChange start.*/
            OnRectTransformDimensionsChange: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#OnRectTransformDimensionsChange", this ); }

                this.ResizeWebInput();
            },
            /*UnityEngine.UI.InputField.OnRectTransformDimensionsChange end.*/

            /*UnityEngine.UI.InputField.AllCanvasedEnabled start.*/
            AllCanvasedEnabled: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#AllCanvasedEnabled", this ); }

                var allEnable = this.canvases.length !== 0;
                for (var i = 0; i < this.canvases.length; i++) {
                    if (!this.canvases[i].enabled) {
                        allEnable = false;
                        break;
                    }
                }

                return allEnable;
            },
            /*UnityEngine.UI.InputField.AllCanvasedEnabled end.*/

            /*UnityEngine.UI.InputField.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#Update", this ); }

                var allEnable = this.AllCanvasedEnabled();

                if (this.shouldBeShown !== allEnable) {
                    this.shouldBeShown = allEnable;
                    this.webInput.style.display = allEnable ? UnityEngine.UI.InputField.StyleDisplayBlock : UnityEngine.UI.InputField.StyleDisplayNone;
                }

                if (allEnable) {
                    this.ResizeWebInput(); // 'resizecanvas' works badly, so for now, update size in update
                }
            },
            /*UnityEngine.UI.InputField.Update end.*/

            /*UnityEngine.UI.InputField.OnDisableWebInput start.*/
            OnDisableWebInput: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#OnDisableWebInput", this ); }

                this.webInput.style.display = UnityEngine.UI.InputField.StyleDisplayNone;
            },
            /*UnityEngine.UI.InputField.OnDisableWebInput end.*/

            /*UnityEngine.UI.InputField.ResizeWebInput start.*/
            ResizeWebInput: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.InputField#ResizeWebInput", this ); }

                if (UnityEngine.Component.op_Equality(this.rt, null) || this.webInput == null) {
                    return;
                }

                var screenSize = new pc.Vec2( UnityEngine.Screen.width, UnityEngine.Screen.height );
                this.rt.GetWorldCorners(this.corners); // 4 vertices is clockwise : LB LT RT RB
                for (var i = 0; i < 4; i++) {
                    this.cornersScreen[i] = UnityEngine.Vector3.FromVector2(UnityEngine.RectTransformUtility.WorldToScreenPoint(null, this.corners[i].$clone()));
                }

                var leftTopScreenPoint = this.cornersScreen[1].$clone();
                var width = this.cornersScreen[2].x - this.cornersScreen[1].x;
                var height = this.cornersScreen[1].y - this.cornersScreen[0].y;
                var top = screenSize.y - leftTopScreenPoint.y;
                var left = leftTopScreenPoint.x;
                // Debug.Log($"width: {width}, height: {height}, top: {top},     left: {left}, screenWidth: {screenSize.x}, screenHeight: {screenSize.y}");

                this.webInput.style.left = System.String.format("{0}px", [left]);
                this.webInput.style.top = System.String.format("{0}px", [top]);
                this.webInput.style.width = System.String.format("{0}px", [width]);
                this.webInput.style.height = System.String.format("{0}px", [height]);
            },
            /*UnityEngine.UI.InputField.ResizeWebInput end.*/


        },
        overloads: {
            "MoveDown(bool, bool)": "MoveDown$1",
            "MoveUp(bool, bool)": "MoveUp$1",
            "Append(string)": "Append$1"
        }
    });
    /*UnityEngine.UI.InputField end.*/

    /*UnityEngine.UI.Outline start.*/
    Bridge.define("UnityEngine.UI.Outline", {
        inherits: [UnityEngine.UI.Shadow],
        alias: ["ModifyMesh$1", "UnityEngine$UI$IMeshModifier$ModifyMesh$1"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Outline#ctor", this ); }

                this.$initialize();
                UnityEngine.UI.Shadow.ctor.call(this);
            }
        },
        methods: {
            /*UnityEngine.UI.Outline.ModifyMesh$1 start.*/
            ModifyMesh$1: function (vh) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Outline#ModifyMesh$1", this ); }

                return;
                // if (!IsActive())
                //     return;
                //
                // var verts = ListPool<UIVertex>.Get();
                // vh.GetUIVertexStream(verts);
                //
                // var neededCpacity = verts.Count * 5;
                // if (verts.Capacity < neededCpacity)
                //     verts.Capacity = neededCpacity;
                //
                // var start = 0;
                // var end = verts.Count;
                // ApplyShadowZeroAlloc(verts, effectColor, start, verts.Count, effectDistance.x, effectDistance.y);
                //
                // start = end;
                // end = verts.Count;
                // ApplyShadowZeroAlloc(verts, effectColor, start, verts.Count, effectDistance.x, -effectDistance.y);
                //
                // start = end;
                // end = verts.Count;
                // ApplyShadowZeroAlloc(verts, effectColor, start, verts.Count, -effectDistance.x, effectDistance.y);
                //
                // start = end;
                // end = verts.Count;
                // ApplyShadowZeroAlloc(verts, effectColor, start, verts.Count, -effectDistance.x, -effectDistance.y);
                //
                // vh.Clear();
                // vh.AddUIVertexTriangleStream(verts);
                // ListPool<UIVertex>.Release(verts);
            },
            /*UnityEngine.UI.Outline.ModifyMesh$1 end.*/


        },
        overloads: {
            "ModifyMesh(VertexHelper)": "ModifyMesh$1"
        }
    });
    /*UnityEngine.UI.Outline end.*/

    /*UnityEngine.UI.RawImage start.*/
    Bridge.define("UnityEngine.UI.RawImage", {
        inherits: [UnityEngine.UI.MaskableGraphic],
        fields: {
            /**
             * The m texture.
             *
             * @instance
             * @protected
             * @memberof UnityEngine.UI.RawImage
             * @type UnityEngine.Texture
             */
            m_Texture: null,
            /**
             * The m UVR ect.
             *
             * @instance
             * @protected
             * @memberof UnityEngine.UI.RawImage
             * @type UnityEngine.Rect
             */
            m_UVRect: null
        },
        props: {
            /**
             * Gets or sets the texture.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.RawImage
             * @function texture
             * @type UnityEngine.Texture
             */
            texture: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.RawImage#texture#get", this ); }

                    return this.m_Texture;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.RawImage#texture#set", this ); }

                    this.m_Texture = value;
                    this.handle.entity.element.texture = (value != null ? value.handle : null) != null ? value.handle : null;
                }
            },
            mainTexture: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.RawImage#mainTexture#get", this ); }

                    return this.m_Texture;
                }
            },
            /**
             * Gets or sets the uv rect.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.RawImage
             * @function uvRect
             * @type UnityEngine.Rect
             */
            uvRect: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.RawImage#uvRect#get", this ); }

                    return this.m_UVRect.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.RawImage#uvRect#set", this ); }

                    this.m_UVRect = value.$clone();
                    this.handle.entity.element._image.rect = new pc.Vec4( value.x, value.y, value.width, value.height );
                }
            },
            /**
             * Gets or sets a value indicating whether this {@link } is enabled.
             *
             * @instance
             * @public
             * @override
             * @memberof UnityEngine.UI.RawImage
             * @function enabled
             * @type boolean
             */
            enabled: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.RawImage#enabled#get", this ); }

                    return this.handle.entity.element._image.enabled;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.RawImage#enabled#set", this ); }

                    this.handle.entity.element._image.enabled = value;
                    this.handle.enabled = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.RawImage#init", this ); }

                this.m_UVRect = new UnityEngine.Rect();
                this.m_UVRect = new UnityEngine.Rect.$ctor1(0, 0, 1, 1);
            },
            /**
             * Initializes a new instance of the {@link } class.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.RawImage
             * @memberof UnityEngine.UI.RawImage
             * @param   {pc.ElementComponent}    handle    Handle.
             * @return  {void}
             */
            $ctor1: function (handle) {
if ( TRACE ) { TRACE( "UnityEngine.UI.RawImage#$ctor1", this ); }

                this.$initialize();
                UnityEngine.UI.MaskableGraphic.$ctor1.call(this, handle);
            },
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.RawImage#ctor", this ); }

                this.$initialize();
                UnityEngine.UI.MaskableGraphic.$ctor1.call(this, null);
            }
        },
        methods: {
            /*UnityEngine.UI.RawImage.Awake start.*/
            /**
             * Awake this instance.
             *
             * @instance
             * @protected
             * @override
             * @this UnityEngine.UI.RawImage
             * @memberof UnityEngine.UI.RawImage
             * @return  {void}
             */
            Awake: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.RawImage#Awake", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.Awake.call(this);

                this.handle.entity.element["UnityEngine.UI.RawImage"] = this;
                this.handle.entity.element._image.rect = new pc.Vec4( this.m_UVRect.x, this.m_UVRect.y, this.m_UVRect.width, this.m_UVRect.height );

                this.handle.entity.element.material = this.m_Material != null ? this.m_Material.handle : null;
                this.handle.entity.element.texture = this.m_Texture != null ? this.m_Texture.handle : null;
                this.handle.entity.element._image.enabled = this.handle.enabled;

                this.canvasRenderer.SetColor(this.m_Color.$clone());
            },
            /*UnityEngine.UI.RawImage.Awake end.*/

            /*UnityEngine.UI.RawImage.OnDidApplyAnimationProperties start.*/
            /**
             * Synchronizes animatable properties with lower-level counterpart.
             *
             * @instance
             * @protected
             * @override
             * @this UnityEngine.UI.RawImage
             * @memberof UnityEngine.UI.RawImage
             * @return  {void}
             */
            OnDidApplyAnimationProperties: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.RawImage#OnDidApplyAnimationProperties", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.OnDidApplyAnimationProperties.call(this);
                this.handle.entity.element._image.synchornizeProperties( this, true );
            },
            /*UnityEngine.UI.RawImage.OnDidApplyAnimationProperties end.*/

            /*UnityEngine.UI.RawImage.ConfigureForEntity start.*/
            /**
             * Configures for entity.
             *
             * @instance
             * @public
             * @override
             * @this UnityEngine.UI.RawImage
             * @memberof UnityEngine.UI.RawImage
             * @param   {pc.Entity}    entity    Entity.
             * @return  {void}
             */
            ConfigureForEntity: function (entity) {
if ( TRACE ) { TRACE( "UnityEngine.UI.RawImage#ConfigureForEntity", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.ConfigureForEntity.call(this, entity);
                entity.element.type = "image";
            },
            /*UnityEngine.UI.RawImage.ConfigureForEntity end.*/


        }
    });
    /*UnityEngine.UI.RawImage end.*/

    /*UnityEngine.UI.Scrollbar start.*/
    /**
     * A standard scrollbar with a variable sized handle that can be dragged between 0 and 1.
     *
     * @public
     * @class UnityEngine.UI.Scrollbar
     * @augments UnityEngine.UI.Selectable
     * @implements  UnityEngine.EventSystems.IBeginDragHandler
     * @implements  UnityEngine.EventSystems.IDragHandler
     * @implements  UnityEngine.EventSystems.IInitializePotentialDragHandler
     * @implements  UnityEngine.UI.ICanvasElement
     */
    Bridge.define("UnityEngine.UI.Scrollbar", {
        inherits: [UnityEngine.UI.Selectable,UnityEngine.EventSystems.IBeginDragHandler,UnityEngine.EventSystems.IDragHandler,UnityEngine.EventSystems.IInitializePotentialDragHandler,UnityEngine.UI.ICanvasElement],
        fields: {
            _containerRect: null,
            _delayedUpdateVisuals: false,
            _isPointerDownAndNotDragging: false,
            _offset: null,
            _pointerDownRepeat: null,
            _tracker: null,
            m_Direction: 0,
            m_HandleRect: null,
            m_NumberOfSteps: 0,
            m_Size: 0,
            m_Value: 0,
            /**
             * Handling for when the scrollbar value is changed.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Scrollbar
             * @function onValueChanged
             * @type UnityEngine.UI.Scrollbar.ScrollEvent
             */
            onValueChanged: null
        },
        props: {
            /**
             * The RectTransform to use for the handle.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Scrollbar
             * @function handleRect
             * @type UnityEngine.RectTransform
             */
            handleRect: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#handleRect#get", this ); }

                    return this.m_HandleRect;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#handleRect#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetClass(UnityEngine.RectTransform, Bridge.ref(this, "m_HandleRect"), value)) {
                        this.UpdateCachedReferences();
                        this.UpdateVisuals();
                    }
                }
            },
            /**
             * The direction of the scrollbar from minimum to maximum value.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Scrollbar
             * @function direction
             * @type number
             */
            direction: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#direction#get", this ); }

                    return this.m_Direction;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#direction#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetStruct(UnityEngine.UI.Scrollbar.Direction, Bridge.ref(this, "m_Direction"), value)) {
                        this.UpdateVisuals();
                    }
                }
            },
            /**
             * The current value of the scrollbar, between 0 and 1.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Scrollbar
             * @function value
             * @type number
             */
            value: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#value#get", this ); }

                    var val = this.m_Value;
                    if (this.m_NumberOfSteps > 1) {
                        val = Math.round(val * (this.m_NumberOfSteps - 1)) / (this.m_NumberOfSteps - 1);
                    }

                    return val;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#value#set", this ); }

                    this.Set(value);
                }
            },
            /**
             * The size of the scrollbar handle where 1 means it fills the entire scrollbar.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Scrollbar
             * @function size
             * @type number
             */
            size: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#size#get", this ); }

                    return this.m_Size;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#size#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetStruct(System.Single, Bridge.ref(this, "m_Size"), Math.max(0, Math.min(1, value)))) {
                        this.UpdateVisuals();
                    }
                }
            },
            /**
             * The number of steps to use for the value. A value of 0 disables use of steps.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Scrollbar
             * @function numberOfSteps
             * @type number
             */
            numberOfSteps: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#numberOfSteps#get", this ); }

                    return this.m_NumberOfSteps;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#numberOfSteps#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetStruct(System.Int32, Bridge.ref(this, "m_NumberOfSteps"), value)) {
                        this.Set(this.m_Value);
                        this.UpdateVisuals();
                    }
                }
            },
            stepSize: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#stepSize#get", this ); }

                    return this.m_NumberOfSteps > 1 ? 1.0 / (this.m_NumberOfSteps - 1) : 0.1;
                }
            },
            axis: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#axis#get", this ); }

                    return this.m_Direction === UnityEngine.UI.Scrollbar.Direction.LeftToRight || this.m_Direction === UnityEngine.UI.Scrollbar.Direction.RightToLeft ? UnityEngine.UI.Scrollbar.Axis.Horizontal : UnityEngine.UI.Scrollbar.Axis.Vertical;
                }
            },
            reverseValue: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#reverseValue#get", this ); }

                    return this.m_Direction === UnityEngine.UI.Scrollbar.Direction.RightToLeft || this.m_Direction === UnityEngine.UI.Scrollbar.Direction.TopToBottom;
                }
            }
        },
        alias: [
            "OnBeginDrag", "UnityEngine$EventSystems$IBeginDragHandler$OnBeginDrag",
            "Rebuild", "UnityEngine$UI$ICanvasElement$Rebuild",
            "LayoutComplete", "UnityEngine$UI$ICanvasElement$LayoutComplete",
            "GraphicUpdateComplete", "UnityEngine$UI$ICanvasElement$GraphicUpdateComplete",
            "OnDrag", "UnityEngine$EventSystems$IDragHandler$OnDrag",
            "OnInitializePotentialDrag", "UnityEngine$EventSystems$IInitializePotentialDragHandler$OnInitializePotentialDrag",
            "OnPointerDown", "UnityEngine$EventSystems$IPointerDownHandler$OnPointerDown",
            "OnPointerUp", "UnityEngine$EventSystems$IPointerUpHandler$OnPointerUp",
            "OnMove", "UnityEngine$EventSystems$IMoveHandler$OnMove",
            "IsDestroyed", "UnityEngine$UI$ICanvasElement$IsDestroyed",
            "transform", "UnityEngine$UI$ICanvasElement$transform"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#init", this ); }

                this._offset = new UnityEngine.Vector2();
                this._tracker = new ( pc.stubProxy.generateConstructorFor( 'UnityEngine.DrivenRectTransformTracker' ) )();
                this._offset = pc.Vec2.ZERO.clone();
                this.m_Direction = UnityEngine.UI.Scrollbar.Direction.LeftToRight;
                this.m_Size = 0.2;
                this.onValueChanged = new UnityEngine.UI.Scrollbar.ScrollEvent();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#ctor", this ); }

                this.$initialize();
                UnityEngine.UI.Selectable.ctor.call(this);
            }
        },
        methods: {
            /*UnityEngine.UI.Scrollbar.Update start.*/
            /**
             * Update the rect based on the delayed update visuals.
             Got around issue of calling sendMessage from onValidate.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.Scrollbar
             * @memberof UnityEngine.UI.Scrollbar
             * @return  {void}
             */
            Update: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#Update", this ); }

                if (this._delayedUpdateVisuals) {
                    this._delayedUpdateVisuals = false;
                    this.UpdateVisuals();
                }
            },
            /*UnityEngine.UI.Scrollbar.Update end.*/

            /*UnityEngine.UI.Scrollbar.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#OnEnable", this ); }

                UnityEngine.UI.Selectable.prototype.OnEnable.call(this);
                this.UpdateCachedReferences();
                this.Set(this.m_Value, false);
                // Update rects since they need to be initialized correctly.
                this.UpdateVisuals();
            },
            /*UnityEngine.UI.Scrollbar.OnEnable end.*/

            /*UnityEngine.UI.Scrollbar.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#OnDisable", this ); }

                this._tracker.reportMethod( 'UnityEngine.DrivenRectTransformTracker.Clear', null );
                UnityEngine.UI.Selectable.prototype.OnDisable.call(this);
            },
            /*UnityEngine.UI.Scrollbar.OnDisable end.*/

            /*UnityEngine.UI.Scrollbar.OnRectTransformDimensionsChange start.*/
            OnRectTransformDimensionsChange: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#OnRectTransformDimensionsChange", this ); }

                UnityEngine.UI.Selectable.prototype.OnRectTransformDimensionsChange.call(this);

                //This can be invoked before OnEnabled is called. So we shouldn't be accessing other objects, before OnEnable is called.
                if (!this.IsActive()) {
                    return;
                }

                this.UpdateVisuals();
            },
            /*UnityEngine.UI.Scrollbar.OnRectTransformDimensionsChange end.*/

            /*UnityEngine.UI.Scrollbar.OnBeginDrag start.*/
            /**
             * Handling for when the scrollbar value is begin being dragged.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Scrollbar
             * @memberof UnityEngine.UI.Scrollbar
             * @param   {UnityEngine.EventSystems.PointerEventData}    eventData
             * @return  {void}
             */
            OnBeginDrag: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#OnBeginDrag", this ); }

                this._isPointerDownAndNotDragging = false;

                if (!this.MayDrag(eventData)) {
                    return;
                }

                if (UnityEngine.Component.op_Equality(this._containerRect, null)) {
                    return;
                }

                this._offset = pc.Vec2.ZERO.clone();
                if (UnityEngine.RectTransformUtility.RectangleContainsScreenPoint$1(this.m_HandleRect, eventData.position, eventData.enterEventCamera)) {
                    var localMousePos = { v : new UnityEngine.Vector2() };
                    if (UnityEngine.RectTransformUtility.ScreenPointToLocalPointInRectangle(this.m_HandleRect, eventData.position, eventData.pressEventCamera, localMousePos)) {
                        this._offset = localMousePos.v.$clone().sub( this.m_HandleRect.rect.center );
                    }
                }
            },
            /*UnityEngine.UI.Scrollbar.OnBeginDrag end.*/

            /*UnityEngine.UI.Scrollbar.Rebuild start.*/
            Rebuild: function (executing) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#Rebuild", this ); }
 },
            /*UnityEngine.UI.Scrollbar.Rebuild end.*/

            /*UnityEngine.UI.Scrollbar.LayoutComplete start.*/
            /**
             * See ICanvasElement.LayoutComplete.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Scrollbar
             * @memberof UnityEngine.UI.Scrollbar
             * @return  {void}
             */
            LayoutComplete: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#LayoutComplete", this ); }
 },
            /*UnityEngine.UI.Scrollbar.LayoutComplete end.*/

            /*UnityEngine.UI.Scrollbar.GraphicUpdateComplete start.*/
            /**
             * See ICanvasElement.GraphicUpdateComplete.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Scrollbar
             * @memberof UnityEngine.UI.Scrollbar
             * @return  {void}
             */
            GraphicUpdateComplete: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#GraphicUpdateComplete", this ); }
 },
            /*UnityEngine.UI.Scrollbar.GraphicUpdateComplete end.*/

            /*UnityEngine.UI.Scrollbar.OnDrag start.*/
            /**
             * Handling for when the scrollbar value is dragged.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Scrollbar
             * @memberof UnityEngine.UI.Scrollbar
             * @param   {UnityEngine.EventSystems.PointerEventData}    eventData
             * @return  {void}
             */
            OnDrag: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#OnDrag", this ); }

                if (!this.MayDrag(eventData)) {
                    return;
                }

                if (UnityEngine.Component.op_Inequality(this._containerRect, null)) {
                    this.UpdateDrag(eventData);
                }
            },
            /*UnityEngine.UI.Scrollbar.OnDrag end.*/

            /*UnityEngine.UI.Scrollbar.OnInitializePotentialDrag start.*/
            /**
             * See: IInitializePotentialDragHandler.OnInitializePotentialDrag
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Scrollbar
             * @memberof UnityEngine.UI.Scrollbar
             * @param   {UnityEngine.EventSystems.PointerEventData}    eventData
             * @return  {void}
             */
            OnInitializePotentialDrag: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#OnInitializePotentialDrag", this ); }

                eventData.useDragThreshold = false;
            },
            /*UnityEngine.UI.Scrollbar.OnInitializePotentialDrag end.*/

            /*UnityEngine.UI.Scrollbar.SetValueWithoutNotify start.*/
            /**
             * Set the value of the scrollbar without invoking onValueChanged callback.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Scrollbar
             * @memberof UnityEngine.UI.Scrollbar
             * @param   {number}    input    The new value for the scrollbar.
             * @return  {void}
             */
            SetValueWithoutNotify: function (input) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#SetValueWithoutNotify", this ); }

                this.Set(input, false);
            },
            /*UnityEngine.UI.Scrollbar.SetValueWithoutNotify end.*/

            /*UnityEngine.UI.Scrollbar.UpdateCachedReferences start.*/
            UpdateCachedReferences: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#UpdateCachedReferences", this ); }

                if (UnityEngine.Object.op_Implicit(this.m_HandleRect) && UnityEngine.Component.op_Inequality(this.m_HandleRect.parent, null)) {
                    this._containerRect = this.m_HandleRect.parent.GetComponent(UnityEngine.RectTransform);
                } else {
                    this._containerRect = null;
                }
            },
            /*UnityEngine.UI.Scrollbar.UpdateCachedReferences end.*/

            /*UnityEngine.UI.Scrollbar.Set start.*/
            Set: function (input, sendCallback) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#Set", this ); }

                if (sendCallback === void 0) { sendCallback = true; }
                var currentValue = this.m_Value;

                // bugfix (case 802330) clamp01 input in callee before calling this function, this allows inertia from dragging content to go past extremities without being clamped
                this.m_Value = input;

                // If the stepped value doesn't match the last one, it's time to update
                if (currentValue === this.value) {
                    return;
                }

                this.UpdateVisuals();
                if (sendCallback) {
                    this.onValueChanged.Invoke(this.value);
                }
            },
            /*UnityEngine.UI.Scrollbar.Set end.*/

            /*UnityEngine.UI.Scrollbar.UpdateVisuals start.*/
            UpdateVisuals: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#UpdateVisuals", this ); }

                this._tracker.reportMethod( 'UnityEngine.DrivenRectTransformTracker.Clear', null );

                if (UnityEngine.Component.op_Inequality(this._containerRect, null)) {
                    this._tracker.reportMethod( 'UnityEngine.DrivenRectTransformTracker.Add', null );
                    var anchorMin = pc.Vec2.ZERO.clone();
                    var anchorMax = pc.Vec2.ONE.clone();

                    var movement = Math.max(0, Math.min(1, this.value)) * (1 - this.size);
                    if (this.reverseValue) {
                        anchorMin.setitem(this.axis, 1 - movement - this.size);
                        anchorMax.setitem(this.axis, 1 - movement);
                    } else {
                        anchorMin.setitem(this.axis, movement);
                        anchorMax.setitem(this.axis, movement + this.size);
                    }

                    this.m_HandleRect.anchorMin = anchorMin.$clone();
                    this.m_HandleRect.anchorMax = anchorMax.$clone();
                }
            },
            /*UnityEngine.UI.Scrollbar.UpdateVisuals end.*/

            /*UnityEngine.UI.Scrollbar.UpdateDrag start.*/
            UpdateDrag: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#UpdateDrag", this ); }

                if (eventData.button !== UnityEngine.EventSystems.PointerEventData.InputButton.Left) {
                    return;
                }

                if (UnityEngine.Component.op_Equality(this._containerRect, null)) {
                    return;
                }

                var localCursor = { v : new UnityEngine.Vector2() };
                if (!UnityEngine.RectTransformUtility.ScreenPointToLocalPointInRectangle(this._containerRect, eventData.position, eventData.pressEventCamera, localCursor)) {
                    return;
                }

                var handleCenterRelativeToContainerCorner = localCursor.v.$clone().sub( this._offset ).sub( this._containerRect.rect.position );
                var handleCorner = handleCenterRelativeToContainerCorner.$clone().sub( (this.m_HandleRect.rect.size.$clone().sub( this.m_HandleRect.sizeDelta )).scale( 0.5 ) );

                var parentSize = this.axis === 0 ? this._containerRect.rect.width : this._containerRect.rect.height;
                var remainingSize = parentSize * (1 - this.size);
                if (remainingSize <= 0) {
                    return;
                }

                this.DoUpdateDrag(handleCorner.$clone(), remainingSize);
            },
            /*UnityEngine.UI.Scrollbar.UpdateDrag end.*/

            /*UnityEngine.UI.Scrollbar.DoUpdateDrag start.*/
            DoUpdateDrag: function (handleCorner, remainingSize) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#DoUpdateDrag", this ); }

                switch (this.m_Direction) {
                    case UnityEngine.UI.Scrollbar.Direction.LeftToRight: 
                        this.Set(Math.max(0, Math.min(1, handleCorner.x / remainingSize)));
                        break;
                    case UnityEngine.UI.Scrollbar.Direction.RightToLeft: 
                        this.Set(Math.max(0, Math.min(1, 1.0 - handleCorner.x / remainingSize)));
                        break;
                    case UnityEngine.UI.Scrollbar.Direction.BottomToTop: 
                        this.Set(Math.max(0, Math.min(1, handleCorner.y / remainingSize)));
                        break;
                    case UnityEngine.UI.Scrollbar.Direction.TopToBottom: 
                        this.Set(Math.max(0, Math.min(1, 1.0 - handleCorner.y / remainingSize)));
                        break;
                }
            },
            /*UnityEngine.UI.Scrollbar.DoUpdateDrag end.*/

            /*UnityEngine.UI.Scrollbar.MayDrag start.*/
            MayDrag: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#MayDrag", this ); }

                return this.IsActive() && this.IsInteractable() && eventData.button === UnityEngine.EventSystems.PointerEventData.InputButton.Left;
            },
            /*UnityEngine.UI.Scrollbar.MayDrag end.*/

            /*UnityEngine.UI.Scrollbar.OnPointerDown start.*/
            /**
             * Event triggered when pointer is pressed down on the scrollbar.
             *
             * @instance
             * @public
             * @override
             * @this UnityEngine.UI.Scrollbar
             * @memberof UnityEngine.UI.Scrollbar
             * @param   {UnityEngine.EventSystems.PointerEventData}    eventData
             * @return  {void}
             */
            OnPointerDown: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#OnPointerDown", this ); }

                if (!this.MayDrag(eventData)) {
                    return;
                }

                UnityEngine.UI.Selectable.prototype.OnPointerDown.call(this, eventData);
                this._isPointerDownAndNotDragging = true;
                this._pointerDownRepeat = this.StartCoroutine$1(this.ClickRepeat(eventData));
            },
            /*UnityEngine.UI.Scrollbar.OnPointerDown end.*/

            /*UnityEngine.UI.Scrollbar.ClickRepeat start.*/
            /**
             * Coroutine function for handling continual press during Scrollbar.OnPointerDown.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.Scrollbar
             * @memberof UnityEngine.UI.Scrollbar
             * @param   {UnityEngine.EventSystems.PointerEventData}    eventData
             * @return  {System.Collections.IEnumerator}
             */
            ClickRepeat: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#ClickRepeat", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    localMousePos,
                    axisCoordinate,
                    change,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if ( this._isPointerDownAndNotDragging ) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 3;
                                        continue;
                                }
                                case 1: {
                                    if (!UnityEngine.RectTransformUtility.RectangleContainsScreenPoint$1(this.m_HandleRect, eventData.position, eventData.enterEventCamera)) {
                                            localMousePos = { v : new UnityEngine.Vector2() };
                                            if (UnityEngine.RectTransformUtility.ScreenPointToLocalPointInRectangle(this.m_HandleRect, eventData.position, eventData.pressEventCamera, localMousePos)) {
                                                axisCoordinate = this.axis === 0 ? localMousePos.v.x : localMousePos.v.y;

                                                // modifying value depending on direction, fixes (case 925824)

                                                change = axisCoordinate < 0 ? this.size : -this.size;
                                                this.value += this.reverseValue ? change : -change;
                                            }
                                        }

                                        $enumerator.current = new UnityEngine.WaitForEndOfFrame();
                                        $step = 2;
                                        return true;
                                }
                                case 2: {
                                    
                                        $step = 0;
                                        continue;
                                }
                                case 3: {
                                    this.StopCoroutine$2(this._pointerDownRepeat);

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*UnityEngine.UI.Scrollbar.ClickRepeat end.*/

            /*UnityEngine.UI.Scrollbar.OnPointerUp start.*/
            /**
             * Event triggered when pointer is released after pressing on the scrollbar.
             *
             * @instance
             * @public
             * @override
             * @this UnityEngine.UI.Scrollbar
             * @memberof UnityEngine.UI.Scrollbar
             * @param   {UnityEngine.EventSystems.PointerEventData}    eventData
             * @return  {void}
             */
            OnPointerUp: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#OnPointerUp", this ); }

                UnityEngine.UI.Selectable.prototype.OnPointerUp.call(this, eventData);
                this._isPointerDownAndNotDragging = false;
            },
            /*UnityEngine.UI.Scrollbar.OnPointerUp end.*/

            /*UnityEngine.UI.Scrollbar.OnMove start.*/
            /**
             * Handling for movement events.
             *
             * @instance
             * @public
             * @override
             * @this UnityEngine.UI.Scrollbar
             * @memberof UnityEngine.UI.Scrollbar
             * @param   {UnityEngine.EventSystems.AxisEventData}    eventData
             * @return  {void}
             */
            OnMove: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#OnMove", this ); }

                if (!this.IsActive() || !this.IsInteractable()) {
                    UnityEngine.UI.Selectable.prototype.OnMove.call(this, eventData);
                    return;
                }

                switch (eventData.moveDir) {
                    case UnityEngine.EventSystems.MoveDirection.Left: 
                        if (this.axis === UnityEngine.UI.Scrollbar.Axis.Horizontal && UnityEngine.MonoBehaviour.op_Equality(this.FindSelectableOnLeft(), null)) {
                            this.Set(Math.max(0, Math.min(1, this.reverseValue ? this.value + this.stepSize : this.value - this.stepSize)));
                        } else {
                            UnityEngine.UI.Selectable.prototype.OnMove.call(this, eventData);
                        }
                        break;
                    case UnityEngine.EventSystems.MoveDirection.Right: 
                        if (this.axis === UnityEngine.UI.Scrollbar.Axis.Horizontal && UnityEngine.MonoBehaviour.op_Equality(this.FindSelectableOnRight(), null)) {
                            this.Set(Math.max(0, Math.min(1, this.reverseValue ? this.value - this.stepSize : this.value + this.stepSize)));
                        } else {
                            UnityEngine.UI.Selectable.prototype.OnMove.call(this, eventData);
                        }
                        break;
                    case UnityEngine.EventSystems.MoveDirection.Up: 
                        if (this.axis === UnityEngine.UI.Scrollbar.Axis.Vertical && UnityEngine.MonoBehaviour.op_Equality(this.FindSelectableOnUp(), null)) {
                            this.Set(Math.max(0, Math.min(1, this.reverseValue ? this.value - this.stepSize : this.value + this.stepSize)));
                        } else {
                            UnityEngine.UI.Selectable.prototype.OnMove.call(this, eventData);
                        }
                        break;
                    case UnityEngine.EventSystems.MoveDirection.Down: 
                        if (this.axis === UnityEngine.UI.Scrollbar.Axis.Vertical && UnityEngine.MonoBehaviour.op_Equality(this.FindSelectableOnDown(), null)) {
                            this.Set(Math.max(0, Math.min(1, this.reverseValue ? this.value + this.stepSize : this.value - this.stepSize)));
                        } else {
                            UnityEngine.UI.Selectable.prototype.OnMove.call(this, eventData);
                        }
                        break;
                }
            },
            /*UnityEngine.UI.Scrollbar.OnMove end.*/

            /*UnityEngine.UI.Scrollbar.FindSelectableOnLeft start.*/
            /**
             * Prevents selection if we we move on the Horizontal axis. See Selectable.FindSelectableOnLeft.
             *
             * @instance
             * @public
             * @override
             * @this UnityEngine.UI.Scrollbar
             * @memberof UnityEngine.UI.Scrollbar
             * @return  {UnityEngine.UI.Selectable}
             */
            FindSelectableOnLeft: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#FindSelectableOnLeft", this ); }

                if (this.navigation.mode === UnityEngine.UI.Navigation.Mode.Automatic && this.axis === UnityEngine.UI.Scrollbar.Axis.Horizontal) {
                    return null;
                }

                return UnityEngine.UI.Selectable.prototype.FindSelectableOnLeft.call(this);
            },
            /*UnityEngine.UI.Scrollbar.FindSelectableOnLeft end.*/

            /*UnityEngine.UI.Scrollbar.FindSelectableOnRight start.*/
            /**
             * Prevents selection if we we move on the Horizontal axis.  See Selectable.FindSelectableOnRight.
             *
             * @instance
             * @public
             * @override
             * @this UnityEngine.UI.Scrollbar
             * @memberof UnityEngine.UI.Scrollbar
             * @return  {UnityEngine.UI.Selectable}
             */
            FindSelectableOnRight: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#FindSelectableOnRight", this ); }

                if (this.navigation.mode === UnityEngine.UI.Navigation.Mode.Automatic && this.axis === UnityEngine.UI.Scrollbar.Axis.Horizontal) {
                    return null;
                }

                return UnityEngine.UI.Selectable.prototype.FindSelectableOnRight.call(this);
            },
            /*UnityEngine.UI.Scrollbar.FindSelectableOnRight end.*/

            /*UnityEngine.UI.Scrollbar.FindSelectableOnUp start.*/
            /**
             * Prevents selection if we we move on the Vertical axis. See Selectable.FindSelectableOnUp.
             *
             * @instance
             * @public
             * @override
             * @this UnityEngine.UI.Scrollbar
             * @memberof UnityEngine.UI.Scrollbar
             * @return  {UnityEngine.UI.Selectable}
             */
            FindSelectableOnUp: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#FindSelectableOnUp", this ); }

                if (this.navigation.mode === UnityEngine.UI.Navigation.Mode.Automatic && this.axis === UnityEngine.UI.Scrollbar.Axis.Vertical) {
                    return null;
                }

                return UnityEngine.UI.Selectable.prototype.FindSelectableOnUp.call(this);
            },
            /*UnityEngine.UI.Scrollbar.FindSelectableOnUp end.*/

            /*UnityEngine.UI.Scrollbar.FindSelectableOnDown start.*/
            /**
             * Prevents selection if we we move on the Vertical axis. See Selectable.FindSelectableOnDown.
             *
             * @instance
             * @public
             * @override
             * @this UnityEngine.UI.Scrollbar
             * @memberof UnityEngine.UI.Scrollbar
             * @return  {UnityEngine.UI.Selectable}
             */
            FindSelectableOnDown: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#FindSelectableOnDown", this ); }

                if (this.navigation.mode === UnityEngine.UI.Navigation.Mode.Automatic && this.axis === UnityEngine.UI.Scrollbar.Axis.Vertical) {
                    return null;
                }

                return UnityEngine.UI.Selectable.prototype.FindSelectableOnDown.call(this);
            },
            /*UnityEngine.UI.Scrollbar.FindSelectableOnDown end.*/

            /*UnityEngine.UI.Scrollbar.SetDirection start.*/
            /**
             * Set the direction of the scrollbar, optionally setting the layout as well.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Scrollbar
             * @memberof UnityEngine.UI.Scrollbar
             * @param   {number}     direction             The direction of the scrollbar.
             * @param   {boolean}    includeRectLayouts    Should the layout be flipped together with the direction?
             * @return  {void}
             */
            SetDirection: function (direction, includeRectLayouts) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Scrollbar#SetDirection", this ); }

                var oldAxis = this.axis;
                var oldReverse = this.reverseValue;
                this.direction = direction;

                if (!includeRectLayouts) {
                    return;
                }

                if (this.axis !== oldAxis) {
                    UnityEngine.RectTransformUtility.FlipLayoutAxes(Bridge.as(this.transform, UnityEngine.RectTransform), true, true);
                }

                if (this.reverseValue !== oldReverse) {
                    UnityEngine.RectTransformUtility.FlipLayoutOnAxis(Bridge.as(this.transform, UnityEngine.RectTransform), this.axis, true, true);
                }
            },
            /*UnityEngine.UI.Scrollbar.SetDirection end.*/


        }
    });
    /*UnityEngine.UI.Scrollbar end.*/

    /*UnityEngine.UI.Slider start.*/
    /**
     * A standard slider that can be moved between a minimum and maximum value.
     *
     * @public
     * @class UnityEngine.UI.Slider
     * @augments UnityEngine.UI.Selectable
     * @implements  UnityEngine.EventSystems.IDragHandler
     * @implements  UnityEngine.EventSystems.IInitializePotentialDragHandler
     * @implements  UnityEngine.UI.ICanvasElement
     */
    Bridge.define("UnityEngine.UI.Slider", {
        inherits: [UnityEngine.UI.Selectable,UnityEngine.EventSystems.IDragHandler,UnityEngine.EventSystems.IInitializePotentialDragHandler,UnityEngine.UI.ICanvasElement],
        fields: {
            m_FillRect: null,
            m_HandleRect: null,
            m_Direction: 0,
            m_MinValue: 0,
            m_MaxValue: 0,
            m_WholeNumbers: false,
            m_Value: 0,
            m_OnValueChanged: null,
            _fillImage: null,
            _fillTransform: null,
            _fillContainerRect: null,
            _handleTransform: null,
            _handleContainerRect: null,
            _offset: null,
            _tracker: null,
            _delayedUpdateVisuals: false
        },
        props: {
            /**
             * Optional RectTransform to use as fill for the slider.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Slider
             * @function fillRect
             * @type UnityEngine.RectTransform
             */
            fillRect: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#fillRect#get", this ); }

                    return this.m_FillRect;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#fillRect#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetClass(UnityEngine.RectTransform, Bridge.ref(this, "m_FillRect"), value)) {
                        this.UpdateCachedReferences();
                        this.UpdateVisuals();
                    }
                }
            },
            /**
             * Optional RectTransform to use as a handle for the slider.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Slider
             * @function handleRect
             * @type UnityEngine.RectTransform
             */
            handleRect: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#handleRect#get", this ); }

                    return this.m_HandleRect;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#handleRect#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetClass(UnityEngine.RectTransform, Bridge.ref(this, "m_HandleRect"), value)) {
                        this.UpdateCachedReferences();
                        this.UpdateVisuals();
                    }
                }
            },
            /**
             * The direction of the slider, from minimum to maximum value.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Slider
             * @function direction
             * @type number
             */
            direction: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#direction#get", this ); }

                    return this.m_Direction;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#direction#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetStruct(UnityEngine.UI.Slider.Direction, Bridge.ref(this, "m_Direction"), value)) {
                        this.UpdateVisuals();
                    }
                }
            },
            /**
             * The minimum allowed value of the slider.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Slider
             * @function minValue
             * @type number
             */
            minValue: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#minValue#get", this ); }

                    return this.m_MinValue;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#minValue#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetStruct(System.Single, Bridge.ref(this, "m_MinValue"), value)) {
                        this.Set(this.m_Value);
                        this.UpdateVisuals();
                    }
                }
            },
            /**
             * The maximum allowed value of the slider.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Slider
             * @function maxValue
             * @type number
             */
            maxValue: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#maxValue#get", this ); }

                    return this.m_MaxValue;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#maxValue#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetStruct(System.Single, Bridge.ref(this, "m_MaxValue"), value)) {
                        this.Set(this.m_Value);
                        this.UpdateVisuals();
                    }
                }
            },
            /**
             * Should the value only be allowed to be whole numbers?
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Slider
             * @function wholeNumbers
             * @type boolean
             */
            wholeNumbers: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#wholeNumbers#get", this ); }

                    return this.m_WholeNumbers;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#wholeNumbers#set", this ); }

                    if (UnityEngine.UI.SetPropertyUtility.SetStruct(System.Boolean, Bridge.ref(this, "m_WholeNumbers"), value)) {
                        this.Set(this.m_Value);
                        this.UpdateVisuals();
                    }
                }
            },
            /**
             * The current value of the slider.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Slider
             * @function value
             * @type number
             */
            value: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#value#get", this ); }

                    if (this.wholeNumbers) {
                        return Math.round(this.m_Value);
                    }

                    return this.m_Value;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#value#set", this ); }

                    this.Set(value);
                }
            },
            /**
             * The current value of the slider normalized into a value between 0 and 1.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Slider
             * @function normalizedValue
             * @type number
             */
            normalizedValue: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#normalizedValue#get", this ); }

                    if (UnityEngine.Mathf.Approximately(this.minValue, this.maxValue)) {
                        return 0;
                    }

                    return pc.math.inverseLerp(this.minValue, this.maxValue, this.value);
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#normalizedValue#set", this ); }

                    this.value = pc.math.lerp(this.minValue, this.maxValue, value);
                }
            },
            /**
             * Callback executed when the value of the slider is changed.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Slider
             * @function onValueChanged
             * @type UnityEngine.UI.Slider.SliderEvent
             */
            onValueChanged: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#onValueChanged#get", this ); }

                    return this.m_OnValueChanged;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#onValueChanged#set", this ); }

                    this.m_OnValueChanged = value;
                }
            },
            stepSize: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#stepSize#get", this ); }

                    return this.wholeNumbers ? 1 : (this.maxValue - this.minValue) * 0.1;
                }
            },
            axis: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#axis#get", this ); }

                    return this.m_Direction === UnityEngine.UI.Slider.Direction.LeftToRight || this.m_Direction === UnityEngine.UI.Slider.Direction.RightToLeft ? UnityEngine.UI.Slider.Axis.Horizontal : UnityEngine.UI.Slider.Axis.Vertical;
                }
            },
            reverseValue: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#reverseValue#get", this ); }

                    return this.m_Direction === UnityEngine.UI.Slider.Direction.RightToLeft || this.m_Direction === UnityEngine.UI.Slider.Direction.TopToBottom;
                }
            }
        },
        alias: [
            "Rebuild", "UnityEngine$UI$ICanvasElement$Rebuild",
            "LayoutComplete", "UnityEngine$UI$ICanvasElement$LayoutComplete",
            "GraphicUpdateComplete", "UnityEngine$UI$ICanvasElement$GraphicUpdateComplete",
            "OnPointerDown", "UnityEngine$EventSystems$IPointerDownHandler$OnPointerDown",
            "OnDrag", "UnityEngine$EventSystems$IDragHandler$OnDrag",
            "OnMove", "UnityEngine$EventSystems$IMoveHandler$OnMove",
            "OnInitializePotentialDrag", "UnityEngine$EventSystems$IInitializePotentialDragHandler$OnInitializePotentialDrag",
            "IsDestroyed", "UnityEngine$UI$ICanvasElement$IsDestroyed",
            "transform", "UnityEngine$UI$ICanvasElement$transform"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#init", this ); }

                this._offset = new UnityEngine.Vector2();
                this._tracker = new ( pc.stubProxy.generateConstructorFor( 'UnityEngine.DrivenRectTransformTracker' ) )();
                this.m_Direction = UnityEngine.UI.Slider.Direction.LeftToRight;
                this.m_MinValue = 0;
                this.m_MaxValue = 1;
                this.m_WholeNumbers = false;
                this.m_OnValueChanged = new UnityEngine.UI.Slider.SliderEvent();
                this._offset = pc.Vec2.ZERO.clone();
                this._delayedUpdateVisuals = false;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#ctor", this ); }

                this.$initialize();
                UnityEngine.UI.Selectable.ctor.call(this);
            },
            $ctor1: function (handle) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#$ctor1", this ); }

                this.$initialize();
                UnityEngine.UI.Selectable.$ctor1.call(this, handle);
            }
        },
        methods: {
            /*UnityEngine.UI.Slider.SetValueWithoutNotify start.*/
            /**
             * Set the value of the slider without invoking onValueChanged callback.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Slider
             * @memberof UnityEngine.UI.Slider
             * @param   {number}    input    The new value for the slider.
             * @return  {void}
             */
            SetValueWithoutNotify: function (input) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#SetValueWithoutNotify", this ); }

                this.Set(input, false);
            },
            /*UnityEngine.UI.Slider.SetValueWithoutNotify end.*/

            /*UnityEngine.UI.Slider.Rebuild start.*/
            Rebuild: function (executing) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#Rebuild", this ); }
 },
            /*UnityEngine.UI.Slider.Rebuild end.*/

            /*UnityEngine.UI.Slider.LayoutComplete start.*/
            /**
             * See ICanvasElement.LayoutComplete
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Slider
             * @memberof UnityEngine.UI.Slider
             * @return  {void}
             */
            LayoutComplete: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#LayoutComplete", this ); }
 },
            /*UnityEngine.UI.Slider.LayoutComplete end.*/

            /*UnityEngine.UI.Slider.GraphicUpdateComplete start.*/
            /**
             * See ICanvasElement.GraphicUpdateComplete
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Slider
             * @memberof UnityEngine.UI.Slider
             * @return  {void}
             */
            GraphicUpdateComplete: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#GraphicUpdateComplete", this ); }
 },
            /*UnityEngine.UI.Slider.GraphicUpdateComplete end.*/

            /*UnityEngine.UI.Slider.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#OnEnable", this ); }

                UnityEngine.UI.Selectable.prototype.OnEnable.call(this);
                this.UpdateCachedReferences();
                this.Set(this.m_Value, false);
                // Update rects since they need to be initialized correctly.
                this.UpdateVisuals();
            },
            /*UnityEngine.UI.Slider.OnEnable end.*/

            /*UnityEngine.UI.Slider.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#OnDisable", this ); }

                this._tracker.reportMethod( 'UnityEngine.DrivenRectTransformTracker.Clear', null );
                UnityEngine.UI.Selectable.prototype.OnDisable.call(this);
            },
            /*UnityEngine.UI.Slider.OnDisable end.*/

            /*UnityEngine.UI.Slider.Update start.*/
            /**
             * Update the rect based on the delayed update visuals.
             Got around issue of calling sendMessage from onValidate.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.Slider
             * @memberof UnityEngine.UI.Slider
             * @return  {void}
             */
            Update: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#Update", this ); }

                if (this._delayedUpdateVisuals) {
                    this._delayedUpdateVisuals = false;
                    this.UpdateVisuals();
                }
            },
            /*UnityEngine.UI.Slider.Update end.*/

            /*UnityEngine.UI.Slider.OnDidApplyAnimationProperties start.*/
            OnDidApplyAnimationProperties: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#OnDidApplyAnimationProperties", this ); }

                // Has value changed? Various elements of the slider have the old normalisedValue assigned, we can use this to perform a comparison.
                // We also need to ensure the value stays within min/max.
                this.m_Value = this.ClampValue(this.m_Value);
                var oldNormalizedValue = this.normalizedValue;
                if (UnityEngine.Component.op_Inequality(this._fillContainerRect, null)) {
                    if (UnityEngine.MonoBehaviour.op_Inequality(this._fillImage, null) && this._fillImage.type === UnityEngine.UI.Image.Type.Filled) {
                        oldNormalizedValue = this._fillImage.fillAmount;
                    } else {
                        oldNormalizedValue = this.reverseValue ? 1 - this.m_FillRect.anchorMin.getitem(this.axis) : this.m_FillRect.anchorMax.getitem(this.axis);
                    }
                } else if (UnityEngine.Component.op_Inequality(this._handleContainerRect, null)) {
                    oldNormalizedValue = this.reverseValue ? 1 - this.m_HandleRect.anchorMin.getitem(this.axis) : this.m_HandleRect.anchorMin.getitem(this.axis);
                }

                this.UpdateVisuals();

                if (oldNormalizedValue !== this.normalizedValue) {
                    this.onValueChanged.Invoke(this.m_Value);
                }
            },
            /*UnityEngine.UI.Slider.OnDidApplyAnimationProperties end.*/

            /*UnityEngine.UI.Slider.UpdateCachedReferences start.*/
            UpdateCachedReferences: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#UpdateCachedReferences", this ); }

                if (UnityEngine.Object.op_Implicit(this.m_FillRect) && UnityEngine.Component.op_Inequality(this.m_FillRect, Bridge.cast(this.transform, UnityEngine.RectTransform))) {
                    this._fillTransform = this.m_FillRect.transform;
                    this._fillImage = this.m_FillRect.GetComponent(UnityEngine.UI.Image);
                    if (UnityEngine.Component.op_Inequality(this._fillTransform.parent, null)) {
                        this._fillContainerRect = this._fillTransform.parent.GetComponent(UnityEngine.RectTransform);
                    }
                } else {
                    this.m_FillRect = null;
                    this._fillContainerRect = null;
                    this._fillImage = null;
                }

                if (UnityEngine.Object.op_Implicit(this.m_HandleRect) && UnityEngine.Component.op_Inequality(this.m_HandleRect, Bridge.cast(this.transform, UnityEngine.RectTransform))) {
                    this._handleTransform = this.m_HandleRect.transform;
                    if (UnityEngine.Component.op_Inequality(this._handleTransform.parent, null)) {
                        this._handleContainerRect = this._handleTransform.parent.GetComponent(UnityEngine.RectTransform);
                    }
                } else {
                    this.m_HandleRect = null;
                    this._handleContainerRect = null;
                }
            },
            /*UnityEngine.UI.Slider.UpdateCachedReferences end.*/

            /*UnityEngine.UI.Slider.ClampValue start.*/
            ClampValue: function (input) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#ClampValue", this ); }

                var newValue = Math.max(this.minValue, Math.min(input, this.maxValue));
                if (this.wholeNumbers) {
                    newValue = Math.round(newValue);
                }

                return newValue;
            },
            /*UnityEngine.UI.Slider.ClampValue end.*/

            /*UnityEngine.UI.Slider.Set start.*/
            /**
             * Set the value of the slider.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.Slider
             * @memberof UnityEngine.UI.Slider
             * @param   {number}     input           The new value for the slider.
             * @param   {boolean}    sendCallback    If the OnValueChanged callback should be invoked.
             * @return  {void}
             */
            Set: function (input, sendCallback) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#Set", this ); }

                if (sendCallback === void 0) { sendCallback = true; }
                // Clamp the input
                var newValue = this.ClampValue(input);

                // If the stepped value doesn't match the last one, it's time to update
                if (this.m_Value === newValue) {
                    return;
                }

                this.m_Value = newValue;
                this.UpdateVisuals();
                if (sendCallback) {
                    this.m_OnValueChanged.Invoke(newValue);
                }
            },
            /*UnityEngine.UI.Slider.Set end.*/

            /*UnityEngine.UI.Slider.OnRectTransformDimensionsChange start.*/
            OnRectTransformDimensionsChange: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#OnRectTransformDimensionsChange", this ); }

                UnityEngine.UI.Selectable.prototype.OnRectTransformDimensionsChange.call(this);

                //This can be invoked before OnEnabled is called. So we shouldn't be accessing other objects, before OnEnable is called.
                if (!this.IsActive()) {
                    return;
                }

                this.UpdateVisuals();
            },
            /*UnityEngine.UI.Slider.OnRectTransformDimensionsChange end.*/

            /*UnityEngine.UI.Slider.UpdateVisuals start.*/
            UpdateVisuals: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#UpdateVisuals", this ); }

                var $t;
                this._tracker.reportMethod( 'UnityEngine.DrivenRectTransformTracker.Clear', null );

                if (UnityEngine.Component.op_Inequality(this._fillContainerRect, null)) {
                    this._tracker.reportMethod( 'UnityEngine.DrivenRectTransformTracker.Add', null );
                    var anchorMin = pc.Vec2.ZERO.clone();
                    var anchorMax = pc.Vec2.ONE.clone();

                    if (UnityEngine.MonoBehaviour.op_Inequality(this._fillImage, null) && this._fillImage.type === UnityEngine.UI.Image.Type.Filled) {
                        this._fillImage.fillAmount = this.normalizedValue;
                    } else {
                        if (this.reverseValue) {
                            anchorMin.setitem(this.axis, 1 - this.normalizedValue);
                        } else {
                            anchorMax.setitem(this.axis, this.normalizedValue);
                        }
                    }

                    this.m_FillRect.anchorMin = anchorMin.$clone();
                    this.m_FillRect.anchorMax = anchorMax.$clone();
                }

                if (UnityEngine.Component.op_Inequality(this._handleContainerRect, null)) {
                    this._tracker.reportMethod( 'UnityEngine.DrivenRectTransformTracker.Add', null );
                    var anchorMin1 = pc.Vec2.ZERO.clone();
                    var anchorMax1 = pc.Vec2.ONE.clone();
                    anchorMin1.setitem(this.axis, ($t = this.reverseValue ? 1 - this.normalizedValue : this.normalizedValue, anchorMax1.setitem(this.axis, $t), $t));
                    this.m_HandleRect.anchorMin = anchorMin1.$clone();
                    this.m_HandleRect.anchorMax = anchorMax1.$clone();
                }
            },
            /*UnityEngine.UI.Slider.UpdateVisuals end.*/

            /*UnityEngine.UI.Slider.UpdateDrag start.*/
            UpdateDrag: function (eventData, cam) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#UpdateDrag", this ); }

                var clickRect = this._handleContainerRect || this._fillContainerRect;
                if (UnityEngine.Component.op_Inequality(clickRect, null) && clickRect.rect.size.getitem(this.axis) > 0) {
                    var localCursor = { v : new UnityEngine.Vector2() };
                    if (!UnityEngine.RectTransformUtility.ScreenPointToLocalPointInRectangle(clickRect, eventData.position, cam, localCursor)) {
                        return;
                    }

                    localCursor.v = localCursor.v.$clone().sub( clickRect.rect.position.$clone() );

                    var val = Math.max(0, Math.min(1, (localCursor.v.$clone().sub( this._offset )).getitem(this.axis) / clickRect.rect.size.getitem(this.axis)));
                    this.normalizedValue = this.reverseValue ? 1.0 - val : val;
                }
            },
            /*UnityEngine.UI.Slider.UpdateDrag end.*/

            /*UnityEngine.UI.Slider.MayDrag start.*/
            MayDrag: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#MayDrag", this ); }

                return this.IsActive() && this.IsInteractable() && eventData.button === UnityEngine.EventSystems.PointerEventData.InputButton.Left;
            },
            /*UnityEngine.UI.Slider.MayDrag end.*/

            /*UnityEngine.UI.Slider.OnPointerDown start.*/
            OnPointerDown: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#OnPointerDown", this ); }

                if (!this.MayDrag(eventData)) {
                    return;
                }

                UnityEngine.UI.Selectable.prototype.OnPointerDown.call(this, eventData);

                this._offset = pc.Vec2.ZERO.clone();
                if (UnityEngine.Component.op_Inequality(this._handleContainerRect, null) && UnityEngine.RectTransformUtility.RectangleContainsScreenPoint$1(this.m_HandleRect, eventData.position, eventData.enterEventCamera)) {
                    var localMousePos = { v : new UnityEngine.Vector2() };
                    if (UnityEngine.RectTransformUtility.ScreenPointToLocalPointInRectangle(this.m_HandleRect, eventData.position, eventData.pressEventCamera, localMousePos)) {
                        this._offset = localMousePos.v.$clone();
                    }
                } else {
                    // Outside the slider handle - jump to this point instead
                    this.UpdateDrag(eventData, eventData.pressEventCamera);
                }
            },
            /*UnityEngine.UI.Slider.OnPointerDown end.*/

            /*UnityEngine.UI.Slider.OnDrag start.*/
            OnDrag: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#OnDrag", this ); }

                if (!this.MayDrag(eventData)) {
                    return;
                }

                this.UpdateDrag(eventData, eventData.pressEventCamera);
            },
            /*UnityEngine.UI.Slider.OnDrag end.*/

            /*UnityEngine.UI.Slider.OnMove start.*/
            OnMove: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#OnMove", this ); }

                if (!this.IsActive() || !this.IsInteractable()) {
                    UnityEngine.UI.Selectable.prototype.OnMove.call(this, eventData);
                    return;
                }

                switch (eventData.moveDir) {
                    case UnityEngine.EventSystems.MoveDirection.Left: 
                        if (this.axis === UnityEngine.UI.Slider.Axis.Horizontal && UnityEngine.MonoBehaviour.op_Equality(this.FindSelectableOnLeft(), null)) {
                            this.Set(this.reverseValue ? this.value + this.stepSize : this.value - this.stepSize);
                        } else {
                            UnityEngine.UI.Selectable.prototype.OnMove.call(this, eventData);
                        }
                        break;
                    case UnityEngine.EventSystems.MoveDirection.Right: 
                        if (this.axis === UnityEngine.UI.Slider.Axis.Horizontal && UnityEngine.MonoBehaviour.op_Equality(this.FindSelectableOnRight(), null)) {
                            this.Set(this.reverseValue ? this.value - this.stepSize : this.value + this.stepSize);
                        } else {
                            UnityEngine.UI.Selectable.prototype.OnMove.call(this, eventData);
                        }
                        break;
                    case UnityEngine.EventSystems.MoveDirection.Up: 
                        if (this.axis === UnityEngine.UI.Slider.Axis.Vertical && UnityEngine.MonoBehaviour.op_Equality(this.FindSelectableOnUp(), null)) {
                            this.Set(this.reverseValue ? this.value - this.stepSize : this.value + this.stepSize);
                        } else {
                            UnityEngine.UI.Selectable.prototype.OnMove.call(this, eventData);
                        }
                        break;
                    case UnityEngine.EventSystems.MoveDirection.Down: 
                        if (this.axis === UnityEngine.UI.Slider.Axis.Vertical && UnityEngine.MonoBehaviour.op_Equality(this.FindSelectableOnDown(), null)) {
                            this.Set(this.reverseValue ? this.value + this.stepSize : this.value - this.stepSize);
                        } else {
                            UnityEngine.UI.Selectable.prototype.OnMove.call(this, eventData);
                        }
                        break;
                }
            },
            /*UnityEngine.UI.Slider.OnMove end.*/

            /*UnityEngine.UI.Slider.FindSelectableOnLeft start.*/
            /**
             * See Selectable.FindSelectableOnLeft
             *
             * @instance
             * @public
             * @override
             * @this UnityEngine.UI.Slider
             * @memberof UnityEngine.UI.Slider
             * @return  {UnityEngine.UI.Selectable}
             */
            FindSelectableOnLeft: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#FindSelectableOnLeft", this ); }

                if (this.navigation.mode === UnityEngine.UI.Navigation.Mode.Automatic && this.axis === UnityEngine.UI.Slider.Axis.Horizontal) {
                    return null;
                }

                return UnityEngine.UI.Selectable.prototype.FindSelectableOnLeft.call(this);
            },
            /*UnityEngine.UI.Slider.FindSelectableOnLeft end.*/

            /*UnityEngine.UI.Slider.FindSelectableOnRight start.*/
            /**
             * See Selectable.FindSelectableOnRight
             *
             * @instance
             * @public
             * @override
             * @this UnityEngine.UI.Slider
             * @memberof UnityEngine.UI.Slider
             * @return  {UnityEngine.UI.Selectable}
             */
            FindSelectableOnRight: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#FindSelectableOnRight", this ); }

                if (this.navigation.mode === UnityEngine.UI.Navigation.Mode.Automatic && this.axis === UnityEngine.UI.Slider.Axis.Horizontal) {
                    return null;
                }

                return UnityEngine.UI.Selectable.prototype.FindSelectableOnRight.call(this);
            },
            /*UnityEngine.UI.Slider.FindSelectableOnRight end.*/

            /*UnityEngine.UI.Slider.FindSelectableOnUp start.*/
            /**
             * See Selectable.FindSelectableOnUp
             *
             * @instance
             * @public
             * @override
             * @this UnityEngine.UI.Slider
             * @memberof UnityEngine.UI.Slider
             * @return  {UnityEngine.UI.Selectable}
             */
            FindSelectableOnUp: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#FindSelectableOnUp", this ); }

                if (this.navigation.mode === UnityEngine.UI.Navigation.Mode.Automatic && this.axis === UnityEngine.UI.Slider.Axis.Vertical) {
                    return null;
                }

                return UnityEngine.UI.Selectable.prototype.FindSelectableOnUp.call(this);
            },
            /*UnityEngine.UI.Slider.FindSelectableOnUp end.*/

            /*UnityEngine.UI.Slider.FindSelectableOnDown start.*/
            /**
             * See Selectable.FindSelectableOnDown
             *
             * @instance
             * @public
             * @override
             * @this UnityEngine.UI.Slider
             * @memberof UnityEngine.UI.Slider
             * @return  {UnityEngine.UI.Selectable}
             */
            FindSelectableOnDown: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#FindSelectableOnDown", this ); }

                if (this.navigation.mode === UnityEngine.UI.Navigation.Mode.Automatic && this.axis === UnityEngine.UI.Slider.Axis.Vertical) {
                    return null;
                }

                return UnityEngine.UI.Selectable.prototype.FindSelectableOnDown.call(this);
            },
            /*UnityEngine.UI.Slider.FindSelectableOnDown end.*/

            /*UnityEngine.UI.Slider.OnInitializePotentialDrag start.*/
            OnInitializePotentialDrag: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#OnInitializePotentialDrag", this ); }

                eventData.useDragThreshold = false;
            },
            /*UnityEngine.UI.Slider.OnInitializePotentialDrag end.*/

            /*UnityEngine.UI.Slider.SetDirection start.*/
            /**
             * Sets the direction of this slider, optionally changing the layout as well.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Slider
             * @memberof UnityEngine.UI.Slider
             * @param   {number}     direction             The direction of the slider
             * @param   {boolean}    includeRectLayouts    Should the layout be flipped together with the slider direction
             * @return  {void}
             */
            SetDirection: function (direction, includeRectLayouts) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#SetDirection", this ); }

                var oldAxis = this.axis;
                var oldReverse = this.reverseValue;
                this.direction = direction;

                if (!includeRectLayouts) {
                    return;
                }

                if (this.axis !== oldAxis) {
                    UnityEngine.RectTransformUtility.FlipLayoutAxes(Bridge.as(this.transform, UnityEngine.RectTransform), true, true);
                }

                if (this.reverseValue !== oldReverse) {
                    UnityEngine.RectTransformUtility.FlipLayoutOnAxis(Bridge.as(this.transform, UnityEngine.RectTransform), this.axis, true, true);
                }
            },
            /*UnityEngine.UI.Slider.SetDirection end.*/

            /*UnityEngine.UI.Slider.ConfigureForEntity start.*/
            /**
             * Configures for entity.
             *
             * @instance
             * @public
             * @override
             * @this UnityEngine.UI.Slider
             * @memberof UnityEngine.UI.Slider
             * @param   {pc.Entity}    entity    Entity.
             * @return  {void}
             */
            ConfigureForEntity: function (entity) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Slider#ConfigureForEntity", this ); }

                UnityEngine.UI.Selectable.prototype.ConfigureForEntity.call(this, entity);
                entity.element["UnityEngine.UI.Slider"] = this;
            },
            /*UnityEngine.UI.Slider.ConfigureForEntity end.*/


        }
    });
    /*UnityEngine.UI.Slider end.*/

    /*UnityEngine.UI.Text start.*/
    Bridge.define("UnityEngine.UI.Text", {
        inherits: [UnityEngine.UI.MaskableGraphic,UnityEngine.UI.ILayoutElement],
        fields: {
            /**
             * The m font data.
             *
             * @instance
             * @protected
             * @memberof UnityEngine.UI.Text
             * @type UnityEngine.UI.FontData
             */
            m_FontData: null,
            /**
             * The m text.
             *
             * @instance
             * @protected
             * @memberof UnityEngine.UI.Text
             * @default ""
             * @type string
             */
            m_Text: null
        },
        props: {
            /**
             * Gets or sets the material.
             *
             * @instance
             * @public
             * @override
             * @memberof UnityEngine.UI.Text
             * @function material
             * @type UnityEngine.Material
             */
            material: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#material#get", this ); }

                    if (this.m_Material != null) {
                        return this.m_Material;
                    }

                    return this.defaultMaterial;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#material#set", this ); }

                    Bridge.ensureBaseProperty(this, "material").$UnityEngine$UI$Graphic$material = value;
                }
            },
            /**
             * Gets or sets the font data.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Text
             * @function fontData
             * @type UnityEngine.UI.FontData
             */
            fontData: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#fontData#get", this ); }

                    return this.m_FontData;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#fontData#set", this ); }

                    this.m_FontData = value;
                    this.ApplyFontDataChanges();
                }
            },
            /**
             * Text's texture comes from the font.
             *
             * @instance
             * @public
             * @override
             * @readonly
             * @memberof UnityEngine.UI.Text
             * @function mainTexture
             * @type UnityEngine.Texture
             */
            mainTexture: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#mainTexture#get", this ); }

                    if (this.fontData != null && this.fontData.font != null && this.fontData.font.handle != null) {
                        return UnityEngine.Object.FromHandle(UnityEngine.Texture, this.fontData.font.handle.texture);
                    }

                    if (this.m_Material != null) {
                        return this.m_Material.mainTexture;
                    }

                    return Bridge.ensureBaseProperty(this, "mainTexture").$UnityEngine$UI$Graphic$mainTexture;
                }
            },
            /**
             * Gets or sets the alignment.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Text
             * @function alignment
             * @type UnityEngine.TextAnchor
             */
            alignment: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#alignment#get", this ); }

                    return this.m_FontData.alignment;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#alignment#set", this ); }

                    this.m_FontData.alignment = value;
                    this.ApplyFontDataChanges();
                }
            },
            /**
             * Gets or sets the text.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Text
             * @function text
             * @type string
             */
            text: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#text#get", this ); }

                    return this.m_Text;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#text#set", this ); }

                    if (System.String.isNullOrEmpty(value)) {
                        if (System.String.isNullOrEmpty(this.m_Text)) {
                            return;
                        }

                        this.m_Text = "";
                        this.handle.entity.element.text = value;
                        this.SetVerticesDirty();
                    } else if (!Bridge.referenceEquals(this.m_Text, value)) {
                        this.m_Text = value;
                        this.handle.entity.element.text = value;
                        this.SetVerticesDirty();
                        this.SetLayoutDirty();
                    }
                }
            },
            /**
             * Gets or sets the font.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Text
             * @function font
             * @type UnityEngine.Font
             */
            font: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#font#get", this ); }

                    return this.m_FontData.font;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#font#set", this ); }

                    this.m_FontData.font = value;
                    this.ApplyFontDataChanges();
                }
            },
            /**
             * Gets or sets the size of the font.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Text
             * @function fontSize
             * @type number
             */
            fontSize: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#fontSize#get", this ); }

                    return this.m_FontData.fontSize;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#fontSize#set", this ); }

                    this.m_FontData.fontSize = value;
                    this.ApplyFontDataChanges();
                }
            },
            /**
             * Font style used by the Text's text.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Text
             * @function fontStyle
             * @type UnityEngine.FontStyle
             */
            fontStyle: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#fontStyle#get", this ); }

                    return this.m_FontData.fontStyle;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#fontStyle#set", this ); }

                    if (this.m_FontData.fontStyle === value) {
                        return;
                    }

                    this.m_FontData.fontStyle = value;
                    this.SetVerticesDirty();
                    this.SetLayoutDirty();
                }
            },
            /**
             * Gets or sets the size of the resize text max.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Text
             * @function resizeTextMaxSize
             * @type number
             */
            resizeTextMaxSize: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#resizeTextMaxSize#get", this ); }

                    return this.m_FontData.maxSize;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#resizeTextMaxSize#set", this ); }

                    this.m_FontData.maxSize = value;
                    this.ApplyFontDataChanges();
                }
            },
            /**
             * Gets or sets the size of the resize text minimum.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Text
             * @function resizeTextMinSize
             * @type number
             */
            resizeTextMinSize: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#resizeTextMinSize#get", this ); }

                    return this.m_FontData.minSize;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#resizeTextMinSize#set", this ); }

                    this.m_FontData.minSize = value;
                    this.ApplyFontDataChanges();
                }
            },
            /**
             * Returns native text generator instance.
             *
             * @instance
             * @protected
             * @readonly
             * @memberof UnityEngine.UI.Text
             * @function textGenerator
             * @type pc.TextGenerator
             */
            textGenerator: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#textGenerator#get", this ); }

                    return this.entity.element._text._textGenerator;
                }
            },
            /**
             * Returns managed text generator instance.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.Text
             * @function cachedTextGenerator
             * @type UnityEngine.TextGenerator
             */
            cachedTextGenerator: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#cachedTextGenerator#get", this ); }

                    return UnityEngine.Object.FromHandle(UnityEngine.TextGenerator, this.textGenerator);
                }
            },
            /**
             * Gets or sets a value indicating whether this {@link } resize text for best fit.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Text
             * @function resizeTextForBestFit
             * @type boolean
             */
            resizeTextForBestFit: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#resizeTextForBestFit#get", this ); }

                    return this.m_FontData.bestFit;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#resizeTextForBestFit#set", this ); }

                    this.m_FontData.bestFit = value;
                    this.ApplyFontDataChanges();
                }
            },
            /**
             * Gets the height of the flexible.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.Text
             * @function flexibleHeight
             * @type number
             */
            flexibleHeight: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#flexibleHeight#get", this ); }

                    return -1.0;
                }
            },
            /**
             * Gets the width of the flexible.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.Text
             * @function flexibleWidth
             * @type number
             */
            flexibleWidth: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#flexibleWidth#get", this ); }

                    return -1.0;
                }
            },
            /**
             * Gets the layout priority.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.Text
             * @function layoutPriority
             * @type number
             */
            layoutPriority: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#layoutPriority#get", this ); }

                    return 0;
                }
            },
            /**
             * Gets the minimum height.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.Text
             * @function minHeight
             * @type number
             */
            minHeight: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#minHeight#get", this ); }

                    return 0;
                }
            },
            /**
             * Gets the minimum width.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.Text
             * @function minWidth
             * @type number
             */
            minWidth: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#minWidth#get", this ); }

                    return 0;
                }
            },
            /**
             * Gets or sets the width of the preferred.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.Text
             * @function preferredWidth
             * @type number
             */
            preferredWidth: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#preferredWidth#get", this ); }

                    return this.textGenerator.measureText(this.m_Text, 1E+15, this.entity.element._text).x;
                }
            },
            /**
             * Gets or sets the height of the preferred.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.Text
             * @function preferredHeight
             * @type number
             */
            preferredHeight: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#preferredHeight#get", this ); }

                    return this.textGenerator.measureText(this.m_Text, this.rectTransform.rect.width, this.entity.element._text).y;
                }
            },
            /**
             * <p>Horizontal overflow mode.</p>
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Text
             * @function horizontalOverflow
             * @type UnityEngine.HorizontalWrapMode
             */
            horizontalOverflow: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#horizontalOverflow#get", this ); }

                    return this.m_FontData.horizontalOverflow;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#horizontalOverflow#set", this ); }

                    if (this.m_FontData.horizontalOverflow === value) {
                        return;
                    }

                    this.m_FontData.horizontalOverflow = value;
                    this.SetVerticesDirty();
                    this.SetLayoutDirty();
                }
            },
            /**
             * <p>Vertical overflow mode.</p>
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Text
             * @function verticalOverflow
             * @type UnityEngine.VerticalWrapMode
             */
            verticalOverflow: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#verticalOverflow#get", this ); }

                    return this.m_FontData.verticalOverflow;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#verticalOverflow#set", this ); }

                    if (this.m_FontData.verticalOverflow === value) {
                        return;
                    }

                    this.m_FontData.verticalOverflow = value;
                    this.SetVerticesDirty();
                    this.SetLayoutDirty();
                }
            },
            supportRichText: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#supportRichText#get", this ); }

                    return this.m_FontData.richText;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#supportRichText#set", this ); }

                    if (this.m_FontData.richText === value) {
                        return;
                    }

                    this.m_FontData.richText = value;
                    this.SetVerticesDirty();
                    this.SetLayoutDirty();
                }
            },
            /**
             * Provides information about how fonts are scale to the screen.
             *
             * @instance
             * @public
             * @readonly
             * @memberof UnityEngine.UI.Text
             * @function pixelsPerUnit
             * @type number
             */
            pixelsPerUnit: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#pixelsPerUnit#get", this ); }

                    return 1;
                }
            }
        },
        alias: [
            "flexibleHeight", "UnityEngine$UI$ILayoutElement$flexibleHeight",
            "flexibleWidth", "UnityEngine$UI$ILayoutElement$flexibleWidth",
            "layoutPriority", "UnityEngine$UI$ILayoutElement$layoutPriority",
            "minHeight", "UnityEngine$UI$ILayoutElement$minHeight",
            "minWidth", "UnityEngine$UI$ILayoutElement$minWidth",
            "preferredWidth", "UnityEngine$UI$ILayoutElement$preferredWidth",
            "preferredHeight", "UnityEngine$UI$ILayoutElement$preferredHeight",
            "CalculateLayoutInputHorizontal", "UnityEngine$UI$ILayoutElement$CalculateLayoutInputHorizontal",
            "CalculateLayoutInputVertical", "UnityEngine$UI$ILayoutElement$CalculateLayoutInputVertical"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#init", this ); }

                this.m_FontData = UnityEngine.UI.FontData.defaultFontData;
                this.m_Text = "";
            },
            $ctor1: function (handle) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#$ctor1", this ); }

                this.$initialize();
                UnityEngine.UI.MaskableGraphic.$ctor1.call(this, handle);
            },
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#ctor", this ); }

                this.$initialize();
                UnityEngine.UI.MaskableGraphic.$ctor1.call(this, null);
            }
        },
        methods: {
            /*UnityEngine.UI.Text.ConfigureForEntity start.*/
            /**
             * Configures for entity.
             *
             * @instance
             * @public
             * @override
             * @this UnityEngine.UI.Text
             * @memberof UnityEngine.UI.Text
             * @param   {pc.Entity}    entity    Entity.
             * @return  {void}
             */
            ConfigureForEntity: function (entity) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#ConfigureForEntity", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.ConfigureForEntity.call(this, entity);
                entity.element.type = "text";
            },
            /*UnityEngine.UI.Text.ConfigureForEntity end.*/

            /*UnityEngine.UI.Text.Awake start.*/
            /**
             * Awake this instance.
             *
             * @instance
             * @protected
             * @override
             * @this UnityEngine.UI.Text
             * @memberof UnityEngine.UI.Text
             * @return  {void}
             */
            Awake: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#Awake", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.Awake.call(this);

                this.handle.entity.element["UnityEngine.UI.Text"] = this;
                this.handle.entity.element._text.enabled = this.handle.enabled;

                this.ApplyFontDataChanges();
            },
            /*UnityEngine.UI.Text.Awake end.*/

            /*UnityEngine.UI.Text.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#OnEnable", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.OnEnable.call(this);

                if (this.handle.entity.element != null) {
                    this.handle.entity.element._text.enabled = true;
                    this.SetAllDirty();
                }
            },
            /*UnityEngine.UI.Text.OnEnable end.*/

            /*UnityEngine.UI.Text.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#OnDisable", this ); }

                if (this.handle.entity.element != null) {
                    this.handle.entity.element._text.enabled = false;
                    this.SetAllDirty();
                }

                UnityEngine.UI.MaskableGraphic.prototype.OnDisable.call(this);
            },
            /*UnityEngine.UI.Text.OnDisable end.*/

            /*UnityEngine.UI.Text.ApplyFontDataChanges start.*/
            /**
             * Applies the font data changes.
             *
             * @instance
             * @protected
             * @this UnityEngine.UI.Text
             * @memberof UnityEngine.UI.Text
             * @return  {void}
             */
            ApplyFontDataChanges: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#ApplyFontDataChanges", this ); }

                var $t;
                var element = this.handle.entity.element;
                element._text.font = ($t = this.m_FontData.font) != null ? $t.handle : null;
                element.color = this.m_Color.$clone();

                element._text.fontSize = this.m_FontData.fontSize;
                element._text.minFontSize = this.m_FontData.minSize;
                element._text.maxFontSize = this.m_FontData.maxSize;
                element._text.bestFit = this.m_FontData.bestFit;
                element._text.lineSpacing = this.m_FontData.lineSpacing;
                element._text.horizontalWrap = this.m_FontData.horizontalOverflow === UnityEngine.HorizontalWrapMode.Wrap;
                element._text.verticalOverflow = this.m_FontData.verticalOverflow === UnityEngine.VerticalWrapMode.Overflow;

                element.material = this.m_Material != null ? this.m_Material.handle : null;

                switch (this.m_FontData.alignment) {
                    case UnityEngine.TextAnchor.LowerCenter: 
                        element._text.align = pc.TEXT_ALIGN_CENTER;
                        element._text.verticalAlign = pc.TEXT_VERTICAL_ALIGN_BOTTOM;
                        break;
                    case UnityEngine.TextAnchor.LowerLeft: 
                        element._text.align = pc.TEXT_ALIGN_LEFT;
                        element._text.verticalAlign = pc.TEXT_VERTICAL_ALIGN_BOTTOM;
                        break;
                    case UnityEngine.TextAnchor.LowerRight: 
                        element._text.align = pc.TEXT_ALIGN_RIGHT;
                        element._text.verticalAlign = pc.TEXT_VERTICAL_ALIGN_BOTTOM;
                        break;
                    case UnityEngine.TextAnchor.MiddleCenter: 
                        element._text.align = pc.TEXT_ALIGN_CENTER;
                        element._text.verticalAlign = pc.TEXT_VERTICAL_ALIGN_MIDDLE;
                        break;
                    case UnityEngine.TextAnchor.MiddleLeft: 
                        element._text.align = pc.TEXT_ALIGN_LEFT;
                        element._text.verticalAlign = pc.TEXT_VERTICAL_ALIGN_MIDDLE;
                        break;
                    case UnityEngine.TextAnchor.MiddleRight: 
                        element._text.align = pc.TEXT_ALIGN_RIGHT;
                        element._text.verticalAlign = pc.TEXT_VERTICAL_ALIGN_MIDDLE;
                        break;
                    case UnityEngine.TextAnchor.UpperCenter: 
                        element._text.align = pc.TEXT_ALIGN_CENTER;
                        element._text.verticalAlign = pc.TEXT_VERTICAL_ALIGN_TOP;
                        break;
                    case UnityEngine.TextAnchor.UpperLeft: 
                        element._text.align = pc.TEXT_ALIGN_LEFT;
                        element._text.verticalAlign = pc.TEXT_VERTICAL_ALIGN_TOP;
                        break;
                    case UnityEngine.TextAnchor.UpperRight: 
                        element._text.align = pc.TEXT_ALIGN_RIGHT;
                        element._text.verticalAlign = pc.TEXT_VERTICAL_ALIGN_TOP;
                        break;
                }

                element.text = this.m_Text;
                this.SetAllDirty();
            },
            /*UnityEngine.UI.Text.ApplyFontDataChanges end.*/

            /*UnityEngine.UI.Text.CalculateLayoutInputHorizontal start.*/
            /**
             * Calculates the layout input horizontal.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Text
             * @memberof UnityEngine.UI.Text
             * @return  {void}
             */
            CalculateLayoutInputHorizontal: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#CalculateLayoutInputHorizontal", this ); }
 },
            /*UnityEngine.UI.Text.CalculateLayoutInputHorizontal end.*/

            /*UnityEngine.UI.Text.CalculateLayoutInputVertical start.*/
            /**
             * Calculates the layout input vertical.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Text
             * @memberof UnityEngine.UI.Text
             * @return  {void}
             */
            CalculateLayoutInputVertical: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#CalculateLayoutInputVertical", this ); }
 },
            /*UnityEngine.UI.Text.CalculateLayoutInputVertical end.*/

            /*UnityEngine.UI.Text.OnDidApplyAnimationProperties start.*/
            /**
             * Synchronizes animatable properties with lower-level counterpart.
             *
             * @instance
             * @protected
             * @override
             * @this UnityEngine.UI.Text
             * @memberof UnityEngine.UI.Text
             * @return  {void}
             */
            OnDidApplyAnimationProperties: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#OnDidApplyAnimationProperties", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.OnDidApplyAnimationProperties.call(this);
                this.handle.entity.element._text.synchornizeProperties( this );
            },
            /*UnityEngine.UI.Text.OnDidApplyAnimationProperties end.*/

            /*UnityEngine.UI.Text.OnRectTransformDimensionsChange start.*/
            /**
             * Handles resizing event - the text might want to adjust its mesh in this case.
             *
             * @instance
             * @protected
             * @override
             * @this UnityEngine.UI.Text
             * @memberof UnityEngine.UI.Text
             * @return  {void}
             */
            OnRectTransformDimensionsChange: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#OnRectTransformDimensionsChange", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.OnRectTransformDimensionsChange.call(this);
                this.SetAllDirty();
            },
            /*UnityEngine.UI.Text.OnRectTransformDimensionsChange end.*/

            /*UnityEngine.UI.Text.GetGenerationSettings start.*/
            /**
             * Convenience function to populate the generation setting for the text.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Text
             * @memberof UnityEngine.UI.Text
             * @param   {UnityEngine.Vector2}                   extents    The extents the text can draw in.
             * @return  {UnityEngine.TextGenerationSettings}               Generated settings.
             */
            GetGenerationSettings: function (extents) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Text#GetGenerationSettings", this ); }

                var settings = new UnityEngine.TextGenerationSettings();

                settings.generationExtents = extents.$clone();
                if (this.font != null && this.font.dynamic) {
                    settings.fontSize = this.m_FontData.fontSize;
                    settings.resizeTextMinSize = this.m_FontData.minSize;
                    settings.resizeTextMaxSize = this.m_FontData.maxSize;
                }

                // Other settings
                settings.textAnchor = this.m_FontData.alignment;
                settings.alignByGeometry = this.m_FontData.alignByGeometry;
                settings.scaleFactor = this.pixelsPerUnit;
                settings.color = this.color.$clone();
                settings.font = this.font;
                settings.pivot = this.rectTransform.pivot.$clone();
                settings.richText = this.m_FontData.richText;
                settings.lineSpacing = this.m_FontData.lineSpacing;
                settings.fontStyle = this.m_FontData.fontStyle;
                settings.resizeTextForBestFit = this.m_FontData.bestFit;
                settings.updateBounds = false;
                settings.horizontalOverflow = this.m_FontData.horizontalOverflow;
                settings.verticalOverflow = this.m_FontData.verticalOverflow;

                return settings.$clone();
            },
            /*UnityEngine.UI.Text.GetGenerationSettings end.*/


        }
    });
    /*UnityEngine.UI.Text end.*/

    /*UnityEngine.UI.Toggle start.*/
    /**
     * A standard toggle that has an on / off state.
     *
     * @public
     * @class UnityEngine.UI.Toggle
     * @augments UnityEngine.UI.Selectable
     * @implements  UnityEngine.EventSystems.IPointerClickHandler
     * @implements  UnityEngine.EventSystems.ISubmitHandler
     * @implements  UnityEngine.UI.ICanvasElement
     */
    Bridge.define("UnityEngine.UI.Toggle", {
        inherits: [UnityEngine.UI.Selectable,UnityEngine.EventSystems.IPointerClickHandler,UnityEngine.EventSystems.ISubmitHandler,UnityEngine.UI.ICanvasElement],
        fields: {
            /**
             * Transition mode for the toggle.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Toggle
             * @type number
             */
            toggleTransition: 0,
            /**
             * Graphic the toggle should be working with.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Toggle
             * @type UnityEngine.UI.Graphic
             */
            graphic: null,
            /**
             * Allow for delegate-based subscriptions for faster events than 'eventReceiver', and allowing for multiple receivers.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Toggle
             * @type UnityEngine.UI.Toggle.ToggleEvent
             */
            onValueChanged: null,
            m_Group: null,
            m_IsOn: false
        },
        props: {
            /**
             * Group the toggle belongs to.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Toggle
             * @function group
             * @type UnityEngine.UI.ToggleGroup
             */
            group: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Toggle#group#get", this ); }

                    return this.m_Group;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Toggle#group#set", this ); }

                    this.m_Group = value;
                    this.SetToggleGroup(this.m_Group, true);
                    this.PlayEffect(true);
                }
            },
            /**
             * Whether the toggle is currently active.
             *
             * @instance
             * @public
             * @memberof UnityEngine.UI.Toggle
             * @function isOn
             * @type boolean
             */
            isOn: {
                get: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Toggle#isOn#get", this ); }

                    return this.m_IsOn;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Toggle#isOn#set", this ); }

                    this.Set(value);
                }
            }
        },
        alias: [
            "Rebuild", "UnityEngine$UI$ICanvasElement$Rebuild",
            "LayoutComplete", "UnityEngine$UI$ICanvasElement$LayoutComplete",
            "GraphicUpdateComplete", "UnityEngine$UI$ICanvasElement$GraphicUpdateComplete",
            "OnPointerClick", "UnityEngine$EventSystems$IPointerClickHandler$OnPointerClick",
            "OnSubmit", "UnityEngine$EventSystems$ISubmitHandler$OnSubmit",
            "IsDestroyed", "UnityEngine$UI$ICanvasElement$IsDestroyed",
            "transform", "UnityEngine$UI$ICanvasElement$transform"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Toggle#init", this ); }

                this.toggleTransition = UnityEngine.UI.Toggle.ToggleTransition.Fade;
                this.onValueChanged = new UnityEngine.UI.Toggle.ToggleEvent();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Toggle#ctor", this ); }

                this.$initialize();
                UnityEngine.UI.Selectable.ctor.call(this);
            }
        },
        methods: {
            /*UnityEngine.UI.Toggle.Start start.*/
            /**
             * Assume the correct visual state.
             *
             * @instance
             * @protected
             * @override
             * @this UnityEngine.UI.Toggle
             * @memberof UnityEngine.UI.Toggle
             * @return  {void}
             */
            Start: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Toggle#Start", this ); }

                this.PlayEffect(true);
            },
            /*UnityEngine.UI.Toggle.Start end.*/

            /*UnityEngine.UI.Toggle.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Toggle#OnEnable", this ); }

                UnityEngine.UI.Selectable.prototype.OnEnable.call(this);
                this.SetToggleGroup(this.m_Group, false);
                this.PlayEffect(true);
            },
            /*UnityEngine.UI.Toggle.OnEnable end.*/

            /*UnityEngine.UI.Toggle.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Toggle#OnDisable", this ); }

                this.SetToggleGroup(null, false);
                UnityEngine.UI.Selectable.prototype.OnDisable.call(this);
            },
            /*UnityEngine.UI.Toggle.OnDisable end.*/

            /*UnityEngine.UI.Toggle.OnDidApplyAnimationProperties start.*/
            OnDidApplyAnimationProperties: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Toggle#OnDidApplyAnimationProperties", this ); }

                // Check if isOn has been changed by the animation.
                // Unfortunately there is no way to check if we don�t have a graphic.
                if (UnityEngine.MonoBehaviour.op_Inequality(this.graphic, null)) {
                    var oldValue = !UnityEngine.Mathf.Approximately(this.graphic.canvasRenderer.GetColor().a, 0);
                    if (this.m_IsOn !== oldValue) {
                        this.m_IsOn = oldValue;
                        this.Set(!oldValue);
                    }
                }

                UnityEngine.UI.Selectable.prototype.OnDidApplyAnimationProperties.call(this);
            },
            /*UnityEngine.UI.Toggle.OnDidApplyAnimationProperties end.*/

            /*UnityEngine.UI.Toggle.Rebuild start.*/
            Rebuild: function (executing) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Toggle#Rebuild", this ); }
 },
            /*UnityEngine.UI.Toggle.Rebuild end.*/

            /*UnityEngine.UI.Toggle.LayoutComplete start.*/
            LayoutComplete: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Toggle#LayoutComplete", this ); }
 },
            /*UnityEngine.UI.Toggle.LayoutComplete end.*/

            /*UnityEngine.UI.Toggle.GraphicUpdateComplete start.*/
            GraphicUpdateComplete: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Toggle#GraphicUpdateComplete", this ); }
 },
            /*UnityEngine.UI.Toggle.GraphicUpdateComplete end.*/

            /*UnityEngine.UI.Toggle.OnPointerClick start.*/
            /**
             * React to clicks.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Toggle
             * @memberof UnityEngine.UI.Toggle
             * @param   {UnityEngine.EventSystems.PointerEventData}    eventData
             * @return  {void}
             */
            OnPointerClick: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Toggle#OnPointerClick", this ); }

                if (eventData.button !== UnityEngine.EventSystems.PointerEventData.InputButton.Left) {
                    return;
                }

                this.InternalToggle();
            },
            /*UnityEngine.UI.Toggle.OnPointerClick end.*/

            /*UnityEngine.UI.Toggle.OnSubmit start.*/
            OnSubmit: function (eventData) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Toggle#OnSubmit", this ); }

                this.InternalToggle();
            },
            /*UnityEngine.UI.Toggle.OnSubmit end.*/

            /*UnityEngine.UI.Toggle.SetToggleGroup start.*/
            SetToggleGroup: function (newGroup, setMemberValue) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Toggle#SetToggleGroup", this ); }

                // Sometimes IsActive returns false in OnDisable so don't check for it.
                // Rather remove the toggle too often than too little.
                if (UnityEngine.MonoBehaviour.op_Inequality(this.m_Group, null)) {
                    this.m_Group.UnregisterToggle(this);
                }

                // At runtime the group variable should be set but not when calling this method from OnEnable or OnDisable.
                // That's why we use the setMemberValue parameter.
                if (setMemberValue) {
                    this.m_Group = newGroup;
                }

                // Only register to the new group if this Toggle is active.
                if (UnityEngine.MonoBehaviour.op_Inequality(newGroup, null) && this.IsActive()) {
                    newGroup.RegisterToggle(this);
                }

                // If we are in a new group, and this toggle is on, notify group.
                // Note: Don't refer to m_Group here as it's not guaranteed to have been set.
                if (UnityEngine.MonoBehaviour.op_Inequality(newGroup, null) && this.isOn && this.IsActive()) {
                    newGroup.NotifyToggleOn(this);
                }
            },
            /*UnityEngine.UI.Toggle.SetToggleGroup end.*/

            /*UnityEngine.UI.Toggle.SetIsOnWithoutNotify start.*/
            /**
             * Set isOn without invoking onValueChanged callback.
             *
             * @instance
             * @public
             * @this UnityEngine.UI.Toggle
             * @memberof UnityEngine.UI.Toggle
             * @param   {boolean}    value    New Value for isOn.
             * @return  {void}
             */
            SetIsOnWithoutNotify: function (value) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Toggle#SetIsOnWithoutNotify", this ); }

                this.Set(value, false);
            },
            /*UnityEngine.UI.Toggle.SetIsOnWithoutNotify end.*/

            /*UnityEngine.UI.Toggle.Set start.*/
            Set: function (value, sendCallback) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Toggle#Set", this ); }

                if (sendCallback === void 0) { sendCallback = true; }
                if (this.m_IsOn === value) {
                    return;
                }

                // if we are in a group and set to true, do group logic
                this.m_IsOn = value;
                if (UnityEngine.MonoBehaviour.op_Inequality(this.m_Group, null) && this.IsActive()) {
                    if (this.m_IsOn || !this.m_Group.AnyTogglesOn() && !this.m_Group.allowSwitchOff) {
                        this.m_IsOn = true;
                        this.m_Group.NotifyToggleOn(this, sendCallback);
                    }
                }

                // Always send event when toggle is clicked, even if value didn't change
                // due to already active toggle in a toggle group being clicked.
                // Controls like Dropdown rely on this.
                // It's up to the user to ignore a selection being set to the same value it already was, if desired.
                this.PlayEffect(this.toggleTransition === UnityEngine.UI.Toggle.ToggleTransition.None);
                if (sendCallback) {
                    this.onValueChanged.Invoke(this.m_IsOn);
                }
            },
            /*UnityEngine.UI.Toggle.Set end.*/

            /*UnityEngine.UI.Toggle.PlayEffect start.*/
            /**
             * Play the appropriate effect.
             *
             * @instance
             * @private
             * @this UnityEngine.UI.Toggle
             * @memberof UnityEngine.UI.Toggle
             * @param   {boolean}    instant
             * @return  {void}
             */
            PlayEffect: function (instant) {
if ( TRACE ) { TRACE( "UnityEngine.UI.Toggle#PlayEffect", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.graphic, null)) {
                    return;
                }

                this.graphic.CrossFadeAlpha(this.m_IsOn ? 1.0 : 0.0, instant ? 0.0 : 0.1, true);
            },
            /*UnityEngine.UI.Toggle.PlayEffect end.*/

            /*UnityEngine.UI.Toggle.InternalToggle start.*/
            InternalToggle: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.Toggle#InternalToggle", this ); }

                if (!this.IsActive() || !this.IsInteractable()) {
                    return;
                }

                this.isOn = !this.isOn;
            },
            /*UnityEngine.UI.Toggle.InternalToggle end.*/


        }
    });
    /*UnityEngine.UI.Toggle end.*/

    /*UnityEngine.UI.HorizontalLayoutGroup start.*/
    Bridge.define("UnityEngine.UI.HorizontalLayoutGroup", {
        inherits: [UnityEngine.UI.HorizontalOrVerticalLayoutGroup],
        alias: [
            "CalculateLayoutInputHorizontal", "UnityEngine$UI$ILayoutElement$CalculateLayoutInputHorizontal",
            "CalculateLayoutInputVertical", "UnityEngine$UI$ILayoutElement$CalculateLayoutInputVertical",
            "SetLayoutHorizontal", "UnityEngine$UI$ILayoutController$SetLayoutHorizontal",
            "SetLayoutVertical", "UnityEngine$UI$ILayoutController$SetLayoutVertical"
        ],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.HorizontalLayoutGroup#ctor", this ); }

                this.$initialize();
                UnityEngine.UI.HorizontalOrVerticalLayoutGroup.ctor.call(this);
            }
        },
        methods: {
            /*UnityEngine.UI.HorizontalLayoutGroup.CalculateLayoutInputHorizontal start.*/
            CalculateLayoutInputHorizontal: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.HorizontalLayoutGroup#CalculateLayoutInputHorizontal", this ); }

                UnityEngine.UI.HorizontalOrVerticalLayoutGroup.prototype.CalculateLayoutInputHorizontal.call(this);
                this.CalcAlongAxis(0, false);
            },
            /*UnityEngine.UI.HorizontalLayoutGroup.CalculateLayoutInputHorizontal end.*/

            /*UnityEngine.UI.HorizontalLayoutGroup.CalculateLayoutInputVertical start.*/
            CalculateLayoutInputVertical: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.HorizontalLayoutGroup#CalculateLayoutInputVertical", this ); }

                this.CalcAlongAxis(1, false);
            },
            /*UnityEngine.UI.HorizontalLayoutGroup.CalculateLayoutInputVertical end.*/

            /*UnityEngine.UI.HorizontalLayoutGroup.SetLayoutHorizontal start.*/
            SetLayoutHorizontal: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.HorizontalLayoutGroup#SetLayoutHorizontal", this ); }

                this.SetChildrenAlongAxis(0, false);
            },
            /*UnityEngine.UI.HorizontalLayoutGroup.SetLayoutHorizontal end.*/

            /*UnityEngine.UI.HorizontalLayoutGroup.SetLayoutVertical start.*/
            SetLayoutVertical: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.HorizontalLayoutGroup#SetLayoutVertical", this ); }

                this.SetChildrenAlongAxis(1, false);
            },
            /*UnityEngine.UI.HorizontalLayoutGroup.SetLayoutVertical end.*/


        }
    });
    /*UnityEngine.UI.HorizontalLayoutGroup end.*/

    /*UnityEngine.UI.VerticalLayoutGroup start.*/
    Bridge.define("UnityEngine.UI.VerticalLayoutGroup", {
        inherits: [UnityEngine.UI.HorizontalOrVerticalLayoutGroup],
        alias: [
            "CalculateLayoutInputHorizontal", "UnityEngine$UI$ILayoutElement$CalculateLayoutInputHorizontal",
            "CalculateLayoutInputVertical", "UnityEngine$UI$ILayoutElement$CalculateLayoutInputVertical",
            "SetLayoutHorizontal", "UnityEngine$UI$ILayoutController$SetLayoutHorizontal",
            "SetLayoutVertical", "UnityEngine$UI$ILayoutController$SetLayoutVertical"
        ],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.VerticalLayoutGroup#ctor", this ); }

                this.$initialize();
                UnityEngine.UI.HorizontalOrVerticalLayoutGroup.ctor.call(this);
            }
        },
        methods: {
            /*UnityEngine.UI.VerticalLayoutGroup.CalculateLayoutInputHorizontal start.*/
            CalculateLayoutInputHorizontal: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.VerticalLayoutGroup#CalculateLayoutInputHorizontal", this ); }

                UnityEngine.UI.HorizontalOrVerticalLayoutGroup.prototype.CalculateLayoutInputHorizontal.call(this);
                this.CalcAlongAxis(0, true);
            },
            /*UnityEngine.UI.VerticalLayoutGroup.CalculateLayoutInputHorizontal end.*/

            /*UnityEngine.UI.VerticalLayoutGroup.CalculateLayoutInputVertical start.*/
            CalculateLayoutInputVertical: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.VerticalLayoutGroup#CalculateLayoutInputVertical", this ); }

                this.CalcAlongAxis(1, true);
            },
            /*UnityEngine.UI.VerticalLayoutGroup.CalculateLayoutInputVertical end.*/

            /*UnityEngine.UI.VerticalLayoutGroup.SetLayoutHorizontal start.*/
            SetLayoutHorizontal: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.VerticalLayoutGroup#SetLayoutHorizontal", this ); }

                this.SetChildrenAlongAxis(0, true);
            },
            /*UnityEngine.UI.VerticalLayoutGroup.SetLayoutHorizontal end.*/

            /*UnityEngine.UI.VerticalLayoutGroup.SetLayoutVertical start.*/
            SetLayoutVertical: function () {
if ( TRACE ) { TRACE( "UnityEngine.UI.VerticalLayoutGroup#SetLayoutVertical", this ); }

                this.SetChildrenAlongAxis(1, true);
            },
            /*UnityEngine.UI.VerticalLayoutGroup.SetLayoutVertical end.*/


        }
    });
    /*UnityEngine.UI.VerticalLayoutGroup end.*/

    if ( MODULE_reflection ) {
    var $m = Bridge.setMetadata,
        $n = ["System","UnityEngine","System.Collections.Generic","UnityEngine.UI"];

    /*UnityEngine.UI.AnimationTriggers start.*/
    $m("UnityEngine.UI.AnimationTriggers", function () { return {"at":[new System.SerializableAttribute()],"m":[{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("disabledTrigger"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_DisabledTrigger","t":4,"rt":$n[0].String,"sn":"m_DisabledTrigger"},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("highlightedTrigger"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_HighlightedTrigger","t":4,"rt":$n[0].String,"sn":"m_HighlightedTrigger"},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("normalTrigger"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_NormalTrigger","t":4,"rt":$n[0].String,"sn":"m_NormalTrigger"},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("pressedTrigger"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_PressedTrigger","t":4,"rt":$n[0].String,"sn":"m_PressedTrigger"},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_HighlightedTrigger"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_SelectedTrigger","t":4,"rt":$n[0].String,"sn":"m_SelectedTrigger"}]}; }, $n);
    /*UnityEngine.UI.AnimationTriggers end.*/

    /*UnityEngine.UI.ColorBlock start.*/
    $m("UnityEngine.UI.ColorBlock", function () { return {"at":[new System.SerializableAttribute()],"m":[{"at":[new UnityEngine.RangeAttribute(1.0, 5.0),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_ColorMultiplier","t":4,"rt":$n[0].Single,"sn":"m_ColorMultiplier","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("disabledColor"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_DisabledColor","t":4,"rt":$n[1].Color,"sn":"m_DisabledColor"},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("fadeDuration"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_FadeDuration","t":4,"rt":$n[0].Single,"sn":"m_FadeDuration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("highlightedColor"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_HighlightedColor","t":4,"rt":$n[1].Color,"sn":"m_HighlightedColor"},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("normalColor"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_NormalColor","t":4,"rt":$n[1].Color,"sn":"m_NormalColor"},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("pressedColor"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_PressedColor","t":4,"rt":$n[1].Color,"sn":"m_PressedColor"},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_HighlightedColor"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_SelectedColor","t":4,"rt":$n[1].Color,"sn":"m_SelectedColor"}]}; }, $n);
    /*UnityEngine.UI.ColorBlock end.*/

    /*UnityEngine.UI.Dropdown+DropdownEvent start.*/
    $m("UnityEngine.UI.Dropdown.DropdownEvent", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*UnityEngine.UI.Dropdown+DropdownEvent end.*/

    /*UnityEngine.UI.Dropdown+OptionData start.*/
    $m("UnityEngine.UI.Dropdown.OptionData", function () { return {"at":[new System.SerializableAttribute()],"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Image","t":4,"rt":$n[1].Sprite,"sn":"m_Image"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Text","t":4,"rt":$n[0].String,"sn":"m_Text"}]}; }, $n);
    /*UnityEngine.UI.Dropdown+OptionData end.*/

    /*UnityEngine.UI.Dropdown+OptionDataList start.*/
    $m("UnityEngine.UI.Dropdown.OptionDataList", function () { return {"at":[new System.SerializableAttribute()],"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Options","t":4,"rt":$n[2].List$1(UnityEngine.UI.Dropdown.OptionData),"sn":"m_Options"}]}; }, $n);
    /*UnityEngine.UI.Dropdown+OptionDataList end.*/

    /*UnityEngine.UI.InputField+OnChangeEvent start.*/
    $m("UnityEngine.UI.InputField.OnChangeEvent", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*UnityEngine.UI.InputField+OnChangeEvent end.*/

    /*UnityEngine.UI.InputField+SubmitEvent start.*/
    $m("UnityEngine.UI.InputField.SubmitEvent", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*UnityEngine.UI.InputField+SubmitEvent end.*/

    /*UnityEngine.UI.MaskableGraphic+CullStateChangedEvent start.*/
    $m("UnityEngine.UI.MaskableGraphic.CullStateChangedEvent", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*UnityEngine.UI.MaskableGraphic+CullStateChangedEvent end.*/

    /*UnityEngine.UI.Navigation start.*/
    $m("UnityEngine.UI.Navigation", function () { return {"at":[new System.SerializableAttribute()],"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Mode","t":4,"rt":$n[3].Navigation.Mode,"sn":"m_Mode","box":function ($v) { return Bridge.box($v, UnityEngine.UI.Navigation.Mode, System.Enum.toStringFn(UnityEngine.UI.Navigation.Mode));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_SelectOnDown","t":4,"rt":$n[3].Selectable,"sn":"m_SelectOnDown"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_SelectOnLeft","t":4,"rt":$n[3].Selectable,"sn":"m_SelectOnLeft"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_SelectOnRight","t":4,"rt":$n[3].Selectable,"sn":"m_SelectOnRight"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_SelectOnUp","t":4,"rt":$n[3].Selectable,"sn":"m_SelectOnUp"}]}; }, $n);
    /*UnityEngine.UI.Navigation end.*/

    /*UnityEngine.UI.Scrollbar+ScrollEvent start.*/
    $m("UnityEngine.UI.Scrollbar.ScrollEvent", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*UnityEngine.UI.Scrollbar+ScrollEvent end.*/

    /*UnityEngine.UI.ScrollRect+ScrollRectEvent start.*/
    $m("UnityEngine.UI.ScrollRect.ScrollRectEvent", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*UnityEngine.UI.ScrollRect+ScrollRectEvent end.*/

    /*UnityEngine.UI.Slider+SliderEvent start.*/
    $m("UnityEngine.UI.Slider.SliderEvent", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*UnityEngine.UI.Slider+SliderEvent end.*/

    /*UnityEngine.UI.SpriteState start.*/
    $m("UnityEngine.UI.SpriteState", function () { return {"at":[new System.SerializableAttribute()],"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_DisabledSprite","t":4,"rt":$n[1].Sprite,"sn":"m_DisabledSprite"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_HighlightedSprite","t":4,"rt":$n[1].Sprite,"sn":"m_HighlightedSprite"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_PressedSprite","t":4,"rt":$n[1].Sprite,"sn":"m_PressedSprite"},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_HighlightedSprite"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_SelectedSprite","t":4,"rt":$n[1].Sprite,"sn":"m_SelectedSprite"}]}; }, $n);
    /*UnityEngine.UI.SpriteState end.*/

    /*UnityEngine.UI.Toggle+ToggleEvent start.*/
    $m("UnityEngine.UI.Toggle.ToggleEvent", function () { return {"at":[new System.SerializableAttribute()]}; }, $n);
    /*UnityEngine.UI.Toggle+ToggleEvent end.*/

    /*UnityEngine.EventSystems.EventSystem start.*/
    $m("UnityEngine.EventSystems.EventSystem", function () { return {"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"_sendNavigationEvents","t":4,"rt":$n[0].Boolean,"sn":"_sendNavigationEvents","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"dragThreshold","t":4,"rt":$n[0].Int32,"sn":"dragThreshold","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_Selected")],"a":1,"n":"firstSelected","t":4,"rt":$n[1].GameObject,"sn":"firstSelected"}]}; }, $n);
    /*UnityEngine.EventSystems.EventSystem end.*/

    /*UnityEngine.UI.CanvasScaler start.*/
    $m("UnityEngine.UI.CanvasScaler", function () { return {"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_ScreenMatchMode","t":4,"rt":$n[3].CanvasScaler.ScreenMatchMode,"sn":"m_ScreenMatchMode","box":function ($v) { return Bridge.box($v, UnityEngine.UI.CanvasScaler.ScreenMatchMode, System.Enum.toStringFn(UnityEngine.UI.CanvasScaler.ScreenMatchMode));}}]}; }, $n);
    /*UnityEngine.UI.CanvasScaler end.*/

    /*UnityEngine.UI.ToggleGroup start.*/
    $m("UnityEngine.UI.ToggleGroup", function () { return {"at":[new UnityEngine.AddComponentMenu.$ctor1("UI/Toggle Group", 32),new UnityEngine.DisallowMultipleComponent()],"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_AllowSwitchOff","t":4,"rt":$n[0].Boolean,"sn":"m_AllowSwitchOff","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*UnityEngine.UI.ToggleGroup end.*/

    /*UnityEngine.EventSystems.PhysicsRaycaster start.*/
    $m("UnityEngine.EventSystems.PhysicsRaycaster", function () { return {"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_EventMask","t":4,"rt":$n[1].LayerMask,"sn":"m_EventMask"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_MaxRayIntersections","t":4,"rt":$n[0].Int32,"sn":"m_MaxRayIntersections","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*UnityEngine.EventSystems.PhysicsRaycaster end.*/

    /*UnityEngine.UI.Selectable start.*/
    $m("UnityEngine.UI.Selectable", function () { return {"m":[{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("animationTriggers"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_AnimationTriggers","t":4,"rt":$n[3].AnimationTriggers,"sn":"m_AnimationTriggers"},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("colors"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Colors","t":4,"rt":$n[3].ColorBlock,"sn":"m_Colors"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Interactable","t":4,"rt":$n[0].Boolean,"sn":"m_Interactable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("navigation"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Navigation","t":4,"rt":$n[3].Navigation,"sn":"m_Navigation"},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("spriteState"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_SpriteState","t":4,"rt":$n[3].SpriteState,"sn":"m_SpriteState"},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("highlightGraphic"),new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_HighlightGraphic"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_TargetGraphic","t":4,"rt":$n[3].Graphic,"sn":"m_TargetGraphic"},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("transition"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Transition","t":4,"rt":$n[3].Selectable.Transition,"sn":"m_Transition","box":function ($v) { return Bridge.box($v, UnityEngine.UI.Selectable.Transition, System.Enum.toStringFn(UnityEngine.UI.Selectable.Transition));}}]}; }, $n);
    /*UnityEngine.UI.Selectable end.*/

    /*UnityEngine.UI.Dropdown+DropdownItem start.*/
    $m("UnityEngine.UI.Dropdown.DropdownItem", function () { return {"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Image","t":4,"rt":$n[3].Image,"sn":"m_Image"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_RectTransform","t":4,"rt":$n[1].RectTransform,"sn":"m_RectTransform"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Text","t":4,"rt":$n[3].Text,"sn":"m_Text"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Toggle","t":4,"rt":$n[3].Toggle,"sn":"m_Toggle"}]}; }, $n);
    /*UnityEngine.UI.Dropdown+DropdownItem end.*/

    /*UnityEngine.UI.GraphicRaycaster start.*/
    $m("UnityEngine.UI.GraphicRaycaster", function () { return {"m":[{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("blockingObjects"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"_blockingObjects","t":4,"rt":$n[3].GraphicRaycaster.BlockingObjects,"sn":"_blockingObjects","box":function ($v) { return Bridge.box($v, UnityEngine.UI.GraphicRaycaster.BlockingObjects, System.Enum.toStringFn(UnityEngine.UI.GraphicRaycaster.BlockingObjects));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"_ignoreReversedGraphics","t":4,"rt":$n[0].Boolean,"sn":"_ignoreReversedGraphics","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_BlockingMask","t":4,"rt":$n[1].LayerMask,"sn":"m_BlockingMask"}]}; }, $n);
    /*UnityEngine.UI.GraphicRaycaster end.*/

    /*UnityEngine.UI.MaskableGraphic start.*/
    $m("UnityEngine.UI.MaskableGraphic", function () { return {"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_OnCullStateChanged","t":4,"rt":$n[3].MaskableGraphic.CullStateChangedEvent,"sn":"m_OnCullStateChanged"}]}; }, $n);
    /*UnityEngine.UI.MaskableGraphic end.*/

    /*UnityEngine.UI.Shadow start.*/
    $m("UnityEngine.UI.Shadow", function () { return {"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_EffectColor","t":4,"rt":$n[1].Color,"sn":"m_EffectColor"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_EffectDistance","t":4,"rt":$n[1].Vector2,"sn":"m_EffectDistance"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_UseGraphicAlpha","t":4,"rt":$n[0].Boolean,"sn":"m_UseGraphicAlpha","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*UnityEngine.UI.Shadow end.*/

    /*UnityEngine.UI.ScrollRect start.*/
    $m("UnityEngine.UI.ScrollRect", function () { return {"at":[new SelectionBase(),new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.RequireComponent.ctor(UnityEngine.RectTransform)],"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Content","t":4,"rt":$n[1].RectTransform,"sn":"m_Content"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_DecelerationRate","t":4,"rt":$n[0].Single,"sn":"m_DecelerationRate","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Elasticity","t":4,"rt":$n[0].Single,"sn":"m_Elasticity","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Horizontal","t":4,"rt":$n[0].Boolean,"sn":"m_Horizontal","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_HorizontalScrollbar","t":4,"rt":$n[3].Scrollbar,"sn":"m_HorizontalScrollbar"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_HorizontalScrollbarSpacing","t":4,"rt":$n[0].Single,"sn":"m_HorizontalScrollbarSpacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_HorizontalScrollbarVisibility","t":4,"rt":$n[3].ScrollRect.ScrollbarVisibility,"sn":"m_HorizontalScrollbarVisibility","box":function ($v) { return Bridge.box($v, UnityEngine.UI.ScrollRect.ScrollbarVisibility, System.Enum.toStringFn(UnityEngine.UI.ScrollRect.ScrollbarVisibility));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Inertia","t":4,"rt":$n[0].Boolean,"sn":"m_Inertia","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_MovementType","t":4,"rt":$n[3].ScrollRect.MovementType,"sn":"m_MovementType","box":function ($v) { return Bridge.box($v, UnityEngine.UI.ScrollRect.MovementType, System.Enum.toStringFn(UnityEngine.UI.ScrollRect.MovementType));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_OnValueChanged","t":4,"rt":$n[3].ScrollRect.ScrollRectEvent,"sn":"m_OnValueChanged"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_ScrollSensitivity","t":4,"rt":$n[0].Single,"sn":"m_ScrollSensitivity","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Vertical","t":4,"rt":$n[0].Boolean,"sn":"m_Vertical","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_VerticalScrollbar","t":4,"rt":$n[3].Scrollbar,"sn":"m_VerticalScrollbar"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_VerticalScrollbarSpacing","t":4,"rt":$n[0].Single,"sn":"m_VerticalScrollbarSpacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_VerticalScrollbarVisibility","t":4,"rt":$n[3].ScrollRect.ScrollbarVisibility,"sn":"m_VerticalScrollbarVisibility","box":function ($v) { return Bridge.box($v, UnityEngine.UI.ScrollRect.ScrollbarVisibility, System.Enum.toStringFn(UnityEngine.UI.ScrollRect.ScrollbarVisibility));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Viewport","t":4,"rt":$n[1].RectTransform,"sn":"m_Viewport"}]}; }, $n);
    /*UnityEngine.UI.ScrollRect end.*/

    /*UnityEngine.EventSystems.StandaloneInputModule start.*/
    $m("UnityEngine.EventSystems.StandaloneInputModule", function () { return {"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"_cancelButton","t":4,"rt":$n[0].String,"sn":"_cancelButton"},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_AllowActivationOnMobileDevice")],"a":1,"n":"_forceModuleActive","t":4,"rt":$n[0].Boolean,"sn":"_forceModuleActive","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"_horizontalAxis","t":4,"rt":$n[0].String,"sn":"_horizontalAxis"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"_inputActionsPerSecond","t":4,"rt":$n[0].Single,"sn":"_inputActionsPerSecond","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"_repeatDelay","t":4,"rt":$n[0].Single,"sn":"_repeatDelay","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"_submitButton","t":4,"rt":$n[0].String,"sn":"_submitButton"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"_verticalAxis","t":4,"rt":$n[0].String,"sn":"_verticalAxis"}]}; }, $n);
    /*UnityEngine.EventSystems.StandaloneInputModule end.*/

    /*UnityEngine.UI.Dropdown start.*/
    $m("UnityEngine.UI.Dropdown", function () { return {"at":[new UnityEngine.AddComponentMenu.$ctor1("UI/Dropdown", 35),new UnityEngine.RequireComponent.ctor(UnityEngine.RectTransform)],"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_AlphaFadeSpeed","t":4,"rt":$n[0].Single,"sn":"m_AlphaFadeSpeed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_CaptionImage","t":4,"rt":$n[3].Image,"sn":"m_CaptionImage"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_CaptionText","t":4,"rt":$n[3].Text,"sn":"m_CaptionText"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_ItemImage","t":4,"rt":$n[3].Image,"sn":"m_ItemImage"},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_ItemText","t":4,"rt":$n[3].Text,"sn":"m_ItemText"},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_OnValueChanged","t":4,"rt":$n[3].Dropdown.DropdownEvent,"sn":"m_OnValueChanged"},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Options","t":4,"rt":$n[3].Dropdown.OptionDataList,"sn":"m_Options"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Template","t":4,"rt":$n[1].RectTransform,"sn":"m_Template"},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Value","t":4,"rt":$n[0].Int32,"sn":"m_Value","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*UnityEngine.UI.Dropdown end.*/

    /*UnityEngine.UI.InputField start.*/
    $m("UnityEngine.UI.InputField", function () { return {"at":[new UnityEngine.AddComponentMenu.$ctor1("UI/Input Field", 31)],"m":[{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("asteriskChar"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_AsteriskChar","t":4,"rt":$n[0].Char,"sn":"m_AsteriskChar","box":function ($v) { return Bridge.box($v, System.Char, String.fromCharCode, System.Char.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.RangeAttribute(0.0, 4.0)],"a":1,"n":"m_CaretBlinkRate","t":4,"rt":$n[0].Single,"sn":"m_CaretBlinkRate","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("selectionColor"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_CaretColor","t":4,"rt":$n[1].Color,"sn":"m_CaretColor"},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.RangeAttribute(1.0, 5.0)],"a":1,"n":"m_CaretWidth","t":4,"rt":$n[0].Int32,"sn":"m_CaretWidth","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("characterLimit"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_CharacterLimit","t":4,"rt":$n[0].Int32,"sn":"m_CharacterLimit","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("validation"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_CharacterValidation","t":4,"rt":$n[3].InputField.CharacterValidation,"sn":"m_CharacterValidation","box":function ($v) { return Bridge.box($v, UnityEngine.UI.InputField.CharacterValidation, System.Enum.toStringFn(UnityEngine.UI.InputField.CharacterValidation));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_ContentType","t":4,"rt":$n[3].InputField.ContentType,"sn":"m_ContentType","box":function ($v) { return Bridge.box($v, UnityEngine.UI.InputField.ContentType, System.Enum.toStringFn(UnityEngine.UI.InputField.ContentType));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_CustomCaretColor","t":4,"rt":$n[0].Boolean,"sn":"m_CustomCaretColor","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("hideMobileInput"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_HideMobileInput","t":4,"rt":$n[0].Boolean,"sn":"m_HideMobileInput","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("inputType"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_InputType","t":4,"rt":$n[3].InputField.InputType,"sn":"m_InputType","box":function ($v) { return Bridge.box($v, UnityEngine.UI.InputField.InputType, System.Enum.toStringFn(UnityEngine.UI.InputField.InputType));}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("keyboardType"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_KeyboardType","t":4,"rt":$n[1].TouchScreenKeyboardType,"sn":"m_KeyboardType","box":function ($v) { return Bridge.box($v, UnityEngine.TouchScreenKeyboardType, System.Enum.toStringFn(UnityEngine.TouchScreenKeyboardType));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_LineType","t":4,"rt":$n[3].InputField.LineType,"sn":"m_LineType","box":function ($v) { return Bridge.box($v, UnityEngine.UI.InputField.LineType, System.Enum.toStringFn(UnityEngine.UI.InputField.LineType));}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("onSubmit"),new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_OnSubmit"),new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_EndEdit"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_OnEndEdit","t":4,"rt":$n[3].InputField.SubmitEvent,"sn":"m_OnEndEdit"},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("onValidateInput"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_OnValidateInput","t":4,"rt":Function,"sn":"m_OnValidateInput"},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("onValueChange"),new UnityEngine.Serialization.FormerlySerializedAsAttribute("m_OnValueChange"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_OnValueChanged","t":4,"rt":$n[3].InputField.OnChangeEvent,"sn":"m_OnValueChanged"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_Placeholder","t":4,"rt":$n[3].Graphic,"sn":"m_Placeholder"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_ReadOnly","t":4,"rt":$n[0].Boolean,"sn":"m_ReadOnly","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_SelectionColor","t":4,"rt":$n[1].Color,"sn":"m_SelectionColor"},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.Serialization.FormerlySerializedAsAttribute("mValue")],"a":3,"n":"m_Text","t":4,"rt":$n[0].String,"sn":"m_Text"},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.Serialization.FormerlySerializedAsAttribute("text")],"a":3,"n":"m_TextComponent","t":4,"rt":$n[3].Text,"sn":"m_TextComponent"}]}; }, $n);
    /*UnityEngine.UI.InputField end.*/

    /*UnityEngine.UI.Scrollbar start.*/
    $m("UnityEngine.UI.Scrollbar", function () { return {"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.RectTransform)],"m":[{"at":[new UnityEngine.SpaceAttribute.$ctor1(6.0),new UnityEngine.SerializeFieldAttribute()],"a":2,"n":"onValueChanged","t":16,"rt":$n[3].Scrollbar.ScrollEvent,"g":{"a":2,"n":"get_onValueChanged","t":8,"rt":$n[3].Scrollbar.ScrollEvent,"fg":"onValueChanged"},"s":{"a":2,"n":"set_onValueChanged","t":8,"p":[$n[3].Scrollbar.ScrollEvent],"rt":$n[0].Void,"fs":"onValueChanged"},"fn":"onValueChanged"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Direction","t":4,"rt":$n[3].Scrollbar.Direction,"sn":"m_Direction","box":function ($v) { return Bridge.box($v, UnityEngine.UI.Scrollbar.Direction, System.Enum.toStringFn(UnityEngine.UI.Scrollbar.Direction));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_HandleRect","t":4,"rt":$n[1].RectTransform,"sn":"m_HandleRect"},{"at":[new UnityEngine.RangeAttribute(0.0, 11.0),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_NumberOfSteps","t":4,"rt":$n[0].Int32,"sn":"m_NumberOfSteps","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.RangeAttribute(0.0, 1.0),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Size","t":4,"rt":$n[0].Single,"sn":"m_Size","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.RangeAttribute(0.0, 1.0),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Value","t":4,"rt":$n[0].Single,"sn":"m_Value","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<onValueChanged>k__BackingField","t":4,"rt":$n[3].Scrollbar.ScrollEvent,"sn":"onValueChanged"}]}; }, $n);
    /*UnityEngine.UI.Scrollbar end.*/

    /*UnityEngine.UI.Slider start.*/
    $m("UnityEngine.UI.Slider", function () { return {"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.RectTransform)],"m":[{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Direction","t":4,"rt":$n[3].Slider.Direction,"sn":"m_Direction","box":function ($v) { return Bridge.box($v, UnityEngine.UI.Slider.Direction, System.Enum.toStringFn(UnityEngine.UI.Slider.Direction));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_FillRect","t":4,"rt":$n[1].RectTransform,"sn":"m_FillRect"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_HandleRect","t":4,"rt":$n[1].RectTransform,"sn":"m_HandleRect"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_MaxValue","t":4,"rt":$n[0].Single,"sn":"m_MaxValue","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_MinValue","t":4,"rt":$n[0].Single,"sn":"m_MinValue","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_OnValueChanged","t":4,"rt":$n[3].Slider.SliderEvent,"sn":"m_OnValueChanged"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"m_Value","t":4,"rt":$n[0].Single,"sn":"m_Value","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_WholeNumbers","t":4,"rt":$n[0].Boolean,"sn":"m_WholeNumbers","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*UnityEngine.UI.Slider end.*/

    /*UnityEngine.UI.Toggle start.*/
    $m("UnityEngine.UI.Toggle", function () { return {"at":[new UnityEngine.AddComponentMenu.$ctor1("UI/Toggle", 31),new UnityEngine.RequireComponent.ctor(UnityEngine.RectTransform)],"m":[{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_Group","t":4,"rt":$n[3].ToggleGroup,"sn":"m_Group"},{"at":[new UnityEngine.TooltipAttribute("Is the toggle currently on or off?"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"m_IsOn","t":4,"rt":$n[0].Boolean,"sn":"m_IsOn","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*UnityEngine.UI.Toggle end.*/

    }});
